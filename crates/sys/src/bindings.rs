/* automatically generated by rust-bindgen 0.61.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const API_VERSION: u32 = 458757;
pub type wint_t = core::ffi::c_ushort;
pub type _off_t = core::ffi::c_long;
pub type _fpos_t = core::ffi::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: core::ffi::c_int,
    pub _maxwds: core::ffi::c_int,
    pub _sign: core::ffi::c_int,
    pub _wds: core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        32usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        8usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: core::ffi::c_int,
    pub __tm_min: core::ffi::c_int,
    pub __tm_hour: core::ffi::c_int,
    pub __tm_mday: core::ffi::c_int,
    pub __tm_mon: core::ffi::c_int,
    pub __tm_year: core::ffi::c_int,
    pub __tm_wday: core::ffi::c_int,
    pub __tm_yday: core::ffi::c_int,
    pub __tm_isdst: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        520usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        8usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        792usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        8usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut core::ffi::c_uchar,
    pub _size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut core::ffi::c_uchar,
    pub _r: core::ffi::c_int,
    pub _w: core::ffi::c_int,
    pub _flags: core::ffi::c_short,
    pub _file: core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: core::ffi::c_int,
    pub _cookie: *mut core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *mut core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *const core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: _fpos_t,
            arg4: core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut core::ffi::c_uchar,
    pub _ur: core::ffi::c_int,
    pub _ubuf: [core::ffi::c_uchar; 3usize],
    pub _nbuf: [core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        176usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        24usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        8usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [core::ffi::c_ushort; 3usize],
    pub _mult: [core::ffi::c_ushort; 3usize],
    pub _add: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: core::ffi::c_int,
    pub _emergency: [core::ffi::c_char; 25usize],
    pub _unspecified_locale_info: core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: core::ffi::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: core::ffi::c_int,
    pub _cvtbuf: *mut core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: core::ffi::c_uint,
    pub _strtok_last: *mut core::ffi::c_char,
    pub _asctime_buf: [core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: core::ffi::c_int,
    pub _rand_next: core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [core::ffi::c_char; 8usize],
    pub _signal_buf: [core::ffi::c_char; 24usize],
    pub _getdate_err: core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        216usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut core::ffi::c_uchar; 30usize],
    pub _nmalloc: [core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        360usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        360usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1864usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn free(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn malloc(arg1: core::ffi::c_ulonglong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rand() -> core::ffi::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn srand(__seed: core::ffi::c_uint);
}
extern "C" {
    pub fn strtof(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn random() -> core::ffi::c_long;
}
extern "C" {
    pub fn strtoull(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    #[doc = " Crash system"]
    pub fn __furi_crash();
}
extern "C" {
    #[doc = " Halt system"]
    pub fn __furi_halt();
}
extern "C" {
    #[doc = "< System Clock Frequency"]
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    pub fn furi_thread_catch() -> !;
}
pub type BaseType_t = core::ffi::c_long;
pub type UBaseType_t = core::ffi::c_ulong;
pub type TickType_t = u32;
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\defgroup TaskHandle_t TaskHandle_t"]
#[doc = " \\ingroup Tasks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
extern "C" {
    #[doc = " task. h"]
    #[doc = " @code{c}"]
    #[doc = " void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Set the priority of any task."]
    #[doc = ""]
    #[doc = " A context switch will occur before the function returns if the priority"]
    #[doc = " being set is higher than the currently executing task."]
    #[doc = ""]
    #[doc = " @param xTask Handle to the task for which the priority is being set."]
    #[doc = " Passing a NULL handle results in the priority of the calling task being set."]
    #[doc = ""]
    #[doc = " @param uxNewPriority The priority to which the task will be set."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = " void vAFunction( void )"]
    #[doc = " {"]
    #[doc = " TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to raise the priority of the created task."]
    #[doc = "   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use a NULL handle to raise our priority to the same value."]
    #[doc = "   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\defgroup vTaskPrioritySet vTaskPrioritySet"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " @code{c}"]
    #[doc = " TickType_t xTaskGetTickCount( void );"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskGetTickCount xTaskGetTickCount"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " @code{c}"]
    #[doc = " TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " NOTE:  This function takes a relatively long time to complete and should be"]
    #[doc = " used sparingly."]
    #[doc = ""]
    #[doc = " @return The handle of the task that has the human readable name pcNameToQuery."]
    #[doc = " NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle"]
    #[doc = " must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available."]
    #[doc = ""]
    #[doc = " \\defgroup pcTaskGetHandle pcTaskGetHandle"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetHandle(pcNameToQuery: *const core::ffi::c_char) -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
#[doc = "< Operation completed successfully."]
pub const FuriStatus_FuriStatusOk: FuriStatus = 0;
pub const FuriStatus_FuriStatusError: FuriStatus = -1;
#[doc = "< Operation not completed within the timeout period."]
pub const FuriStatus_FuriStatusErrorTimeout: FuriStatus = -2;
#[doc = "< Resource not available."]
pub const FuriStatus_FuriStatusErrorResource: FuriStatus = -3;
#[doc = "< Parameter error."]
pub const FuriStatus_FuriStatusErrorParameter: FuriStatus = -4;
pub const FuriStatus_FuriStatusErrorNoMemory: FuriStatus = -5;
pub const FuriStatus_FuriStatusErrorISR: FuriStatus = -6;
#[doc = "< Prevents enum down-size compiler optimization."]
pub const FuriStatus_FuriStatusReserved: FuriStatus = 2147483647;
pub type FuriStatus = core::ffi::c_int;
pub type FuriEventFlag = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate FuriEventFlag"]
    #[doc = ""]
    #[doc = " @return     pointer to FuriEventFlag"]
    pub fn furi_event_flag_alloc() -> *mut FuriEventFlag;
}
extern "C" {
    #[doc = " Deallocate FuriEventFlag"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriEventFlag"]
    pub fn furi_event_flag_free(instance: *mut FuriEventFlag);
}
extern "C" {
    #[doc = " Set flags"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriEventFlag"]
    #[doc = " @param[in]  flags     The flags"]
    #[doc = ""]
    #[doc = " @return     Resulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_set(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
    #[doc = " Clear flags"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriEventFlag"]
    #[doc = " @param[in]  flags     The flags"]
    #[doc = ""]
    #[doc = " @return     Resulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_clear(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
    #[doc = " Get flags"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriEventFlag"]
    #[doc = ""]
    #[doc = " @return     Resulting flags"]
    pub fn furi_event_flag_get(instance: *mut FuriEventFlag) -> u32;
}
extern "C" {
    #[doc = " Wait flags"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriEventFlag"]
    #[doc = " @param[in]  flags     The flags"]
    #[doc = " @param[in]  options   The option flags"]
    #[doc = " @param[in]  timeout   The timeout"]
    #[doc = ""]
    #[doc = " @return     Resulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_wait(
        instance: *mut FuriEventFlag,
        flags: u32,
        options: u32,
        timeout: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Lock kernel, pause process scheduling"]
    #[doc = ""]
    #[doc = " @return     previous lock state(0 - unlocked, 1 - locked)"]
    pub fn furi_kernel_lock() -> i32;
}
extern "C" {
    #[doc = " Unlock kernel, resume process scheduling"]
    #[doc = ""]
    #[doc = " @return     previous lock state(0 - unlocked, 1 - locked)"]
    pub fn furi_kernel_unlock() -> i32;
}
extern "C" {
    #[doc = " Restore kernel lock state"]
    #[doc = ""]
    #[doc = " @param[in]  lock  The lock state"]
    #[doc = ""]
    #[doc = " @return     new lock state or error"]
    pub fn furi_kernel_restore_lock(lock: i32) -> i32;
}
extern "C" {
    #[doc = " Get kernel systick frequency"]
    #[doc = ""]
    #[doc = " @return     systick counts per second"]
    pub fn furi_kernel_get_tick_frequency() -> u32;
}
extern "C" {
    #[doc = " Delay execution"]
    #[doc = ""]
    #[doc = " Also keep in mind delay is aliased to scheduler timer intervals."]
    #[doc = ""]
    #[doc = " @param[in]  ticks  The ticks count to pause"]
    pub fn furi_delay_tick(ticks: u32);
}
extern "C" {
    #[doc = " Delay until tick"]
    #[doc = ""]
    #[doc = " @param[in]  ticks  The tick until which kerel should delay task execution"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_delay_until_tick(tick: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Get current tick counter"]
    #[doc = ""]
    #[doc = " System uptime, may overflow."]
    #[doc = ""]
    #[doc = " @return     Current ticks in milliseconds"]
    pub fn furi_get_tick() -> u32;
}
extern "C" {
    #[doc = " Convert milliseconds to ticks"]
    #[doc = ""]
    #[doc = " @param[in]   milliseconds    time in milliseconds"]
    #[doc = " @return      time in ticks"]
    pub fn furi_ms_to_ticks(milliseconds: u32) -> u32;
}
extern "C" {
    #[doc = " Delay in milliseconds"]
    #[doc = ""]
    #[doc = " This method uses kernel ticks on the inside, which causes delay to be aliased to scheduler timer intervals."]
    #[doc = " Real wait time will be between X+ milliseconds."]
    #[doc = " Special value: 0, will cause task yield."]
    #[doc = " Also if used when kernel is not running will fall back to `furi_delay_us`."]
    #[doc = ""]
    #[doc = " @warning    Cannot be used from ISR"]
    #[doc = ""]
    #[doc = " @param[in]  milliseconds  milliseconds to wait"]
    pub fn furi_delay_ms(milliseconds: u32);
}
extern "C" {
    #[doc = " Delay in microseconds"]
    #[doc = ""]
    #[doc = " Implemented using Cortex DWT counter. Blocking and non aliased."]
    #[doc = ""]
    #[doc = " @param[in]  microseconds  microseconds to wait"]
    pub fn furi_delay_us(microseconds: u32);
}
pub type va_list = __builtin_va_list;
pub type FILE = __FILE;
extern "C" {
    pub fn sscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_ulonglong,
        arg3: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
pub const FuriLogLevel_FuriLogLevelDefault: FuriLogLevel = 0;
pub const FuriLogLevel_FuriLogLevelNone: FuriLogLevel = 1;
pub const FuriLogLevel_FuriLogLevelError: FuriLogLevel = 2;
pub const FuriLogLevel_FuriLogLevelWarn: FuriLogLevel = 3;
pub const FuriLogLevel_FuriLogLevelInfo: FuriLogLevel = 4;
pub const FuriLogLevel_FuriLogLevelDebug: FuriLogLevel = 5;
pub const FuriLogLevel_FuriLogLevelTrace: FuriLogLevel = 6;
pub type FuriLogLevel = core::ffi::c_uchar;
extern "C" {
    #[doc = " Print log record"]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = " @param tag"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    pub fn furi_log_print_format(
        level: FuriLogLevel,
        tag: *const core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Set log level"]
    #[doc = ""]
    #[doc = " @param[in]  level  The level"]
    pub fn furi_log_set_level(level: FuriLogLevel);
}
extern "C" {
    #[doc = " Get log level"]
    #[doc = ""]
    #[doc = " @return     The furi log level."]
    pub fn furi_log_get_level() -> FuriLogLevel;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulonglong,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcasestr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulonglong,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    #[doc = " Get free heap size"]
    #[doc = ""]
    #[doc = " @return     free heap size in bytes"]
    pub fn memmgr_get_free_heap() -> usize;
}
extern "C" {
    #[doc = " Get total heap size"]
    #[doc = ""]
    #[doc = " @return     total heap size in bytes"]
    pub fn memmgr_get_total_heap() -> usize;
}
extern "C" {
    #[doc = " Get heap watermark"]
    #[doc = ""]
    #[doc = " @return     minimum heap in bytes"]
    pub fn memmgr_get_minimum_free_heap() -> usize;
}
extern "C" {
    #[doc = " An aligned version of malloc, used when you need to get the aligned space on the heap"]
    #[doc = " Freeing the received address is performed ONLY through the aligned_free function"]
    #[doc = " @param size"]
    #[doc = " @param alignment"]
    #[doc = " @return void*"]
    pub fn aligned_malloc(size: usize, alignment: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Freed space obtained through the aligned_malloc function"]
    #[doc = " @param p pointer to result of aligned_malloc"]
    pub fn aligned_free(p: *mut core::ffi::c_void);
}
pub const FuriThreadState_FuriThreadStateStopped: FuriThreadState = 0;
pub const FuriThreadState_FuriThreadStateStarting: FuriThreadState = 1;
pub const FuriThreadState_FuriThreadStateRunning: FuriThreadState = 2;
#[doc = " FuriThreadState"]
pub type FuriThreadState = core::ffi::c_uchar;
#[doc = "< Uninitialized, choose system default"]
pub const FuriThreadPriority_FuriThreadPriorityNone: FuriThreadPriority = 0;
#[doc = "< Idle priority"]
pub const FuriThreadPriority_FuriThreadPriorityIdle: FuriThreadPriority = 1;
#[doc = "< Lowest"]
pub const FuriThreadPriority_FuriThreadPriorityLowest: FuriThreadPriority = 14;
#[doc = "< Low"]
pub const FuriThreadPriority_FuriThreadPriorityLow: FuriThreadPriority = 15;
#[doc = "< Normal"]
pub const FuriThreadPriority_FuriThreadPriorityNormal: FuriThreadPriority = 16;
#[doc = "< High"]
pub const FuriThreadPriority_FuriThreadPriorityHigh: FuriThreadPriority = 17;
#[doc = "< Highest"]
pub const FuriThreadPriority_FuriThreadPriorityHighest: FuriThreadPriority = 18;
#[doc = "< Deffered Isr (highest possible)"]
pub const FuriThreadPriority_FuriThreadPriorityIsr: FuriThreadPriority = 32;
#[doc = " FuriThreadPriority"]
pub type FuriThreadPriority = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriThread {
    _unused: [u8; 0],
}
#[doc = " FuriThreadId proxy type to OS low level functions"]
pub type FuriThreadId = *mut core::ffi::c_void;
#[doc = " FuriThreadCallback Your callback to run in new thread"]
#[doc = " @warning    never use osThreadExit in FuriThread"]
pub type FuriThreadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> i32>;
#[doc = " Write to stdout callback"]
#[doc = " @param      data     pointer to data"]
#[doc = " @param      size     data size @warning your handler must consume everything"]
pub type FuriThreadStdoutWriteCallback =
    ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char, size: usize)>;
#[doc = " FuriThread state change calback called upon thread state change"]
#[doc = " @param      state    new thread state"]
#[doc = " @param      context  callback context"]
pub type FuriThreadStateCallback = ::core::option::Option<
    unsafe extern "C" fn(state: FuriThreadState, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Allocate FuriThread"]
    #[doc = ""]
    #[doc = " @return     FuriThread instance"]
    pub fn furi_thread_alloc() -> *mut FuriThread;
}
extern "C" {
    #[doc = " Release FuriThread"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    pub fn furi_thread_free(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Set FuriThread name"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = " @param      name    string"]
    pub fn furi_thread_set_name(thread: *mut FuriThread, name: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Mark thread as service"]
    #[doc = " The service cannot be stopped or removed, and cannot exit from the thread body"]
    #[doc = ""]
    #[doc = " @param thread"]
    pub fn furi_thread_mark_as_service(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Set FuriThread stack size"]
    #[doc = ""]
    #[doc = " @param      thread      FuriThread instance"]
    #[doc = " @param      stack_size  stack size in bytes"]
    pub fn furi_thread_set_stack_size(thread: *mut FuriThread, stack_size: usize);
}
extern "C" {
    #[doc = " Set FuriThread callback"]
    #[doc = ""]
    #[doc = " @param      thread    FuriThread instance"]
    #[doc = " @param      callback  FuriThreadCallback, called upon thread run"]
    pub fn furi_thread_set_callback(thread: *mut FuriThread, callback: FuriThreadCallback);
}
extern "C" {
    #[doc = " Set FuriThread context"]
    #[doc = ""]
    #[doc = " @param      thread   FuriThread instance"]
    #[doc = " @param      context  pointer to context for thread callback"]
    pub fn furi_thread_set_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set FuriThread priority"]
    #[doc = ""]
    #[doc = " @param      thread   FuriThread instance"]
    #[doc = " @param      priority FuriThreadPriority value"]
    pub fn furi_thread_set_priority(thread: *mut FuriThread, priority: FuriThreadPriority);
}
extern "C" {
    #[doc = " Set FuriThread state change callback"]
    #[doc = ""]
    #[doc = " @param      thread    FuriThread instance"]
    #[doc = " @param      callback  state change callback"]
    pub fn furi_thread_set_state_callback(
        thread: *mut FuriThread,
        callback: FuriThreadStateCallback,
    );
}
extern "C" {
    #[doc = " Set FuriThread state change context"]
    #[doc = ""]
    #[doc = " @param      thread   FuriThread instance"]
    #[doc = " @param      context  pointer to context"]
    pub fn furi_thread_set_state_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Get FuriThread state"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = ""]
    #[doc = " @return     thread state from FuriThreadState"]
    pub fn furi_thread_get_state(thread: *mut FuriThread) -> FuriThreadState;
}
extern "C" {
    #[doc = " Start FuriThread"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    pub fn furi_thread_start(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Join FuriThread"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = ""]
    #[doc = " @return     bool"]
    pub fn furi_thread_join(thread: *mut FuriThread) -> bool;
}
extern "C" {
    #[doc = " Get FreeRTOS FuriThreadId for FuriThread instance"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = ""]
    #[doc = " @return     FuriThreadId or NULL"]
    pub fn furi_thread_get_id(thread: *mut FuriThread) -> FuriThreadId;
}
extern "C" {
    #[doc = " Enable heap tracing"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    pub fn furi_thread_enable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Get thread heap size"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = ""]
    #[doc = " @return     size in bytes"]
    pub fn furi_thread_get_heap_size(thread: *mut FuriThread) -> usize;
}
extern "C" {
    #[doc = " Get thread return code"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = ""]
    #[doc = " @return     return code"]
    pub fn furi_thread_get_return_code(thread: *mut FuriThread) -> i32;
}
extern "C" {
    #[doc = " Get FreeRTOS FuriThreadId for current thread"]
    #[doc = ""]
    #[doc = " @param      thread  FuriThread instance"]
    #[doc = ""]
    #[doc = " @return     FuriThreadId or NULL"]
    pub fn furi_thread_get_current_id() -> FuriThreadId;
}
extern "C" {
    #[doc = " Get FuriThread instance for current thread"]
    #[doc = ""]
    #[doc = " @return FuriThread*"]
    pub fn furi_thread_get_current() -> *mut FuriThread;
}
extern "C" {
    #[doc = " Return control to scheduler"]
    pub fn furi_thread_yield();
}
extern "C" {
    pub fn furi_thread_flags_set(thread_id: FuriThreadId, flags: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_flags_clear(flags: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_flags_get() -> u32;
}
extern "C" {
    pub fn furi_thread_flags_wait(flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_enumerate(thread_array: *mut FuriThreadId, array_items: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_get_name(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn furi_thread_get_stack_space(thread_id: FuriThreadId) -> u32;
}
extern "C" {
    #[doc = " Set STDOUT callback for thread"]
    #[doc = ""]
    #[doc = " @param      callback  callback or NULL to clear"]
    #[doc = ""]
    #[doc = " @return     true on success, otherwise fail"]
    pub fn furi_thread_set_stdout_callback(callback: FuriThreadStdoutWriteCallback) -> bool;
}
extern "C" {
    #[doc = " Write data to buffered STDOUT"]
    #[doc = ""]
    #[doc = " @param data input data"]
    #[doc = " @param size input data size"]
    #[doc = ""]
    #[doc = " @return size_t written data size"]
    pub fn furi_thread_stdout_write(data: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Flush data to STDOUT"]
    #[doc = ""]
    #[doc = " @return int32_t error code"]
    pub fn furi_thread_stdout_flush() -> i32;
}
extern "C" {
    #[doc = " Suspend thread"]
    #[doc = ""]
    #[doc = " @param thread_id thread id"]
    pub fn furi_thread_suspend(thread_id: FuriThreadId);
}
extern "C" {
    #[doc = " Resume thread"]
    #[doc = ""]
    #[doc = " @param thread_id thread id"]
    pub fn furi_thread_resume(thread_id: FuriThreadId);
}
extern "C" {
    #[doc = " Get thread suspended state"]
    #[doc = ""]
    #[doc = " @param thread_id thread id"]
    #[doc = " @return true if thread is suspended"]
    pub fn furi_thread_is_suspended(thread_id: FuriThreadId) -> bool;
}
extern "C" {
    #[doc = " Memmgr heap enable thread allocation tracking"]
    #[doc = ""]
    #[doc = " @param      thread_id  - thread id to track"]
    pub fn memmgr_heap_enable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
    #[doc = " Memmgr heap disable thread allocation tracking"]
    #[doc = ""]
    #[doc = " @param      thread_id  - thread id to track"]
    pub fn memmgr_heap_disable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
    #[doc = " Memmgr heap get allocatred thread memory"]
    #[doc = ""]
    #[doc = " @param      thread_id  - thread id to track"]
    #[doc = ""]
    #[doc = " @return     bytes allocated right now"]
    pub fn memmgr_heap_get_thread_memory(taks_handle: FuriThreadId) -> usize;
}
extern "C" {
    #[doc = " Memmgr heap get the max contiguous block size on the heap"]
    #[doc = ""]
    #[doc = " @return     size_t max contiguous block size"]
    pub fn memmgr_heap_get_max_free_block() -> usize;
}
extern "C" {
    #[doc = " Print the address and size of all free blocks to stdout"]
    pub fn memmgr_heap_printf_free_blocks();
}
pub type FuriMessageQueue = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate furi message queue"]
    #[doc = ""]
    #[doc = " @param[in]  msg_count  The message count"]
    #[doc = " @param[in]  msg_size   The message size"]
    #[doc = ""]
    #[doc = " @return     pointer to FuriMessageQueue instance"]
    pub fn furi_message_queue_alloc(msg_count: u32, msg_size: u32) -> *mut FuriMessageQueue;
}
extern "C" {
    #[doc = " Free queue"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    pub fn furi_message_queue_free(instance: *mut FuriMessageQueue);
}
extern "C" {
    #[doc = " Put message into queue"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = " @param[in]  msg_ptr   The message pointer"]
    #[doc = " @param[in]  timeout   The timeout"]
    #[doc = " @param[in]  msg_prio  The message prio"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_message_queue_put(
        instance: *mut FuriMessageQueue,
        msg_ptr: *const core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
extern "C" {
    #[doc = " Get message from queue"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = " @param      msg_ptr   The message pointer"]
    #[doc = " @param      msg_prio  The message prioority"]
    #[doc = " @param[in]  timeout   The timeout"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_message_queue_get(
        instance: *mut FuriMessageQueue,
        msg_ptr: *mut core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
extern "C" {
    #[doc = " Get queue capacity"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = ""]
    #[doc = " @return     capacity in object count"]
    pub fn furi_message_queue_get_capacity(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Get message size"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = ""]
    #[doc = " @return     Message size in bytes"]
    pub fn furi_message_queue_get_message_size(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Get message count in queue"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = ""]
    #[doc = " @return     Message count"]
    pub fn furi_message_queue_get_count(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Get queue available space"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = ""]
    #[doc = " @return     Message count"]
    pub fn furi_message_queue_get_space(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Reset queue"]
    #[doc = ""]
    #[doc = " @param      instance  pointer to FuriMessageQueue instance"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_message_queue_reset(instance: *mut FuriMessageQueue) -> FuriStatus;
}
pub const FuriMutexType_FuriMutexTypeNormal: FuriMutexType = 0;
pub const FuriMutexType_FuriMutexTypeRecursive: FuriMutexType = 1;
pub type FuriMutexType = core::ffi::c_uchar;
pub type FuriMutex = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate FuriMutex"]
    #[doc = ""]
    #[doc = " @param[in]  type  The mutex type"]
    #[doc = ""]
    #[doc = " @return     pointer to FuriMutex instance"]
    pub fn furi_mutex_alloc(type_: FuriMutexType) -> *mut FuriMutex;
}
extern "C" {
    #[doc = " Free FuriMutex"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriMutex instance"]
    pub fn furi_mutex_free(instance: *mut FuriMutex);
}
extern "C" {
    #[doc = " Acquire mutex"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriMutex instance"]
    #[doc = " @param[in]  timeout   The timeout"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_mutex_acquire(instance: *mut FuriMutex, timeout: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Release mutex"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriMutex instance"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_mutex_release(instance: *mut FuriMutex) -> FuriStatus;
}
extern "C" {
    #[doc = " Get mutex owner thread id"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriMutex instance"]
    #[doc = ""]
    #[doc = " @return     The furi thread identifier."]
    pub fn furi_mutex_get_owner(instance: *mut FuriMutex) -> FuriThreadId;
}
#[doc = " FuriPubSub Callback type"]
pub type FuriPubSubCallback = ::core::option::Option<
    unsafe extern "C" fn(message: *const core::ffi::c_void, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSubSubscription {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate FuriPubSub"]
    #[doc = ""]
    #[doc = " Reentrable, Not threadsafe, one owner"]
    #[doc = ""]
    #[doc = " @return     pointer to FuriPubSub instance"]
    pub fn furi_pubsub_alloc() -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Subscribe to FuriPubSub"]
    #[doc = ""]
    #[doc = " Threadsafe, Reentrable"]
    #[doc = ""]
    #[doc = " @param      pubsub            pointer to FuriPubSub instance"]
    #[doc = " @param[in]  callback          The callback"]
    #[doc = " @param      callback_context  The callback context"]
    #[doc = ""]
    #[doc = " @return     pointer to FuriPubSubSubscription instance"]
    pub fn furi_pubsub_subscribe(
        pubsub: *mut FuriPubSub,
        callback: FuriPubSubCallback,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut FuriPubSubSubscription;
}
extern "C" {
    #[doc = " Unsubscribe from FuriPubSub"]
    #[doc = ""]
    #[doc = " No use of `pubsub_subscription` allowed after call of this method"]
    #[doc = " Threadsafe, Reentrable."]
    #[doc = ""]
    #[doc = " @param      pubsub               pointer to FuriPubSub instance"]
    #[doc = " @param      pubsub_subscription  pointer to FuriPubSubSubscription instance"]
    pub fn furi_pubsub_unsubscribe(
        pubsub: *mut FuriPubSub,
        pubsub_subscription: *mut FuriPubSubSubscription,
    );
}
extern "C" {
    #[doc = " Publish message to FuriPubSub"]
    #[doc = ""]
    #[doc = " Threadsafe, Reentrable."]
    #[doc = ""]
    #[doc = " @param      pubsub   pointer to FuriPubSub instance"]
    #[doc = " @param      message  message pointer to publish"]
    pub fn furi_pubsub_publish(pubsub: *mut FuriPubSub, message: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Check if record exists"]
    #[doc = ""]
    #[doc = " @param      name  record name"]
    #[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
    #[doc = "             thread."]
    pub fn furi_record_exists(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Create record"]
    #[doc = ""]
    #[doc = " @param      name  record name"]
    #[doc = " @param      data  data pointer"]
    #[doc = " @note       Thread safe. Create and destroy must be executed from the same"]
    #[doc = "             thread."]
    pub fn furi_record_create(name: *const core::ffi::c_char, data: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Open record"]
    #[doc = ""]
    #[doc = " @param      name  record name"]
    #[doc = ""]
    #[doc = " @return     pointer to the record"]
    #[doc = " @note       Thread safe. Open and close must be executed from the same"]
    #[doc = "             thread. Suspends caller thread till record is available"]
    pub fn furi_record_open(name: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Close record"]
    #[doc = ""]
    #[doc = " @param      name  record name"]
    #[doc = " @note       Thread safe. Open and close must be executed from the same"]
    #[doc = "             thread."]
    pub fn furi_record_close(name: *const core::ffi::c_char);
}
pub type FuriSemaphore = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate semaphore"]
    #[doc = ""]
    #[doc = " @param[in]  max_count      The maximum count"]
    #[doc = " @param[in]  initial_count  The initial count"]
    #[doc = ""]
    #[doc = " @return     pointer to FuriSemaphore instance"]
    pub fn furi_semaphore_alloc(max_count: u32, initial_count: u32) -> *mut FuriSemaphore;
}
extern "C" {
    #[doc = " Free semaphore"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriSemaphore instance"]
    pub fn furi_semaphore_free(instance: *mut FuriSemaphore);
}
extern "C" {
    #[doc = " Acquire semaphore"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriSemaphore instance"]
    #[doc = " @param[in]  timeout   The timeout"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_semaphore_acquire(instance: *mut FuriSemaphore, timeout: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Release semaphore"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriSemaphore instance"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_semaphore_release(instance: *mut FuriSemaphore) -> FuriStatus;
}
extern "C" {
    #[doc = " Get semaphore count"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriSemaphore instance"]
    #[doc = ""]
    #[doc = " @return     Semaphore count"]
    pub fn furi_semaphore_get_count(instance: *mut FuriSemaphore) -> u32;
}
pub type FuriTimerCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "< One-shot timer."]
pub const FuriTimerType_FuriTimerTypeOnce: FuriTimerType = 0;
#[doc = "< Repeating timer."]
pub const FuriTimerType_FuriTimerTypePeriodic: FuriTimerType = 1;
pub type FuriTimerType = core::ffi::c_uchar;
pub type FuriTimer = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate timer"]
    #[doc = ""]
    #[doc = " @param[in]  func     The callback function"]
    #[doc = " @param[in]  type     The timer type"]
    #[doc = " @param      context  The callback context"]
    #[doc = ""]
    #[doc = " @return     The pointer to FuriTimer instance"]
    pub fn furi_timer_alloc(
        func: FuriTimerCallback,
        type_: FuriTimerType,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriTimer;
}
extern "C" {
    #[doc = " Free timer"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriTimer instance"]
    pub fn furi_timer_free(instance: *mut FuriTimer);
}
extern "C" {
    #[doc = " Start timer"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriTimer instance"]
    #[doc = " @param[in]  ticks     The ticks"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_timer_start(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Stop timer"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriTimer instance"]
    #[doc = ""]
    #[doc = " @return     The furi status."]
    pub fn furi_timer_stop(instance: *mut FuriTimer) -> FuriStatus;
}
extern "C" {
    #[doc = " Is timer running"]
    #[doc = ""]
    #[doc = " @param      instance  The pointer to FuriTimer instance"]
    #[doc = ""]
    #[doc = " @return     0: not running, 1: running"]
    pub fn furi_timer_is_running(instance: *mut FuriTimer) -> u32;
}
#[doc = " == ValueMutex =="]
#[doc = ""]
#[doc = " The most simple concept is ValueMutex."]
#[doc = " It is wrapper around mutex and value pointer."]
#[doc = " You can take and give mutex to work with value and read and write value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueMutex {
    pub value: *mut core::ffi::c_void,
    pub size: usize,
    pub mutex: *mut FuriMutex,
}
#[test]
fn bindgen_test_layout_ValueMutex() {
    const UNINIT: ::core::mem::MaybeUninit<ValueMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ValueMutex>(),
        24usize,
        concat!("Size of: ", stringify!(ValueMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<ValueMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(ValueMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueMutex),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueMutex),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueMutex),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[doc = " Creates ValueMutex."]
    pub fn init_mutex(
        valuemutex: *mut ValueMutex,
        value: *mut core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Free resources allocated by `init_mutex`."]
    #[doc = " This function doesn't free the memory occupied by `ValueMutex` itself."]
    pub fn delete_mutex(valuemutex: *mut ValueMutex) -> bool;
}
extern "C" {
    #[doc = " Call for work with data stored in mutex."]
    #[doc = " @return pointer to data if success, NULL otherwise."]
    pub fn acquire_mutex(valuemutex: *mut ValueMutex, timeout: u32) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Release mutex after end of work with data."]
    #[doc = " Call `release_mutex` and pass ValueData instance and pointer to data."]
    pub fn release_mutex(valuemutex: *mut ValueMutex, value: *const core::ffi::c_void) -> bool;
}
extern "C" {
    pub static _ctype_: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __assert_func(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
        arg4: *const core::ffi::c_char,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriString {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Allocate new FuriString."]
    #[doc = " @return FuriString*"]
    pub fn furi_string_alloc() -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and set it to string."]
    #[doc = " Allocate & Set the string a to the string."]
    #[doc = " @param source"]
    #[doc = " @return FuriString*"]
    pub fn furi_string_alloc_set(source: *const FuriString) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and set it to C string."]
    #[doc = " Allocate & Set the string a to the C string."]
    #[doc = " @param cstr_source"]
    #[doc = " @return FuriString*"]
    pub fn furi_string_alloc_set_str(cstr_source: *const core::ffi::c_char) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and printf to it."]
    #[doc = " Initialize and set a string to the given formatted value."]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    #[doc = " @return FuriString*"]
    pub fn furi_string_alloc_printf(format: *const core::ffi::c_char, ...) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and printf to it."]
    #[doc = " Initialize and set a string to the given formatted value."]
    #[doc = " @param format"]
    #[doc = " @param args"]
    #[doc = " @return FuriString*"]
    pub fn furi_string_alloc_vprintf(
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and move source string content to it."]
    #[doc = " Allocate the string, set it to the other one, and destroy the other one."]
    #[doc = " @param source"]
    #[doc = " @return FuriString*"]
    pub fn furi_string_alloc_move(source: *mut FuriString) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Free FuriString."]
    #[doc = " @param string"]
    pub fn furi_string_free(string: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Reserve memory for string."]
    #[doc = " Modify the string capacity to be able to handle at least 'alloc' characters (including final null char)."]
    #[doc = " @param string"]
    #[doc = " @param size"]
    pub fn furi_string_reserve(string: *mut FuriString, size: usize);
}
extern "C" {
    #[doc = " @brief Reset string."]
    #[doc = " Make the string empty."]
    #[doc = " @param s"]
    pub fn furi_string_reset(string: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Swap two strings."]
    #[doc = " Swap the two strings string_1 and string_2."]
    #[doc = " @param string_1"]
    #[doc = " @param string_2"]
    pub fn furi_string_swap(string_1: *mut FuriString, string_2: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Move string_2 content to string_1."]
    #[doc = " Set the string to the other one, and destroy the other one."]
    #[doc = " @param string_1"]
    #[doc = " @param string_2"]
    pub fn furi_string_move(string_1: *mut FuriString, string_2: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Compute a hash for the string."]
    #[doc = " @param string"]
    #[doc = " @return size_t"]
    pub fn furi_string_hash(string: *const FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Get string size (usually length, but not for UTF-8)"]
    #[doc = " @param string"]
    #[doc = " @return size_t"]
    pub fn furi_string_size(string: *const FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Check that string is empty or not"]
    #[doc = " @param string"]
    #[doc = " @return bool"]
    pub fn furi_string_empty(string: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Get the character at the given index."]
    #[doc = " Return the selected character of the string."]
    #[doc = " @param string"]
    #[doc = " @param index"]
    #[doc = " @return char"]
    pub fn furi_string_get_char(string: *const FuriString, index: usize) -> core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Return the string view a classic C string."]
    #[doc = " @param string"]
    #[doc = " @return const char*"]
    pub fn furi_string_get_cstr(string: *const FuriString) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Set the string to the other string."]
    #[doc = " Set the string to the source string."]
    #[doc = " @param string"]
    #[doc = " @param source"]
    pub fn furi_string_set(string: *mut FuriString, source: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Set the string to the other C string."]
    #[doc = " Set the string to the source C string."]
    #[doc = " @param string"]
    #[doc = " @param source"]
    pub fn furi_string_set_str(string: *mut FuriString, source: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Set the string to the n first characters of the C string."]
    #[doc = " @param string"]
    #[doc = " @param source"]
    #[doc = " @param length"]
    pub fn furi_string_set_strn(
        string: *mut FuriString,
        source: *const core::ffi::c_char,
        length: usize,
    );
}
extern "C" {
    #[doc = " @brief Set the character at the given index."]
    #[doc = " @param string"]
    #[doc = " @param index"]
    #[doc = " @param c"]
    pub fn furi_string_set_char(string: *mut FuriString, index: usize, c: core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Set the string to the n first characters of other one."]
    #[doc = " @param string"]
    #[doc = " @param source"]
    #[doc = " @param offset"]
    #[doc = " @param length"]
    pub fn furi_string_set_n(
        string: *mut FuriString,
        source: *const FuriString,
        offset: usize,
        length: usize,
    );
}
extern "C" {
    #[doc = " @brief Format in the string the given printf format"]
    #[doc = " @param string"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    #[doc = " @return int"]
    pub fn furi_string_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Format in the string the given printf format"]
    #[doc = " @param string"]
    #[doc = " @param format"]
    #[doc = " @param args"]
    #[doc = " @return int"]
    pub fn furi_string_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Append a character to the string."]
    #[doc = " @param string"]
    #[doc = " @param c"]
    pub fn furi_string_push_back(string: *mut FuriString, c: core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Append a string to the string."]
    #[doc = " Concatenate the string with the other string."]
    #[doc = " @param string_1"]
    #[doc = " @param string_2"]
    pub fn furi_string_cat(string_1: *mut FuriString, string_2: *const FuriString);
}
extern "C" {
    #[doc = " @brief Append a C string to the string."]
    #[doc = " Concatenate the string with the C string."]
    #[doc = " @param string_1"]
    #[doc = " @param cstring_2"]
    pub fn furi_string_cat_str(string_1: *mut FuriString, cstring_2: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Append to the string the formatted string of the given printf format."]
    #[doc = " @param string"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    #[doc = " @return int"]
    pub fn furi_string_cat_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Append to the string the formatted string of the given printf format."]
    #[doc = " @param string"]
    #[doc = " @param format"]
    #[doc = " @param args"]
    #[doc = " @return int"]
    pub fn furi_string_cat_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare two strings and return the sort order."]
    #[doc = " @param string_1"]
    #[doc = " @param string_2"]
    #[doc = " @return int"]
    pub fn furi_string_cmp(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare string with C string and return the sort order."]
    #[doc = " @param string_1"]
    #[doc = " @param cstring_2"]
    #[doc = " @return int"]
    pub fn furi_string_cmp_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare two strings (case insensitive according to the current locale) and return the sort order."]
    #[doc = " Note: doesn't work with UTF-8 strings."]
    #[doc = " @param string_1"]
    #[doc = " @param string_2"]
    #[doc = " @return int"]
    pub fn furi_string_cmpi(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare string with C string (case insensitive according to the current locale) and return the sort order."]
    #[doc = " Note: doesn't work with UTF-8 strings."]
    #[doc = " @param string_1"]
    #[doc = " @param cstring_2"]
    #[doc = " @return int"]
    pub fn furi_string_cmpi_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Search the first occurrence of the needle in the string from the position start."]
    #[doc = " Return STRING_FAILURE if not found."]
    #[doc = " By default, start is zero."]
    #[doc = " @param string"]
    #[doc = " @param needle"]
    #[doc = " @param start"]
    #[doc = " @return size_t"]
    pub fn furi_string_search(
        string: *const FuriString,
        needle: *const FuriString,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Search the first occurrence of the needle in the string from the position start."]
    #[doc = " Return STRING_FAILURE if not found."]
    #[doc = " @param string"]
    #[doc = " @param needle"]
    #[doc = " @param start"]
    #[doc = " @return size_t"]
    pub fn furi_string_search_str(
        string: *const FuriString,
        needle: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Search for the position of the character c from the position start (include) in the string."]
    #[doc = " Return STRING_FAILURE if not found."]
    #[doc = " By default, start is zero."]
    #[doc = " @param string"]
    #[doc = " @param c"]
    #[doc = " @param start"]
    #[doc = " @return size_t"]
    pub fn furi_string_search_char(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Reverse search for the position of the character c from the position start (include) in the string."]
    #[doc = " Return STRING_FAILURE if not found."]
    #[doc = " By default, start is zero."]
    #[doc = " @param string"]
    #[doc = " @param c"]
    #[doc = " @param start"]
    #[doc = " @return size_t"]
    pub fn furi_string_search_rchar(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Test if two strings are equal."]
    #[doc = " @param string_1"]
    #[doc = " @param string_2"]
    #[doc = " @return bool"]
    pub fn furi_string_equal(string_1: *const FuriString, string_2: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string is equal to the C string."]
    #[doc = " @param string_1"]
    #[doc = " @param cstring_2"]
    #[doc = " @return bool"]
    pub fn furi_string_equal_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Replace in the string the sub-string at position 'pos' for 'len' bytes into the C string 'replace'."]
    #[doc = " @param string"]
    #[doc = " @param pos"]
    #[doc = " @param len"]
    #[doc = " @param replace"]
    pub fn furi_string_replace_at(
        string: *mut FuriString,
        pos: usize,
        len: usize,
        replace: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Replace a string 'needle' to string 'replace' in a string from 'start' position."]
    #[doc = " By default, start is zero."]
    #[doc = " Return STRING_FAILURE if 'needle' not found or replace position."]
    #[doc = " @param string"]
    #[doc = " @param needle"]
    #[doc = " @param replace"]
    #[doc = " @param start"]
    #[doc = " @return size_t"]
    pub fn furi_string_replace(
        string: *mut FuriString,
        needle: *mut FuriString,
        replace: *mut FuriString,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Replace a C string 'needle' to C string 'replace' in a string from 'start' position."]
    #[doc = " By default, start is zero."]
    #[doc = " Return STRING_FAILURE if 'needle' not found or replace position."]
    #[doc = " @param string"]
    #[doc = " @param needle"]
    #[doc = " @param replace"]
    #[doc = " @param start"]
    #[doc = " @return size_t"]
    pub fn furi_string_replace_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Replace all occurrences of 'needle' string into 'replace' string."]
    #[doc = " @param string"]
    #[doc = " @param needle"]
    #[doc = " @param replace"]
    pub fn furi_string_replace_all(
        string: *mut FuriString,
        needle: *const FuriString,
        replace: *const FuriString,
    );
}
extern "C" {
    #[doc = " @brief Replace all occurrences of 'needle' C string into 'replace' C string."]
    #[doc = " @param string"]
    #[doc = " @param needle"]
    #[doc = " @param replace"]
    pub fn furi_string_replace_all_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Test if the string starts with the given string."]
    #[doc = " @param string"]
    #[doc = " @param start"]
    #[doc = " @return bool"]
    pub fn furi_string_start_with(string: *const FuriString, start: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string starts with the given C string."]
    #[doc = " @param string"]
    #[doc = " @param start"]
    #[doc = " @return bool"]
    pub fn furi_string_start_with_str(
        string: *const FuriString,
        start: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string ends with the given string."]
    #[doc = " @param string"]
    #[doc = " @param end"]
    #[doc = " @return bool"]
    pub fn furi_string_end_with(string: *const FuriString, end: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string ends with the given C string."]
    #[doc = " @param string"]
    #[doc = " @param end"]
    #[doc = " @return bool"]
    pub fn furi_string_end_with_str(
        string: *const FuriString,
        end: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Trim the string left to the first 'index' bytes."]
    #[doc = " @param string"]
    #[doc = " @param index"]
    pub fn furi_string_left(string: *mut FuriString, index: usize);
}
extern "C" {
    #[doc = " @brief Trim the string right from the 'index' position to the last position."]
    #[doc = " @param string"]
    #[doc = " @param index"]
    pub fn furi_string_right(string: *mut FuriString, index: usize);
}
extern "C" {
    #[doc = " @brief Trim the string from position index to size bytes."]
    #[doc = " See also furi_string_set_n."]
    #[doc = " @param string"]
    #[doc = " @param index"]
    #[doc = " @param size"]
    pub fn furi_string_mid(string: *mut FuriString, index: usize, size: usize);
}
extern "C" {
    #[doc = " @brief Trim a string from the given set of characters (default is \" \\n\\r\\t\")."]
    #[doc = " @param string"]
    #[doc = " @param chars"]
    pub fn furi_string_trim(string: *mut FuriString, chars: *const core::ffi::c_char);
}
#[doc = " @brief An unicode value."]
pub type FuriStringUnicodeValue = core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Compute the length in UTF8 characters in the string."]
    #[doc = " @param string"]
    #[doc = " @return size_t"]
    pub fn furi_string_utf8_length(string: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Push unicode into string, encoding it in UTF8."]
    #[doc = " @param string"]
    #[doc = " @param unicode"]
    pub fn furi_string_utf8_push(string: *mut FuriString, unicode: FuriStringUnicodeValue);
}
pub const FuriStringUTF8State_FuriStringUTF8StateStarting: FuriStringUTF8State = 0;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding1: FuriStringUTF8State = 1;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding2: FuriStringUTF8State = 2;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding3: FuriStringUTF8State = 3;
pub const FuriStringUTF8State_FuriStringUTF8StateError: FuriStringUTF8State = 4;
#[doc = " @brief State of the UTF8 decoding machine state."]
pub type FuriStringUTF8State = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Main generic UTF8 decoder."]
    #[doc = " It takes a character, and the previous state and the previous value of the unicode value."]
    #[doc = " It updates the state and the decoded unicode value."]
    #[doc = " A decoded unicode encoded value is valid only when the state is FuriStringUTF8StateStarting."]
    #[doc = " @param c"]
    #[doc = " @param state"]
    #[doc = " @param unicode"]
    pub fn furi_string_utf8_decode(
        c: core::ffi::c_char,
        state: *mut FuriStringUTF8State,
        unicode: *mut FuriStringUnicodeValue,
    );
}
pub type FuriStreamBuffer = core::ffi::c_void;
extern "C" {
    #[doc = " @brief Allocate stream buffer instance."]
    #[doc = " Stream buffer implementation assumes there is only one task or"]
    #[doc = " interrupt that will write to the buffer (the writer), and only one task or"]
    #[doc = " interrupt that will read from the buffer (the reader)."]
    #[doc = ""]
    #[doc = " @param size The total number of bytes the stream buffer will be able to hold at any one time."]
    #[doc = " @param trigger_level The number of bytes that must be in the stream buffer"]
    #[doc = " before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state."]
    #[doc = " @return The stream buffer instance."]
    pub fn furi_stream_buffer_alloc(size: usize, trigger_level: usize) -> *mut FuriStreamBuffer;
}
extern "C" {
    #[doc = " @brief Free stream buffer instance"]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    pub fn furi_stream_buffer_free(stream_buffer: *mut FuriStreamBuffer);
}
extern "C" {
    #[doc = " @brief Set trigger level for stream buffer."]
    #[doc = " A stream buffer's trigger level is the number of bytes that must be in the"]
    #[doc = " stream buffer before a task that is blocked on the stream buffer to"]
    #[doc = " wait for data is moved out of the blocked state."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance"]
    #[doc = " @param trigger_level The new trigger level for the stream buffer."]
    #[doc = " @return true if trigger level can be be updated (new trigger level was less than or equal to the stream buffer's length)."]
    #[doc = " @return false if trigger level can't be be updated (new trigger level was greater than the stream buffer's length)."]
    pub fn furi_stream_set_trigger_level(
        stream_buffer: *mut FuriStreamBuffer,
        trigger_level: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends bytes to a stream buffer. The bytes are copied into the stream buffer."]
    #[doc = " Wakes up task waiting for data to become available if called from ISR."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    #[doc = " @param data A pointer to the data that is to be copied into the stream buffer."]
    #[doc = " @param length The maximum number of bytes to copy from data into the stream buffer."]
    #[doc = " @param timeout The maximum amount of time the task should remain in the"]
    #[doc = " Blocked state to wait for space to become available if the stream buffer is full."]
    #[doc = " Will return immediately if timeout is zero."]
    #[doc = " Setting timeout to FuriWaitForever will cause the task to wait indefinitely."]
    #[doc = " Ignored if called from ISR."]
    #[doc = " @return The number of bytes actually written to the stream buffer."]
    pub fn furi_stream_buffer_send(
        stream_buffer: *mut FuriStreamBuffer,
        data: *const core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Receives bytes from a stream buffer."]
    #[doc = " Wakes up task waiting for space to become available if called from ISR."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    #[doc = " @param data A pointer to the buffer into which the received bytes will be"]
    #[doc = " copied."]
    #[doc = " @param length The length of the buffer pointed to by the data parameter."]
    #[doc = " @param timeout The maximum amount of time the task should remain in the"]
    #[doc = " Blocked state to wait for data to become available if the stream buffer is empty."]
    #[doc = " Will return immediately if timeout is zero."]
    #[doc = " Setting timeout to FuriWaitForever will cause the task to wait indefinitely."]
    #[doc = " Ignored if called from ISR."]
    #[doc = " @return The number of bytes read from the stream buffer, if any."]
    pub fn furi_stream_buffer_receive(
        stream_buffer: *mut FuriStreamBuffer,
        data: *mut core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see how much data it contains, which is equal to"]
    #[doc = " the number of bytes that can be read from the stream buffer before the stream"]
    #[doc = " buffer would be empty."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    #[doc = " @return The number of bytes that can be read from the stream buffer before"]
    #[doc = " the stream buffer would be empty."]
    pub fn furi_stream_buffer_bytes_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see how much free space it contains, which is"]
    #[doc = " equal to the amount of data that can be sent to the stream buffer before it"]
    #[doc = " is full."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    #[doc = " @return The number of bytes that can be written to the stream buffer before"]
    #[doc = " the stream buffer would be full."]
    pub fn furi_stream_buffer_spaces_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see if it is full."]
    #[doc = ""]
    #[doc = " @param stream_buffer stream buffer instance."]
    #[doc = " @return true if the stream buffer is full."]
    #[doc = " @return false if the stream buffer is not full."]
    pub fn furi_stream_buffer_is_full(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see if it is empty."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    #[doc = " @return true if the stream buffer is empty."]
    #[doc = " @return false if the stream buffer is not empty."]
    pub fn furi_stream_buffer_is_empty(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
extern "C" {
    #[doc = " @brief Resets a stream buffer to its initial, empty, state. Any data that was"]
    #[doc = " in the stream buffer is discarded. A stream buffer can only be reset if there"]
    #[doc = " are no tasks blocked waiting to either send to or receive from the stream buffer."]
    #[doc = ""]
    #[doc = " @param stream_buffer The stream buffer instance."]
    #[doc = " @return FuriStatusOk if the stream buffer is reset."]
    #[doc = " @return FuriStatusError if there was a task blocked waiting to send to or read"]
    #[doc = " from the stream buffer then the stream buffer is not reset."]
    pub fn furi_stream_buffer_reset(stream_buffer: *mut FuriStreamBuffer) -> FuriStatus;
}
#[doc = " @brief Comparator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_TypeDef {
    #[doc = "< COMP control and status register,               Address offset: 0x00"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<COMP_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<COMP_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "< DMA interrupt status register,                 Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< DMA interrupt flag clear register,             Address offset: 0x04"]
    pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DMA_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IFCR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(IFCR)
        )
    );
}
#[doc = " @brief General Purpose I/O"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_TypeDef {
    #[doc = "< GPIO port mode register,               Address offset: 0x00"]
    pub MODER: u32,
    #[doc = "< GPIO port output type register,        Address offset: 0x04"]
    pub OTYPER: u32,
    #[doc = "< GPIO port output speed register,       Address offset: 0x08"]
    pub OSPEEDR: u32,
    #[doc = "< GPIO port pull-up/pull-down register,  Address offset: 0x0C"]
    pub PUPDR: u32,
    #[doc = "< GPIO port input data register,         Address offset: 0x10"]
    pub IDR: u32,
    #[doc = "< GPIO port output data register,        Address offset: 0x14"]
    pub ODR: u32,
    #[doc = "< GPIO port bit set/reset  register,     Address offset: 0x18"]
    pub BSRR: u32,
    #[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
    pub LCKR: u32,
    #[doc = "< GPIO alternate function registers,     Address offset: 0x20-0x24"]
    pub AFR: [u32; 2usize],
    #[doc = "< GPIO Bit Reset register,               Address offset: 0x28"]
    pub BRR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<GPIO_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GPIO_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(MODER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OTYPER) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OTYPER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OSPEEDR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OSPEEDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PUPDR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(PUPDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ODR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(ODR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSRR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BSRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LCKR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(LCKR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AFR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(AFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
}
#[doc = " @brief Inter-integrated Circuit Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_TypeDef {
    #[doc = "< I2C Control register 1,            Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< I2C Control register 2,            Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< I2C Own address 1 register,        Address offset: 0x08"]
    pub OAR1: u32,
    #[doc = "< I2C Own address 2 register,        Address offset: 0x0C"]
    pub OAR2: u32,
    #[doc = "< I2C Timing register,               Address offset: 0x10"]
    pub TIMINGR: u32,
    #[doc = "< I2C Timeout register,              Address offset: 0x14"]
    pub TIMEOUTR: u32,
    #[doc = "< I2C Interrupt and status register, Address offset: 0x18"]
    pub ISR: u32,
    #[doc = "< I2C Interrupt clear register,      Address offset: 0x1C"]
    pub ICR: u32,
    #[doc = "< I2C PEC register,                  Address offset: 0x20"]
    pub PECR: u32,
    #[doc = "< I2C Receive data register,         Address offset: 0x24"]
    pub RXDR: u32,
    #[doc = "< I2C Transmit data register,        Address offset: 0x28"]
    pub TXDR: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<I2C_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<I2C_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMINGR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMINGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMEOUTR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMEOUTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PECR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(PECR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(RXDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TXDR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TXDR)
        )
    );
}
#[doc = " @brief LPTIMER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_TypeDef {
    #[doc = "< LPTIM Interrupt and Status register,                Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< LPTIM Interrupt Clear register,                     Address offset: 0x04"]
    pub ICR: u32,
    #[doc = "< LPTIM Interrupt Enable register,                    Address offset: 0x08"]
    pub IER: u32,
    #[doc = "< LPTIM Configuration register,                       Address offset: 0x0C"]
    pub CFGR: u32,
    #[doc = "< LPTIM Control register,                             Address offset: 0x10"]
    pub CR: u32,
    #[doc = "< LPTIM Compare register,                             Address offset: 0x14"]
    pub CMP: u32,
    #[doc = "< LPTIM Autoreload register,                          Address offset: 0x18"]
    pub ARR: u32,
    #[doc = "< LPTIM Counter register,                             Address offset: 0x1C"]
    pub CNT: u32,
    #[doc = "< LPTIM Option register,                              Address offset: 0x20"]
    pub OR: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LPTIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LPTIM_TypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMP) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
}
#[doc = " @brief Real-Time Clock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TypeDef {
    #[doc = "< RTC time register,                                         Address offset: 0x00"]
    pub TR: u32,
    #[doc = "< RTC date register,                                         Address offset: 0x04"]
    pub DR: u32,
    #[doc = "< RTC control register,                                      Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< RTC initialization and status register,                    Address offset: 0x0C"]
    pub ISR: u32,
    #[doc = "< RTC prescaler register,                                    Address offset: 0x10"]
    pub PRER: u32,
    #[doc = "< RTC wakeup timer register,                                 Address offset: 0x14"]
    pub WUTR: u32,
    #[doc = "< Reserved,                                                  Address offset: 0x18"]
    pub RESERVED: u32,
    #[doc = "< RTC alarm A register,                                      Address offset: 0x1C"]
    pub ALRMAR: u32,
    #[doc = "< RTC alarm B register,                                      Address offset: 0x20"]
    pub ALRMBR: u32,
    #[doc = "< RTC write protection register,                             Address offset: 0x24"]
    pub WPR: u32,
    #[doc = "< RTC sub second register,                                   Address offset: 0x28"]
    pub SSR: u32,
    #[doc = "< RTC shift control register,                                Address offset: 0x2C"]
    pub SHIFTR: u32,
    #[doc = "< RTC time stamp time register,                              Address offset: 0x30"]
    pub TSTR: u32,
    #[doc = "< RTC time stamp date register,                              Address offset: 0x34"]
    pub TSDR: u32,
    #[doc = "< RTC time-stamp sub second register,                        Address offset: 0x38"]
    pub TSSSR: u32,
    #[doc = "< RTC calibration register,                                  Address offset: 0x3C"]
    pub CALR: u32,
    #[doc = "< RTC tamper configuration register,                         Address offset: 0x40"]
    pub TAMPCR: u32,
    #[doc = "< RTC alarm A sub second register,                           Address offset: 0x44"]
    pub ALRMASSR: u32,
    #[doc = "< RTC alarm B sub second register,                           Address offset: 0x48"]
    pub ALRMBSSR: u32,
    #[doc = "< RTC option register,                                       Address offset  0x4C"]
    pub OR: u32,
    #[doc = "< RTC backup register 0,                                     Address offset: 0x50"]
    pub BKP0R: u32,
    #[doc = "< RTC backup register 1,                                     Address offset: 0x54"]
    pub BKP1R: u32,
    #[doc = "< RTC backup register 2,                                     Address offset: 0x58"]
    pub BKP2R: u32,
    #[doc = "< RTC backup register 3,                                     Address offset: 0x5C"]
    pub BKP3R: u32,
    #[doc = "< RTC backup register 4,                                     Address offset: 0x60"]
    pub BKP4R: u32,
    #[doc = "< RTC backup register 5,                                     Address offset: 0x64"]
    pub BKP5R: u32,
    #[doc = "< RTC backup register 6,                                     Address offset: 0x68"]
    pub BKP6R: u32,
    #[doc = "< RTC backup register 7,                                     Address offset: 0x6C"]
    pub BKP7R: u32,
    #[doc = "< RTC backup register 8,                                     Address offset: 0x70"]
    pub BKP8R: u32,
    #[doc = "< RTC backup register 9,                                     Address offset: 0x74"]
    pub BKP9R: u32,
    #[doc = "< RTC backup register 10,                                    Address offset: 0x78"]
    pub BKP10R: u32,
    #[doc = "< RTC backup register 11,                                    Address offset: 0x7C"]
    pub BKP11R: u32,
    #[doc = "< RTC backup register 12,                                    Address offset: 0x80"]
    pub BKP12R: u32,
    #[doc = "< RTC backup register 13,                                    Address offset: 0x84"]
    pub BKP13R: u32,
    #[doc = "< RTC backup register 14,                                    Address offset: 0x88"]
    pub BKP14R: u32,
    #[doc = "< RTC backup register 15,                                    Address offset: 0x8C"]
    pub BKP15R: u32,
    #[doc = "< RTC backup register 16,                                    Address offset: 0x90"]
    pub BKP16R: u32,
    #[doc = "< RTC backup register 17,                                    Address offset: 0x94"]
    pub BKP17R: u32,
    #[doc = "< RTC backup register 18,                                    Address offset: 0x98"]
    pub BKP18R: u32,
    #[doc = "< RTC backup register 19,                                    Address offset: 0x9C"]
    pub BKP19R: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TypeDef>(),
        160usize,
        concat!("Size of: ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRER) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(PRER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WUTR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WUTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMAR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMBR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WPR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHIFTR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SHIFTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSTR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSDR) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSSSR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSSSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALR) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CALR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPCR) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TAMPCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMASSR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMASSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMBSSR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBSSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP0R) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP0R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP1R) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP1R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP2R) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP2R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP3R) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP3R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP4R) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP4R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP5R) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP5R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP6R) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP6R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP7R) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP7R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP8R) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP8R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP9R) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP9R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP10R) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP10R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP11R) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP11R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP12R) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP12R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP13R) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP13R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP14R) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP14R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP15R) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP15R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP16R) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP16R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP17R) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP17R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP18R) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP18R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP19R) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP19R)
        )
    );
}
#[doc = " @brief Serial Peripheral Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_TypeDef {
    #[doc = "< SPI Control register 1,       Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< SPI Control register 2,       Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< SPI Status register,          Address offset: 0x08"]
    pub SR: u32,
    #[doc = "< SPI data register,            Address offset: 0x0C"]
    pub DR: u32,
    #[doc = "< SPI CRC polynomial register,  Address offset: 0x10"]
    pub CRCPR: u32,
    #[doc = "< SPI Rx CRC register,          Address offset: 0x14"]
    pub RXCRCR: u32,
    #[doc = "< SPI Tx CRC register,          Address offset: 0x18"]
    pub TXCRCR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<SPI_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SPI_TypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CRCPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXCRCR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(RXCRCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TXCRCR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(TXCRCR)
        )
    );
}
#[doc = " @brief TIM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_TypeDef {
    #[doc = "< TIM control register 1,                   Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< TIM control register 2,                   Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< TIM slave mode control register,          Address offset: 0x08"]
    pub SMCR: u32,
    #[doc = "< TIM DMA/interrupt enable register,        Address offset: 0x0C"]
    pub DIER: u32,
    #[doc = "< TIM status register,                      Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< TIM event generation register,            Address offset: 0x14"]
    pub EGR: u32,
    #[doc = "< TIM capture/compare mode register 1,      Address offset: 0x18"]
    pub CCMR1: u32,
    #[doc = "< TIM capture/compare mode register 2,      Address offset: 0x1C"]
    pub CCMR2: u32,
    #[doc = "< TIM capture/compare enable register,      Address offset: 0x20"]
    pub CCER: u32,
    #[doc = "< TIM counter register,                     Address offset: 0x24"]
    pub CNT: u32,
    #[doc = "< TIM prescaler register,                   Address offset: 0x28"]
    pub PSC: u32,
    #[doc = "< TIM auto-reload register,                 Address offset: 0x2C"]
    pub ARR: u32,
    #[doc = "< TIM repetition counter register,          Address offset: 0x30"]
    pub RCR: u32,
    #[doc = "< TIM capture/compare register 1,           Address offset: 0x34"]
    pub CCR1: u32,
    #[doc = "< TIM capture/compare register 2,           Address offset: 0x38"]
    pub CCR2: u32,
    #[doc = "< TIM capture/compare register 3,           Address offset: 0x3C"]
    pub CCR3: u32,
    #[doc = "< TIM capture/compare register 4,           Address offset: 0x40"]
    pub CCR4: u32,
    #[doc = "< TIM break and dead-time register,         Address offset: 0x44"]
    pub BDTR: u32,
    #[doc = "< TIM DMA control register,                 Address offset: 0x48"]
    pub DCR: u32,
    #[doc = "< TIM DMA address for full transfer,        Address offset: 0x4C"]
    pub DMAR: u32,
    #[doc = "< TIM option register                       Address offset: 0x50"]
    pub OR: u32,
    #[doc = "< TIM capture/compare mode register 3,      Address offset: 0x54"]
    pub CCMR3: u32,
    #[doc = "< TIM capture/compare register5,            Address offset: 0x58"]
    pub CCR5: u32,
    #[doc = "< TIM capture/compare register6,            Address offset: 0x5C"]
    pub CCR6: u32,
    #[doc = "< TIM Alternate function option register 1, Address offset: 0x60"]
    pub AF1: u32,
    #[doc = "< TIM Alternate function option register 2, Address offset: 0x64"]
    pub AF2: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_TypeDef>(),
        104usize,
        concat!("Size of: ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SMCR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIER) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EGR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCER) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PSC) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RCR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(RCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR3) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BDTR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(BDTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DMAR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR3) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR5) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR6) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AF1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(AF1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AF2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(AF2)
        )
    );
}
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "< USART Control register 1,                 Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< USART Control register 2,                 Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< USART Control register 3,                 Address offset: 0x08"]
    pub CR3: u32,
    #[doc = "< USART Baud rate register,                 Address offset: 0x0C"]
    pub BRR: u32,
    #[doc = "< USART Guard time and prescaler register,  Address offset: 0x10"]
    pub GTPR: u32,
    #[doc = "< USART Receiver Time Out register,         Address offset: 0x14"]
    pub RTOR: u32,
    #[doc = "< USART Request register,                   Address offset: 0x18"]
    pub RQR: u32,
    #[doc = "< USART Interrupt and status register,      Address offset: 0x1C"]
    pub ISR: u32,
    #[doc = "< USART Interrupt flag Clear register,      Address offset: 0x20"]
    pub ICR: u32,
    #[doc = "< USART Receive Data register,              Address offset: 0x24"]
    pub RDR: u32,
    #[doc = "< USART Transmit Data register,             Address offset: 0x28"]
    pub TDR: u32,
    #[doc = "< USART Prescaler register,                 Address offset: 0x2C"]
    pub PRESC: u32,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<USART_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USART_TypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USART_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GTPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(GTPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RTOR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RTOR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RQR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RQR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TDR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(TDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRESC) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(PRESC)
        )
    );
}
pub const ErrorStatus_SUCCESS: ErrorStatus = 0;
pub const ErrorStatus_ERROR: ErrorStatus = 1;
pub type ErrorStatus = core::ffi::c_uchar;
#[doc = " @brief LL GPIO Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_GPIO_InitTypeDef {
    #[doc = "< Specifies the GPIO pins to be configured."]
    #[doc = "This parameter can be any value of @ref GPIO_LL_EC_PIN"]
    pub Pin: u32,
    #[doc = "< Specifies the operating mode for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_LL_EC_MODE."]
    #[doc = ""]
    #[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinMode()."]
    pub Mode: u32,
    #[doc = "< Specifies the speed for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_LL_EC_SPEED."]
    #[doc = ""]
    #[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinSpeed()."]
    pub Speed: u32,
    #[doc = "< Specifies the operating output type for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_LL_EC_OUTPUT."]
    #[doc = ""]
    #[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinOutputType()."]
    pub OutputType: u32,
    #[doc = "< Specifies the operating Pull-up/Pull down for the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_LL_EC_PULL."]
    #[doc = ""]
    #[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinPull()."]
    pub Pull: u32,
    #[doc = "< Specifies the Peripheral to be connected to the selected pins."]
    #[doc = "This parameter can be a value of @ref GPIO_LL_EC_AF."]
    #[doc = ""]
    #[doc = "GPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetAFPin_0_7() and LL_GPIO_SetAFPin_8_15()."]
    pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_LL_GPIO_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_GPIO_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_GPIO_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(LL_GPIO_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_GPIO_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_GPIO_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(OutputType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pull) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Pull)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alternate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Alternate)
        )
    );
}
extern "C" {
    pub fn LL_GPIO_Init(
        GPIOx: *mut GPIO_TypeDef,
        GPIO_InitStruct: *mut LL_GPIO_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " Interrupt callback prototype"]
pub type GpioExtiCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
pub const GpioMode_GpioModeInput: GpioMode = 0;
pub const GpioMode_GpioModeOutputPushPull: GpioMode = 1;
pub const GpioMode_GpioModeOutputOpenDrain: GpioMode = 2;
pub const GpioMode_GpioModeAltFunctionPushPull: GpioMode = 3;
pub const GpioMode_GpioModeAltFunctionOpenDrain: GpioMode = 4;
pub const GpioMode_GpioModeAnalog: GpioMode = 5;
pub const GpioMode_GpioModeInterruptRise: GpioMode = 6;
pub const GpioMode_GpioModeInterruptFall: GpioMode = 7;
pub const GpioMode_GpioModeInterruptRiseFall: GpioMode = 8;
pub const GpioMode_GpioModeEventRise: GpioMode = 9;
pub const GpioMode_GpioModeEventFall: GpioMode = 10;
pub const GpioMode_GpioModeEventRiseFall: GpioMode = 11;
#[doc = " Gpio modes"]
pub type GpioMode = core::ffi::c_uchar;
pub const GpioPull_GpioPullNo: GpioPull = 0;
pub const GpioPull_GpioPullUp: GpioPull = 1;
pub const GpioPull_GpioPullDown: GpioPull = 2;
#[doc = " Gpio pull modes"]
pub type GpioPull = core::ffi::c_uchar;
pub const GpioSpeed_GpioSpeedLow: GpioSpeed = 0;
pub const GpioSpeed_GpioSpeedMedium: GpioSpeed = 1;
pub const GpioSpeed_GpioSpeedHigh: GpioSpeed = 2;
pub const GpioSpeed_GpioSpeedVeryHigh: GpioSpeed = 3;
#[doc = " Gpio speed modes"]
pub type GpioSpeed = core::ffi::c_uchar;
#[doc = "< MCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0MCO: GpioAltFn = 0;
#[doc = "< LSCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0LSCO: GpioAltFn = 0;
#[doc = "< JTMS-SWDIO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTMS_SWDIO: GpioAltFn = 0;
#[doc = "< JTCK-SWCLK Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTCK_SWCLK: GpioAltFn = 0;
#[doc = "< JTDI Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTDI: GpioAltFn = 0;
#[doc = "< RCT_OUT Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0RTC_OUT: GpioAltFn = 0;
#[doc = "< JTDO-TRACESWO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTD_TRACE: GpioAltFn = 0;
#[doc = "< NJTRST Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0NJTRST: GpioAltFn = 0;
#[doc = "< RTC_REFIN Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0RTC_REFIN: GpioAltFn = 0;
#[doc = "< TRACED0 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED0: GpioAltFn = 0;
#[doc = "< TRACED1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED1: GpioAltFn = 0;
#[doc = "< TRACED2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED2: GpioAltFn = 0;
#[doc = "< TRACED3 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED3: GpioAltFn = 0;
#[doc = "< TRIG_INOUT Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRIG_INOUT: GpioAltFn = 0;
#[doc = "< TRACECK Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACECK: GpioAltFn = 0;
#[doc = "< System Function mapping"]
pub const GpioAltFn_GpioAltFn0SYS: GpioAltFn = 0;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn1TIM1: GpioAltFn = 1;
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn1TIM2: GpioAltFn = 1;
#[doc = "< LPTIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn1LPTIM1: GpioAltFn = 1;
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn2TIM2: GpioAltFn = 2;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn2TIM1: GpioAltFn = 2;
#[doc = "< SAI1_CK1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn3SAI1: GpioAltFn = 3;
#[doc = "< SPI2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn3SPI2: GpioAltFn = 3;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn3TIM1: GpioAltFn = 3;
#[doc = "< I2C1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn4I2C1: GpioAltFn = 4;
#[doc = "< I2C3 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn4I2C3: GpioAltFn = 4;
#[doc = "< SPI1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn5SPI1: GpioAltFn = 5;
#[doc = "< SPI2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn5SPI2: GpioAltFn = 5;
#[doc = "< MCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6MCO: GpioAltFn = 6;
#[doc = "< LSCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6LSCO: GpioAltFn = 6;
#[doc = "< RF_DTB0 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB0: GpioAltFn = 6;
#[doc = "< RF_DTB1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB1: GpioAltFn = 6;
#[doc = "< RF_DTB2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB2: GpioAltFn = 6;
#[doc = "< RF_DTB3 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB3: GpioAltFn = 6;
#[doc = "< RF_DTB4 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB4: GpioAltFn = 6;
#[doc = "< RF_DTB5 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB5: GpioAltFn = 6;
#[doc = "< RF_DTB6 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB6: GpioAltFn = 6;
#[doc = "< RF_DTB7 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB7: GpioAltFn = 6;
#[doc = "< RF_DTB8 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB8: GpioAltFn = 6;
#[doc = "< RF_DTB9 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB9: GpioAltFn = 6;
#[doc = "< RF_DTB10 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB10: GpioAltFn = 6;
#[doc = "< RF_DTB11 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB11: GpioAltFn = 6;
#[doc = "< RF_DTB12 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB12: GpioAltFn = 6;
#[doc = "< RF_DTB13 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB13: GpioAltFn = 6;
#[doc = "< RF_DTB14 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB14: GpioAltFn = 6;
#[doc = "< RF_DTB15 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB15: GpioAltFn = 6;
#[doc = "< RF_DTB16 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB16: GpioAltFn = 6;
#[doc = "< RF_DTB17 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB17: GpioAltFn = 6;
#[doc = "< RF_DTB18 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB18: GpioAltFn = 6;
#[doc = "< RF_MISO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_MISO: GpioAltFn = 6;
#[doc = "< RF_MOSI Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_MOSI: GpioAltFn = 6;
#[doc = "< RF_SCK Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_SCK: GpioAltFn = 6;
#[doc = "< RF_NSS Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_NSS: GpioAltFn = 6;
#[doc = "< USART1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn7USART1: GpioAltFn = 7;
#[doc = "< LPUART1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn8LPUART1: GpioAltFn = 8;
#[doc = "< IR Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn8IR: GpioAltFn = 8;
#[doc = "< TSC Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn9TSC: GpioAltFn = 9;
#[doc = "< QUADSPI Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn10QUADSPI: GpioAltFn = 10;
#[doc = "< USB Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn10USB: GpioAltFn = 10;
#[doc = "< LCD Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn11LCD: GpioAltFn = 11;
#[doc = "< COMP1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn12COMP1: GpioAltFn = 12;
#[doc = "< COMP2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn12COMP2: GpioAltFn = 12;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn12TIM1: GpioAltFn = 12;
#[doc = "< SAI1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn13SAI1: GpioAltFn = 13;
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14TIM2: GpioAltFn = 14;
#[doc = "< TIM16 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14TIM16: GpioAltFn = 14;
#[doc = "< TIM17 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14TIM17: GpioAltFn = 14;
#[doc = "< LPTIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14LPTIM2: GpioAltFn = 14;
#[doc = "< EVENTOUT Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn15EVENTOUT: GpioAltFn = 15;
#[doc = "< just dummy value"]
pub const GpioAltFn_GpioAltFnUnused: GpioAltFn = 16;
#[doc = " Gpio alternate functions"]
pub type GpioAltFn = core::ffi::c_uchar;
#[doc = " Gpio structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPin {
    pub port: *mut GPIO_TypeDef,
    pub pin: u16,
}
#[test]
fn bindgen_test_layout_GpioPin() {
    const UNINIT: ::core::mem::MaybeUninit<GpioPin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GpioPin>(),
        16usize,
        concat!("Size of: ", stringify!(GpioPin))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPin>(),
        8usize,
        concat!("Alignment of ", stringify!(GpioPin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPin),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPin),
            "::",
            stringify!(pin)
        )
    );
}
extern "C" {
    #[doc = " GPIO initialization function, simple version"]
    #[doc = " @param gpio  GpioPin"]
    #[doc = " @param mode  GpioMode"]
    pub fn furi_hal_gpio_init_simple(gpio: *const GpioPin, mode: GpioMode);
}
extern "C" {
    #[doc = " GPIO initialization function, normal version"]
    #[doc = " @param gpio  GpioPin"]
    #[doc = " @param mode  GpioMode"]
    #[doc = " @param pull  GpioPull"]
    #[doc = " @param speed GpioSpeed"]
    pub fn furi_hal_gpio_init(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
    );
}
extern "C" {
    #[doc = " GPIO initialization function, extended version"]
    #[doc = " @param gpio  GpioPin"]
    #[doc = " @param mode  GpioMode"]
    #[doc = " @param pull  GpioPull"]
    #[doc = " @param speed GpioSpeed"]
    #[doc = " @param alt_fn GpioAltFn"]
    pub fn furi_hal_gpio_init_ex(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
        alt_fn: GpioAltFn,
    );
}
extern "C" {
    #[doc = " Add and enable interrupt"]
    #[doc = " @param gpio GpioPin"]
    #[doc = " @param cb   GpioExtiCallback"]
    #[doc = " @param ctx  context for callback"]
    pub fn furi_hal_gpio_add_int_callback(
        gpio: *const GpioPin,
        cb: GpioExtiCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Enable interrupt"]
    #[doc = " @param gpio GpioPin"]
    pub fn furi_hal_gpio_enable_int_callback(gpio: *const GpioPin);
}
extern "C" {
    #[doc = " Disable interrupt"]
    #[doc = " @param gpio GpioPin"]
    pub fn furi_hal_gpio_disable_int_callback(gpio: *const GpioPin);
}
extern "C" {
    #[doc = " Remove interrupt"]
    #[doc = " @param gpio GpioPin"]
    pub fn furi_hal_gpio_remove_int_callback(gpio: *const GpioPin);
}
extern "C" {
    pub fn furi_run();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bt {
    _unused: [u8; 0],
}
pub const BtStatus_BtStatusUnavailable: BtStatus = 0;
pub const BtStatus_BtStatusOff: BtStatus = 1;
pub const BtStatus_BtStatusAdvertising: BtStatus = 2;
pub const BtStatus_BtStatusConnected: BtStatus = 3;
pub type BtStatus = core::ffi::c_uchar;
pub const BtProfile_BtProfileSerial: BtProfile = 0;
pub const BtProfile_BtProfileHidKeyboard: BtProfile = 1;
pub type BtProfile = core::ffi::c_uchar;
pub type BtStatusChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(status: BtStatus, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Change BLE Profile"]
    #[doc = " @note Call of this function leads to 2nd core restart"]
    #[doc = ""]
    #[doc = " @param bt        Bt instance"]
    #[doc = " @param profile   BtProfile"]
    #[doc = ""]
    #[doc = " @return          true on success"]
    pub fn bt_set_profile(bt: *mut Bt, profile: BtProfile) -> bool;
}
extern "C" {
    #[doc = " Disconnect from Central"]
    #[doc = ""]
    #[doc = " @param bt        Bt instance"]
    pub fn bt_disconnect(bt: *mut Bt);
}
extern "C" {
    #[doc = " Set callback for Bluetooth status change notification"]
    #[doc = ""]
    #[doc = " @param bt        Bt instance"]
    #[doc = " @param callback  BtStatusChangedCallback instance"]
    #[doc = " @param context   pointer to context"]
    pub fn bt_set_status_changed_callback(
        bt: *mut Bt,
        callback: BtStatusChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Forget bonded devices"]
    #[doc = " @note Leads to wipe ble key storage and deleting bt.keys"]
    #[doc = ""]
    #[doc = " @param bt        Bt instance"]
    pub fn bt_forget_bonded_devices(bt: *mut Bt);
}
#[doc = "< Default, loader lock is used"]
pub const CliCommandFlag_CliCommandFlagDefault: CliCommandFlag = 0;
pub const CliCommandFlag_CliCommandFlagParallelSafe: CliCommandFlag = 1;
#[doc = "< Safe to run with insomnia mode on"]
pub const CliCommandFlag_CliCommandFlagInsomniaSafe: CliCommandFlag = 2;
pub type CliCommandFlag = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cli {
    _unused: [u8; 0],
}
#[doc = " Cli callback function pointer. Implement this interface and use"]
#[doc = " add_cli_command"]
#[doc = " @param      args     string with what was passed after command"]
#[doc = " @param      context  pointer to whatever you gave us on cli_add_command"]
pub type CliCallback = ::core::option::Option<
    unsafe extern "C" fn(cli: *mut Cli, args: *mut FuriString, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Add cli command Registers you command callback"]
    #[doc = ""]
    #[doc = " @param      cli       pointer to cli instance"]
    #[doc = " @param      name      command name"]
    #[doc = " @param      flags     CliCommandFlag"]
    #[doc = " @param      callback  callback function"]
    #[doc = " @param      context   pointer to whatever we need to pass to callback"]
    pub fn cli_add_command(
        cli: *mut Cli,
        name: *const core::ffi::c_char,
        flags: CliCommandFlag,
        callback: CliCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Print unified cmd usage tip"]
    #[doc = ""]
    #[doc = " @param      cmd    cmd name"]
    #[doc = " @param      usage  usage tip"]
    #[doc = " @param      arg    arg passed by user"]
    pub fn cli_print_usage(
        cmd: *const core::ffi::c_char,
        usage: *const core::ffi::c_char,
        arg: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Delete cli command"]
    #[doc = ""]
    #[doc = " @param      cli   pointer to cli instance"]
    #[doc = " @param      name  command name"]
    pub fn cli_delete_command(cli: *mut Cli, name: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Read from terminal"]
    #[doc = ""]
    #[doc = " @param      cli     Cli instance"]
    #[doc = " @param      buffer  pointer to buffer"]
    #[doc = " @param      size    size of buffer in bytes"]
    #[doc = ""]
    #[doc = " @return     bytes read"]
    pub fn cli_read(cli: *mut Cli, buffer: *mut u8, size: usize) -> usize;
}
extern "C" {
    #[doc = " Non-blocking read from terminal"]
    #[doc = ""]
    #[doc = " @param      cli     Cli instance"]
    #[doc = " @param      buffer  pointer to buffer"]
    #[doc = " @param      size    size of buffer in bytes"]
    #[doc = " @param      timeout timeout value in ms"]
    #[doc = ""]
    #[doc = " @return     bytes read"]
    pub fn cli_read_timeout(cli: *mut Cli, buffer: *mut u8, size: usize, timeout: u32) -> usize;
}
extern "C" {
    #[doc = " Non-blocking check for interrupt command received"]
    #[doc = ""]
    #[doc = " @param      cli   Cli instance"]
    #[doc = ""]
    #[doc = " @return     true if received"]
    pub fn cli_cmd_interrupt_received(cli: *mut Cli) -> bool;
}
extern "C" {
    #[doc = " Write to terminal Do it only from inside of cli call."]
    #[doc = ""]
    #[doc = " @param      cli     Cli instance"]
    #[doc = " @param      buffer  pointer to buffer"]
    #[doc = " @param      size    size of buffer in bytes"]
    pub fn cli_write(cli: *mut Cli, buffer: *const u8, size: usize);
}
extern "C" {
    #[doc = " Read character"]
    #[doc = ""]
    #[doc = " @param      cli   Cli instance"]
    #[doc = ""]
    #[doc = " @return     char"]
    pub fn cli_getc(cli: *mut Cli) -> core::ffi::c_char;
}
extern "C" {
    #[doc = " New line Send new ine sequence"]
    pub fn cli_nl();
}
extern "C" {
    pub fn cli_session_open(cli: *mut Cli, session: *mut core::ffi::c_void);
}
extern "C" {
    pub fn cli_session_close(cli: *mut Cli);
}
extern "C" {
    pub fn cli_is_connected(cli: *mut Cli) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CliSession {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut cli_vcp: CliSession;
}
extern "C" {
    #[doc = " Get icon width"]
    #[doc = ""]
    #[doc = " @param[in]  instance  pointer to Icon data"]
    #[doc = ""]
    #[doc = " @return     width in pixels"]
    pub fn icon_get_width(instance: *const Icon) -> u8;
}
extern "C" {
    #[doc = " Get icon height"]
    #[doc = ""]
    #[doc = " @param[in]  instance  pointer to Icon data"]
    #[doc = ""]
    #[doc = " @return     height in pixels"]
    pub fn icon_get_height(instance: *const Icon) -> u8;
}
extern "C" {
    #[doc = " Get Icon XBM bitmap data"]
    #[doc = ""]
    #[doc = " @param[in]  instance  pointer to Icon data"]
    #[doc = ""]
    #[doc = " @return     pointer to XBM bitmap data"]
    pub fn icon_get_data(instance: *const Icon) -> *const u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IconAnimation {
    _unused: [u8; 0],
}
#[doc = " Icon Animation Callback. Used for update notification"]
pub type IconAnimationCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut IconAnimation, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Allocate icon animation instance with const icon data."]
    #[doc = ""]
    #[doc = " always returns Icon or stops system if not enough memory"]
    #[doc = ""]
    #[doc = " @param[in]  icon  pointer to Icon data"]
    #[doc = ""]
    #[doc = " @return     IconAnimation instance"]
    pub fn icon_animation_alloc(icon: *const Icon) -> *mut IconAnimation;
}
extern "C" {
    #[doc = " Release icon animation instance"]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    pub fn icon_animation_free(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = " Set IconAnimation update callback"]
    #[doc = ""]
    #[doc = " Normally you do not need to use this function, use view_tie_icon_animation"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    #[doc = " @param[in]  callback  IconAnimationCallback"]
    #[doc = " @param      context   callback context"]
    pub fn icon_animation_set_update_callback(
        instance: *mut IconAnimation,
        callback: IconAnimationCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get icon animation width"]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    #[doc = ""]
    #[doc = " @return     width in pixels"]
    pub fn icon_animation_get_width(instance: *mut IconAnimation) -> u8;
}
extern "C" {
    #[doc = " Get icon animation height"]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    #[doc = ""]
    #[doc = " @return     height in pixels"]
    pub fn icon_animation_get_height(instance: *mut IconAnimation) -> u8;
}
extern "C" {
    #[doc = " Start icon animation"]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    pub fn icon_animation_start(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = " Stop icon animation"]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    pub fn icon_animation_stop(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = " Returns true if current frame is a last one"]
    #[doc = ""]
    #[doc = " @param      instance  IconAnimation instance"]
    #[doc = ""]
    #[doc = " @return     true if last frame"]
    pub fn icon_animation_is_last_frame(instance: *mut IconAnimation) -> bool;
}
pub const Color_ColorWhite: Color = 0;
pub const Color_ColorBlack: Color = 1;
#[doc = " Color enumeration"]
pub type Color = core::ffi::c_uchar;
pub const Font_FontPrimary: Font = 0;
pub const Font_FontSecondary: Font = 1;
pub const Font_FontKeyboard: Font = 2;
pub const Font_FontBigNumbers: Font = 3;
pub const Font_FontTotalNumber: Font = 4;
#[doc = " Fonts enumeration"]
pub type Font = core::ffi::c_uchar;
pub const Align_AlignLeft: Align = 0;
pub const Align_AlignRight: Align = 1;
pub const Align_AlignTop: Align = 2;
pub const Align_AlignBottom: Align = 3;
pub const Align_AlignCenter: Align = 4;
#[doc = " Alignment enumeration"]
pub type Align = core::ffi::c_uchar;
pub const CanvasDirection_CanvasDirectionLeftToRight: CanvasDirection = 0;
pub const CanvasDirection_CanvasDirectionTopToBottom: CanvasDirection = 1;
pub const CanvasDirection_CanvasDirectionRightToLeft: CanvasDirection = 2;
pub const CanvasDirection_CanvasDirectionBottomToTop: CanvasDirection = 3;
#[doc = " Font Direction"]
pub type CanvasDirection = core::ffi::c_uchar;
#[doc = " Font parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CanvasFontParameters {
    pub leading_default: u8,
    pub leading_min: u8,
    pub height: u8,
    pub descender: u8,
}
#[test]
fn bindgen_test_layout_CanvasFontParameters() {
    const UNINIT: ::core::mem::MaybeUninit<CanvasFontParameters> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CanvasFontParameters>(),
        4usize,
        concat!("Size of: ", stringify!(CanvasFontParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<CanvasFontParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(CanvasFontParameters))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leading_default) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(leading_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leading_min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(leading_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(descender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Canvas {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get Canvas width"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = ""]
    #[doc = " @return     width in pixels."]
    pub fn canvas_width(canvas: *mut Canvas) -> u8;
}
extern "C" {
    #[doc = " Get Canvas height"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = ""]
    #[doc = " @return     height in pixels."]
    pub fn canvas_height(canvas: *mut Canvas) -> u8;
}
extern "C" {
    #[doc = " Get current font height"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = ""]
    #[doc = " @return     height in pixels."]
    pub fn canvas_current_font_height(canvas: *mut Canvas) -> u8;
}
extern "C" {
    #[doc = " Get font parameters"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      font    Font"]
    #[doc = ""]
    #[doc = " @return     pointer to CanvasFontParameters structure"]
    pub fn canvas_get_font_params(canvas: *mut Canvas, font: Font) -> *mut CanvasFontParameters;
}
extern "C" {
    #[doc = " Clear canvas"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    pub fn canvas_clear(canvas: *mut Canvas);
}
extern "C" {
    #[doc = " Set drawing color"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      color   Color"]
    pub fn canvas_set_color(canvas: *mut Canvas, color: Color);
}
extern "C" {
    #[doc = " Set font swap"]
    #[doc = " Argument String Rotation Description"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      dir     Direction font"]
    pub fn canvas_set_font_direction(canvas: *mut Canvas, dir: CanvasDirection);
}
extern "C" {
    #[doc = " Invert drawing color"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    pub fn canvas_invert_color(canvas: *mut Canvas);
}
extern "C" {
    #[doc = " Set drawing font"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      font    Font"]
    pub fn canvas_set_font(canvas: *mut Canvas, font: Font);
}
extern "C" {
    #[doc = " Draw string at position of baseline defined by x, y."]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       anchor point x coordinate"]
    #[doc = " @param      y       anchor point y coordinate"]
    #[doc = " @param      str     C-string"]
    pub fn canvas_draw_str(canvas: *mut Canvas, x: u8, y: u8, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw aligned string defined by x, y."]
    #[doc = ""]
    #[doc = " Align calculated from position of baseline, string width and ascent (height"]
    #[doc = " of the glyphs above the baseline)"]
    #[doc = ""]
    #[doc = " @param      canvas      Canvas instance"]
    #[doc = " @param      x           anchor point x coordinate"]
    #[doc = " @param      y           anchor point y coordinate"]
    #[doc = " @param      horizontal  horizontal alignment"]
    #[doc = " @param      vertical    vertical alignment"]
    #[doc = " @param      str         C-string"]
    pub fn canvas_draw_str_aligned(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        str_: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get string width"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      str     C-string"]
    #[doc = ""]
    #[doc = " @return     width in pixels."]
    pub fn canvas_string_width(canvas: *mut Canvas, str_: *const core::ffi::c_char) -> u16;
}
extern "C" {
    #[doc = " Get glyph width"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param[in]  symbol  character"]
    #[doc = ""]
    #[doc = " @return     width in pixels"]
    pub fn canvas_glyph_width(canvas: *mut Canvas, symbol: core::ffi::c_char) -> u8;
}
extern "C" {
    #[doc = " Draw bitmap picture at position defined by x,y."]
    #[doc = ""]
    #[doc = " @param      canvas                   Canvas instance"]
    #[doc = " @param      x                        x coordinate"]
    #[doc = " @param      y                        y coordinate"]
    #[doc = " @param      width                    width of bitmap"]
    #[doc = " @param      height                   height of bitmap"]
    #[doc = " @param      compressed_bitmap_data   compressed bitmap data"]
    pub fn canvas_draw_bitmap(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        compressed_bitmap_data: *const u8,
    );
}
extern "C" {
    #[doc = " Draw animation at position defined by x,y."]
    #[doc = ""]
    #[doc = " @param      canvas          Canvas instance"]
    #[doc = " @param      x               x coordinate"]
    #[doc = " @param      y               y coordinate"]
    #[doc = " @param      icon_animation  IconAnimation instance"]
    pub fn canvas_draw_icon_animation(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        icon_animation: *mut IconAnimation,
    );
}
extern "C" {
    #[doc = " Draw icon at position defined by x,y."]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      icon    Icon instance"]
    pub fn canvas_draw_icon(canvas: *mut Canvas, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Draw XBM bitmap"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      w       bitmap width"]
    #[doc = " @param      h       bitmap height"]
    #[doc = " @param      bitmap  pointer to XBM bitmap data"]
    pub fn canvas_draw_xbm(canvas: *mut Canvas, x: u8, y: u8, w: u8, h: u8, bitmap: *const u8);
}
extern "C" {
    #[doc = " Draw dot at x,y"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    pub fn canvas_draw_dot(canvas: *mut Canvas, x: u8, y: u8);
}
extern "C" {
    #[doc = " Draw box of width, height at x,y"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      width   box width"]
    #[doc = " @param      height  box height"]
    pub fn canvas_draw_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw frame of width, height at x,y"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      width   frame width"]
    #[doc = " @param      height  frame height"]
    pub fn canvas_draw_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw line from x1,y1 to x2,y2"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x1      x1 coordinate"]
    #[doc = " @param      y1      y1 coordinate"]
    #[doc = " @param      x2      x2 coordinate"]
    #[doc = " @param      y2      y2 coordinate"]
    pub fn canvas_draw_line(canvas: *mut Canvas, x1: u8, y1: u8, x2: u8, y2: u8);
}
extern "C" {
    #[doc = " Draw circle at x,y with radius r"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      r       radius"]
    pub fn canvas_draw_circle(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
    #[doc = " Draw disc at x,y with radius r"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      r       radius"]
    pub fn canvas_draw_disc(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
    #[doc = " Draw triangle with given base and height lengths and their intersection coordinate"]
    #[doc = ""]
    #[doc = " @param       canvas  Canvas instance"]
    #[doc = " @param       x       x coordinate of base and height intersection"]
    #[doc = " @param       y       y coordinate of base and height intersection"]
    #[doc = " @param       base    length of triangle side"]
    #[doc = " @param       height  length of triangle height"]
    #[doc = " @param       dir     CanvasDirection triangle orientation"]
    pub fn canvas_draw_triangle(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        base: u8,
        height: u8,
        dir: CanvasDirection,
    );
}
extern "C" {
    #[doc = " Draw glyph"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      ch      character"]
    pub fn canvas_draw_glyph(canvas: *mut Canvas, x: u8, y: u8, ch: u16);
}
extern "C" {
    #[doc = " Set transparency mode"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      alpha   transparency mode"]
    pub fn canvas_set_bitmap_mode(canvas: *mut Canvas, alpha: bool);
}
extern "C" {
    #[doc = " Draw rounded-corner frame of width, height at x,y, with round value radius"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      width   frame width"]
    #[doc = " @param      height  frame height"]
    #[doc = " @param      radius  frame corner radius"]
    pub fn canvas_draw_rframe(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
extern "C" {
    #[doc = " Draw rounded-corner box of width, height at x,y, with round value raduis"]
    #[doc = ""]
    #[doc = " @param      canvas  Canvas instance"]
    #[doc = " @param      x       x coordinate"]
    #[doc = " @param      y       y coordinate"]
    #[doc = " @param      width   box width"]
    #[doc = " @param      height  box height"]
    #[doc = " @param      radius  box corner radius"]
    pub fn canvas_draw_rbox(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
pub const InputKey_InputKeyUp: InputKey = 0;
pub const InputKey_InputKeyDown: InputKey = 1;
pub const InputKey_InputKeyRight: InputKey = 2;
pub const InputKey_InputKeyLeft: InputKey = 3;
pub const InputKey_InputKeyOk: InputKey = 4;
pub const InputKey_InputKeyBack: InputKey = 5;
#[doc = "< Special value"]
pub const InputKey_InputKeyMAX: InputKey = 6;
pub type InputKey = core::ffi::c_uchar;
pub const Light_LightRed: Light = 1;
pub const Light_LightGreen: Light = 2;
pub const Light_LightBlue: Light = 4;
pub const Light_LightBacklight: Light = 8;
pub type Light = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputPin {
    pub gpio: *const GpioPin,
    pub key: InputKey,
    pub inverted: bool,
    pub name: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InputPin() {
    const UNINIT: ::core::mem::MaybeUninit<InputPin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputPin>(),
        24usize,
        concat!("Size of: ", stringify!(InputPin))
    );
    assert_eq!(
        ::core::mem::align_of::<InputPin>(),
        8usize,
        concat!("Alignment of ", stringify!(InputPin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(gpio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inverted) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(inverted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    pub static input_pins: [InputPin; 0usize];
}
extern "C" {
    pub static input_pins_count: usize;
}
extern "C" {
    pub static vibro_gpio: GpioPin;
}
extern "C" {
    pub static ibutton_gpio: GpioPin;
}
extern "C" {
    pub static gpio_cc1101_g0: GpioPin;
}
extern "C" {
    pub static gpio_rf_sw_0: GpioPin;
}
extern "C" {
    pub static gpio_subghz_cs: GpioPin;
}
extern "C" {
    pub static gpio_display_cs: GpioPin;
}
extern "C" {
    pub static gpio_display_rst_n: GpioPin;
}
extern "C" {
    pub static gpio_display_di: GpioPin;
}
extern "C" {
    pub static gpio_sdcard_cs: GpioPin;
}
extern "C" {
    pub static gpio_sdcard_cd: GpioPin;
}
extern "C" {
    pub static gpio_nfc_cs: GpioPin;
}
extern "C" {
    pub static gpio_button_up: GpioPin;
}
extern "C" {
    pub static gpio_button_down: GpioPin;
}
extern "C" {
    pub static gpio_button_right: GpioPin;
}
extern "C" {
    pub static gpio_button_left: GpioPin;
}
extern "C" {
    pub static gpio_button_ok: GpioPin;
}
extern "C" {
    pub static gpio_button_back: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_miso: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_mosi: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_sck: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_miso: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_mosi: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_sck: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc0: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc1: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc3: GpioPin;
}
extern "C" {
    pub static gpio_ext_pb2: GpioPin;
}
extern "C" {
    pub static gpio_ext_pb3: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa4: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa6: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa7: GpioPin;
}
extern "C" {
    pub static gpio_nfc_irq_rfid_pull: GpioPin;
}
extern "C" {
    pub static gpio_rfid_carrier_out: GpioPin;
}
extern "C" {
    pub static gpio_rfid_data_in: GpioPin;
}
extern "C" {
    pub static gpio_rfid_carrier: GpioPin;
}
extern "C" {
    pub static gpio_infrared_rx: GpioPin;
}
extern "C" {
    pub static gpio_infrared_tx: GpioPin;
}
extern "C" {
    pub static gpio_usart_tx: GpioPin;
}
extern "C" {
    pub static gpio_usart_rx: GpioPin;
}
extern "C" {
    pub static gpio_i2c_power_sda: GpioPin;
}
extern "C" {
    pub static gpio_i2c_power_scl: GpioPin;
}
extern "C" {
    pub static gpio_speaker: GpioPin;
}
extern "C" {
    pub static periph_power: GpioPin;
}
extern "C" {
    pub static gpio_usb_dm: GpioPin;
}
extern "C" {
    pub static gpio_usb_dp: GpioPin;
}
extern "C" {
    pub fn furi_hal_resources_deinit_early();
}
#[doc = "< Press event, emitted after debounce"]
pub const InputType_InputTypePress: InputType = 0;
#[doc = "< Release event, emitted after debounce"]
pub const InputType_InputTypeRelease: InputType = 1;
#[doc = "< Short event, emitted after InputTypeRelease done withing INPUT_LONG_PRESS interval"]
pub const InputType_InputTypeShort: InputType = 2;
#[doc = "< Long event, emmited after INPUT_LONG_PRESS interval, asynchronouse to InputTypeRelease"]
pub const InputType_InputTypeLong: InputType = 3;
#[doc = "< Repeat event, emmited with INPUT_REPEATE_PRESS period after InputTypeLong event"]
pub const InputType_InputTypeRepeat: InputType = 4;
#[doc = "< Special value for exceptional"]
pub const InputType_InputTypeMAX: InputType = 5;
#[doc = " Input Types"]
#[doc = " Some of them are physical events and some logical"]
pub type InputType = core::ffi::c_uchar;
#[doc = " Input Event, dispatches with FuriPubSub"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputEvent {
    pub sequence: u32,
    pub key: InputKey,
    pub type_: InputType,
}
#[test]
fn bindgen_test_layout_InputEvent() {
    const UNINIT: ::core::mem::MaybeUninit<InputEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputEvent>(),
        8usize,
        concat!("Size of: ", stringify!(InputEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<InputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(InputEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Get human readable input key name"]
    #[doc = " @param key - InputKey"]
    #[doc = " @return string"]
    pub fn input_get_key_name(key: InputKey) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get human readable input type name"]
    #[doc = " @param type - InputType"]
    #[doc = " @return string"]
    pub fn input_get_type_name(type_: InputType) -> *const core::ffi::c_char;
}
pub const ViewOrientation_ViewOrientationHorizontal: ViewOrientation = 0;
pub const ViewOrientation_ViewOrientationHorizontalFlip: ViewOrientation = 1;
pub const ViewOrientation_ViewOrientationVertical: ViewOrientation = 2;
pub const ViewOrientation_ViewOrientationVerticalFlip: ViewOrientation = 3;
pub type ViewOrientation = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct View {
    _unused: [u8; 0],
}
#[doc = " View Draw callback"]
#[doc = " @param      canvas,      pointer to canvas"]
#[doc = " @param      view_model,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, model: *mut core::ffi::c_void),
>;
#[doc = " View Input callback"]
#[doc = " @param      event,    pointer to input event data"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     true if event handled, false if event ignored"]
#[doc = " @warning    called from GUI thread"]
pub type ViewInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = " View Custom callback"]
#[doc = " @param      event,    number of custom event"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     true if event handled, false if event ignored"]
pub type ViewCustomCallback = ::core::option::Option<
    unsafe extern "C" fn(event: u32, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = " View navigation callback"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @return     next view id"]
#[doc = " @warning    called from GUI thread"]
pub type ViewNavigationCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> u32>;
#[doc = " View callback"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " View Update Callback Called upon model change, need to be propagated to GUI"]
#[doc = " throw ViewPort update"]
#[doc = " @param      view,     pointer to view"]
#[doc = " @param      context,  pointer to context"]
#[doc = " @warning    called from GUI thread"]
pub type ViewUpdateCallback =
    ::core::option::Option<unsafe extern "C" fn(view: *mut View, context: *mut core::ffi::c_void)>;
#[doc = " Model is not allocated"]
pub const ViewModelType_ViewModelTypeNone: ViewModelType = 0;
#[doc = " Model consist of atomic types and/or partial update is not critical for rendering."]
#[doc = " Lock free."]
pub const ViewModelType_ViewModelTypeLockFree: ViewModelType = 1;
#[doc = " Model access is guarded with mutex."]
#[doc = " Locking gui thread."]
pub const ViewModelType_ViewModelTypeLocking: ViewModelType = 2;
#[doc = " View model types"]
pub type ViewModelType = core::ffi::c_uchar;
extern "C" {
    #[doc = " Allocate and init View"]
    #[doc = " @return View instance"]
    pub fn view_alloc() -> *mut View;
}
extern "C" {
    #[doc = " Free View"]
    #[doc = ""]
    #[doc = " @param      view  instance"]
    pub fn view_free(view: *mut View);
}
extern "C" {
    #[doc = " Tie IconAnimation with View"]
    #[doc = ""]
    #[doc = " @param      view            View instance"]
    #[doc = " @param      icon_animation  IconAnimation instance"]
    pub fn view_tie_icon_animation(view: *mut View, icon_animation: *mut IconAnimation);
}
extern "C" {
    #[doc = " Set View Draw callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  draw callback"]
    pub fn view_set_draw_callback(view: *mut View, callback: ViewDrawCallback);
}
extern "C" {
    #[doc = " Set View Input callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  input callback"]
    pub fn view_set_input_callback(view: *mut View, callback: ViewInputCallback);
}
extern "C" {
    #[doc = " Set View Custom callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  input callback"]
    pub fn view_set_custom_callback(view: *mut View, callback: ViewCustomCallback);
}
extern "C" {
    #[doc = " Set Navigation Previous callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  input callback"]
    pub fn view_set_previous_callback(view: *mut View, callback: ViewNavigationCallback);
}
extern "C" {
    #[doc = " Set Enter callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  callback"]
    pub fn view_set_enter_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
    #[doc = " Set Exit callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  callback"]
    pub fn view_set_exit_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
    #[doc = " Set Update callback"]
    #[doc = ""]
    #[doc = " @param      view      View instance"]
    #[doc = " @param      callback  callback"]
    pub fn view_set_update_callback(view: *mut View, callback: ViewUpdateCallback);
}
extern "C" {
    #[doc = " Set View Draw callback"]
    #[doc = ""]
    #[doc = " @param      view     View instance"]
    #[doc = " @param      context  context for callbacks"]
    pub fn view_set_update_callback_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set View Draw callback"]
    #[doc = ""]
    #[doc = " @param      view     View instance"]
    #[doc = " @param      context  context for callbacks"]
    pub fn view_set_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set View Orientation"]
    #[doc = ""]
    #[doc = " @param      view         View instance"]
    #[doc = " @param      orientation  either vertical or horizontal"]
    pub fn view_set_orientation(view: *mut View, orientation: ViewOrientation);
}
extern "C" {
    #[doc = " Allocate view model."]
    #[doc = ""]
    #[doc = " @param      view  View instance"]
    #[doc = " @param      type  View Model Type"]
    #[doc = " @param      size  size"]
    pub fn view_allocate_model(view: *mut View, type_: ViewModelType, size: usize);
}
extern "C" {
    #[doc = " Free view model data memory."]
    #[doc = ""]
    #[doc = " @param      view  View instance"]
    pub fn view_free_model(view: *mut View);
}
extern "C" {
    #[doc = " Get view model data"]
    #[doc = ""]
    #[doc = " @param      view  View instance"]
    #[doc = ""]
    #[doc = " @return     pointer to model data"]
    #[doc = " @warning    Don't forget to commit model changes"]
    pub fn view_get_model(view: *mut View) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Commit view model"]
    #[doc = ""]
    #[doc = " @param      view    View instance"]
    #[doc = " @param      update  true if you want to emit view update, false otherwise"]
    pub fn view_commit_model(view: *mut View, update: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileBrowser {
    _unused: [u8; 0],
}
pub type FileBrowserCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type FileBrowserLoadItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        path: *mut FuriString,
        context: *mut core::ffi::c_void,
        icon: *mut *mut u8,
        item_name: *mut FuriString,
    ) -> bool,
>;
extern "C" {
    pub fn file_browser_alloc(result_path: *mut FuriString) -> *mut FileBrowser;
}
extern "C" {
    pub fn file_browser_free(browser: *mut FileBrowser);
}
extern "C" {
    pub fn file_browser_get_view(browser: *mut FileBrowser) -> *mut View;
}
extern "C" {
    pub fn file_browser_configure(
        browser: *mut FileBrowser,
        extension: *const core::ffi::c_char,
        skip_assets: bool,
        file_icon: *const Icon,
        hide_ext: bool,
    );
}
extern "C" {
    pub fn file_browser_start(browser: *mut FileBrowser, path: *mut FuriString);
}
extern "C" {
    pub fn file_browser_stop(browser: *mut FileBrowser);
}
extern "C" {
    pub fn file_browser_set_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn file_browser_set_item_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserLoadItemCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsApp {
    _unused: [u8; 0],
}
#[doc = " File browser dialog extra options"]
#[doc = " @param extension file extension to be offered for selection"]
#[doc = " @param skip_assets true - do not show assets folders"]
#[doc = " @param icon file icon pointer, NULL for default icon"]
#[doc = " @param hide_ext true - hide extensions for files"]
#[doc = " @param item_loader_callback callback function for providing custom icon & entry name"]
#[doc = " @param hide_ext callback context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsFileBrowserOptions {
    pub extension: *const core::ffi::c_char,
    pub skip_assets: bool,
    pub icon: *const Icon,
    pub hide_ext: bool,
    pub item_loader_callback: FileBrowserLoadItemCallback,
    pub item_loader_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_DialogsFileBrowserOptions() {
    const UNINIT: ::core::mem::MaybeUninit<DialogsFileBrowserOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DialogsFileBrowserOptions>(),
        48usize,
        concat!("Size of: ", stringify!(DialogsFileBrowserOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<DialogsFileBrowserOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(DialogsFileBrowserOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip_assets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(skip_assets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hide_ext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(hide_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_loader_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(item_loader_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_loader_context) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(item_loader_context)
        )
    );
}
extern "C" {
    #[doc = " Initialize file browser dialog options"]
    #[doc = " and set default values"]
    #[doc = " @param options pointer to options structure"]
    #[doc = " @param extension file extension to filter"]
    #[doc = " @param icon file icon pointer, NULL for default icon"]
    pub fn dialog_file_browser_set_basic_options(
        options: *mut DialogsFileBrowserOptions,
        extension: *const core::ffi::c_char,
        icon: *const Icon,
    );
}
extern "C" {
    #[doc = " Shows and processes the file browser dialog"]
    #[doc = " @param context api pointer"]
    #[doc = " @param result_path selected file path string pointer"]
    #[doc = " @param path preselected file path string pointer"]
    #[doc = " @param options file browser dialog extra options, may be null"]
    #[doc = " @return bool whether a file was selected"]
    pub fn dialog_file_browser_show(
        context: *mut DialogsApp,
        result_path: *mut FuriString,
        path: *mut FuriString,
        options: *const DialogsFileBrowserOptions,
    ) -> bool;
}
pub const DialogMessageButton_DialogMessageButtonBack: DialogMessageButton = 0;
pub const DialogMessageButton_DialogMessageButtonLeft: DialogMessageButton = 1;
pub const DialogMessageButton_DialogMessageButtonCenter: DialogMessageButton = 2;
pub const DialogMessageButton_DialogMessageButtonRight: DialogMessageButton = 3;
#[doc = " Message result type"]
pub type DialogMessageButton = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogMessage {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and fill message"]
    #[doc = " @return DialogMessage*"]
    pub fn dialog_message_alloc() -> *mut DialogMessage;
}
extern "C" {
    #[doc = " Free message struct"]
    #[doc = " @param message message pointer"]
    pub fn dialog_message_free(message: *mut DialogMessage);
}
extern "C" {
    #[doc = " Set message text"]
    #[doc = " @param message message pointer"]
    #[doc = " @param text text, can be NULL if you don't want to display the text"]
    #[doc = " @param x x position"]
    #[doc = " @param y y position"]
    #[doc = " @param horizontal horizontal alignment"]
    #[doc = " @param vertical vertical alignment"]
    pub fn dialog_message_set_text(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set message header"]
    #[doc = " @param message message pointer"]
    #[doc = " @param text text, can be NULL if you don't want to display the header"]
    #[doc = " @param x x position"]
    #[doc = " @param y y position"]
    #[doc = " @param horizontal horizontal alignment"]
    #[doc = " @param vertical vertical alignment"]
    pub fn dialog_message_set_header(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set message icon"]
    #[doc = " @param message message pointer"]
    #[doc = " @param icon icon pointer, can be NULL if you don't want to display the icon"]
    #[doc = " @param x x position"]
    #[doc = " @param y y position"]
    pub fn dialog_message_set_icon(message: *mut DialogMessage, icon: *const Icon, x: u8, y: u8);
}
extern "C" {
    #[doc = " Set message buttons text, button text can be NULL if you don't want to display and process some buttons"]
    #[doc = " @param message message pointer"]
    #[doc = " @param left left button text, can be NULL if you don't want to display the left button"]
    #[doc = " @param center center button text, can be NULL if you don't want to display the center button"]
    #[doc = " @param right right button text, can be NULL if you don't want to display the right button"]
    pub fn dialog_message_set_buttons(
        message: *mut DialogMessage,
        left: *const core::ffi::c_char,
        center: *const core::ffi::c_char,
        right: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Show message from filled struct"]
    #[doc = " @param context api pointer"]
    #[doc = " @param message message struct pointer to be shown"]
    #[doc = " @return DialogMessageButton type"]
    pub fn dialog_message_show(
        context: *mut DialogsApp,
        message: *const DialogMessage,
    ) -> DialogMessageButton;
}
extern "C" {
    #[doc = " Show SD error message (with question sign)"]
    #[doc = " @param context"]
    #[doc = " @param error_text"]
    pub fn dialog_message_show_storage_error(
        context: *mut DialogsApp,
        error_text: *const core::ffi::c_char,
    );
}
pub const DolphinApp_DolphinAppSubGhz: DolphinApp = 0;
pub const DolphinApp_DolphinAppRfid: DolphinApp = 1;
pub const DolphinApp_DolphinAppNfc: DolphinApp = 2;
pub const DolphinApp_DolphinAppIr: DolphinApp = 3;
pub const DolphinApp_DolphinAppIbutton: DolphinApp = 4;
pub const DolphinApp_DolphinAppBadusb: DolphinApp = 5;
pub const DolphinApp_DolphinAppPlugin: DolphinApp = 6;
pub const DolphinApp_DolphinAppMAX: DolphinApp = 7;
pub type DolphinApp = core::ffi::c_uchar;
pub const DolphinDeed_DolphinDeedSubGhzReceiverInfo: DolphinDeed = 0;
pub const DolphinDeed_DolphinDeedSubGhzSave: DolphinDeed = 1;
pub const DolphinDeed_DolphinDeedSubGhzRawRec: DolphinDeed = 2;
pub const DolphinDeed_DolphinDeedSubGhzAddManually: DolphinDeed = 3;
pub const DolphinDeed_DolphinDeedSubGhzSend: DolphinDeed = 4;
pub const DolphinDeed_DolphinDeedSubGhzFrequencyAnalyzer: DolphinDeed = 5;
pub const DolphinDeed_DolphinDeedRfidRead: DolphinDeed = 6;
pub const DolphinDeed_DolphinDeedRfidReadSuccess: DolphinDeed = 7;
pub const DolphinDeed_DolphinDeedRfidSave: DolphinDeed = 8;
pub const DolphinDeed_DolphinDeedRfidEmulate: DolphinDeed = 9;
pub const DolphinDeed_DolphinDeedRfidAdd: DolphinDeed = 10;
pub const DolphinDeed_DolphinDeedNfcRead: DolphinDeed = 11;
pub const DolphinDeed_DolphinDeedNfcReadSuccess: DolphinDeed = 12;
pub const DolphinDeed_DolphinDeedNfcSave: DolphinDeed = 13;
pub const DolphinDeed_DolphinDeedNfcDetectReader: DolphinDeed = 14;
pub const DolphinDeed_DolphinDeedNfcEmulate: DolphinDeed = 15;
pub const DolphinDeed_DolphinDeedNfcMfcAdd: DolphinDeed = 16;
pub const DolphinDeed_DolphinDeedNfcAddSave: DolphinDeed = 17;
pub const DolphinDeed_DolphinDeedNfcAddEmulate: DolphinDeed = 18;
pub const DolphinDeed_DolphinDeedIrSend: DolphinDeed = 19;
pub const DolphinDeed_DolphinDeedIrLearnSuccess: DolphinDeed = 20;
pub const DolphinDeed_DolphinDeedIrSave: DolphinDeed = 21;
pub const DolphinDeed_DolphinDeedIbuttonRead: DolphinDeed = 22;
pub const DolphinDeed_DolphinDeedIbuttonReadSuccess: DolphinDeed = 23;
pub const DolphinDeed_DolphinDeedIbuttonSave: DolphinDeed = 24;
pub const DolphinDeed_DolphinDeedIbuttonEmulate: DolphinDeed = 25;
pub const DolphinDeed_DolphinDeedIbuttonAdd: DolphinDeed = 26;
pub const DolphinDeed_DolphinDeedBadUsbPlayScript: DolphinDeed = 27;
pub const DolphinDeed_DolphinDeedU2fAuthorized: DolphinDeed = 28;
pub const DolphinDeed_DolphinDeedGpioUartBridge: DolphinDeed = 29;
pub const DolphinDeed_DolphinDeedPluginStart: DolphinDeed = 30;
pub const DolphinDeed_DolphinDeedPluginGameStart: DolphinDeed = 31;
pub const DolphinDeed_DolphinDeedPluginGameWin: DolphinDeed = 32;
pub const DolphinDeed_DolphinDeedMAX: DolphinDeed = 33;
pub const DolphinDeed_DolphinDeedTestLeft: DolphinDeed = 34;
pub const DolphinDeed_DolphinDeedTestRight: DolphinDeed = 35;
pub type DolphinDeed = core::ffi::c_uchar;
extern "C" {
    pub fn dolphin_deed_get_app(deed: DolphinDeed) -> DolphinApp;
}
extern "C" {
    pub fn dolphin_deed_get_app_limit(app: DolphinApp) -> u8;
}
extern "C" {
    pub fn dolphin_deed_get_weight(deed: DolphinDeed) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dolphin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinStats {
    pub icounter: u32,
    pub butthurt: u32,
    pub timestamp: u64,
    pub level: u8,
    pub level_up_is_pending: bool,
}
#[test]
fn bindgen_test_layout_DolphinStats() {
    const UNINIT: ::core::mem::MaybeUninit<DolphinStats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DolphinStats>(),
        24usize,
        concat!("Size of: ", stringify!(DolphinStats))
    );
    assert_eq!(
        ::core::mem::align_of::<DolphinStats>(),
        8usize,
        concat!("Alignment of ", stringify!(DolphinStats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(icounter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).butthurt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(butthurt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level_up_is_pending) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(level_up_is_pending)
        )
    );
}
extern "C" {
    #[doc = " Deed complete notification. Call it on deed completion."]
    #[doc = " See dolphin_deed.h for available deeds. In futures it will become part of assets."]
    #[doc = " Thread safe, async"]
    pub fn dolphin_deed(dolphin: *mut Dolphin, deed: DolphinDeed);
}
extern "C" {
    #[doc = " Retrieve dolphin stats"]
    #[doc = " Thread safe, blocking"]
    pub fn dolphin_stats(dolphin: *mut Dolphin) -> DolphinStats;
}
extern "C" {
    #[doc = " Flush dolphin queue and save state"]
    #[doc = " Thread safe, blocking"]
    pub fn dolphin_flush(dolphin: *mut Dolphin);
}
extern "C" {
    pub fn dolphin_upgrade_level(dolphin: *mut Dolphin);
}
extern "C" {
    pub fn dolphin_get_pubsub(dolphin: *mut Dolphin) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Draw progress bar."]
    #[doc = ""]
    #[doc = " @param   canvas      Canvas instance"]
    #[doc = " @param   x           progress bar position on X axis"]
    #[doc = " @param   y           progress bar position on Y axis"]
    #[doc = " @param   width       progress bar width"]
    #[doc = " @param   progress    progress (0.0 - 1.0)"]
    pub fn elements_progress_bar(canvas: *mut Canvas, x: u8, y: u8, width: u8, progress: f32);
}
extern "C" {
    #[doc = " Draw scrollbar on canvas at specific position."]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   x       scrollbar position on X axis"]
    #[doc = " @param   y       scrollbar position on Y axis"]
    #[doc = " @param   height  scrollbar height"]
    #[doc = " @param   pos     current element"]
    #[doc = " @param   total   total elements"]
    pub fn elements_scrollbar_pos(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        height: u8,
        pos: u16,
        total: u16,
    );
}
extern "C" {
    #[doc = " Draw scrollbar on canvas."]
    #[doc = " @note    width 3px, height equal to canvas height"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   pos     current element of total elements"]
    #[doc = " @param   total   total elements"]
    pub fn elements_scrollbar(canvas: *mut Canvas, pos: u16, total: u16);
}
extern "C" {
    #[doc = " Draw rounded frame"]
    #[doc = ""]
    #[doc = " @param   canvas          Canvas instance"]
    #[doc = " @param   x, y            top left corner coordinates"]
    #[doc = " @param   width, height   frame width and height"]
    pub fn elements_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw button in left corner"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   str     button text"]
    pub fn elements_button_left(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw button in right corner"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   str     button text"]
    pub fn elements_button_right(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw button in center"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   str     button text"]
    pub fn elements_button_center(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw aligned multiline text"]
    #[doc = ""]
    #[doc = " @param   canvas                  Canvas instance"]
    #[doc = " @param   x, y                    coordinates based on align param"]
    #[doc = " @param   horizontal, vertical    aligment of multiline text"]
    #[doc = " @param   text                    string (possible multiline)"]
    pub fn elements_multiline_text_aligned(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw multiline text"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   x, y    top left corner coordinates"]
    #[doc = " @param   text    string (possible multiline)"]
    pub fn elements_multiline_text(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw framed multiline text"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   x, y    top left corner coordinates"]
    #[doc = " @param   text    string (possible multiline)"]
    pub fn elements_multiline_text_framed(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw slightly rounded frame"]
    #[doc = ""]
    #[doc = " @param   canvas          Canvas instance"]
    #[doc = " @param   x, y            top left corner coordinates"]
    #[doc = " @param   width, height   size of frame"]
    pub fn elements_slightly_rounded_frame(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
    );
}
extern "C" {
    #[doc = " Draw slightly rounded box"]
    #[doc = ""]
    #[doc = " @param   canvas          Canvas instance"]
    #[doc = " @param   x, y            top left corner coordinates"]
    #[doc = " @param   width, height   size of box"]
    pub fn elements_slightly_rounded_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw bold rounded frame"]
    #[doc = ""]
    #[doc = " @param   canvas          Canvas instance"]
    #[doc = " @param   x, y            top left corner coordinates"]
    #[doc = " @param   width, height   size of frame"]
    pub fn elements_bold_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw bubble frame for text"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   x       left x coordinates"]
    #[doc = " @param   y       top y coordinate"]
    #[doc = " @param   width   bubble width"]
    #[doc = " @param   height  bubble height"]
    pub fn elements_bubble(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw bubble frame for text with corner"]
    #[doc = ""]
    #[doc = " @param   canvas      Canvas instance"]
    #[doc = " @param   x           left x coordinates"]
    #[doc = " @param   y           top y coordinate"]
    #[doc = " @param   width       bubble width"]
    #[doc = " @param   height      bubble height"]
    #[doc = " @param   horizontal  horizontal aligning"]
    #[doc = " @param   vertical    aligning"]
    pub fn elements_bubble_str(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Trim string buffer to fit width in pixels"]
    #[doc = ""]
    #[doc = " @param   canvas  Canvas instance"]
    #[doc = " @param   string  string to trim"]
    #[doc = " @param   width   max width"]
    pub fn elements_string_fit_width(canvas: *mut Canvas, string: *mut FuriString, width: u8);
}
extern "C" {
    #[doc = " Draw text box element"]
    #[doc = ""]
    #[doc = " @param       canvas          Canvas instance"]
    #[doc = " @param       x               x coordinate"]
    #[doc = " @param       y               y coordinate"]
    #[doc = " @param       width           width to fit text"]
    #[doc = " @param       height          height to fit text"]
    #[doc = " @param       horizontal      Align instance"]
    #[doc = " @param       vertical        Align instance"]
    #[doc = " @param[in]   text            Formatted text. The following formats are available:"]
    #[doc = "                              \"\\e#Bold text\\e#\" - bold font is used"]
    #[doc = "                              \"\\e*Monospaced text\\e*\" - monospaced font is used"]
    #[doc = "                              \"\\e!Inversed text\\e!\" - white text on black background"]
    #[doc = " @param      strip_to_dots    Strip text to ... if does not fit to width"]
    pub fn elements_text_box(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewPort {
    _unused: [u8; 0],
}
pub const ViewPortOrientation_ViewPortOrientationHorizontal: ViewPortOrientation = 0;
pub const ViewPortOrientation_ViewPortOrientationHorizontalFlip: ViewPortOrientation = 1;
pub const ViewPortOrientation_ViewPortOrientationVertical: ViewPortOrientation = 2;
pub const ViewPortOrientation_ViewPortOrientationVerticalFlip: ViewPortOrientation = 3;
#[doc = "< Special value, don't use it"]
pub const ViewPortOrientation_ViewPortOrientationMAX: ViewPortOrientation = 4;
pub type ViewPortOrientation = core::ffi::c_uchar;
#[doc = " ViewPort Draw callback"]
#[doc = " @warning    called from GUI thread"]
pub type ViewPortDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, context: *mut core::ffi::c_void),
>;
#[doc = " ViewPort Input callback"]
#[doc = " @warning    called from GUI thread"]
pub type ViewPortInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " ViewPort allocator"]
    #[doc = ""]
    #[doc = " always returns view_port or stops system if not enough memory."]
    #[doc = ""]
    #[doc = " @return     ViewPort instance"]
    pub fn view_port_alloc() -> *mut ViewPort;
}
extern "C" {
    #[doc = " ViewPort deallocator"]
    #[doc = ""]
    #[doc = " Ensure that view_port was unregistered in GUI system before use."]
    #[doc = ""]
    #[doc = " @param      view_port  ViewPort instance"]
    pub fn view_port_free(view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Set view_port width."]
    #[doc = ""]
    #[doc = " Will be used to limit canvas drawing area and autolayout feature."]
    #[doc = ""]
    #[doc = " @param      view_port  ViewPort instance"]
    #[doc = " @param      width      wanted width, 0 - auto."]
    pub fn view_port_set_width(view_port: *mut ViewPort, width: u8);
}
extern "C" {
    pub fn view_port_get_width(view_port: *mut ViewPort) -> u8;
}
extern "C" {
    #[doc = " Set view_port height."]
    #[doc = ""]
    #[doc = " Will be used to limit canvas drawing area and autolayout feature."]
    #[doc = ""]
    #[doc = " @param      view_port  ViewPort instance"]
    #[doc = " @param      height     wanted height, 0 - auto."]
    pub fn view_port_set_height(view_port: *mut ViewPort, height: u8);
}
extern "C" {
    pub fn view_port_get_height(view_port: *mut ViewPort) -> u8;
}
extern "C" {
    #[doc = " Enable or disable view_port rendering."]
    #[doc = ""]
    #[doc = " @param      view_port  ViewPort instance"]
    #[doc = " @param      enabled    Indicates if enabled"]
    #[doc = " @warning    automatically dispatches update event"]
    pub fn view_port_enabled_set(view_port: *mut ViewPort, enabled: bool);
}
extern "C" {
    pub fn view_port_is_enabled(view_port: *mut ViewPort) -> bool;
}
extern "C" {
    #[doc = " ViewPort event callbacks"]
    #[doc = ""]
    #[doc = " @param      view_port  ViewPort instance"]
    #[doc = " @param      callback   appropriate callback function"]
    #[doc = " @param      context    context to pass to callback"]
    pub fn view_port_draw_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortDrawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn view_port_input_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortInputCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Emit update signal to GUI system."]
    #[doc = ""]
    #[doc = " Rendering will happen later after GUI system process signal."]
    #[doc = ""]
    #[doc = " @param      view_port  ViewPort instance"]
    pub fn view_port_update(view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Set ViewPort orientation."]
    #[doc = ""]
    #[doc = " @param      view_port    ViewPort instance"]
    #[doc = " @param      orientation  display orientation, horizontal or vertical."]
    pub fn view_port_set_orientation(view_port: *mut ViewPort, orientation: ViewPortOrientation);
}
extern "C" {
    pub fn view_port_get_orientation(view_port: *const ViewPort) -> ViewPortOrientation;
}
#[doc = "< Desktop layer for internal use. Like fullscreen but with status bar"]
pub const GuiLayer_GuiLayerDesktop: GuiLayer = 0;
#[doc = "< Window layer, status bar is shown"]
pub const GuiLayer_GuiLayerWindow: GuiLayer = 1;
#[doc = "< Status bar left-side layer, auto-layout"]
pub const GuiLayer_GuiLayerStatusBarLeft: GuiLayer = 2;
#[doc = "< Status bar right-side layer, auto-layout"]
pub const GuiLayer_GuiLayerStatusBarRight: GuiLayer = 3;
#[doc = "< Fullscreen layer, no status bar"]
pub const GuiLayer_GuiLayerFullscreen: GuiLayer = 4;
#[doc = "< Don't use or move, special value"]
pub const GuiLayer_GuiLayerMAX: GuiLayer = 5;
#[doc = " Gui layers"]
pub type GuiLayer = core::ffi::c_uchar;
#[doc = " Gui Canvas Commit Callback"]
pub type GuiCanvasCommitCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut u8, size: usize, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gui {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Add view_port to view_port tree"]
    #[doc = ""]
    #[doc = " @remark     thread safe"]
    #[doc = ""]
    #[doc = " @param      gui        Gui instance"]
    #[doc = " @param      view_port  ViewPort instance"]
    #[doc = " @param[in]  layer      GuiLayer where to place view_port"]
    pub fn gui_add_view_port(gui: *mut Gui, view_port: *mut ViewPort, layer: GuiLayer);
}
extern "C" {
    #[doc = " Remove view_port from rendering tree"]
    #[doc = ""]
    #[doc = " @remark     thread safe"]
    #[doc = ""]
    #[doc = " @param      gui        Gui instance"]
    #[doc = " @param      view_port  ViewPort instance"]
    pub fn gui_remove_view_port(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Send ViewPort to the front"]
    #[doc = ""]
    #[doc = " Places selected ViewPort to the top of the drawing stack"]
    #[doc = ""]
    #[doc = " @param      gui        Gui instance"]
    #[doc = " @param      view_port  ViewPort instance"]
    pub fn gui_view_port_send_to_front(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Add gui canvas commit callback"]
    #[doc = ""]
    #[doc = " This callback will be called upon Canvas commit Callback dispatched from GUI"]
    #[doc = " thread and is time critical"]
    #[doc = ""]
    #[doc = " @param      gui       Gui instance"]
    #[doc = " @param      callback  GuiCanvasCommitCallback"]
    #[doc = " @param      context   GuiCanvasCommitCallback context"]
    pub fn gui_add_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Remove gui canvas commit callback"]
    #[doc = ""]
    #[doc = " @param      gui       Gui instance"]
    #[doc = " @param      callback  GuiCanvasCommitCallback"]
    #[doc = " @param      context   GuiCanvasCommitCallback context"]
    pub fn gui_remove_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get gui canvas frame buffer size"]
    #[doc = " *"]
    #[doc = " @param      gui       Gui instance"]
    #[doc = " @return     size_t    size of frame buffer in bytes"]
    pub fn gui_get_framebuffer_size(gui: *mut Gui) -> usize;
}
extern "C" {
    #[doc = " Set lockdown mode"]
    #[doc = ""]
    #[doc = " When lockdown mode is enabled, only GuiLayerDesktop is shown."]
    #[doc = " This feature prevents services from showing sensitive information when flipper is locked."]
    #[doc = ""]
    #[doc = " @param      gui       Gui instance"]
    #[doc = " @param      lockdown  bool, true if enabled"]
    pub fn gui_set_lockdown(gui: *mut Gui, lockdown: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Icon {
    pub width: u8,
    pub height: u8,
    pub frame_count: u8,
    pub frame_rate: u8,
    pub frames: *const *const u8,
}
#[test]
fn bindgen_test_layout_Icon() {
    const UNINIT: ::core::mem::MaybeUninit<Icon> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Icon>(),
        16usize,
        concat!("Size of: ", stringify!(Icon))
    );
    assert_eq!(
        ::core::mem::align_of::<Icon>(),
        8usize,
        concat!("Alignment of ", stringify!(Icon))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frame_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frames)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenuItem {
    _unused: [u8; 0],
}
#[doc = " Callback for any button menu actions"]
pub type ButtonMenuItemCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, index: i32, type_: InputType),
>;
pub const ButtonMenuItemType_ButtonMenuItemTypeCommon: ButtonMenuItemType = 0;
pub const ButtonMenuItemType_ButtonMenuItemTypeControl: ButtonMenuItemType = 1;
#[doc = " Type of button. Difference in drawing buttons."]
pub type ButtonMenuItemType = core::ffi::c_uchar;
extern "C" {
    #[doc = " Get button menu view"]
    #[doc = ""]
    #[doc = " @param      button_menu  ButtonMenu instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn button_menu_get_view(button_menu: *mut ButtonMenu) -> *mut View;
}
extern "C" {
    #[doc = " Clean button menu"]
    #[doc = ""]
    #[doc = " @param      button_menu  ButtonMenu instance"]
    pub fn button_menu_reset(button_menu: *mut ButtonMenu);
}
extern "C" {
    #[doc = " Add item to button menu instance"]
    #[doc = ""]
    #[doc = " @param      button_menu       ButtonMenu instance"]
    #[doc = " @param      label             text inside new button"]
    #[doc = " @param      index             value to distinct between buttons inside"]
    #[doc = "                               ButtonMenuItemCallback"]
    #[doc = " @param      callback          The callback"]
    #[doc = " @param      type              type of button to create. Differ by button"]
    #[doc = "                               drawing. Control buttons have no frames, and"]
    #[doc = "                               have more squared borders."]
    #[doc = " @param      callback_context  The callback context"]
    #[doc = ""]
    #[doc = " @return     pointer to just-created item"]
    pub fn button_menu_add_item(
        button_menu: *mut ButtonMenu,
        label: *const core::ffi::c_char,
        index: i32,
        callback: ButtonMenuItemCallback,
        type_: ButtonMenuItemType,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut ButtonMenuItem;
}
extern "C" {
    #[doc = " Allocate and initialize new instance of ButtonMenu model"]
    #[doc = ""]
    #[doc = " @return     just-created ButtonMenu model"]
    pub fn button_menu_alloc() -> *mut ButtonMenu;
}
extern "C" {
    #[doc = " Free ButtonMenu element"]
    #[doc = ""]
    #[doc = " @param      button_menu  ButtonMenu instance"]
    pub fn button_menu_free(button_menu: *mut ButtonMenu);
}
extern "C" {
    #[doc = " Set ButtonMenu header on top of canvas"]
    #[doc = ""]
    #[doc = " @param      button_menu  ButtonMenu instance"]
    #[doc = " @param      header       header on the top of button menu"]
    pub fn button_menu_set_header(button_menu: *mut ButtonMenu, header: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Set selected item"]
    #[doc = ""]
    #[doc = " @param      button_menu  ButtonMenu instance"]
    #[doc = " @param      index        index of ButtonMenu to be selected"]
    pub fn button_menu_set_selected_item(button_menu: *mut ButtonMenu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonPanel {
    _unused: [u8; 0],
}
#[doc = " Callback type to call for handling selecting button_panel items"]
pub type ButtonItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Allocate new button_panel module."]
    #[doc = ""]
    #[doc = " @return     ButtonPanel instance"]
    pub fn button_panel_alloc() -> *mut ButtonPanel;
}
extern "C" {
    #[doc = " Free button_panel module."]
    #[doc = ""]
    #[doc = " @param      button_panel  ButtonPanel instance"]
    pub fn button_panel_free(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = " Free items from button_panel module. Preallocated matrix stays unchanged."]
    #[doc = ""]
    #[doc = " @param      button_panel  ButtonPanel instance"]
    pub fn button_panel_reset(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = " Reserve space for adding items."]
    #[doc = ""]
    #[doc = " One does not simply use button_panel_add_item() without this function. It"]
    #[doc = " should be allocated space for it first."]
    #[doc = ""]
    #[doc = " @param      button_panel  ButtonPanel instance"]
    #[doc = " @param      reserve_x     number of columns in button_panel"]
    #[doc = " @param      reserve_y     number of rows in button_panel"]
    pub fn button_panel_reserve(button_panel: *mut ButtonPanel, reserve_x: usize, reserve_y: usize);
}
extern "C" {
    #[doc = " Add item to button_panel module."]
    #[doc = ""]
    #[doc = " Have to set element in bounds of allocated size by X and by Y."]
    #[doc = ""]
    #[doc = " @param      button_panel        ButtonPanel instance"]
    #[doc = " @param      index               value to pass to callback"]
    #[doc = " @param      matrix_place_x      coordinates by x-axis on virtual grid, it"]
    #[doc = "                                 is only used for navigation"]
    #[doc = " @param      matrix_place_y      coordinates by y-axis on virtual grid, it"]
    #[doc = "                                 is only used for naviagation"]
    #[doc = " @param      x                   x-coordinate to draw icon on"]
    #[doc = " @param      y                   y-coordinate to draw icon on"]
    #[doc = " @param      icon_name           name of the icon to draw"]
    #[doc = " @param      icon_name_selected  name of the icon to draw when current"]
    #[doc = "                                 element is selected"]
    #[doc = " @param      callback            function to call when specific element is"]
    #[doc = "                                 selected (pressed Ok on selected item)"]
    #[doc = " @param      callback_context    context to pass to callback"]
    pub fn button_panel_add_item(
        button_panel: *mut ButtonPanel,
        index: u32,
        matrix_place_x: u16,
        matrix_place_y: u16,
        x: u16,
        y: u16,
        icon_name: *const Icon,
        icon_name_selected: *const Icon,
        callback: ButtonItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get button_panel view."]
    #[doc = ""]
    #[doc = " @param      button_panel  ButtonPanel instance"]
    #[doc = ""]
    #[doc = " @return     acquired view"]
    pub fn button_panel_get_view(button_panel: *mut ButtonPanel) -> *mut View;
}
extern "C" {
    #[doc = " Add label to button_panel module."]
    #[doc = ""]
    #[doc = " @param      button_panel  ButtonPanel instance"]
    #[doc = " @param      x             x-coordinate to place label"]
    #[doc = " @param      y             y-coordinate to place label"]
    #[doc = " @param      font          font to write label with"]
    #[doc = " @param      label_str     string label to write"]
    pub fn button_panel_add_label(
        button_panel: *mut ButtonPanel,
        x: u16,
        y: u16,
        font: Font,
        label_str: *const core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteInput {
    _unused: [u8; 0],
}
#[doc = " callback that is executed on save button press"]
pub type ByteInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " callback that is executed when byte buffer is changed"]
pub type ByteChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate and initialize byte input. This byte input is used to enter bytes."]
    #[doc = ""]
    #[doc = " @return     ByteInput instance pointer"]
    pub fn byte_input_alloc() -> *mut ByteInput;
}
extern "C" {
    #[doc = " Deinitialize and free byte input"]
    #[doc = ""]
    #[doc = " @param      byte_input  Byte input instance"]
    pub fn byte_input_free(byte_input: *mut ByteInput);
}
extern "C" {
    #[doc = " Get byte input view"]
    #[doc = ""]
    #[doc = " @param      byte_input  byte input instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn byte_input_get_view(byte_input: *mut ByteInput) -> *mut View;
}
extern "C" {
    #[doc = " Set byte input result callback"]
    #[doc = ""]
    #[doc = " @param      byte_input        byte input instance"]
    #[doc = " @param      input_callback    input callback fn"]
    #[doc = " @param      changed_callback  changed callback fn"]
    #[doc = " @param      callback_context  callback context"]
    #[doc = " @param      bytes             buffer to use"]
    #[doc = " @param      bytes_count       buffer length"]
    pub fn byte_input_set_result_callback(
        byte_input: *mut ByteInput,
        input_callback: ByteInputCallback,
        changed_callback: ByteChangedCallback,
        callback_context: *mut core::ffi::c_void,
        bytes: *mut u8,
        bytes_count: u8,
    );
}
extern "C" {
    #[doc = " Set byte input header text"]
    #[doc = ""]
    #[doc = " @param      byte_input  byte input instance"]
    #[doc = " @param      text        text to be shown"]
    pub fn byte_input_set_header_text(byte_input: *mut ByteInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogEx {
    _unused: [u8; 0],
}
pub const DialogExResult_DialogExResultLeft: DialogExResult = 0;
pub const DialogExResult_DialogExResultCenter: DialogExResult = 1;
pub const DialogExResult_DialogExResultRight: DialogExResult = 2;
pub const DialogExResult_DialogExPressLeft: DialogExResult = 3;
pub const DialogExResult_DialogExPressCenter: DialogExResult = 4;
pub const DialogExResult_DialogExPressRight: DialogExResult = 5;
pub const DialogExResult_DialogExReleaseLeft: DialogExResult = 6;
pub const DialogExResult_DialogExReleaseCenter: DialogExResult = 7;
pub const DialogExResult_DialogExReleaseRight: DialogExResult = 8;
#[doc = " DialogEx result"]
pub type DialogExResult = core::ffi::c_uchar;
#[doc = " DialogEx result callback type"]
#[doc = " @warning comes from GUI thread"]
pub type DialogExResultCallback = ::core::option::Option<
    unsafe extern "C" fn(result: DialogExResult, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Allocate and initialize dialog"]
    #[doc = ""]
    #[doc = " This dialog used to ask simple questions"]
    #[doc = ""]
    #[doc = " @return     DialogEx instance"]
    pub fn dialog_ex_alloc() -> *mut DialogEx;
}
extern "C" {
    #[doc = " Deinitialize and free dialog"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_free(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = " Get dialog view"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn dialog_ex_get_view(dialog_ex: *mut DialogEx) -> *mut View;
}
extern "C" {
    #[doc = " Set dialog result callback"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = " @param      callback   result callback function"]
    pub fn dialog_ex_set_result_callback(
        dialog_ex: *mut DialogEx,
        callback: DialogExResultCallback,
    );
}
extern "C" {
    #[doc = " Set dialog context"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = " @param      context    context pointer, will be passed to result callback"]
    pub fn dialog_ex_set_context(dialog_ex: *mut DialogEx, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set dialog header text"]
    #[doc = ""]
    #[doc = " If text is null, dialog header will not be rendered"]
    #[doc = ""]
    #[doc = " @param      dialog_ex   DialogEx instance"]
    #[doc = " @param      text        text to be shown, can be multiline"]
    #[doc = " @param      x           x position"]
    #[doc = " @param      y           y position"]
    #[doc = " @param      horizontal  horizontal text aligment"]
    #[doc = " @param      vertical    vertical text aligment"]
    pub fn dialog_ex_set_header(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set dialog text"]
    #[doc = ""]
    #[doc = " If text is null, dialog text will not be rendered"]
    #[doc = ""]
    #[doc = " @param      dialog_ex   DialogEx instance"]
    #[doc = " @param      text        text to be shown, can be multiline"]
    #[doc = " @param      x           x position"]
    #[doc = " @param      y           y position"]
    #[doc = " @param      horizontal  horizontal text aligment"]
    #[doc = " @param      vertical    vertical text aligment"]
    pub fn dialog_ex_set_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set dialog icon"]
    #[doc = ""]
    #[doc = " If x or y is negative, dialog icon will not be rendered"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = " @param      x          x position"]
    #[doc = " @param      y          y position"]
    #[doc = " @param      icon       The icon"]
    #[doc = " @param      name  icon to be shown"]
    pub fn dialog_ex_set_icon(dialog_ex: *mut DialogEx, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Set left button text"]
    #[doc = ""]
    #[doc = " If text is null, left button will not be rendered and processed"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = " @param      text       text to be shown"]
    pub fn dialog_ex_set_left_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Set center button text"]
    #[doc = ""]
    #[doc = " If text is null, center button will not be rendered and processed"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = " @param      text       text to be shown"]
    pub fn dialog_ex_set_center_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Set right button text"]
    #[doc = ""]
    #[doc = " If text is null, right button will not be rendered and processed"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    #[doc = " @param      text       text to be shown"]
    pub fn dialog_ex_set_right_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Clean dialog"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_reset(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = " Enable press/release events"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_enable_extended_events(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = " Disable press/release events"]
    #[doc = ""]
    #[doc = " @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_disable_extended_events(dialog_ex: *mut DialogEx);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmptyScreen {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize empty screen"]
    #[doc = ""]
    #[doc = " This empty screen used to ask simple questions like Yes/"]
    #[doc = ""]
    #[doc = " @return     EmptyScreen instance"]
    pub fn empty_screen_alloc() -> *mut EmptyScreen;
}
extern "C" {
    #[doc = " Deinitialize and free empty screen"]
    #[doc = ""]
    #[doc = " @param      empty_screen  Empty screen instance"]
    pub fn empty_screen_free(empty_screen: *mut EmptyScreen);
}
extern "C" {
    #[doc = " Get empty screen view"]
    #[doc = ""]
    #[doc = " @param      empty_screen  Empty screen instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn empty_screen_get_view(empty_screen: *mut EmptyScreen) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrowserWorker {
    _unused: [u8; 0],
}
pub type BrowserWorkerFolderOpenCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_cnt: u32,
        file_idx: i32,
        is_root: bool,
    ),
>;
pub type BrowserWorkerListLoadCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, list_load_offset: u32),
>;
pub type BrowserWorkerListItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_path: *mut FuriString,
        is_folder: bool,
        is_last: bool,
    ),
>;
pub type BrowserWorkerLongLoadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn file_browser_worker_alloc(
        path: *mut FuriString,
        filter_ext: *const core::ffi::c_char,
        skip_assets: bool,
    ) -> *mut BrowserWorker;
}
extern "C" {
    pub fn file_browser_worker_free(browser: *mut BrowserWorker);
}
extern "C" {
    pub fn file_browser_worker_set_callback_context(
        browser: *mut BrowserWorker,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn file_browser_worker_set_folder_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerFolderOpenCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_list_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListLoadCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_item_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListItemCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_long_load_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerLongLoadCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_config(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        filter_ext: *const core::ffi::c_char,
        skip_assets: bool,
    );
}
extern "C" {
    pub fn file_browser_worker_folder_enter(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        item_idx: i32,
    );
}
extern "C" {
    pub fn file_browser_worker_folder_exit(browser: *mut BrowserWorker);
}
extern "C" {
    pub fn file_browser_worker_folder_refresh(browser: *mut BrowserWorker, item_idx: i32);
}
extern "C" {
    pub fn file_browser_worker_load(browser: *mut BrowserWorker, offset: u32, count: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loading {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize"]
    #[doc = ""]
    #[doc = " This View used to show system is doing some processing"]
    #[doc = ""]
    #[doc = " @return     Loading View instance"]
    pub fn loading_alloc() -> *mut Loading;
}
extern "C" {
    #[doc = " Deinitialize and free Loading View"]
    #[doc = ""]
    #[doc = " @param      instance  Loading instance"]
    pub fn loading_free(instance: *mut Loading);
}
extern "C" {
    #[doc = " Get Loading view"]
    #[doc = ""]
    #[doc = " @param      instance  Loading instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn loading_get_view(instance: *mut Loading) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Menu {
    _unused: [u8; 0],
}
#[doc = " Menu Item Callback"]
pub type MenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Menu allocation and initialization"]
    #[doc = ""]
    #[doc = " @return     Menu instance"]
    pub fn menu_alloc() -> *mut Menu;
}
extern "C" {
    #[doc = " Free menu"]
    #[doc = ""]
    #[doc = " @param      menu  Menu instance"]
    pub fn menu_free(menu: *mut Menu);
}
extern "C" {
    #[doc = " Get Menu view"]
    #[doc = ""]
    #[doc = " @param      menu  Menu instance"]
    #[doc = ""]
    #[doc = " @return     View instance"]
    pub fn menu_get_view(menu: *mut Menu) -> *mut View;
}
extern "C" {
    #[doc = " Add item to menu"]
    #[doc = ""]
    #[doc = " @param      menu      Menu instance"]
    #[doc = " @param      label     menu item string label"]
    #[doc = " @param      icon      IconAnimation instance"]
    #[doc = " @param      index     menu item index"]
    #[doc = " @param      callback  MenuItemCallback instance"]
    #[doc = " @param      context   pointer to context"]
    pub fn menu_add_item(
        menu: *mut Menu,
        label: *const core::ffi::c_char,
        icon: *const Icon,
        index: u32,
        callback: MenuItemCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Clean menu"]
    #[doc = " @note       this function does not free menu instance"]
    #[doc = ""]
    #[doc = " @param      menu  Menu instance"]
    pub fn menu_reset(menu: *mut Menu);
}
extern "C" {
    #[doc = " Set current menu item"]
    #[doc = ""]
    #[doc = " @param      menu   Menu instance"]
    #[doc = " @param      index  The index"]
    pub fn menu_set_selected_item(menu: *mut Menu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Popup {
    _unused: [u8; 0],
}
#[doc = " Popup result callback type"]
#[doc = " @warning    comes from GUI thread"]
pub type PopupCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate and initialize popup"]
    #[doc = ""]
    #[doc = " This popup used to ask simple questions like Yes/"]
    #[doc = ""]
    #[doc = " @return     Popup instance"]
    pub fn popup_alloc() -> *mut Popup;
}
extern "C" {
    #[doc = " Deinitialize and free popup"]
    #[doc = ""]
    #[doc = " @param      popup  Popup instance"]
    pub fn popup_free(popup: *mut Popup);
}
extern "C" {
    #[doc = " Get popup view"]
    #[doc = ""]
    #[doc = " @param      popup  Popup instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn popup_get_view(popup: *mut Popup) -> *mut View;
}
extern "C" {
    #[doc = " Set popup header text"]
    #[doc = ""]
    #[doc = " @param      popup     Popup instance"]
    #[doc = " @param      callback  PopupCallback"]
    pub fn popup_set_callback(popup: *mut Popup, callback: PopupCallback);
}
extern "C" {
    #[doc = " Set popup context"]
    #[doc = ""]
    #[doc = " @param      popup    Popup instance"]
    #[doc = " @param      context  context pointer, will be passed to result callback"]
    pub fn popup_set_context(popup: *mut Popup, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set popup header text"]
    #[doc = ""]
    #[doc = " If text is null, popup header will not be rendered"]
    #[doc = ""]
    #[doc = " @param      popup       Popup instance"]
    #[doc = " @param      text        text to be shown, can be multiline"]
    #[doc = " @param      x           x position"]
    #[doc = " @param      y           y position"]
    #[doc = " @param      horizontal  horizontal alignment"]
    #[doc = " @param      vertical    vertical aligment"]
    pub fn popup_set_header(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set popup text"]
    #[doc = ""]
    #[doc = " If text is null, popup text will not be rendered"]
    #[doc = ""]
    #[doc = " @param      popup       Popup instance"]
    #[doc = " @param      text        text to be shown, can be multiline"]
    #[doc = " @param      x           x position"]
    #[doc = " @param      y           y position"]
    #[doc = " @param      horizontal  horizontal alignment"]
    #[doc = " @param      vertical    vertical aligment"]
    pub fn popup_set_text(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set popup icon"]
    #[doc = ""]
    #[doc = " If icon position is negative, popup icon will not be rendered"]
    #[doc = ""]
    #[doc = " @param      popup  Popup instance"]
    #[doc = " @param      x      x position"]
    #[doc = " @param      y      y position"]
    #[doc = " @param      icon   pointer to Icon data"]
    pub fn popup_set_icon(popup: *mut Popup, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Set popup timeout"]
    #[doc = ""]
    #[doc = " @param      popup          Popup instance"]
    #[doc = " @param      timeout_in_ms  popup timeout value in milliseconds"]
    pub fn popup_set_timeout(popup: *mut Popup, timeout_in_ms: u32);
}
extern "C" {
    #[doc = " Enable popup timeout"]
    #[doc = ""]
    #[doc = " @param      popup  Popup instance"]
    pub fn popup_enable_timeout(popup: *mut Popup);
}
extern "C" {
    #[doc = " Disable popup timeout"]
    #[doc = ""]
    #[doc = " @param      popup  Popup instance"]
    pub fn popup_disable_timeout(popup: *mut Popup);
}
extern "C" {
    #[doc = " Reset popup instance state"]
    #[doc = ""]
    #[doc = " @param       popup Popup instance"]
    pub fn popup_reset(popup: *mut Popup);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Submenu {
    _unused: [u8; 0],
}
pub type SubmenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Allocate and initialize submenu"]
    #[doc = ""]
    #[doc = " This submenu is used to select one option"]
    #[doc = ""]
    #[doc = " @return     Submenu instance"]
    pub fn submenu_alloc() -> *mut Submenu;
}
extern "C" {
    #[doc = " Deinitialize and free submenu"]
    #[doc = ""]
    #[doc = " @param      submenu  Submenu instance"]
    pub fn submenu_free(submenu: *mut Submenu);
}
extern "C" {
    #[doc = " Get submenu view"]
    #[doc = ""]
    #[doc = " @param      submenu  Submenu instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn submenu_get_view(submenu: *mut Submenu) -> *mut View;
}
extern "C" {
    #[doc = " Add item to submenu"]
    #[doc = ""]
    #[doc = " @param      submenu           Submenu instance"]
    #[doc = " @param      label             menu item label"]
    #[doc = " @param      index             menu item index, used for callback, may be"]
    #[doc = "                               the same with other items"]
    #[doc = " @param      callback          menu item callback"]
    #[doc = " @param      callback_context  menu item callback context"]
    pub fn submenu_add_item(
        submenu: *mut Submenu,
        label: *const core::ffi::c_char,
        index: u32,
        callback: SubmenuItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Remove all items from submenu"]
    #[doc = ""]
    #[doc = " @param      submenu  Submenu instance"]
    pub fn submenu_reset(submenu: *mut Submenu);
}
extern "C" {
    #[doc = " Set submenu item selector"]
    #[doc = ""]
    #[doc = " @param      submenu  Submenu instance"]
    #[doc = " @param      index    The index"]
    pub fn submenu_set_selected_item(submenu: *mut Submenu, index: u32);
}
extern "C" {
    #[doc = " Set optional header for submenu"]
    #[doc = ""]
    #[doc = " @param      submenu  Submenu instance"]
    #[doc = " @param      header   header to set"]
    pub fn submenu_set_header(submenu: *mut Submenu, header: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextBox {
    _unused: [u8; 0],
}
pub const TextBoxFont_TextBoxFontText: TextBoxFont = 0;
pub const TextBoxFont_TextBoxFontHex: TextBoxFont = 1;
pub type TextBoxFont = core::ffi::c_uchar;
pub const TextBoxFocus_TextBoxFocusStart: TextBoxFocus = 0;
pub const TextBoxFocus_TextBoxFocusEnd: TextBoxFocus = 1;
pub type TextBoxFocus = core::ffi::c_uchar;
extern "C" {
    #[doc = " Allocate and initialize text_box"]
    #[doc = ""]
    #[doc = " @return     TextBox instance"]
    pub fn text_box_alloc() -> *mut TextBox;
}
extern "C" {
    #[doc = " Deinitialize and free text_box"]
    #[doc = ""]
    #[doc = " @param      text_box  text_box instance"]
    pub fn text_box_free(text_box: *mut TextBox);
}
extern "C" {
    #[doc = " Get text_box view"]
    #[doc = ""]
    #[doc = " @param      text_box  TextBox instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn text_box_get_view(text_box: *mut TextBox) -> *mut View;
}
extern "C" {
    #[doc = " Clean text_box"]
    #[doc = ""]
    #[doc = " @param      text_box  TextBox instance"]
    pub fn text_box_reset(text_box: *mut TextBox);
}
extern "C" {
    #[doc = " Set text for text_box"]
    #[doc = ""]
    #[doc = " @param      text_box  TextBox instance"]
    #[doc = " @param      text      text to set"]
    pub fn text_box_set_text(text_box: *mut TextBox, text: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Set TextBox font"]
    #[doc = ""]
    #[doc = " @param      text_box  TextBox instance"]
    #[doc = " @param      font      TextBoxFont instance"]
    pub fn text_box_set_font(text_box: *mut TextBox, font: TextBoxFont);
}
extern "C" {
    #[doc = " Set TextBox focus"]
    #[doc = " @note Use to display from start or from end"]
    #[doc = ""]
    #[doc = " @param      text_box  TextBox instance"]
    #[doc = " @param      focus     TextBoxFocus instance"]
    pub fn text_box_set_focus(text_box: *mut TextBox, focus: TextBoxFocus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidatorIsFile {
    _unused: [u8; 0],
}
extern "C" {
    pub fn validator_is_file_alloc_init(
        app_path_folder: *const core::ffi::c_char,
        app_extension: *const core::ffi::c_char,
        current_name: *const core::ffi::c_char,
    ) -> *mut ValidatorIsFile;
}
extern "C" {
    pub fn validator_is_file_free(instance: *mut ValidatorIsFile);
}
extern "C" {
    pub fn validator_is_file_callback(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextInput {
    _unused: [u8; 0],
}
pub type TextInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type TextInputValidatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Allocate and initialize text input"]
    #[doc = ""]
    #[doc = " This text input is used to enter string"]
    #[doc = ""]
    #[doc = " @return     TextInput instance"]
    pub fn text_input_alloc() -> *mut TextInput;
}
extern "C" {
    #[doc = " Deinitialize and free text input"]
    #[doc = ""]
    #[doc = " @param      text_input  TextInput instance"]
    pub fn text_input_free(text_input: *mut TextInput);
}
extern "C" {
    #[doc = " Clean text input view Note: this function does not free memory"]
    #[doc = ""]
    #[doc = " @param      text_input  Text input instance"]
    pub fn text_input_reset(text_input: *mut TextInput);
}
extern "C" {
    #[doc = " Get text input view"]
    #[doc = ""]
    #[doc = " @param      text_input  TextInput instance"]
    #[doc = ""]
    #[doc = " @return     View instance that can be used for embedding"]
    pub fn text_input_get_view(text_input: *mut TextInput) -> *mut View;
}
extern "C" {
    #[doc = " Set text input result callback"]
    #[doc = ""]
    #[doc = " @param      text_input          TextInput instance"]
    #[doc = " @param      callback            callback fn"]
    #[doc = " @param      callback_context    callback context"]
    #[doc = " @param      text_buffer         pointer to YOUR text buffer, that we going"]
    #[doc = "                                 to modify"]
    #[doc = " @param      text_buffer_size    YOUR text buffer size in bytes. Max string"]
    #[doc = "                                 length will be text_buffer_size-1."]
    #[doc = " @param      clear_default_text  clear text from text_buffer on first OK"]
    #[doc = "                                 event"]
    pub fn text_input_set_result_callback(
        text_input: *mut TextInput,
        callback: TextInputCallback,
        callback_context: *mut core::ffi::c_void,
        text_buffer: *mut core::ffi::c_char,
        text_buffer_size: usize,
        clear_default_text: bool,
    );
}
extern "C" {
    pub fn text_input_set_validator(
        text_input: *mut TextInput,
        callback: TextInputValidatorCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn text_input_get_validator_callback(
        text_input: *mut TextInput,
    ) -> TextInputValidatorCallback;
}
extern "C" {
    pub fn text_input_get_validator_callback_context(
        text_input: *mut TextInput,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Set text input header text"]
    #[doc = ""]
    #[doc = " @param      text_input  TextInput instance"]
    #[doc = " @param      text        text to be shown"]
    pub fn text_input_set_header_text(text_input: *mut TextInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItemList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItem {
    _unused: [u8; 0],
}
pub type VariableItemChangeCallback =
    ::core::option::Option<unsafe extern "C" fn(item: *mut VariableItem)>;
pub type VariableItemListEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Allocate and initialize VariableItemList"]
    #[doc = ""]
    #[doc = " @return     VariableItemList*"]
    pub fn variable_item_list_alloc() -> *mut VariableItemList;
}
extern "C" {
    #[doc = " Deinitialize and free VariableItemList"]
    #[doc = ""]
    #[doc = " @param      variable_item_list  VariableItemList instance"]
    pub fn variable_item_list_free(variable_item_list: *mut VariableItemList);
}
extern "C" {
    #[doc = " Clear all elements from list"]
    #[doc = ""]
    #[doc = " @param      variable_item_list  VariableItemList instance"]
    pub fn variable_item_list_reset(variable_item_list: *mut VariableItemList);
}
extern "C" {
    #[doc = " Get VariableItemList View instance"]
    #[doc = ""]
    #[doc = " @param      variable_item_list  VariableItemList instance"]
    #[doc = ""]
    #[doc = " @return     View instance"]
    pub fn variable_item_list_get_view(variable_item_list: *mut VariableItemList) -> *mut View;
}
extern "C" {
    #[doc = " Add item to VariableItemList"]
    #[doc = ""]
    #[doc = " @param      variable_item_list  VariableItemList instance"]
    #[doc = " @param      label               item name"]
    #[doc = " @param      values_count        item values count"]
    #[doc = " @param      change_callback     called on value change in gui"]
    #[doc = " @param      context             item context"]
    #[doc = ""]
    #[doc = " @return     VariableItem* item instance"]
    pub fn variable_item_list_add(
        variable_item_list: *mut VariableItemList,
        label: *const core::ffi::c_char,
        values_count: u8,
        change_callback: VariableItemChangeCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut VariableItem;
}
extern "C" {
    #[doc = " Set enter callback"]
    #[doc = ""]
    #[doc = " @param      variable_item_list  VariableItemList instance"]
    #[doc = " @param      callback            VariableItemListEnterCallback instance"]
    #[doc = " @param      context             pointer to context"]
    pub fn variable_item_list_set_enter_callback(
        variable_item_list: *mut VariableItemList,
        callback: VariableItemListEnterCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn variable_item_list_set_selected_item(
        variable_item_list: *mut VariableItemList,
        index: u8,
    );
}
extern "C" {
    pub fn variable_item_list_get_selected_item_index(
        variable_item_list: *mut VariableItemList,
    ) -> u8;
}
extern "C" {
    #[doc = " Set item current selected index"]
    #[doc = ""]
    #[doc = " @param      item                 VariableItem* instance"]
    #[doc = " @param      current_value_index  The current value index"]
    pub fn variable_item_set_current_value_index(item: *mut VariableItem, current_value_index: u8);
}
extern "C" {
    #[doc = " Set number of values for item"]
    #[doc = ""]
    #[doc = " @param      item                 VariableItem* instance"]
    #[doc = " @param      values_count         The new values count"]
    pub fn variable_item_set_values_count(item: *mut VariableItem, values_count: u8);
}
extern "C" {
    #[doc = " Set item current selected text"]
    #[doc = ""]
    #[doc = " @param      item                VariableItem* instance"]
    #[doc = " @param      current_value_text  The current value text"]
    pub fn variable_item_set_current_value_text(
        item: *mut VariableItem,
        current_value_text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get item current selected index"]
    #[doc = ""]
    #[doc = " @param      item  VariableItem* instance"]
    #[doc = ""]
    #[doc = " @return     uint8_t current selected index"]
    pub fn variable_item_get_current_value_index(item: *mut VariableItem) -> u8;
}
extern "C" {
    #[doc = " Get item context"]
    #[doc = ""]
    #[doc = " @param      item  VariableItem* instance"]
    #[doc = ""]
    #[doc = " @return     void* item context"]
    pub fn variable_item_get_context(item: *mut VariableItem) -> *mut core::ffi::c_void;
}
pub const GuiButtonType_GuiButtonTypeLeft: GuiButtonType = 0;
pub const GuiButtonType_GuiButtonTypeCenter: GuiButtonType = 1;
pub const GuiButtonType_GuiButtonTypeRight: GuiButtonType = 2;
pub type GuiButtonType = core::ffi::c_uchar;
pub type ButtonCallback = ::core::option::Option<
    unsafe extern "C" fn(result: GuiButtonType, type_: InputType, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Widget {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate Widget that holds Widget Elements"]
    #[doc = ""]
    #[doc = " @return     Widget instance"]
    pub fn widget_alloc() -> *mut Widget;
}
extern "C" {
    #[doc = " Free Widget"]
    #[doc = " @note       this function free allocated Widget Elements"]
    #[doc = ""]
    #[doc = " @param      widget  Widget instance"]
    pub fn widget_free(widget: *mut Widget);
}
extern "C" {
    #[doc = " Reset Widget"]
    #[doc = ""]
    #[doc = " @param      widget  Widget instance"]
    pub fn widget_reset(widget: *mut Widget);
}
extern "C" {
    #[doc = " Get Widget view"]
    #[doc = ""]
    #[doc = " @param      widget  Widget instance"]
    #[doc = ""]
    #[doc = " @return     View instance"]
    pub fn widget_get_view(widget: *mut Widget) -> *mut View;
}
extern "C" {
    #[doc = " Add Multi String Element"]
    #[doc = ""]
    #[doc = " @param      widget      Widget instance"]
    #[doc = " @param      x           x coordinate"]
    #[doc = " @param      y           y coordinate"]
    #[doc = " @param      horizontal  Align instance"]
    #[doc = " @param      vertical    Align instance"]
    #[doc = " @param      font        Font instance"]
    #[doc = " @param[in]  text        The text"]
    pub fn widget_add_string_multiline_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Add String Element"]
    #[doc = ""]
    #[doc = " @param      widget      Widget instance"]
    #[doc = " @param      x           x coordinate"]
    #[doc = " @param      y           y coordinate"]
    #[doc = " @param      horizontal  Align instance"]
    #[doc = " @param      vertical    Align instance"]
    #[doc = " @param      font        Font instance"]
    #[doc = " @param[in]  text        The text"]
    pub fn widget_add_string_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Add Text Box Element"]
    #[doc = ""]
    #[doc = " @param      widget           Widget instance"]
    #[doc = " @param      x                x coordinate"]
    #[doc = " @param      y                y coordinate"]
    #[doc = " @param      width            width to fit text"]
    #[doc = " @param      height           height to fit text"]
    #[doc = " @param      horizontal       Align instance"]
    #[doc = " @param      vertical         Align instance"]
    #[doc = " @param[in]  text             Formatted text. The following formats are available:"]
    #[doc = "                               \"\\e#Bold text\\e#\" - bold font is used"]
    #[doc = "                               \"\\e*Monospaced text\\e*\" - monospaced font is used"]
    #[doc = "                               \"\\e#Inversed text\\e#\" - white text on black background"]
    #[doc = " @param      strip_to_dots    Strip text to ... if does not fit to width"]
    pub fn widget_add_text_box_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
extern "C" {
    #[doc = " Add Text Scroll Element"]
    #[doc = ""]
    #[doc = " @param      widget           Widget instance"]
    #[doc = " @param      x                x coordinate"]
    #[doc = " @param      y                y coordinate"]
    #[doc = " @param      width            width to fit text"]
    #[doc = " @param      height           height to fit text"]
    #[doc = " @param[in]  text             Formatted text. Default format: align left, Secondary font."]
    #[doc = "                              The following formats are available:"]
    #[doc = "                               \"\\e#Bold text\" - sets bold font before until next '\\n' symbol"]
    #[doc = "                               \"\\ecCenter-aligned text\" - sets center horizontal align until the next '\\n' symbol"]
    #[doc = "                               \"\\erRight-aligned text\" - sets right horizontal align until the next '\\n' symbol"]
    pub fn widget_add_text_scroll_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Add Button Element"]
    #[doc = ""]
    #[doc = " @param      widget       Widget instance"]
    #[doc = " @param      button_type  GuiButtonType instance"]
    #[doc = " @param      text         text on allocated button"]
    #[doc = " @param      callback     ButtonCallback instance"]
    #[doc = " @param      context      pointer to context"]
    pub fn widget_add_button_element(
        widget: *mut Widget,
        button_type: GuiButtonType,
        text: *const core::ffi::c_char,
        callback: ButtonCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Add Icon Element"]
    #[doc = ""]
    #[doc = " @param      widget  Widget instance"]
    #[doc = " @param      x       top left x coordinate"]
    #[doc = " @param      y       top left y coordinate"]
    #[doc = " @param      icon    Icon instance"]
    pub fn widget_add_icon_element(widget: *mut Widget, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Add Frame Element"]
    #[doc = ""]
    #[doc = " @param      widget  Widget instance"]
    #[doc = " @param      x       top left x coordinate"]
    #[doc = " @param      y       top left y coordinate"]
    #[doc = " @param      width   frame width"]
    #[doc = " @param      height  frame height"]
    #[doc = " @param      radius  frame radius"]
    pub fn widget_add_frame_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        radius: u8,
    );
}
pub const SceneManagerEventType_SceneManagerEventTypeCustom: SceneManagerEventType = 0;
pub const SceneManagerEventType_SceneManagerEventTypeBack: SceneManagerEventType = 1;
pub const SceneManagerEventType_SceneManagerEventTypeTick: SceneManagerEventType = 2;
#[doc = " Scene Manager events type"]
pub type SceneManagerEventType = core::ffi::c_uchar;
#[doc = " Scene Manager event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerEvent {
    pub type_: SceneManagerEventType,
    pub event: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SceneManagerEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SceneManagerEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SceneManagerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SceneManagerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SceneManagerEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerEvent),
            "::",
            stringify!(event)
        )
    );
}
#[doc = " Prototype for Scene on_enter handler"]
pub type AppSceneOnEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Prototype for Scene on_event handler"]
pub type AppSceneOnEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: SceneManagerEvent) -> bool,
>;
#[doc = " Prototype for Scene on_exit handler"]
pub type AppSceneOnExitCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Scene Manager configuration structure"]
#[doc = " Contains array of Scene handlers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerHandlers {
    pub on_enter_handlers: *const AppSceneOnEnterCallback,
    pub on_event_handlers: *const AppSceneOnEventCallback,
    pub on_exit_handlers: *const AppSceneOnExitCallback,
    pub scene_num: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerHandlers() {
    const UNINIT: ::core::mem::MaybeUninit<SceneManagerHandlers> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SceneManagerHandlers>(),
        32usize,
        concat!("Size of: ", stringify!(SceneManagerHandlers))
    );
    assert_eq!(
        ::core::mem::align_of::<SceneManagerHandlers>(),
        8usize,
        concat!("Alignment of ", stringify!(SceneManagerHandlers))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_enter_handlers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_enter_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_event_handlers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_event_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_exit_handlers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_exit_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scene_num) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(scene_num)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManager {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set Scene state"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      scene_id       Scene ID"]
    #[doc = " @param      state          Scene new state"]
    pub fn scene_manager_set_scene_state(
        scene_manager: *mut SceneManager,
        scene_id: u32,
        state: u32,
    );
}
extern "C" {
    #[doc = " Get Scene state"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      scene_id       Scene ID"]
    #[doc = ""]
    #[doc = " @return     Scene state"]
    pub fn scene_manager_get_scene_state(scene_manager: *mut SceneManager, scene_id: u32) -> u32;
}
extern "C" {
    #[doc = " Scene Manager allocation and configuration"]
    #[doc = ""]
    #[doc = " Scene Manager allocates all scenes internally"]
    #[doc = ""]
    #[doc = " @param      app_scene_handlers  SceneManagerHandlers instance"]
    #[doc = " @param      context             context to be set on Scene handlers calls"]
    #[doc = ""]
    #[doc = " @return     SceneManager instance"]
    pub fn scene_manager_alloc(
        app_scene_handlers: *const SceneManagerHandlers,
        context: *mut core::ffi::c_void,
    ) -> *mut SceneManager;
}
extern "C" {
    #[doc = " Free Scene Manager with allocated Scenes"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    pub fn scene_manager_free(scene_manager: *mut SceneManager);
}
extern "C" {
    #[doc = " Custom event handler"]
    #[doc = ""]
    #[doc = " Calls Scene event handler with Custom event parameter"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      custom_event   Custom event code"]
    #[doc = ""]
    #[doc = " @return     true if event was consumed, false otherwise"]
    pub fn scene_manager_handle_custom_event(
        scene_manager: *mut SceneManager,
        custom_event: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Back event handler"]
    #[doc = ""]
    #[doc = " Calls Scene event handler with Back event parameter"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = ""]
    #[doc = " @return     true if event was consumed, false otherwise"]
    pub fn scene_manager_handle_back_event(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
    #[doc = " Tick event handler"]
    #[doc = ""]
    #[doc = " Calls Scene event handler with Tick event parameter"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @return     true if event was consumed, false otherwise"]
    pub fn scene_manager_handle_tick_event(scene_manager: *mut SceneManager);
}
extern "C" {
    #[doc = " Add and run next Scene"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      next_scene_id  next Scene ID"]
    pub fn scene_manager_next_scene(scene_manager: *mut SceneManager, next_scene_id: u32);
}
extern "C" {
    #[doc = " Run previous Scene"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = ""]
    #[doc = " @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_previous_scene(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
    #[doc = " Search previous Scene"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      scene_id       Scene ID"]
    #[doc = ""]
    #[doc = " @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_has_previous_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Search and switch to previous Scene"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      scene_id       Scene ID"]
    #[doc = ""]
    #[doc = " @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_previous_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Search and switch to previous Scene, multiple choice"]
    #[doc = ""]
    #[doc = " @param      scene_manager    SceneManager instance"]
    #[doc = " @param      scene_ids        Array of scene IDs"]
    #[doc = " @param      scene_ids_size   Array of scene IDs size"]
    #[doc = ""]
    #[doc = " @return     true if one of previous scenes was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_previous_scene_one_of(
        scene_manager: *mut SceneManager,
        scene_ids: *const u32,
        scene_ids_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Clear Scene stack and switch to another Scene"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    #[doc = " @param      scene_id       Scene ID"]
    #[doc = ""]
    #[doc = " @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_another_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Exit from current scene"]
    #[doc = ""]
    #[doc = " @param      scene_manager  SceneManager instance"]
    pub fn scene_manager_stop(scene_manager: *mut SceneManager);
}
#[doc = "< Desktop layer: fullscreen with status bar on top of it. For internal usage."]
pub const ViewDispatcherType_ViewDispatcherTypeDesktop: ViewDispatcherType = 0;
#[doc = "< Window layer: with status bar"]
pub const ViewDispatcherType_ViewDispatcherTypeWindow: ViewDispatcherType = 1;
#[doc = "< Fullscreen layer: without status bar"]
pub const ViewDispatcherType_ViewDispatcherTypeFullscreen: ViewDispatcherType = 2;
#[doc = " ViewDispatcher view_port placement"]
pub type ViewDispatcherType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewDispatcher {
    _unused: [u8; 0],
}
#[doc = " Prototype for custom event callback"]
pub type ViewDispatcherCustomEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: u32) -> bool,
>;
#[doc = " Prototype for navigation event callback"]
pub type ViewDispatcherNavigationEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> bool>;
#[doc = " Prototype for tick event callback"]
pub type ViewDispatcherTickEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate ViewDispatcher instance"]
    #[doc = ""]
    #[doc = " @return     pointer to ViewDispatcher instance"]
    pub fn view_dispatcher_alloc() -> *mut ViewDispatcher;
}
extern "C" {
    #[doc = " Free ViewDispatcher instance"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  pointer to ViewDispatcher"]
    pub fn view_dispatcher_free(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Enable queue support"]
    #[doc = ""]
    #[doc = " If queue enabled all input and custom events will be dispatched throw"]
    #[doc = " internal queue"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_enable_queue(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Send custom event"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param[in]  event            The event"]
    pub fn view_dispatcher_send_custom_event(view_dispatcher: *mut ViewDispatcher, event: u32);
}
extern "C" {
    #[doc = " Set custom event handler"]
    #[doc = ""]
    #[doc = " Called on Custom Event, if it is not consumed by view"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      callback         ViewDispatcherCustomEventCallback instance"]
    pub fn view_dispatcher_set_custom_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherCustomEventCallback,
    );
}
extern "C" {
    #[doc = " Set navigation event handler"]
    #[doc = ""]
    #[doc = " Called on Input Short Back Event, if it is not consumed by view"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      callback         ViewDispatcherNavigationEventCallback instance"]
    pub fn view_dispatcher_set_navigation_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherNavigationEventCallback,
    );
}
extern "C" {
    #[doc = " Set tick event handler"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      callback         ViewDispatcherTickEventCallback"]
    #[doc = " @param      tick_period      callback call period"]
    pub fn view_dispatcher_set_tick_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherTickEventCallback,
        tick_period: u32,
    );
}
extern "C" {
    #[doc = " Set event callback context"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      context          pointer to context"]
    pub fn view_dispatcher_set_event_callback_context(
        view_dispatcher: *mut ViewDispatcher,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Run ViewDispatcher"]
    #[doc = ""]
    #[doc = " Use only after queue enabled"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_run(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Stop ViewDispatcher"]
    #[doc = ""]
    #[doc = " Use only after queue enabled"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_stop(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Add view to ViewDispatcher"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      view_id          View id to register"]
    #[doc = " @param      view             View instance"]
    pub fn view_dispatcher_add_view(
        view_dispatcher: *mut ViewDispatcher,
        view_id: u32,
        view: *mut View,
    );
}
extern "C" {
    #[doc = " Remove view from ViewDispatcher"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      view_id          View id to remove"]
    pub fn view_dispatcher_remove_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
    #[doc = " Switch to View"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      view_id          View id to register"]
    #[doc = " @warning    switching may be delayed till input events complementarity"]
    #[doc = "             reached"]
    pub fn view_dispatcher_switch_to_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
    #[doc = " Send ViewPort of this ViewDispatcher instance to front"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_send_to_front(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Send ViewPort of this ViewDispatcher instance to back"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_send_to_back(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Attach ViewDispatcher to GUI"]
    #[doc = ""]
    #[doc = " @param      view_dispatcher  ViewDispatcher instance"]
    #[doc = " @param      gui              GUI instance to attach to"]
    #[doc = " @param[in]  type             The type"]
    pub fn view_dispatcher_attach_to_gui(
        view_dispatcher: *mut ViewDispatcher,
        gui: *mut Gui,
        type_: ViewDispatcherType,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStack {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and init ViewStack"]
    #[doc = ""]
    #[doc = " @return      ViewStack instance"]
    pub fn view_stack_alloc() -> *mut ViewStack;
}
extern "C" {
    #[doc = " Free ViewStack instance"]
    #[doc = ""]
    #[doc = " @param       view_stack  instance"]
    pub fn view_stack_free(view_stack: *mut ViewStack);
}
extern "C" {
    #[doc = " Get View of ViewStack."]
    #[doc = " Should this View to any view manager such as"]
    #[doc = " ViewDispatcher or ViewHolder."]
    #[doc = ""]
    #[doc = " @param       view_stack  instance"]
    pub fn view_stack_get_view(view_stack: *mut ViewStack) -> *mut View;
}
extern "C" {
    #[doc = " Add View to ViewStack."]
    #[doc = " Adds View on top of ViewStack."]
    #[doc = ""]
    #[doc = " @param       view_stack  instance"]
    #[doc = " @view        view        view to add"]
    pub fn view_stack_add_view(view_stack: *mut ViewStack, view: *mut View);
}
extern "C" {
    #[doc = " Remove any View in ViewStack."]
    #[doc = " If no View to remove found - ignore."]
    #[doc = ""]
    #[doc = " @param       view_stack  instance"]
    #[doc = " @view        view        view to remove"]
    pub fn view_stack_remove_view(view_stack: *mut ViewStack, view: *mut View);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loader {
    _unused: [u8; 0],
}
pub const LoaderStatus_LoaderStatusOk: LoaderStatus = 0;
pub const LoaderStatus_LoaderStatusErrorAppStarted: LoaderStatus = 1;
pub const LoaderStatus_LoaderStatusErrorUnknownApp: LoaderStatus = 2;
pub const LoaderStatus_LoaderStatusErrorInternal: LoaderStatus = 3;
pub type LoaderStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = " Start application"]
    #[doc = " @param name - application name"]
    #[doc = " @param args - application arguments"]
    #[doc = " @retval true on success"]
    pub fn loader_start(
        instance: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
    ) -> LoaderStatus;
}
extern "C" {
    #[doc = " Lock application start"]
    #[doc = " @retval true on success"]
    pub fn loader_lock(instance: *mut Loader) -> bool;
}
extern "C" {
    #[doc = " Unlock application start"]
    pub fn loader_unlock(instance: *mut Loader);
}
extern "C" {
    #[doc = " Get loader lock status"]
    pub fn loader_is_locked(instance: *mut Loader) -> bool;
}
extern "C" {
    #[doc = " Show primary loader"]
    pub fn loader_show_menu();
}
extern "C" {
    #[doc = " Show primary loader"]
    pub fn loader_update_menu();
}
extern "C" {
    #[doc = " Show primary loader"]
    pub fn loader_get_pubsub(instance: *mut Loader) -> *mut FuriPubSub;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationApp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataSound {
    pub frequency: f32,
    pub volume: f32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataSound() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataSound> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataSound>(),
        8usize,
        concat!("Size of: ", stringify!(NotificationMessageDataSound))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataSound>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataSound))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataSound),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).volume) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataSound),
            "::",
            stringify!(volume)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLed {
    pub value: u8,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLed() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataLed> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataLed>(),
        1usize,
        concat!("Size of: ", stringify!(NotificationMessageDataLed))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataLed>(),
        1usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataLed))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLed),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataVibro {
    pub on: bool,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataVibro() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataVibro> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataVibro>(),
        1usize,
        concat!("Size of: ", stringify!(NotificationMessageDataVibro))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataVibro>(),
        1usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataVibro))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataVibro),
            "::",
            stringify!(on)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataDelay {
    pub length: u32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataDelay() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataDelay> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataDelay>(),
        4usize,
        concat!("Size of: ", stringify!(NotificationMessageDataDelay))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataDelay>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataDelay))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataDelay),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataForcedSettings {
    pub speaker_volume: f32,
    pub vibro: bool,
    pub display_brightness: f32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataForcedSettings() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataForcedSettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataForcedSettings>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NotificationMessageDataForcedSettings)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataForcedSettings>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NotificationMessageDataForcedSettings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).speaker_volume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(speaker_volume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(vibro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_brightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(display_brightness)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLedBlink {
    pub on_time: u16,
    pub period: u16,
    pub color: Light,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLedBlink() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataLedBlink> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataLedBlink>(),
        6usize,
        concat!("Size of: ", stringify!(NotificationMessageDataLedBlink))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataLedBlink>(),
        2usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataLedBlink))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(on_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(color)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NotificationMessageData {
    pub sound: NotificationMessageDataSound,
    pub led: NotificationMessageDataLed,
    pub led_blink: NotificationMessageDataLedBlink,
    pub vibro: NotificationMessageDataVibro,
    pub delay: NotificationMessageDataDelay,
    pub forced_settings: NotificationMessageDataForcedSettings,
}
#[test]
fn bindgen_test_layout_NotificationMessageData() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageData>(),
        12usize,
        concat!("Size of: ", stringify!(NotificationMessageData))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageData>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(sound)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led_blink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(led_blink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(vibro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forced_settings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(forced_settings)
        )
    );
}
pub const NotificationMessageType_NotificationMessageTypeVibro: NotificationMessageType = 0;
pub const NotificationMessageType_NotificationMessageTypeSoundOn: NotificationMessageType = 1;
pub const NotificationMessageType_NotificationMessageTypeSoundOff: NotificationMessageType = 2;
pub const NotificationMessageType_NotificationMessageTypeLedRed: NotificationMessageType = 3;
pub const NotificationMessageType_NotificationMessageTypeLedGreen: NotificationMessageType = 4;
pub const NotificationMessageType_NotificationMessageTypeLedBlue: NotificationMessageType = 5;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkStart: NotificationMessageType = 6;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkStop: NotificationMessageType = 7;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkColor: NotificationMessageType = 8;
pub const NotificationMessageType_NotificationMessageTypeDelay: NotificationMessageType = 9;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklight:
    NotificationMessageType = 10;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklightEnforceOn:
    NotificationMessageType = 11;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklightEnforceAuto:
    NotificationMessageType = 12;
pub const NotificationMessageType_NotificationMessageTypeDoNotReset: NotificationMessageType = 13;
pub const NotificationMessageType_NotificationMessageTypeForceSpeakerVolumeSetting:
    NotificationMessageType = 14;
pub const NotificationMessageType_NotificationMessageTypeForceVibroSetting:
    NotificationMessageType = 15;
pub const NotificationMessageType_NotificationMessageTypeForceDisplayBrightnessSetting:
    NotificationMessageType = 16;
pub const NotificationMessageType_NotificationMessageTypeLedBrightnessSettingApply:
    NotificationMessageType = 17;
pub type NotificationMessageType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NotificationMessage {
    pub type_: NotificationMessageType,
    pub data: NotificationMessageData,
}
#[test]
fn bindgen_test_layout_NotificationMessage() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessage> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessage>(),
        16usize,
        concat!("Size of: ", stringify!(NotificationMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessage),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessage),
            "::",
            stringify!(data)
        )
    );
}
pub type NotificationSequence = [*const NotificationMessage; 0usize];
extern "C" {
    pub fn notification_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
    pub fn notification_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    #[doc = " @brief Send internal (apply to permanent layer) notification message. Think twice before use."]
    #[doc = ""]
    #[doc = " @param app notification record content"]
    #[doc = " @param sequence notification sequence"]
    pub fn notification_internal_message(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    #[doc = " @brief Send internal (apply to permanent layer) notification message and wait for notification end. Think twice before use."]
    #[doc = ""]
    #[doc = " @param app notification record content"]
    #[doc = " @param sequence notification sequence"]
    pub fn notification_internal_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    pub static message_click: NotificationMessage;
}
extern "C" {
    pub static message_note_c0: NotificationMessage;
}
extern "C" {
    pub static message_note_cs0: NotificationMessage;
}
extern "C" {
    pub static message_note_d0: NotificationMessage;
}
extern "C" {
    pub static message_note_ds0: NotificationMessage;
}
extern "C" {
    pub static message_note_e0: NotificationMessage;
}
extern "C" {
    pub static message_note_f0: NotificationMessage;
}
extern "C" {
    pub static message_note_fs0: NotificationMessage;
}
extern "C" {
    pub static message_note_g0: NotificationMessage;
}
extern "C" {
    pub static message_note_gs0: NotificationMessage;
}
extern "C" {
    pub static message_note_a0: NotificationMessage;
}
extern "C" {
    pub static message_note_as0: NotificationMessage;
}
extern "C" {
    pub static message_note_b0: NotificationMessage;
}
extern "C" {
    pub static message_note_c1: NotificationMessage;
}
extern "C" {
    pub static message_note_cs1: NotificationMessage;
}
extern "C" {
    pub static message_note_d1: NotificationMessage;
}
extern "C" {
    pub static message_note_ds1: NotificationMessage;
}
extern "C" {
    pub static message_note_e1: NotificationMessage;
}
extern "C" {
    pub static message_note_f1: NotificationMessage;
}
extern "C" {
    pub static message_note_fs1: NotificationMessage;
}
extern "C" {
    pub static message_note_g1: NotificationMessage;
}
extern "C" {
    pub static message_note_gs1: NotificationMessage;
}
extern "C" {
    pub static message_note_a1: NotificationMessage;
}
extern "C" {
    pub static message_note_as1: NotificationMessage;
}
extern "C" {
    pub static message_note_b1: NotificationMessage;
}
extern "C" {
    pub static message_note_c2: NotificationMessage;
}
extern "C" {
    pub static message_note_cs2: NotificationMessage;
}
extern "C" {
    pub static message_note_d2: NotificationMessage;
}
extern "C" {
    pub static message_note_ds2: NotificationMessage;
}
extern "C" {
    pub static message_note_e2: NotificationMessage;
}
extern "C" {
    pub static message_note_f2: NotificationMessage;
}
extern "C" {
    pub static message_note_fs2: NotificationMessage;
}
extern "C" {
    pub static message_note_g2: NotificationMessage;
}
extern "C" {
    pub static message_note_gs2: NotificationMessage;
}
extern "C" {
    pub static message_note_a2: NotificationMessage;
}
extern "C" {
    pub static message_note_as2: NotificationMessage;
}
extern "C" {
    pub static message_note_b2: NotificationMessage;
}
extern "C" {
    pub static message_note_c3: NotificationMessage;
}
extern "C" {
    pub static message_note_cs3: NotificationMessage;
}
extern "C" {
    pub static message_note_d3: NotificationMessage;
}
extern "C" {
    pub static message_note_ds3: NotificationMessage;
}
extern "C" {
    pub static message_note_e3: NotificationMessage;
}
extern "C" {
    pub static message_note_f3: NotificationMessage;
}
extern "C" {
    pub static message_note_fs3: NotificationMessage;
}
extern "C" {
    pub static message_note_g3: NotificationMessage;
}
extern "C" {
    pub static message_note_gs3: NotificationMessage;
}
extern "C" {
    pub static message_note_a3: NotificationMessage;
}
extern "C" {
    pub static message_note_as3: NotificationMessage;
}
extern "C" {
    pub static message_note_b3: NotificationMessage;
}
extern "C" {
    pub static message_note_c4: NotificationMessage;
}
extern "C" {
    pub static message_note_cs4: NotificationMessage;
}
extern "C" {
    pub static message_note_d4: NotificationMessage;
}
extern "C" {
    pub static message_note_ds4: NotificationMessage;
}
extern "C" {
    pub static message_note_e4: NotificationMessage;
}
extern "C" {
    pub static message_note_f4: NotificationMessage;
}
extern "C" {
    pub static message_note_fs4: NotificationMessage;
}
extern "C" {
    pub static message_note_g4: NotificationMessage;
}
extern "C" {
    pub static message_note_gs4: NotificationMessage;
}
extern "C" {
    pub static message_note_a4: NotificationMessage;
}
extern "C" {
    pub static message_note_as4: NotificationMessage;
}
extern "C" {
    pub static message_note_b4: NotificationMessage;
}
extern "C" {
    pub static message_note_c5: NotificationMessage;
}
extern "C" {
    pub static message_note_cs5: NotificationMessage;
}
extern "C" {
    pub static message_note_d5: NotificationMessage;
}
extern "C" {
    pub static message_note_ds5: NotificationMessage;
}
extern "C" {
    pub static message_note_e5: NotificationMessage;
}
extern "C" {
    pub static message_note_f5: NotificationMessage;
}
extern "C" {
    pub static message_note_fs5: NotificationMessage;
}
extern "C" {
    pub static message_note_g5: NotificationMessage;
}
extern "C" {
    pub static message_note_gs5: NotificationMessage;
}
extern "C" {
    pub static message_note_a5: NotificationMessage;
}
extern "C" {
    pub static message_note_as5: NotificationMessage;
}
extern "C" {
    pub static message_note_b5: NotificationMessage;
}
extern "C" {
    pub static message_note_c6: NotificationMessage;
}
extern "C" {
    pub static message_note_cs6: NotificationMessage;
}
extern "C" {
    pub static message_note_d6: NotificationMessage;
}
extern "C" {
    pub static message_note_ds6: NotificationMessage;
}
extern "C" {
    pub static message_note_e6: NotificationMessage;
}
extern "C" {
    pub static message_note_f6: NotificationMessage;
}
extern "C" {
    pub static message_note_fs6: NotificationMessage;
}
extern "C" {
    pub static message_note_g6: NotificationMessage;
}
extern "C" {
    pub static message_note_gs6: NotificationMessage;
}
extern "C" {
    pub static message_note_a6: NotificationMessage;
}
extern "C" {
    pub static message_note_as6: NotificationMessage;
}
extern "C" {
    pub static message_note_b6: NotificationMessage;
}
extern "C" {
    pub static message_note_c7: NotificationMessage;
}
extern "C" {
    pub static message_note_cs7: NotificationMessage;
}
extern "C" {
    pub static message_note_d7: NotificationMessage;
}
extern "C" {
    pub static message_note_ds7: NotificationMessage;
}
extern "C" {
    pub static message_note_e7: NotificationMessage;
}
extern "C" {
    pub static message_note_f7: NotificationMessage;
}
extern "C" {
    pub static message_note_fs7: NotificationMessage;
}
extern "C" {
    pub static message_note_g7: NotificationMessage;
}
extern "C" {
    pub static message_note_gs7: NotificationMessage;
}
extern "C" {
    pub static message_note_a7: NotificationMessage;
}
extern "C" {
    pub static message_note_as7: NotificationMessage;
}
extern "C" {
    pub static message_note_b7: NotificationMessage;
}
extern "C" {
    pub static message_note_c8: NotificationMessage;
}
extern "C" {
    pub static message_note_cs8: NotificationMessage;
}
extern "C" {
    pub static message_note_d8: NotificationMessage;
}
extern "C" {
    pub static message_note_ds8: NotificationMessage;
}
extern "C" {
    pub static message_note_e8: NotificationMessage;
}
extern "C" {
    pub static message_note_f8: NotificationMessage;
}
extern "C" {
    pub static message_note_fs8: NotificationMessage;
}
extern "C" {
    pub static message_note_g8: NotificationMessage;
}
extern "C" {
    pub static message_note_gs8: NotificationMessage;
}
extern "C" {
    pub static message_note_a8: NotificationMessage;
}
extern "C" {
    pub static message_note_as8: NotificationMessage;
}
extern "C" {
    pub static message_note_b8: NotificationMessage;
}
extern "C" {
    #[doc = " Messages"]
    pub static message_display_backlight_on: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_off: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_enforce_on: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_enforce_auto: NotificationMessage;
}
extern "C" {
    pub static message_red_255: NotificationMessage;
}
extern "C" {
    pub static message_green_255: NotificationMessage;
}
extern "C" {
    pub static message_blue_255: NotificationMessage;
}
extern "C" {
    pub static message_red_0: NotificationMessage;
}
extern "C" {
    pub static message_green_0: NotificationMessage;
}
extern "C" {
    pub static message_blue_0: NotificationMessage;
}
extern "C" {
    pub static message_blink_start_10: NotificationMessage;
}
extern "C" {
    pub static message_blink_start_100: NotificationMessage;
}
extern "C" {
    pub static message_blink_stop: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_red: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_green: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_blue: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_cyan: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_magenta: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_yellow: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_white: NotificationMessage;
}
extern "C" {
    pub static message_delay_1: NotificationMessage;
}
extern "C" {
    pub static message_delay_10: NotificationMessage;
}
extern "C" {
    pub static message_delay_25: NotificationMessage;
}
extern "C" {
    pub static message_delay_50: NotificationMessage;
}
extern "C" {
    pub static message_delay_100: NotificationMessage;
}
extern "C" {
    pub static message_delay_250: NotificationMessage;
}
extern "C" {
    pub static message_delay_500: NotificationMessage;
}
extern "C" {
    pub static message_delay_1000: NotificationMessage;
}
extern "C" {
    pub static message_sound_off: NotificationMessage;
}
extern "C" {
    pub static message_vibro_on: NotificationMessage;
}
extern "C" {
    pub static message_vibro_off: NotificationMessage;
}
extern "C" {
    pub static message_do_not_reset: NotificationMessage;
}
extern "C" {
    pub static message_force_speaker_volume_setting_1f: NotificationMessage;
}
extern "C" {
    pub static message_force_vibro_setting_on: NotificationMessage;
}
extern "C" {
    pub static message_force_vibro_setting_off: NotificationMessage;
}
extern "C" {
    pub static message_force_display_brightness_setting_1f: NotificationMessage;
}
extern "C" {
    #[doc = " Message sequences"]
    pub static sequence_reset_red: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_green: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_blue: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_rgb: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_display: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_sound: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_set_vibro_on: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight wakeup"]
    pub static sequence_display_backlight_on: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight force off"]
    pub static sequence_display_backlight_off: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight force off after a delay of 1000ms"]
    pub static sequence_display_backlight_off_delay_1000: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight always on lock"]
    pub static sequence_display_backlight_enforce_on: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight always on unlock"]
    pub static sequence_display_backlight_enforce_auto: NotificationSequence;
}
extern "C" {
    pub static sequence_charging: NotificationSequence;
}
extern "C" {
    pub static sequence_charged: NotificationSequence;
}
extern "C" {
    pub static sequence_not_charging: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_red_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_green_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_blue_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_red_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_green_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_blue_255: NotificationSequence;
}
extern "C" {
    pub static sequence_solid_yellow: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_blue_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_red_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_green_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_yellow_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_cyan_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_magenta_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_red_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_green_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_blue_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_yellow_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_cyan_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_magenta_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_white_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_blue: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_red: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_green: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_yellow: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_cyan: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_magenta: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_stop: NotificationSequence;
}
extern "C" {
    pub static sequence_single_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_double_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_success: NotificationSequence;
}
extern "C" {
    pub static sequence_error: NotificationSequence;
}
extern "C" {
    pub static sequence_audiovisual_alert: NotificationSequence;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Power {
    _unused: [u8; 0],
}
pub const PowerBootMode_PowerBootModeNormal: PowerBootMode = 0;
pub const PowerBootMode_PowerBootModeDfu: PowerBootMode = 1;
pub const PowerBootMode_PowerBootModeUpdateStart: PowerBootMode = 2;
pub type PowerBootMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PowerInfo {
    pub gauge_is_ok: bool,
    pub is_charging: bool,
    pub current_charger: f32,
    pub current_gauge: f32,
    pub voltage_charger: f32,
    pub voltage_gauge: f32,
    pub voltage_vbus: f32,
    pub capacity_remaining: u32,
    pub capacity_full: u32,
    pub temperature_charger: f32,
    pub temperature_gauge: f32,
    pub charge: u8,
    pub health: u8,
}
#[test]
fn bindgen_test_layout_PowerInfo() {
    const UNINIT: ::core::mem::MaybeUninit<PowerInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PowerInfo>(),
        44usize,
        concat!("Size of: ", stringify!(PowerInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PowerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(PowerInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gauge_is_ok) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(gauge_is_ok)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_charging) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(is_charging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_charger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(current_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_gauge) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(current_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_charger) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_gauge) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_vbus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_vbus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity_remaining) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(capacity_remaining)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity_full) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(capacity_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature_charger) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(temperature_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature_gauge) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(temperature_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).charge) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(charge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).health) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(health)
        )
    );
}
extern "C" {
    #[doc = " Power off device"]
    pub fn power_off(power: *mut Power);
}
extern "C" {
    #[doc = " Reboot device"]
    #[doc = ""]
    #[doc = " @param mode      PowerBootMode"]
    pub fn power_reboot(mode: PowerBootMode);
}
extern "C" {
    #[doc = " Get power info"]
    #[doc = ""]
    #[doc = " @param power     Power instance"]
    #[doc = " @param info      PowerInfo instance"]
    pub fn power_get_info(power: *mut Power, info: *mut PowerInfo);
}
extern "C" {
    #[doc = " Get power event pubsub handler"]
    #[doc = ""]
    #[doc = " @param power     Power instance"]
    #[doc = ""]
    #[doc = " @return          FuriPubSub instance"]
    pub fn power_get_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Check battery health"]
    #[doc = ""]
    #[doc = " @return          true if battery is healthy"]
    pub fn power_is_battery_healthy(power: *mut Power) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rpc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcSession {
    _unused: [u8; 0],
}
#[doc = " Callback to send to client any data (e.g. response to command)"]
pub type RpcSendBytesCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, bytes: *mut u8, bytes_len: usize),
>;
#[doc = " Callback to notify client that buffer is empty"]
pub type RpcBufferIsEmptyCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that close_session command"]
#[doc = " is received. Any other actions lays on transport layer."]
#[doc = " No destruction or session close preformed."]
pub type RpcSessionClosedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that session was closed"]
#[doc = " and all operations were finished"]
pub type RpcSessionTerminatedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Open RPC session"]
    #[doc = ""]
    #[doc = " USAGE:"]
    #[doc = " 1) rpc_session_open();"]
    #[doc = " 2) rpc_session_set_context();"]
    #[doc = " 3) rpc_session_set_send_bytes_callback();"]
    #[doc = " 4) rpc_session_set_close_callback();"]
    #[doc = " 5) while(1) {"]
    #[doc = "      rpc_session_feed();"]
    #[doc = "    }"]
    #[doc = " 6) rpc_session_close();"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param   rpc     instance"]
    #[doc = " @return          pointer to RpcSession descriptor, or"]
    #[doc = "                  NULL if RPC is busy and can't open session now"]
    pub fn rpc_session_open(rpc: *mut Rpc) -> *mut RpcSession;
}
extern "C" {
    #[doc = " Close RPC session"]
    #[doc = " It is guaranteed that no callbacks will be called"]
    #[doc = " as soon as session is closed. So no need in setting"]
    #[doc = " callbacks to NULL after session close."]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    pub fn rpc_session_close(session: *mut RpcSession);
}
extern "C" {
    #[doc = " Set session context for callbacks to pass"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = " @param   context     context to pass to callbacks"]
    pub fn rpc_session_set_context(session: *mut RpcSession, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set callback to send bytes to client"]
    #[doc = "  WARN: It's forbidden to call RPC API within RpcSendBytesCallback"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = " @param   callback    callback to send bytes to client (can be NULL)"]
    pub fn rpc_session_set_send_bytes_callback(
        session: *mut RpcSession,
        callback: RpcSendBytesCallback,
    );
}
extern "C" {
    #[doc = " Set callback to notify that buffer is empty"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = " @param   callback    callback to notify client that buffer is empty (can be NULL)"]
    pub fn rpc_session_set_buffer_is_empty_callback(
        session: *mut RpcSession,
        callback: RpcBufferIsEmptyCallback,
    );
}
extern "C" {
    #[doc = " Set callback to be called when RPC command to close session is received"]
    #[doc = "  WARN: It's forbidden to call RPC API within RpcSessionClosedCallback"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = " @param   callback    callback to inform about RPC close session command (can be NULL)"]
    pub fn rpc_session_set_close_callback(
        session: *mut RpcSession,
        callback: RpcSessionClosedCallback,
    );
}
extern "C" {
    #[doc = " Set callback to be called when RPC session is closed"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = " @param   callback    callback to inform about RPC session state"]
    pub fn rpc_session_set_terminated_callback(
        session: *mut RpcSession,
        callback: RpcSessionTerminatedCallback,
    );
}
extern "C" {
    #[doc = " Give bytes to RPC service to decode them and perform command"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = " @param   buffer      buffer to provide to RPC service"]
    #[doc = " @param   size        size of buffer"]
    #[doc = " @param   timeout     max timeout to wait till all buffer will be consumed"]
    #[doc = ""]
    #[doc = " @return              actually consumed bytes"]
    pub fn rpc_session_feed(
        session: *mut RpcSession,
        buffer: *mut u8,
        size: usize,
        timeout: TickType_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Get available size of RPC buffer"]
    #[doc = ""]
    #[doc = " @param   session     pointer to RpcSession descriptor"]
    #[doc = ""]
    #[doc = " @return              bytes available in buffer"]
    pub fn rpc_session_get_available_size(session: *mut RpcSession) -> usize;
}
pub const RpcAppSystemEvent_RpcAppEventSessionClose: RpcAppSystemEvent = 0;
pub const RpcAppSystemEvent_RpcAppEventAppExit: RpcAppSystemEvent = 1;
pub const RpcAppSystemEvent_RpcAppEventLoadFile: RpcAppSystemEvent = 2;
pub const RpcAppSystemEvent_RpcAppEventButtonPress: RpcAppSystemEvent = 3;
pub const RpcAppSystemEvent_RpcAppEventButtonRelease: RpcAppSystemEvent = 4;
pub type RpcAppSystemEvent = core::ffi::c_uchar;
pub type RpcAppSystemCallback = ::core::option::Option<
    unsafe extern "C" fn(event: RpcAppSystemEvent, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcAppSystem {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rpc_system_app_set_callback(
        rpc_app: *mut RpcAppSystem,
        callback: RpcAppSystemCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rpc_system_app_send_started(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    pub fn rpc_system_app_send_exited(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    pub fn rpc_system_app_get_data(rpc_app: *mut RpcAppSystem) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn rpc_system_app_confirm(
        rpc_app: *mut RpcAppSystem,
        event: RpcAppSystemEvent,
        result: bool,
    );
}
#[doc = "< Read access"]
pub const FS_AccessMode_FSAM_READ: FS_AccessMode = 1;
#[doc = "< Write access"]
pub const FS_AccessMode_FSAM_WRITE: FS_AccessMode = 2;
#[doc = "< Read and write access"]
pub const FS_AccessMode_FSAM_READ_WRITE: FS_AccessMode = 3;
#[doc = " Access mode flags"]
pub type FS_AccessMode = core::ffi::c_uchar;
#[doc = "< Open file, fail if file doesn't exist"]
pub const FS_OpenMode_FSOM_OPEN_EXISTING: FS_OpenMode = 1;
#[doc = "< Open file. Create new file if not exist"]
pub const FS_OpenMode_FSOM_OPEN_ALWAYS: FS_OpenMode = 2;
#[doc = "< Open file. Create new file if not exist. Set R/W pointer to EOF"]
pub const FS_OpenMode_FSOM_OPEN_APPEND: FS_OpenMode = 4;
#[doc = "< Creates a new file. Fails if the file is exist"]
pub const FS_OpenMode_FSOM_CREATE_NEW: FS_OpenMode = 8;
#[doc = "< Creates a new file. If file exist, truncate to zero size"]
pub const FS_OpenMode_FSOM_CREATE_ALWAYS: FS_OpenMode = 16;
#[doc = " Open mode flags"]
pub type FS_OpenMode = core::ffi::c_uchar;
#[doc = "< No error"]
pub const FS_Error_FSE_OK: FS_Error = 0;
#[doc = "< FS not ready"]
pub const FS_Error_FSE_NOT_READY: FS_Error = 1;
#[doc = "< File/Dir alrady exist"]
pub const FS_Error_FSE_EXIST: FS_Error = 2;
#[doc = "< File/Dir does not exist"]
pub const FS_Error_FSE_NOT_EXIST: FS_Error = 3;
#[doc = "< Invalid API parameter"]
pub const FS_Error_FSE_INVALID_PARAMETER: FS_Error = 4;
#[doc = "< Access denied"]
pub const FS_Error_FSE_DENIED: FS_Error = 5;
#[doc = "< Invalid name/path"]
pub const FS_Error_FSE_INVALID_NAME: FS_Error = 6;
#[doc = "< Internal error"]
pub const FS_Error_FSE_INTERNAL: FS_Error = 7;
#[doc = "< Functon not implemented"]
pub const FS_Error_FSE_NOT_IMPLEMENTED: FS_Error = 8;
#[doc = "< File/Dir already opened"]
pub const FS_Error_FSE_ALREADY_OPEN: FS_Error = 9;
#[doc = " API errors enumeration"]
pub type FS_Error = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    _unused: [u8; 0],
}
#[doc = "  Structure that hold file info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileInfo {
    #[doc = "< flags from FS_Flags enum"]
    pub flags: u8,
    #[doc = "< file size"]
    pub size: u64,
}
#[test]
fn bindgen_test_layout_FileInfo() {
    const UNINIT: ::core::mem::MaybeUninit<FileInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FileInfo>(),
        16usize,
        concat!("Size of: ", stringify!(FileInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FileInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FileInfo),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Gets the error text from FS_Error"]
    #[doc = " @param error_id error id"]
    #[doc = " @return const char* error text"]
    pub fn filesystem_api_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
pub const SDFsType_FST_UNKNOWN: SDFsType = 0;
pub const SDFsType_FST_FAT12: SDFsType = 1;
pub const SDFsType_FST_FAT16: SDFsType = 2;
pub const SDFsType_FST_FAT32: SDFsType = 3;
pub const SDFsType_FST_EXFAT: SDFsType = 4;
pub type SDFsType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDInfo {
    pub fs_type: SDFsType,
    pub kb_total: u32,
    pub kb_free: u32,
    pub cluster_size: u16,
    pub sector_size: u16,
    pub label: [core::ffi::c_char; 34usize],
    pub error: FS_Error,
}
#[test]
fn bindgen_test_layout_SDInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDInfo>(),
        52usize,
        concat!("Size of: ", stringify!(SDInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SDInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fs_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(fs_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kb_total) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(kb_total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kb_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(kb_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cluster_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(cluster_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_size) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(sector_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn sd_api_get_fs_type_text(fs_type: SDFsType) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Storage {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocates and initializes a file descriptor"]
    #[doc = " @return File*"]
    pub fn storage_file_alloc(storage: *mut Storage) -> *mut File;
}
extern "C" {
    #[doc = " Frees the file descriptor. Closes the file if it was open."]
    pub fn storage_file_free(file: *mut File);
}
extern "C" {
    #[doc = " Get storage pubsub."]
    #[doc = " Storage will send StorageEvent messages."]
    #[doc = " @param storage"]
    #[doc = " @return FuriPubSub*"]
    pub fn storage_get_pubsub(storage: *mut Storage) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Opens an existing file or create a new one."]
    #[doc = " @param file pointer to file object."]
    #[doc = " @param path path to file"]
    #[doc = " @param access_mode access mode from FS_AccessMode"]
    #[doc = " @param open_mode open mode from FS_OpenMode"]
    #[doc = " @return success flag. You need to close the file even if the open operation failed."]
    pub fn storage_file_open(
        file: *mut File,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Close the file."]
    #[doc = " @param file pointer to a file object, the file object will be freed."]
    #[doc = " @return success flag"]
    pub fn storage_file_close(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Tells if the file is open"]
    #[doc = " @param file pointer to a file object"]
    #[doc = " @return bool true if file is open"]
    pub fn storage_file_is_open(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Tells if the file is a directory"]
    #[doc = " @param file pointer to a file object"]
    #[doc = " @return bool true if file is a directory"]
    pub fn storage_file_is_dir(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Reads bytes from a file into a buffer"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @param buff pointer to a buffer, for reading"]
    #[doc = " @param bytes_to_read how many bytes to read. Must be less than or equal to the size of the buffer."]
    #[doc = " @return uint16_t how many bytes were actually read"]
    pub fn storage_file_read(
        file: *mut File,
        buff: *mut core::ffi::c_void,
        bytes_to_read: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Writes bytes from a buffer to a file"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @param buff pointer to buffer, for writing"]
    #[doc = " @param bytes_to_write how many bytes to write. Must be less than or equal to the size of the buffer."]
    #[doc = " @return uint16_t how many bytes were actually written"]
    pub fn storage_file_write(
        file: *mut File,
        buff: *const core::ffi::c_void,
        bytes_to_write: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Moves the r/w pointer"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @param offset offset to move the r/w pointer"]
    #[doc = " @param from_start set an offset from the start or from the current position"]
    #[doc = " @return success flag"]
    pub fn storage_file_seek(file: *mut File, offset: u32, from_start: bool) -> bool;
}
extern "C" {
    #[doc = " Gets the position of the r/w pointer"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @return uint64_t position of the r/w pointer"]
    pub fn storage_file_tell(file: *mut File) -> u64;
}
extern "C" {
    #[doc = " Truncates the file size to the current position of the r/w pointer"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @return bool success flag"]
    pub fn storage_file_truncate(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Gets the size of the file"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @return uint64_t size of the file"]
    pub fn storage_file_size(file: *mut File) -> u64;
}
extern "C" {
    #[doc = " Checks that the r/w pointer is at the end of the file"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @return bool success flag"]
    pub fn storage_file_eof(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " @brief Check that file exists"]
    #[doc = ""]
    #[doc = " @param storage"]
    #[doc = " @param path"]
    #[doc = " @return true if file exists"]
    pub fn storage_file_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Opens a directory to get objects from it"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @param path path to directory"]
    #[doc = " @return bool success flag. You need to close the directory even if the open operation failed."]
    pub fn storage_dir_open(file: *mut File, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Close the directory. Also free file handle structure and point it to the NULL."]
    #[doc = " @param file pointer to a file object."]
    #[doc = " @return bool success flag"]
    pub fn storage_dir_close(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Reads the next object in the directory"]
    #[doc = " @param file pointer to file object."]
    #[doc = " @param fileinfo pointer to the read FileInfo, may be NULL"]
    #[doc = " @param name pointer to name buffer, may be NULL"]
    #[doc = " @param name_length name buffer length"]
    #[doc = " @return success flag (if the next object does not exist, it also returns false and sets the file error id to FSE_NOT_EXIST)"]
    pub fn storage_dir_read(
        file: *mut File,
        fileinfo: *mut FileInfo,
        name: *mut core::ffi::c_char,
        name_length: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieves unix timestamp of last access"]
    #[doc = ""]
    #[doc = " @param      storage    The storage instance"]
    #[doc = " @param      path       path to file/directory"]
    #[doc = " @param      timestamp  the timestamp pointer"]
    #[doc = ""]
    #[doc = " @return     FS_Error operation result"]
    pub fn storage_common_timestamp(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        timestamp: *mut u32,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves information about a file/directory"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param path path to file/directory"]
    #[doc = " @param fileinfo pointer to the read FileInfo, may be NULL"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_stat(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Removes a file/directory from the repository, the directory must be empty and the file/directory must not be open"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param path"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_remove(storage: *mut Storage, path: *const core::ffi::c_char)
        -> FS_Error;
}
extern "C" {
    #[doc = " Renames file/directory, file/directory must not be open"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param old_path old path"]
    #[doc = " @param new_path new path"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_rename(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Copy file, file must not be open"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param old_path old path"]
    #[doc = " @param new_path new path"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_copy(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Copy one folder contents into another with rename of all conflicting files"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param old_path old path"]
    #[doc = " @param new_path new path"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_merge(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Creates a directory"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param path directory path"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
    #[doc = " Gets general information about the storage"]
    #[doc = " @param app pointer to the api"]
    #[doc = " @param fs_path the path to the storage of interest"]
    #[doc = " @param total_space pointer to total space record, will be filled"]
    #[doc = " @param free_space pointer to free space record, will be filled"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_common_fs_info(
        storage: *mut Storage,
        fs_path: *const core::ffi::c_char,
        total_space: *mut u64,
        free_space: *mut u64,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves the error text from the error id"]
    #[doc = " @param error_id error id"]
    #[doc = " @return const char* error text"]
    pub fn storage_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Retrieves the error id from the file object"]
    #[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE ERROR ID IF THE FILE HAS BEEN CLOSED"]
    #[doc = " @return FS_Error error id"]
    pub fn storage_file_get_error(file: *mut File) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves the error text from the file object"]
    #[doc = " @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETREIVE THE ERROR TEXT IF THE FILE HAS BEEN CLOSED"]
    #[doc = " @return const char* error text"]
    pub fn storage_file_get_error_desc(file: *mut File) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Formats SD Card"]
    #[doc = " @param api pointer to the api"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_sd_format(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = " Will unmount the SD card"]
    #[doc = " @param api pointer to the api"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_sd_unmount(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves SD card information"]
    #[doc = " @param api pointer to the api"]
    #[doc = " @param info pointer to the info"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_sd_info(api: *mut Storage, info: *mut SDInfo) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves SD card status"]
    #[doc = " @param api pointer to the api"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_sd_status(api: *mut Storage) -> FS_Error;
}
#[doc = " Internal LFS Functions"]
pub type Storage_name_converter =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut FuriString)>;
extern "C" {
    #[doc = " Backs up internal storage to a tar archive"]
    #[doc = " @param api pointer to the api"]
    #[doc = " @param dstmane destination archive path"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_int_backup(api: *mut Storage, dstname: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
    #[doc = " Restores internal storage from a tar archive"]
    #[doc = " @param api pointer to the api"]
    #[doc = " @param dstmane archive path"]
    #[doc = " @param converter pointer to filename conversion function, may be NULL"]
    #[doc = " @return FS_Error operation result"]
    pub fn storage_int_restore(
        api: *mut Storage,
        dstname: *const core::ffi::c_char,
        converter: Storage_name_converter,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Removes a file/directory, the directory must be empty and the file/directory must not be open"]
    #[doc = " @param storage pointer to the api"]
    #[doc = " @param path"]
    #[doc = " @return true on success or if file/dir is not exist"]
    pub fn storage_simply_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Recursively removes a file/directory, the directory can be not empty"]
    #[doc = " @param storage pointer to the api"]
    #[doc = " @param path"]
    #[doc = " @return true on success or if file/dir is not exist"]
    pub fn storage_simply_remove_recursive(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates a directory"]
    #[doc = " @param storage"]
    #[doc = " @param path"]
    #[doc = " @return true on success or if directory is already exist"]
    pub fn storage_simply_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " @brief Get next free filename."]
    #[doc = ""]
    #[doc = " @param storage"]
    #[doc = " @param dirname"]
    #[doc = " @param filename"]
    #[doc = " @param fileextension"]
    #[doc = " @param nextfilename return name"]
    #[doc = " @param max_len  max len name"]
    pub fn storage_get_next_filename(
        storage: *mut Storage,
        dirname: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        fileextension: *const core::ffi::c_char,
        nextfilename: *mut FuriString,
        max_len: u8,
    );
}
extern "C" {
    pub fn LL_RCC_GetUSARTClockFreq(USARTxSource: u32) -> u32;
}
extern "C" {
    pub fn LL_RCC_GetLPUARTClockFreq(LPUARTxSource: u32) -> u32;
}
pub const FuriHalClockMcoSourceId_FuriHalClockMcoLse: FuriHalClockMcoSourceId = 0;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoSysclk: FuriHalClockMcoSourceId = 1;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi100k: FuriHalClockMcoSourceId = 2;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi200k: FuriHalClockMcoSourceId = 3;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi400k: FuriHalClockMcoSourceId = 4;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi800k: FuriHalClockMcoSourceId = 5;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi1m: FuriHalClockMcoSourceId = 6;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi2m: FuriHalClockMcoSourceId = 7;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi4m: FuriHalClockMcoSourceId = 8;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi8m: FuriHalClockMcoSourceId = 9;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi16m: FuriHalClockMcoSourceId = 10;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi24m: FuriHalClockMcoSourceId = 11;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi32m: FuriHalClockMcoSourceId = 12;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi48m: FuriHalClockMcoSourceId = 13;
pub type FuriHalClockMcoSourceId = core::ffi::c_uchar;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv1: FuriHalClockMcoDivisorId = 0;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv2: FuriHalClockMcoDivisorId = 268435456;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv4: FuriHalClockMcoDivisorId = 536870912;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv8: FuriHalClockMcoDivisorId = 805306368;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv16: FuriHalClockMcoDivisorId = 1073741824;
pub type FuriHalClockMcoDivisorId = core::ffi::c_uint;
extern "C" {
    #[doc = " Early deinitialization"]
    pub fn furi_hal_clock_deinit_early();
}
extern "C" {
    #[doc = " Enable clock output on MCO pin"]
    #[doc = ""]
    #[doc = " @param      source  MCO clock source"]
    #[doc = " @param      div     MCO clock division"]
    pub fn furi_hal_clock_mco_enable(
        source: FuriHalClockMcoSourceId,
        div: FuriHalClockMcoDivisorId,
    );
}
extern "C" {
    #[doc = " Disable clock output on MCO pin"]
    pub fn furi_hal_clock_mco_disable();
}
pub type FuriHalConsoleTxCallback = ::core::option::Option<
    unsafe extern "C" fn(buffer: *const u8, size: usize, context: *mut core::ffi::c_void),
>;
extern "C" {
    pub fn furi_hal_console_init();
}
extern "C" {
    pub fn furi_hal_console_enable();
}
extern "C" {
    pub fn furi_hal_console_disable();
}
extern "C" {
    pub fn furi_hal_console_set_tx_callback(
        callback: FuriHalConsoleTxCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_console_tx(buffer: *const u8, buffer_size: usize);
}
extern "C" {
    pub fn furi_hal_console_tx_with_new_line(buffer: *const u8, buffer_size: usize);
}
extern "C" {
    #[doc = " Printf-like plain uart interface"]
    #[doc = " @warning Will not work in ISR context"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    pub fn furi_hal_console_printf(format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn furi_hal_console_puts(data: *const core::ffi::c_char);
}
#[doc = " @defgroup I2C_LL_ES_INIT I2C Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_I2C_InitTypeDef {
    #[doc = "< Specifies the peripheral mode."]
    #[doc = "This parameter can be a value of @ref I2C_LL_EC_PERIPHERAL_MODE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_I2C_SetMode()."]
    pub PeripheralMode: u32,
    #[doc = "< Specifies the SDA setup, hold time and the SCL high, low period values."]
    #[doc = "This parameter must be set by referring to the STM32CubeMX Tool and"]
    #[doc = "the helper macro @ref __LL_I2C_CONVERT_TIMINGS()."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_I2C_SetTiming()."]
    pub Timing: u32,
    #[doc = "< Enables or disables analog noise filter."]
    #[doc = "This parameter can be a value of @ref I2C_LL_EC_ANALOGFILTER_SELECTION."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary functions"]
    #[doc = "@ref LL_I2C_EnableAnalogFilter() or LL_I2C_DisableAnalogFilter()."]
    pub AnalogFilter: u32,
    #[doc = "< Configures the digital noise filter."]
    #[doc = "This parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_I2C_SetDigitalFilter()."]
    pub DigitalFilter: u32,
    #[doc = "< Specifies the device own address 1."]
    #[doc = "This parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_I2C_SetOwnAddress1()."]
    pub OwnAddress1: u32,
    #[doc = "< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive"]
    #[doc = "match code or next received byte."]
    #[doc = "This parameter can be a value of @ref I2C_LL_EC_I2C_ACKNOWLEDGE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_I2C_AcknowledgeNextData()."]
    pub TypeAcknowledge: u32,
    #[doc = "< Specifies the device own address 1 size (7-bit or 10-bit)."]
    #[doc = "This parameter can be a value of @ref I2C_LL_EC_OWNADDRESS1."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_I2C_SetOwnAddress1()."]
    pub OwnAddrSize: u32,
}
#[test]
fn bindgen_test_layout_LL_I2C_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_I2C_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_I2C_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(LL_I2C_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_I2C_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_I2C_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeripheralMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(PeripheralMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(Timing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AnalogFilter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(AnalogFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DigitalFilter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(DigitalFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddress1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TypeAcknowledge) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(TypeAcknowledge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddrSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(OwnAddrSize)
        )
    );
}
extern "C" {
    #[doc = " @defgroup I2C_LL_EF_Init Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn LL_I2C_Init(
        I2Cx: *mut I2C_TypeDef,
        I2C_InitStruct: *mut LL_I2C_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "< Bus initialization event, called on system start"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventInit: FuriHalI2cBusEvent = 0;
#[doc = "< Bus deinitialization event, called on system stop"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventDeinit: FuriHalI2cBusEvent = 1;
#[doc = "< Bus lock event, called before activation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventLock: FuriHalI2cBusEvent = 2;
#[doc = "< Bus unlock event, called after deactivation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventUnlock: FuriHalI2cBusEvent = 3;
#[doc = "< Bus activation event, called before handle activation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventActivate: FuriHalI2cBusEvent = 4;
#[doc = "< Bus deactivation event, called after handle deactivation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventDeactivate: FuriHalI2cBusEvent = 5;
#[doc = " FuriHal i2c bus states"]
pub type FuriHalI2cBusEvent = core::ffi::c_uchar;
#[doc = " FuriHal i2c bus event callback"]
pub type FuriHalI2cBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalI2cBus, event: FuriHalI2cBusEvent),
>;
#[doc = " FuriHal i2c bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBus {
    pub i2c: *mut I2C_TypeDef,
    pub current_handle: *mut FuriHalI2cBusHandle,
    pub callback: FuriHalI2cBusEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBus() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalI2cBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalI2cBus>(),
        24usize,
        concat!("Size of: ", stringify!(FuriHalI2cBus))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalI2cBus>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalI2cBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(i2c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(current_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = "< Handle activate: connect gpio and apply bus config"]
pub const FuriHalI2cBusHandleEvent_FuriHalI2cBusHandleEventActivate: FuriHalI2cBusHandleEvent = 0;
#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
pub const FuriHalI2cBusHandleEvent_FuriHalI2cBusHandleEventDeactivate: FuriHalI2cBusHandleEvent = 1;
#[doc = " FuriHal i2c handle states"]
pub type FuriHalI2cBusHandleEvent = core::ffi::c_uchar;
#[doc = " FuriHal i2c handle event callback"]
pub type FuriHalI2cBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalI2cBusHandle, event: FuriHalI2cBusHandleEvent),
>;
#[doc = " FuriHal i2c handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBusHandle {
    pub bus: *mut FuriHalI2cBus,
    pub callback: FuriHalI2cBusHandleEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBusHandle() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalI2cBusHandle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalI2cBusHandle>(),
        16usize,
        concat!("Size of: ", stringify!(FuriHalI2cBusHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalI2cBusHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalI2cBusHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBusHandle),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBusHandle),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    #[doc = " Internal(power) i2c bus, I2C1, under reset when not used"]
    pub static mut furi_hal_i2c_bus_power: FuriHalI2cBus;
}
extern "C" {
    #[doc = " External i2c bus, I2C3, under reset when not used"]
    pub static mut furi_hal_i2c_bus_external: FuriHalI2cBus;
}
extern "C" {
    #[doc = " Handle for internal(power) i2c bus"]
    #[doc = " Bus: furi_hal_i2c_bus_external"]
    #[doc = " Pins: PA9(SCL) / PA10(SDA), float on release"]
    #[doc = " Params: 400khz"]
    pub static mut furi_hal_i2c_handle_power: FuriHalI2cBusHandle;
}
extern "C" {
    #[doc = " Handle for external i2c bus"]
    #[doc = " Bus: furi_hal_i2c_bus_external"]
    #[doc = " Pins: PC0(SCL) / PC1(SDA), float on release"]
    #[doc = " Params: 100khz"]
    pub static mut furi_hal_i2c_handle_external: FuriHalI2cBusHandle;
}
#[doc = " @brief  LPTIM Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPTIM_InitTypeDef {
    #[doc = "< Specifies the source of the clock used by the LPTIM instance."]
    #[doc = "This parameter can be a value of @ref LPTIM_LL_EC_CLK_SOURCE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPTIM_SetClockSource()."]
    pub ClockSource: u32,
    #[doc = "< Specifies the prescaler division ratio."]
    #[doc = "This parameter can be a value of @ref LPTIM_LL_EC_PRESCALER."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using using unitary"]
    #[doc = "function @ref LL_LPTIM_SetPrescaler()."]
    pub Prescaler: u32,
    #[doc = "< Specifies the waveform shape."]
    #[doc = "This parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_WAVEFORM."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPTIM_ConfigOutput()."]
    pub Waveform: u32,
    #[doc = "< Specifies waveform polarity."]
    #[doc = "This parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_POLARITY."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPTIM_ConfigOutput()."]
    pub Polarity: u32,
}
#[test]
fn bindgen_test_layout_LL_LPTIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_LPTIM_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_LPTIM_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(LL_LPTIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_LPTIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_LPTIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockSource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(ClockSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Waveform) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Waveform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Polarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Polarity)
        )
    );
}
extern "C" {
    #[doc = " @defgroup LPTIM_LL_EF_Init Initialisation and deinitialisation functions"]
    #[doc = " @{"]
    pub fn LL_LPTIM_DeInit(LPTIMx: *mut LPTIM_TypeDef) -> ErrorStatus;
}
extern "C" {
    pub fn LL_LPTIM_Init(
        LPTIMx: *mut LPTIM_TypeDef,
        LPTIM_InitStruct: *mut LL_LPTIM_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " @brief  TIM Time Base configuration structure definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_InitTypeDef {
    #[doc = "< Specifies the prescaler value used to divide the TIM clock."]
    #[doc = "This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_SetPrescaler()."]
    pub Prescaler: u16,
    #[doc = "< Specifies the counter mode."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_COUNTERMODE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_SetCounterMode()."]
    pub CounterMode: u32,
    #[doc = "< Specifies the auto reload value to be loaded into the active"]
    #[doc = "Auto-Reload Register at the next update event."]
    #[doc = "This parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
    #[doc = "Some timer instances may support 32 bits counters. In that case this parameter must"]
    #[doc = "be a number between 0x0000 and 0xFFFFFFFF."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_SetAutoReload()."]
    pub Autoreload: u32,
    #[doc = "< Specifies the clock division."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_CLOCKDIVISION."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_SetClockDivision()."]
    pub ClockDivision: u32,
    #[doc = "< Specifies the repetition counter value. Each time the RCR downcounter"]
    #[doc = "reaches zero, an update event is generated and counting restarts"]
    #[doc = "from the RCR value (N)."]
    #[doc = "This means in PWM mode that (N+1) corresponds to:"]
    #[doc = "- the number of PWM periods in edge-aligned mode"]
    #[doc = "- the number of half PWM period in center-aligned mode"]
    #[doc = "GP timers: this parameter must be a number between Min_Data = 0x00 and"]
    #[doc = "Max_Data = 0xFF."]
    #[doc = "Advanced timers: this parameter must be a number between Min_Data = 0x0000 and"]
    #[doc = "Max_Data = 0xFFFF."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_SetRepetitionCounter()."]
    pub RepetitionCounter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_TIM_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_TIM_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(LL_TIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_TIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_TIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CounterMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(CounterMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Autoreload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(Autoreload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockDivision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(ClockDivision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RepetitionCounter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(RepetitionCounter)
        )
    );
}
#[doc = " @brief  TIM Output Compare configuration structure definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_OC_InitTypeDef {
    #[doc = "< Specifies the output mode."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCMODE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_OC_SetMode()."]
    pub OCMode: u32,
    #[doc = "< Specifies the TIM Output Compare state."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCSTATE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary functions"]
    #[doc = "@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
    pub OCState: u32,
    #[doc = "< Specifies the TIM complementary Output Compare state."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCSTATE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary functions"]
    #[doc = "@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
    pub OCNState: u32,
    #[doc = "< Specifies the Compare value to be loaded into the Capture Compare Register."]
    #[doc = "This parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "LL_TIM_OC_SetCompareCHx (x=1..6)."]
    pub CompareValue: u32,
    #[doc = "< Specifies the output polarity."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_OC_SetPolarity()."]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCPOLARITY."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_OC_SetPolarity()."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_OC_SetIdleState()."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state."]
    #[doc = "This parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_TIM_OC_SetIdleState()."]
    pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_OC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_TIM_OC_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_TIM_OC_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LL_TIM_OC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_TIM_OC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_TIM_OC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompareValue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(CompareValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
}
extern "C" {
    #[doc = " @defgroup TIM_LL_EF_Init Initialisation and deinitialisation functions"]
    #[doc = " @{"]
    pub fn LL_TIM_DeInit(TIMx: *mut TIM_TypeDef) -> ErrorStatus;
}
extern "C" {
    pub fn LL_TIM_Init(
        TIMx: *mut TIM_TypeDef,
        TIM_InitStruct: *mut LL_TIM_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_TIM_OC_Init(
        TIMx: *mut TIM_TypeDef,
        Channel: u32,
        TIM_OC_InitStruct: *mut LL_TIM_OC_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " Timer ISR"]
pub type FuriHalInterruptISR =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1TrgComTim17: FuriHalInterruptId = 0;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1Cc: FuriHalInterruptId = 1;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1UpTim16: FuriHalInterruptId = 2;
pub const FuriHalInterruptId_FuriHalInterruptIdTIM2: FuriHalInterruptId = 3;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch1: FuriHalInterruptId = 4;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch2: FuriHalInterruptId = 5;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch3: FuriHalInterruptId = 6;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch4: FuriHalInterruptId = 7;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch5: FuriHalInterruptId = 8;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch6: FuriHalInterruptId = 9;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch7: FuriHalInterruptId = 10;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch1: FuriHalInterruptId = 11;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch2: FuriHalInterruptId = 12;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch3: FuriHalInterruptId = 13;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch4: FuriHalInterruptId = 14;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch5: FuriHalInterruptId = 15;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch6: FuriHalInterruptId = 16;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch7: FuriHalInterruptId = 17;
pub const FuriHalInterruptId_FuriHalInterruptIdRcc: FuriHalInterruptId = 18;
pub const FuriHalInterruptId_FuriHalInterruptIdCOMP: FuriHalInterruptId = 19;
pub const FuriHalInterruptId_FuriHalInterruptIdHsem: FuriHalInterruptId = 20;
pub const FuriHalInterruptId_FuriHalInterruptIdLpTim1: FuriHalInterruptId = 21;
pub const FuriHalInterruptId_FuriHalInterruptIdLpTim2: FuriHalInterruptId = 22;
pub const FuriHalInterruptId_FuriHalInterruptIdMax: FuriHalInterruptId = 23;
pub type FuriHalInterruptId = core::ffi::c_uchar;
extern "C" {
    #[doc = " Set ISR and enable interrupt with default priority"]
    #[doc = " We don't clear interrupt flags for you, do it by your self."]
    #[doc = " @param index - interrupt ID"]
    #[doc = " @param isr - your interrupt service routine or use NULL to clear"]
    #[doc = " @param context - isr context"]
    pub fn furi_hal_interrupt_set_isr(
        index: FuriHalInterruptId,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set ISR and enable interrupt with custom priority"]
    #[doc = " We don't clear interrupt flags for you, do it by your self."]
    #[doc = " @param index - interrupt ID"]
    #[doc = " @param priority - 0 to 15, 0 highest"]
    #[doc = " @param isr - your interrupt service routine or use NULL to clear"]
    #[doc = " @param context - isr context"]
    pub fn furi_hal_interrupt_set_isr_ex(
        index: FuriHalInterruptId,
        priority: u16,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_os_tick();
}
pub const FuriHalPwmOutputId_FuriHalPwmOutputIdTim1PA7: FuriHalPwmOutputId = 0;
pub const FuriHalPwmOutputId_FuriHalPwmOutputIdLptim2PA4: FuriHalPwmOutputId = 1;
pub type FuriHalPwmOutputId = core::ffi::c_uchar;
extern "C" {
    #[doc = " Enable PWM channel and set parameters"]
    #[doc = ""]
    #[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
    #[doc = " @param[in]  freq  Frequency in Hz"]
    #[doc = " @param[in]  duty  Duty cycle value in %"]
    pub fn furi_hal_pwm_start(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
extern "C" {
    #[doc = " Disable PWM channel"]
    #[doc = ""]
    #[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
    pub fn furi_hal_pwm_stop(channel: FuriHalPwmOutputId);
}
extern "C" {
    #[doc = " Set PWM channel parameters"]
    #[doc = ""]
    #[doc = " @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
    #[doc = " @param[in]  freq  Frequency in Hz"]
    #[doc = " @param[in]  duty  Duty cycle value in %"]
    pub fn furi_hal_pwm_set_params(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
#[doc = " @brief  SPI Init structures definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_SPI_InitTypeDef {
    #[doc = "< Specifies the SPI unidirectional or bidirectional data mode."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_TRANSFER_MODE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies the SPI mode (Master/Slave)."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_MODE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetMode()."]
    pub Mode: u32,
    #[doc = "< Specifies the SPI data width."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_DATAWIDTH."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the serial clock steady state."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_POLARITY."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPolarity()."]
    pub ClockPolarity: u32,
    #[doc = "< Specifies the clock active edge for the bit capture."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_PHASE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPhase()."]
    pub ClockPhase: u32,
    #[doc = "< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_NSS_MODE."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetNSSMode()."]
    pub NSS: u32,
    #[doc = "< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_BAUDRATEPRESCALER."]
    #[doc = "@note The communication clock is derived from the master clock. The slave clock does not need to be set."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetBaudRatePrescaler()."]
    pub BaudRate: u32,
    #[doc = "< Specifies whether data transfers start from MSB or LSB bit."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_BIT_ORDER."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferBitOrder()."]
    pub BitOrder: u32,
    #[doc = "< Specifies if the CRC calculation is enabled or not."]
    #[doc = "This parameter can be a value of @ref SPI_LL_EC_CRC_CALCULATION."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary functions @ref LL_SPI_EnableCRC() and @ref LL_SPI_DisableCRC()."]
    pub CRCCalculation: u32,
    #[doc = "< Specifies the polynomial used for the CRC calculation."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_SPI_SetCRCPolynomial()."]
    pub CRCPoly: u32,
}
#[test]
fn bindgen_test_layout_LL_SPI_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_SPI_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_SPI_InitTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(LL_SPI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_SPI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_SPI_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(ClockPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(ClockPhase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NSS) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(NSS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BitOrder) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(BitOrder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCCalculation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(CRCCalculation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCPoly) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(CRCPoly)
        )
    );
}
extern "C" {
    pub fn LL_SPI_Init(
        SPIx: *mut SPI_TypeDef,
        SPI_InitStruct: *mut LL_SPI_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "< Bus initialization event, called on system start"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventInit: FuriHalSpiBusEvent = 0;
#[doc = "< Bus deinitialization event, called on system stop"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventDeinit: FuriHalSpiBusEvent = 1;
#[doc = "< Bus lock event, called before activation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventLock: FuriHalSpiBusEvent = 2;
#[doc = "< Bus unlock event, called after deactivation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventUnlock: FuriHalSpiBusEvent = 3;
#[doc = "< Bus activation event, called before handle activation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventActivate: FuriHalSpiBusEvent = 4;
#[doc = "< Bus deactivation event, called after handle deactivation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventDeactivate: FuriHalSpiBusEvent = 5;
#[doc = " FuriHal spi bus states"]
pub type FuriHalSpiBusEvent = core::ffi::c_uchar;
#[doc = " FuriHal spi bus event callback"]
pub type FuriHalSpiBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalSpiBus, event: FuriHalSpiBusEvent),
>;
#[doc = " FuriHal spi bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBus {
    pub spi: *mut SPI_TypeDef,
    pub callback: FuriHalSpiBusEventCallback,
    pub current_handle: *mut FuriHalSpiBusHandle,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBus() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSpiBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSpiBus>(),
        24usize,
        concat!("Size of: ", stringify!(FuriHalSpiBus))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSpiBus>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalSpiBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(current_handle)
        )
    );
}
#[doc = "< Handle init, called on system start, initialize gpio for idle state"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventInit: FuriHalSpiBusHandleEvent = 0;
#[doc = "< Handle deinit, called on system stop, deinitialize gpio for default state"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventDeinit: FuriHalSpiBusHandleEvent = 1;
#[doc = "< Handle activate: connect gpio and apply bus config"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventActivate: FuriHalSpiBusHandleEvent = 2;
#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventDeactivate: FuriHalSpiBusHandleEvent = 3;
#[doc = " FuriHal spi handle states"]
pub type FuriHalSpiBusHandleEvent = core::ffi::c_uchar;
#[doc = " FuriHal spi handle event callback"]
pub type FuriHalSpiBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalSpiBusHandle, event: FuriHalSpiBusHandleEvent),
>;
#[doc = " FuriHal spi handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBusHandle {
    pub bus: *mut FuriHalSpiBus,
    pub callback: FuriHalSpiBusHandleEventCallback,
    pub miso: *const GpioPin,
    pub mosi: *const GpioPin,
    pub sck: *const GpioPin,
    pub cs: *const GpioPin,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBusHandle() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSpiBusHandle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSpiBusHandle>(),
        48usize,
        concat!("Size of: ", stringify!(FuriHalSpiBusHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSpiBusHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalSpiBusHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miso) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(miso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mosi) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(mosi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sck) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(sck)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(cs)
        )
    );
}
extern "C" {
    #[doc = " Preset for ST25R916"]
    pub static furi_hal_spi_preset_2edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for CC1101"]
    pub static furi_hal_spi_preset_1edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for ST7567 (Display)"]
    pub static furi_hal_spi_preset_1edge_low_4m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for SdCard in fast mode"]
    pub static furi_hal_spi_preset_1edge_low_16m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for SdCard in slow mode"]
    pub static furi_hal_spi_preset_1edge_low_2m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Furi Hal Spi Bus R (Radio: CC1101, Nfc, External)"]
    pub static mut furi_hal_spi_bus_r: FuriHalSpiBus;
}
extern "C" {
    #[doc = " Furi Hal Spi Bus D (Display, SdCard)"]
    pub static mut furi_hal_spi_bus_d: FuriHalSpiBus;
}
extern "C" {
    #[doc = " CC1101 on `furi_hal_spi_bus_r`"]
    pub static mut furi_hal_spi_bus_handle_subghz: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " ST25R3916 on `furi_hal_spi_bus_r`"]
    pub static mut furi_hal_spi_bus_handle_nfc: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " External on `furi_hal_spi_bus_r`"]
    #[doc = " Preset: `furi_hal_spi_preset_1edge_low_2m`"]
    #[doc = ""]
    #[doc = " miso: pa6"]
    #[doc = " mosi: pa7"]
    #[doc = " sck: pb3"]
    #[doc = " cs:  pa4 (software controlled)"]
    #[doc = ""]
    #[doc = " @warning not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize"]
    #[doc = " Bus pins are floating on inactive state, CS high after initialization"]
    #[doc = ""]
    pub static mut furi_hal_spi_bus_handle_external: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " ST7567(Display) on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_display: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " SdCard in fast mode on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_sd_fast: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " SdCard in slow mode on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_sd_slow: FuriHalSpiBusHandle;
}
pub const CC1101State_CC1101StateIDLE: CC1101State = 0;
#[doc = " IDLE state"]
pub const CC1101State_CC1101StateRX: CC1101State = 1;
#[doc = " Receive mode"]
pub const CC1101State_CC1101StateTX: CC1101State = 2;
#[doc = " Transmit mode"]
pub const CC1101State_CC1101StateFSTXON: CC1101State = 3;
#[doc = " Fast TX ready"]
pub const CC1101State_CC1101StateCALIBRATE: CC1101State = 4;
#[doc = " Frequency synthesizer calibration is running"]
pub const CC1101State_CC1101StateSETTLING: CC1101State = 5;
#[doc = " PLL is settling"]
pub const CC1101State_CC1101StateRXFIFO_OVERFLOW: CC1101State = 6;
#[doc = " RX FIFO has overflowed. Read out any useful data, then flush the FIFO with SFRX"]
pub const CC1101State_CC1101StateTXFIFO_UNDERFLOW: CC1101State = 7;
pub type CC1101State = core::ffi::c_uchar;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CC1101Status {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_CC1101Status() {
    assert_eq!(
        ::core::mem::size_of::<CC1101Status>(),
        1usize,
        concat!("Size of: ", stringify!(CC1101Status))
    );
    assert_eq!(
        ::core::mem::align_of::<CC1101Status>(),
        1usize,
        concat!("Alignment of ", stringify!(CC1101Status))
    );
}
impl CC1101Status {
    #[inline]
    pub fn FIFO_BYTES_AVAILABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_FIFO_BYTES_AVAILABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn STATE(&self) -> CC1101State {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_STATE(&mut self, val: CC1101State) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn CHIP_RDYn(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CHIP_RDYn(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FIFO_BYTES_AVAILABLE: u8,
        STATE: CC1101State,
        CHIP_RDYn: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FIFO_BYTES_AVAILABLE: u8 = unsafe { ::core::mem::transmute(FIFO_BYTES_AVAILABLE) };
            FIFO_BYTES_AVAILABLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let STATE: u8 = unsafe { ::core::mem::transmute(STATE) };
            STATE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CHIP_RDYn: u8 = unsafe { ::core::mem::transmute(CHIP_RDYn) };
            CHIP_RDYn as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Early initialize SPI HAL"]
    pub fn furi_hal_spi_init_early();
}
extern "C" {
    #[doc = " Early deinitialize SPI HAL"]
    pub fn furi_hal_spi_deinit_early();
}
extern "C" {
    #[doc = " Initialize SPI Bus"]
    #[doc = ""]
    #[doc = " @param      handle  pointer to FuriHalSpiBus instance"]
    pub fn furi_hal_spi_bus_init(bus: *mut FuriHalSpiBus);
}
extern "C" {
    #[doc = " Deinitialize SPI Bus"]
    #[doc = ""]
    #[doc = " @param      handle  pointer to FuriHalSpiBus instance"]
    pub fn furi_hal_spi_bus_deinit(bus: *mut FuriHalSpiBus);
}
extern "C" {
    #[doc = " Initialize SPI Bus Handle"]
    #[doc = ""]
    #[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_bus_handle_init(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Deinitialize SPI Bus Handle"]
    #[doc = ""]
    #[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_bus_handle_deinit(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Acquire SPI bus"]
    #[doc = ""]
    #[doc = " @warning blocking, calls `furi_crash` on programming error, CS transition is up to handler event routine"]
    #[doc = ""]
    #[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_acquire(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Release SPI bus"]
    #[doc = ""]
    #[doc = " @warning calls `furi_crash` on programming error, CS transition is up to handler event routine"]
    #[doc = ""]
    #[doc = " @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_release(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " SPI Receive"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalSpiBusHandle instance"]
    #[doc = " @param      buffer   receive buffer"]
    #[doc = " @param      size     transaction size (buffer size)"]
    #[doc = " @param      timeout  operation timeout in ms"]
    #[doc = ""]
    #[doc = " @return     true on sucess"]
    pub fn furi_hal_spi_bus_rx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " SPI Transmit"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalSpiBusHandle instance"]
    #[doc = " @param      buffer   transmit buffer"]
    #[doc = " @param      size     transaction size (buffer size)"]
    #[doc = " @param      timeout  operation timeout in ms"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_spi_bus_tx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " SPI Transmit and Receive"]
    #[doc = ""]
    #[doc = " @param      handle     pointer to FuriHalSpiBusHandle instance"]
    #[doc = " @param      tx_buffer  pointer to tx buffer"]
    #[doc = " @param      rx_buffer  pointer to rx buffer"]
    #[doc = " @param      size       transaction size (buffer size)"]
    #[doc = " @param      timeout    operation timeout in ms"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_spi_bus_trx(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *mut u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Strobe command to the device"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      strobe  - command to execute"]
    #[doc = ""]
    #[doc = " @return     device status"]
    pub fn cc1101_strobe(handle: *mut FuriHalSpiBusHandle, strobe: u8) -> CC1101Status;
}
extern "C" {
    #[doc = " Write device register"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      reg     - register"]
    #[doc = " @param      data    - data to write"]
    #[doc = ""]
    #[doc = " @return     device status"]
    pub fn cc1101_write_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, data: u8) -> CC1101Status;
}
extern "C" {
    #[doc = " Read device register"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      reg     - register"]
    #[doc = " @param[out] data    - pointer to data"]
    #[doc = ""]
    #[doc = " @return     device status"]
    pub fn cc1101_read_reg(
        handle: *mut FuriHalSpiBusHandle,
        reg: u8,
        data: *mut u8,
    ) -> CC1101Status;
}
extern "C" {
    #[doc = " Reset"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_reset(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Get status"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = ""]
    #[doc = " @return     CC1101Status structure"]
    pub fn cc1101_get_status(handle: *mut FuriHalSpiBusHandle) -> CC1101Status;
}
extern "C" {
    #[doc = " Enable shutdown mode"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_shutdown(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Get raw RSSI value"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = ""]
    #[doc = " @return     rssi value"]
    pub fn cc1101_get_rssi(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
    #[doc = " Calibrate oscillator"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_calibrate(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Switch to idle"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_switch_to_idle(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Switch to RX"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_switch_to_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Switch to TX"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_switch_to_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Flush RX FIFO"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_flush_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Flush TX FIFO"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_flush_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Set Frequency"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      value   - frequency in herz"]
    #[doc = ""]
    #[doc = " @return     real frequency that were synthesized"]
    pub fn cc1101_set_frequency(handle: *mut FuriHalSpiBusHandle, value: u32) -> u32;
}
extern "C" {
    #[doc = " Set Power Amplifier level table, ramp"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      value   - array of power level values"]
    pub fn cc1101_set_pa_table(handle: *mut FuriHalSpiBusHandle, value: *const u8);
}
extern "C" {
    #[doc = " Write FIFO"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      data    pointer to byte array"]
    #[doc = " @param      size    write bytes count"]
    #[doc = ""]
    #[doc = " @return     size, written bytes count"]
    pub fn cc1101_write_fifo(handle: *mut FuriHalSpiBusHandle, data: *const u8, size: u8) -> u8;
}
extern "C" {
    #[doc = " Read FIFO"]
    #[doc = ""]
    #[doc = " @param      handle  - pointer to FuriHalSpiHandle"]
    #[doc = " @param      data    pointer to byte array"]
    #[doc = " @param      size    bytes to read from fifo"]
    #[doc = ""]
    #[doc = " @return     size, read bytes count"]
    pub fn cc1101_read_fifo(handle: *mut FuriHalSpiBusHandle, data: *mut u8, size: *mut u8) -> u8;
}
pub const FuriHalUartId_FuriHalUartIdUSART1: FuriHalUartId = 0;
pub const FuriHalUartId_FuriHalUartIdLPUART1: FuriHalUartId = 1;
#[doc = " UART channels"]
pub type FuriHalUartId = core::ffi::c_uchar;
pub const UartIrqEvent_UartIrqEventRXNE: UartIrqEvent = 0;
#[doc = " UART events"]
pub type UartIrqEvent = core::ffi::c_uchar;
extern "C" {
    #[doc = " Init UART"]
    #[doc = " Configures GPIO to UART function, onfigures UART hardware, enables UART hardware"]
    #[doc = " @param channel UART channel"]
    #[doc = " @param baud baudrate"]
    pub fn furi_hal_uart_init(channel: FuriHalUartId, baud: u32);
}
extern "C" {
    #[doc = " Deinit UART"]
    #[doc = " Configures GPIO to analog, clears callback and callback context, disables UART hardware"]
    #[doc = " @param channel UART channel"]
    pub fn furi_hal_uart_deinit(channel: FuriHalUartId);
}
extern "C" {
    #[doc = " Suspend UART operation"]
    #[doc = " Disables UART hardware, settings and callbacks are preserved"]
    #[doc = " @param channel UART channel"]
    pub fn furi_hal_uart_suspend(channel: FuriHalUartId);
}
extern "C" {
    #[doc = " Resume UART operation"]
    #[doc = " Resumes UART hardware from suspended state"]
    #[doc = " @param channel UART channel"]
    pub fn furi_hal_uart_resume(channel: FuriHalUartId);
}
extern "C" {
    #[doc = " Changes UART baudrate"]
    #[doc = " @param channel UART channel"]
    #[doc = " @param baud baudrate"]
    pub fn furi_hal_uart_set_br(channel: FuriHalUartId, baud: u32);
}
extern "C" {
    #[doc = " Transmits data"]
    #[doc = " @param channel UART channel"]
    #[doc = " @param buffer data"]
    #[doc = " @param buffer_size data size (in bytes)"]
    pub fn furi_hal_uart_tx(channel: FuriHalUartId, buffer: *mut u8, buffer_size: usize);
}
extern "C" {
    #[doc = " Sets UART event callback"]
    #[doc = " @param channel UART channel"]
    #[doc = " @param callback callback pointer"]
    #[doc = " @param context callback context"]
    pub fn furi_hal_uart_set_irq_cb(
        channel: FuriHalUartId,
        callback: ::core::option::Option<
            unsafe extern "C" fn(event: UartIrqEvent, data: u8, context: *mut core::ffi::c_void),
        >,
        context: *mut core::ffi::c_void,
    );
}
#[doc = "\\brief Line Coding Structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_line_coding {
    #[doc = "<\\brief Data terminal rate, in bits per second."]
    pub dwDTERate: u32,
    #[doc = "<\\brief Stop bits."]
    pub bCharFormat: u8,
    #[doc = "<\\brief Parity."]
    pub bParityType: u8,
    #[doc = "<\\brief Data bits (5,6,7,8 or 16)."]
    pub bDataBits: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_line_coding() {
    const UNINIT: ::core::mem::MaybeUninit<usb_cdc_line_coding> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_line_coding>(),
        7usize,
        concat!("Size of: ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_line_coding>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwDTERate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(dwDTERate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bCharFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bCharFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bParityType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bParityType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDataBits) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bDataBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CdcCallbacks {
    pub tx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub rx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub state_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub ctrl_line_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub config_callback: ::core::option::Option<
        unsafe extern "C" fn(context: *mut core::ffi::c_void, config: *mut usb_cdc_line_coding),
    >,
}
#[test]
fn bindgen_test_layout_CdcCallbacks() {
    const UNINIT: ::core::mem::MaybeUninit<CdcCallbacks> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CdcCallbacks>(),
        40usize,
        concat!("Size of: ", stringify!(CdcCallbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<CdcCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(CdcCallbacks))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_ep_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(tx_ep_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ep_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(rx_ep_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(state_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl_line_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(ctrl_line_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(config_callback)
        )
    );
}
extern "C" {
    pub fn furi_hal_cdc_set_callbacks(
        if_num: u8,
        cb: *mut CdcCallbacks,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_cdc_get_port_settings(if_num: u8) -> *mut usb_cdc_line_coding;
}
extern "C" {
    pub fn furi_hal_cdc_get_ctrl_line_state(if_num: u8) -> u8;
}
extern "C" {
    pub fn furi_hal_cdc_send(if_num: u8, buf: *mut u8, len: u16);
}
extern "C" {
    pub fn furi_hal_cdc_receive(if_num: u8, buf: *mut u8, max_len: u16) -> i32;
}
extern "C" {
    pub fn __errno() -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn __clear_cache(arg1: *mut core::ffi::c_void, arg2: *mut core::ffi::c_void);
}
#[doc = " Cortex timer provides high precision low level expiring timer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCortexTimer {
    pub start: u32,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_FuriHalCortexTimer() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalCortexTimer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalCortexTimer>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalCortexTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalCortexTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalCortexTimer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCortexTimer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCortexTimer),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Microseconds delay"]
    #[doc = ""]
    #[doc = " @param[in]  microseconds  The microseconds to wait"]
    pub fn furi_hal_cortex_delay_us(microseconds: u32);
}
extern "C" {
    #[doc = " Get instructions per microsecond count"]
    #[doc = ""]
    #[doc = " @return     instructions per microsecond count"]
    pub fn furi_hal_cortex_instructions_per_microsecond() -> u32;
}
extern "C" {
    #[doc = " Get Timer"]
    #[doc = ""]
    #[doc = " @param[in]  timeout_us  The expire timeout in us"]
    #[doc = ""]
    #[doc = " @return     The FuriHalCortexTimer"]
    pub fn furi_hal_cortex_timer_get(timeout_us: u32) -> FuriHalCortexTimer;
}
extern "C" {
    #[doc = " Check if timer expired"]
    #[doc = ""]
    #[doc = " @param[in]  cortex_timer  The FuriHalCortexTimer"]
    #[doc = ""]
    #[doc = " @return     true if expired"]
    pub fn furi_hal_cortex_timer_is_expired(cortex_timer: FuriHalCortexTimer) -> bool;
}
extern "C" {
    #[doc = " Wait for timer expire"]
    #[doc = ""]
    #[doc = " @param[in]  cortex_timer  The FuriHalCortexTimer"]
    pub fn furi_hal_cortex_timer_wait(cortex_timer: FuriHalCortexTimer);
}
#[doc = "< Master key"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeMaster: FuriHalCryptoKeyType = 0;
#[doc = "< Simple enencrypted key"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeSimple: FuriHalCryptoKeyType = 1;
#[doc = "< Encrypted with Master key"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeEncrypted: FuriHalCryptoKeyType = 2;
#[doc = " FuriHalCryptoKey Type"]
pub type FuriHalCryptoKeyType = core::ffi::c_uchar;
pub const FuriHalCryptoKeySize_FuriHalCryptoKeySize128: FuriHalCryptoKeySize = 0;
pub const FuriHalCryptoKeySize_FuriHalCryptoKeySize256: FuriHalCryptoKeySize = 1;
#[doc = " FuriHalCryptoKey Size in bits"]
pub type FuriHalCryptoKeySize = core::ffi::c_uchar;
#[doc = " FuriHalCryptoKey"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCryptoKey {
    pub type_: FuriHalCryptoKeyType,
    pub size: FuriHalCryptoKeySize,
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_FuriHalCryptoKey() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalCryptoKey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalCryptoKey>(),
        16usize,
        concat!("Size of: ", stringify!(FuriHalCryptoKey))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalCryptoKey>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalCryptoKey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn furi_hal_crypto_verify_enclave(keys_nb: *mut u8, valid_keys_nb: *mut u8) -> bool;
}
extern "C" {
    pub fn furi_hal_crypto_verify_key(key_slot: u8) -> bool;
}
extern "C" {
    #[doc = " Store key in crypto storage"]
    #[doc = ""]
    #[doc = " @param      key   FuriHalCryptoKey to store. Only Master, Simple or"]
    #[doc = "                   Encrypted"]
    #[doc = " @param      slot  pinter to int where store slot number will be saved"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_crypto_store_add_key(key: *mut FuriHalCryptoKey, slot: *mut u8) -> bool;
}
extern "C" {
    #[doc = " Init AES engine and load key from crypto store"]
    #[doc = ""]
    #[doc = " @param      slot  store slot number"]
    #[doc = " @param[in]  iv    pointer to 16 bytes Initialization Vector data"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_crypto_store_load_key(slot: u8, iv: *const u8) -> bool;
}
extern "C" {
    #[doc = " Unload key engine and deinit AES engine"]
    #[doc = ""]
    #[doc = " @param      slot  store slot number"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_crypto_store_unload_key(slot: u8) -> bool;
}
extern "C" {
    #[doc = " Encrypt data"]
    #[doc = ""]
    #[doc = " @param      input   pointer to input data"]
    #[doc = " @param      output  pointer to output data"]
    #[doc = " @param      size    input/output buffer size in bytes"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_crypto_encrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
    #[doc = " Decrypt data"]
    #[doc = ""]
    #[doc = " @param      input   pointer to input data"]
    #[doc = " @param      output  pointer to output data"]
    #[doc = " @param      size    input/output buffer size in bytes"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_crypto_decrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
    #[doc = " Enable MCU debug"]
    pub fn furi_hal_debug_enable();
}
extern "C" {
    #[doc = " Disable MCU debug"]
    pub fn furi_hal_debug_disable();
}
extern "C" {
    #[doc = " Init SD card detect"]
    pub fn hal_sd_detect_init();
}
extern "C" {
    #[doc = " Set SD card detect pin to low"]
    pub fn hal_sd_detect_set_low();
}
extern "C" {
    #[doc = " Get SD card status"]
    #[doc = ""]
    #[doc = " @return     true if SD card present, false if SD card not present"]
    pub fn hal_sd_detect() -> bool;
}
extern "C" {
    #[doc = " Pointer to currently used SPI Handle"]
    pub static mut furi_hal_sd_spi_handle: *mut FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " Early DeInit I2C"]
    pub fn furi_hal_i2c_deinit_early();
}
extern "C" {
    #[doc = " Acquire i2c bus handle"]
    #[doc = ""]
    #[doc = " @return     Instance of FuriHalI2cBus"]
    pub fn furi_hal_i2c_acquire(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
    #[doc = " Release i2c bus handle"]
    #[doc = ""]
    #[doc = " @param      bus   instance of FuriHalI2cBus aquired in `furi_hal_i2c_acquire`"]
    pub fn furi_hal_i2c_release(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
    #[doc = " Perform I2C tx transfer"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      address  I2C slave address"]
    #[doc = " @param      data     pointer to data buffer"]
    #[doc = " @param      size     size of data buffer"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_tx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *const u8,
        size: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C rx transfer"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      address  I2C slave address"]
    #[doc = " @param      data     pointer to data buffer"]
    #[doc = " @param      size     size of data buffer"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_rx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *mut u8,
        size: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C tx and rx transfers"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      address  I2C slave address"]
    #[doc = " @param      tx_data  pointer to tx data buffer"]
    #[doc = " @param      tx_size  size of tx data buffer"]
    #[doc = " @param      rx_data  pointer to rx data buffer"]
    #[doc = " @param      rx_size  size of rx data buffer"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_trx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        tx_data: *const u8,
        tx_size: u8,
        rx_data: *mut u8,
        rx_size: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if I2C device presents on bus"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true if device present and is ready, false otherwise"]
    pub fn furi_hal_i2c_is_device_ready(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register read (8-bit)"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      reg_addr register address"]
    #[doc = " @param      data     pointer to register value"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register read (16-bit)"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      reg_addr register address"]
    #[doc = " @param      data     pointer to register value"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u16,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device memory read"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      mem_addr memory start address"]
    #[doc = " @param      data     pointer to data buffer"]
    #[doc = " @param      len      size of data buffer"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *mut u8,
        len: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register write (8-bit)"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      reg_addr register address"]
    #[doc = " @param      data     register value"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register write (16-bit)"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      reg_addr register address"]
    #[doc = " @param      data     register value"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u16,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device memory"]
    #[doc = ""]
    #[doc = " @param      handle   pointer to FuriHalI2cBusHandle instance"]
    #[doc = " @param      i2c_addr I2C slave address"]
    #[doc = " @param      mem_addr memory start address"]
    #[doc = " @param      data     pointer to data buffer"]
    #[doc = " @param      len      size of data buffer"]
    #[doc = " @param      timeout  timeout in ticks"]
    #[doc = ""]
    #[doc = " @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *mut u8,
        len: u8,
        timeout: u32,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRegionBand {
    pub start: u32,
    pub end: u32,
    pub power_limit: i8,
    pub duty_cycle: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRegionBand() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRegionBand> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRegionBand>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalRegionBand))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRegionBand>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalRegionBand))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(power_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duty_cycle) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(duty_cycle)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct FuriHalRegion {
    pub country_code: [core::ffi::c_char; 4usize],
    pub bands_count: u16,
    pub bands: __IncompleteArrayField<FuriHalRegionBand>,
}
#[test]
fn bindgen_test_layout_FuriHalRegion() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRegion>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRegion>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(bands_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(bands)
        )
    );
}
extern "C" {
    #[doc = " Get Region Data."]
    #[doc = ""]
    #[doc = " Region data may be allocated in Flash or in RAM."]
    #[doc = " Keep in mind that we don't do memory management on our side."]
    #[doc = ""]
    #[doc = " @return     pointer to FuriHalRegion instance (in RAM or Flash, check before freeing on region update)"]
    pub fn furi_hal_region_get() -> *const FuriHalRegion;
}
extern "C" {
    #[doc = " Set device region data"]
    #[doc = ""]
    #[doc = " @param      region  pointer to the FuriHalRegion"]
    pub fn furi_hal_region_set(region: *mut FuriHalRegion);
}
extern "C" {
    #[doc = " Check if region data provisioned"]
    #[doc = ""]
    #[doc = " @return     true if provisioned, false otherwise"]
    pub fn furi_hal_region_is_provisioned() -> bool;
}
extern "C" {
    #[doc = " Get region name"]
    #[doc = ""]
    #[doc = " 2 letter Region code according to iso 3166 standard"]
    #[doc = " There are 2 extra values that we use in special cases:"]
    #[doc = " - \"00\" - developer edition, unlocked"]
    #[doc = " - \"WW\" - world wide, region provisioned by default"]
    #[doc = " - \"--\" - no provisioned region"]
    #[doc = ""]
    #[doc = " @return     Pointer to string"]
    pub fn furi_hal_region_get_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " heck if transmission is allowed on this frequency for your flipper region"]
    #[doc = ""]
    #[doc = " @param[in]  frequency  The frequency"]
    #[doc = " @param      value  frequency in Hz"]
    #[doc = ""]
    #[doc = " @return     true if allowed"]
    pub fn furi_hal_region_is_frequency_allowed(frequency: u32) -> bool;
}
extern "C" {
    #[doc = " Get band data for frequency"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]  frequency  The frequency"]
    #[doc = ""]
    #[doc = " @return     { description_of_the_return_value }"]
    pub fn furi_hal_region_get_band(frequency: u32) -> *const FuriHalRegionBand;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRtcDateTime {
    #[doc = "< Hour in 24H format: 0-23"]
    pub hour: u8,
    #[doc = "< Minute: 0-59"]
    pub minute: u8,
    #[doc = "< Second: 0-59"]
    pub second: u8,
    #[doc = "< Current day: 1-31"]
    pub day: u8,
    #[doc = "< Current month: 1-12"]
    pub month: u8,
    #[doc = "< Current year: 2000-2099"]
    pub year: u16,
    #[doc = "< Current weekday: 1-7"]
    pub weekday: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRtcDateTime() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRtcDateTime> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRtcDateTime>(),
        10usize,
        concat!("Size of: ", stringify!(FuriHalRtcDateTime))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRtcDateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(FuriHalRtcDateTime))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).weekday) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(weekday)
        )
    );
}
pub const FuriHalRtcFlag_FuriHalRtcFlagDebug: FuriHalRtcFlag = 1;
pub const FuriHalRtcFlag_FuriHalRtcFlagFactoryReset: FuriHalRtcFlag = 2;
pub const FuriHalRtcFlag_FuriHalRtcFlagLock: FuriHalRtcFlag = 4;
pub const FuriHalRtcFlag_FuriHalRtcFlagC2Update: FuriHalRtcFlag = 8;
pub type FuriHalRtcFlag = core::ffi::c_uchar;
#[doc = "< Normal boot mode, default value"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeNormal: FuriHalRtcBootMode = 0;
#[doc = "< Boot to DFU (MCU bootloader by ST)"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeDfu: FuriHalRtcBootMode = 1;
#[doc = "< Boot to Update, pre update"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModePreUpdate: FuriHalRtcBootMode = 2;
#[doc = "< Boot to Update, main"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeUpdate: FuriHalRtcBootMode = 3;
#[doc = "< Boot to Update, post update"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModePostUpdate: FuriHalRtcBootMode = 4;
pub type FuriHalRtcBootMode = core::ffi::c_uchar;
#[doc = "< Disable allocation tracking"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeNone: FuriHalRtcHeapTrackMode = 0;
#[doc = "< Enable allocation tracking for main application thread"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeMain: FuriHalRtcHeapTrackMode = 1;
#[doc = "< Enable allocation tracking for main and children application threads"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeTree: FuriHalRtcHeapTrackMode = 2;
#[doc = "< Enable allocation tracking for all threads"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeAll: FuriHalRtcHeapTrackMode = 3;
pub type FuriHalRtcHeapTrackMode = core::ffi::c_uchar;
#[doc = "< RTC structure header"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterHeader: FuriHalRtcRegister = 0;
#[doc = "< Various system bits"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterSystem: FuriHalRtcRegister = 1;
#[doc = "< Pointer to Version"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterVersion: FuriHalRtcRegister = 2;
#[doc = "< LFS geometry fingerprint"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterLfsFingerprint: FuriHalRtcRegister = 3;
#[doc = "< Pointer to last fault message"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterFaultData: FuriHalRtcRegister = 4;
#[doc = "< Failed pins count"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterPinFails: FuriHalRtcRegister = 5;
pub const FuriHalRtcRegister_FuriHalRtcRegisterUpdateFolderFSIndex: FuriHalRtcRegister = 6;
#[doc = "< Service value, do not use"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterMAX: FuriHalRtcRegister = 7;
pub type FuriHalRtcRegister = core::ffi::c_uchar;
extern "C" {
    #[doc = " Early deinitialization"]
    pub fn furi_hal_rtc_deinit_early();
}
extern "C" {
    pub fn furi_hal_rtc_get_register(reg: FuriHalRtcRegister) -> u32;
}
extern "C" {
    pub fn furi_hal_rtc_set_register(reg: FuriHalRtcRegister, value: u32);
}
extern "C" {
    pub fn furi_hal_rtc_set_log_level(level: u8);
}
extern "C" {
    pub fn furi_hal_rtc_get_log_level() -> u8;
}
extern "C" {
    pub fn furi_hal_rtc_set_flag(flag: FuriHalRtcFlag);
}
extern "C" {
    pub fn furi_hal_rtc_reset_flag(flag: FuriHalRtcFlag);
}
extern "C" {
    pub fn furi_hal_rtc_is_flag_set(flag: FuriHalRtcFlag) -> bool;
}
extern "C" {
    pub fn furi_hal_rtc_set_boot_mode(mode: FuriHalRtcBootMode);
}
extern "C" {
    pub fn furi_hal_rtc_get_boot_mode() -> FuriHalRtcBootMode;
}
extern "C" {
    pub fn furi_hal_rtc_set_heap_track_mode(mode: FuriHalRtcHeapTrackMode);
}
extern "C" {
    pub fn furi_hal_rtc_get_heap_track_mode() -> FuriHalRtcHeapTrackMode;
}
extern "C" {
    pub fn furi_hal_rtc_set_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
    pub fn furi_hal_rtc_get_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
    pub fn furi_hal_rtc_validate_datetime(datetime: *mut FuriHalRtcDateTime) -> bool;
}
extern "C" {
    pub fn furi_hal_rtc_set_fault_data(value: u32);
}
extern "C" {
    pub fn furi_hal_rtc_get_fault_data() -> u32;
}
extern "C" {
    pub fn furi_hal_rtc_set_pin_fails(value: u32);
}
extern "C" {
    pub fn furi_hal_rtc_get_pin_fails() -> u32;
}
extern "C" {
    pub fn furi_hal_rtc_get_timestamp() -> u32;
}
extern "C" {
    pub fn furi_hal_rtc_datetime_to_timestamp(datetime: *mut FuriHalRtcDateTime) -> u32;
}
extern "C" {
    pub fn furi_hal_speaker_start(frequency: f32, volume: f32);
}
extern "C" {
    pub fn furi_hal_speaker_set_volume(volume: f32);
}
extern "C" {
    pub fn furi_hal_speaker_stop();
}
extern "C" {
    #[doc = " Set light value"]
    #[doc = ""]
    #[doc = " @param      light  Light"]
    #[doc = " @param      value  light brightness [0-255]"]
    pub fn furi_hal_light_set(light: Light, value: u8);
}
extern "C" {
    #[doc = " Start hardware LED blinking mode"]
    #[doc = ""]
    #[doc = " @param      light  Light"]
    #[doc = " @param      brightness  light brightness [0-255]"]
    #[doc = " @param      on_time  LED on time in ms"]
    #[doc = " @param      period  LED blink period in ms"]
    pub fn furi_hal_light_blink_start(light: Light, brightness: u8, on_time: u16, period: u16);
}
extern "C" {
    #[doc = " Stop hardware LED blinking mode"]
    pub fn furi_hal_light_blink_stop();
}
extern "C" {
    #[doc = " Set color in hardware LED blinking mode"]
    #[doc = ""]
    #[doc = " @param      light  Light"]
    pub fn furi_hal_light_blink_set_color(light: Light);
}
extern "C" {
    #[doc = " Execute sequence"]
    #[doc = ""]
    #[doc = " @param      sequence  Sequence to execute"]
    pub fn furi_hal_light_sequence(sequence: *const core::ffi::c_char);
}
pub const FuriHalPowerIC_FuriHalPowerICCharger: FuriHalPowerIC = 0;
pub const FuriHalPowerIC_FuriHalPowerICFuelGauge: FuriHalPowerIC = 1;
#[doc = " Power IC type"]
pub type FuriHalPowerIC = core::ffi::c_uchar;
extern "C" {
    #[doc = " Check if gauge is ok"]
    #[doc = ""]
    #[doc = " Verifies that:"]
    #[doc = " - gauge is alive"]
    #[doc = " - correct profile loaded"]
    #[doc = " - self diagnostic status is good"]
    #[doc = ""]
    #[doc = " @return true if gauge is ok"]
    pub fn furi_hal_power_gauge_is_ok() -> bool;
}
extern "C" {
    #[doc = " Enter insomnia mode Prevents device from going to sleep"]
    #[doc = " @warning    Internally increases insomnia level Must be paired with"]
    #[doc = "             furi_hal_power_insomnia_exit"]
    pub fn furi_hal_power_insomnia_enter();
}
extern "C" {
    #[doc = " Exit insomnia mode Allow device to go to sleep"]
    #[doc = " @warning    Internally decreases insomnia level. Must be paired with"]
    #[doc = "             furi_hal_power_insomnia_enter"]
    pub fn furi_hal_power_insomnia_exit();
}
extern "C" {
    #[doc = " Check if sleep availble"]
    #[doc = ""]
    #[doc = " @return     true if available"]
    pub fn furi_hal_power_sleep_available() -> bool;
}
extern "C" {
    #[doc = " Check if deep sleep availble"]
    #[doc = ""]
    #[doc = " @return     true if available"]
    pub fn furi_hal_power_deep_sleep_available() -> bool;
}
extern "C" {
    #[doc = " Go to sleep"]
    pub fn furi_hal_power_sleep();
}
extern "C" {
    #[doc = " Get predicted remaining battery capacity in percents"]
    #[doc = ""]
    #[doc = " @return     remaining battery capacity in percents"]
    pub fn furi_hal_power_get_pct() -> u8;
}
extern "C" {
    #[doc = " Get battery health state in percents"]
    #[doc = ""]
    #[doc = " @return     health in percents"]
    pub fn furi_hal_power_get_bat_health_pct() -> u8;
}
extern "C" {
    #[doc = " Get charging status"]
    #[doc = ""]
    #[doc = " @return     true if charging"]
    pub fn furi_hal_power_is_charging() -> bool;
}
extern "C" {
    #[doc = " Get charge complete status"]
    #[doc = ""]
    #[doc = " @return     true if done charging and connected to charger"]
    pub fn furi_hal_power_is_charging_done() -> bool;
}
extern "C" {
    #[doc = " Switch MCU to SHUTDOWN"]
    pub fn furi_hal_power_shutdown();
}
extern "C" {
    #[doc = " Poweroff device"]
    pub fn furi_hal_power_off();
}
extern "C" {
    #[doc = " Reset device"]
    pub fn furi_hal_power_reset();
}
extern "C" {
    #[doc = " OTG enable"]
    pub fn furi_hal_power_enable_otg();
}
extern "C" {
    #[doc = " OTG disable"]
    pub fn furi_hal_power_disable_otg();
}
extern "C" {
    #[doc = " Check OTG status and disable it if falt happened"]
    pub fn furi_hal_power_check_otg_status();
}
extern "C" {
    #[doc = " Get OTG status"]
    #[doc = ""]
    #[doc = " @return     true if enabled"]
    pub fn furi_hal_power_is_otg_enabled() -> bool;
}
extern "C" {
    #[doc = " Get remaining battery battery capacity in mAh"]
    #[doc = ""]
    #[doc = " @return     capacity in mAh"]
    pub fn furi_hal_power_get_battery_remaining_capacity() -> u32;
}
extern "C" {
    #[doc = " Get full charge battery capacity in mAh"]
    #[doc = ""]
    #[doc = " @return     capacity in mAh"]
    pub fn furi_hal_power_get_battery_full_capacity() -> u32;
}
extern "C" {
    #[doc = " Get battery capacity in mAh from battery profile"]
    #[doc = ""]
    #[doc = " @return     capacity in mAh"]
    pub fn furi_hal_power_get_battery_design_capacity() -> u32;
}
extern "C" {
    #[doc = " Get battery voltage in V"]
    #[doc = ""]
    #[doc = " @param      ic    FuriHalPowerIc to get measurment"]
    #[doc = ""]
    #[doc = " @return     voltage in V"]
    pub fn furi_hal_power_get_battery_voltage(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = " Get battery current in A"]
    #[doc = ""]
    #[doc = " @param      ic    FuriHalPowerIc to get measurment"]
    #[doc = ""]
    #[doc = " @return     current in A"]
    pub fn furi_hal_power_get_battery_current(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = " Get temperature in C"]
    #[doc = ""]
    #[doc = " @param      ic    FuriHalPowerIc to get measurment"]
    #[doc = ""]
    #[doc = " @return     temperature in C"]
    pub fn furi_hal_power_get_battery_temperature(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = " Get USB voltage in V"]
    #[doc = ""]
    #[doc = " @return     voltage in V"]
    pub fn furi_hal_power_get_usb_voltage() -> f32;
}
extern "C" {
    #[doc = " Get power system component state"]
    pub fn furi_hal_power_dump_state();
}
extern "C" {
    #[doc = " Enable 3.3v on external gpio and sd card"]
    pub fn furi_hal_power_enable_external_3_3v();
}
extern "C" {
    #[doc = " Disable 3.3v on external gpio and sd card"]
    pub fn furi_hal_power_disable_external_3_3v();
}
extern "C" {
    #[doc = " Enter supress charge mode."]
    #[doc = ""]
    #[doc = " Use this function when your application need clean power supply."]
    pub fn furi_hal_power_suppress_charge_enter();
}
extern "C" {
    #[doc = " Exit supress charge mode"]
    pub fn furi_hal_power_suppress_charge_exit();
}
#[doc = " Callback type called by furi_hal_power_info_get every time another key-value pair of information is ready"]
#[doc = ""]
#[doc = " @param      key[in]      power information type identifier"]
#[doc = " @param      value[in]    power information value"]
#[doc = " @param      last[in]     whether the passed key-value pair is the last one"]
#[doc = " @param      context[in]  to pass to callback"]
pub type FuriHalPowerInfoCallback = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        last: bool,
        context: *mut core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = " Get power information"]
    #[doc = ""]
    #[doc = " @param[in]  callback     callback to provide with new data"]
    #[doc = " @param[in]  context      context to pass to callback"]
    pub fn furi_hal_power_info_get(
        callback: FuriHalPowerInfoCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Version {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get current running firmware version handle."]
    #[doc = ""]
    #[doc = " You can store it somewhere. But if you want to retrieve data, you have to use"]
    #[doc = " 'version_*_get()' set of functions. Also, 'version_*_get()' imply to use this"]
    #[doc = " handle if no handle (NULL_PTR) provided."]
    #[doc = ""]
    #[doc = " @return     pointer to Version data."]
    pub fn version_get() -> *const Version;
}
extern "C" {
    #[doc = " Get git commit hash."]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     git hash"]
    pub fn version_get_githash(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get git branch."]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     git branch"]
    pub fn version_get_gitbranch(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get number of commit in git branch."]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     number of commit"]
    pub fn version_get_gitbranchnum(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get build date."]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     build date"]
    pub fn version_get_builddate(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get build version. Build version is last tag in git history."]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     build date"]
    pub fn version_get_version(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get hardware target this firmware was built for"]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     build date"]
    pub fn version_get_target(v: *const Version) -> u8;
}
extern "C" {
    #[doc = " Get flag indicating if this build is \"dirty\" (source code had uncommited changes)"]
    #[doc = ""]
    #[doc = " @param      v     pointer to Version data. NULL for currently running"]
    #[doc = "                   software."]
    #[doc = ""]
    #[doc = " @return     build date"]
    pub fn version_get_dirty_flag(v: *const Version) -> bool;
}
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion0: FuriHalVersionOtpVersion = 0;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion1: FuriHalVersionOtpVersion = 1;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion2: FuriHalVersionOtpVersion = 2;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersionEmpty: FuriHalVersionOtpVersion =
    4294967294;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersionUnknown: FuriHalVersionOtpVersion =
    4294967295;
#[doc = " OTP Versions enum"]
pub type FuriHalVersionOtpVersion = core::ffi::c_uint;
pub const FuriHalVersionColor_FuriHalVersionColorUnknown: FuriHalVersionColor = 0;
pub const FuriHalVersionColor_FuriHalVersionColorBlack: FuriHalVersionColor = 1;
pub const FuriHalVersionColor_FuriHalVersionColorWhite: FuriHalVersionColor = 2;
#[doc = " Device Colors"]
pub type FuriHalVersionColor = core::ffi::c_uchar;
pub const FuriHalVersionRegion_FuriHalVersionRegionUnknown: FuriHalVersionRegion = 0;
pub const FuriHalVersionRegion_FuriHalVersionRegionEuRu: FuriHalVersionRegion = 1;
pub const FuriHalVersionRegion_FuriHalVersionRegionUsCaAu: FuriHalVersionRegion = 2;
pub const FuriHalVersionRegion_FuriHalVersionRegionJp: FuriHalVersionRegion = 3;
pub const FuriHalVersionRegion_FuriHalVersionRegionWorld: FuriHalVersionRegion = 4;
#[doc = " Device Regions"]
pub type FuriHalVersionRegion = core::ffi::c_uchar;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayUnknown: FuriHalVersionDisplay = 0;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayErc: FuriHalVersionDisplay = 1;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayMgg: FuriHalVersionDisplay = 2;
#[doc = " Device Display"]
pub type FuriHalVersionDisplay = core::ffi::c_uchar;
extern "C" {
    #[doc = " Check target firmware version"]
    #[doc = ""]
    #[doc = " @return     true if target and real matches"]
    pub fn furi_hal_version_do_i_belong_here() -> bool;
}
extern "C" {
    #[doc = " Get model name"]
    #[doc = ""]
    #[doc = " @return     model name C-string"]
    pub fn furi_hal_version_get_model_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get OTP version"]
    #[doc = ""]
    #[doc = " @return     OTP Version"]
    pub fn furi_hal_version_get_otp_version() -> FuriHalVersionOtpVersion;
}
extern "C" {
    #[doc = " Get hardware version"]
    #[doc = ""]
    #[doc = " @return     Hardware Version"]
    pub fn furi_hal_version_get_hw_version() -> u8;
}
extern "C" {
    #[doc = " Get hardware target"]
    #[doc = ""]
    #[doc = " @return     Hardware Target"]
    pub fn furi_hal_version_get_hw_target() -> u8;
}
extern "C" {
    #[doc = " Get hardware body"]
    #[doc = ""]
    #[doc = " @return     Hardware Body"]
    pub fn furi_hal_version_get_hw_body() -> u8;
}
extern "C" {
    #[doc = " Get hardware body color"]
    #[doc = ""]
    #[doc = " @return     Hardware Color"]
    pub fn furi_hal_version_get_hw_color() -> FuriHalVersionColor;
}
extern "C" {
    #[doc = " Get hardware connect"]
    #[doc = ""]
    #[doc = " @return     Hardware Interconnect"]
    pub fn furi_hal_version_get_hw_connect() -> u8;
}
extern "C" {
    #[doc = " Get hardware region"]
    #[doc = ""]
    #[doc = " @return     Hardware Region"]
    pub fn furi_hal_version_get_hw_region() -> FuriHalVersionRegion;
}
extern "C" {
    #[doc = " Get hardware region name"]
    #[doc = ""]
    #[doc = " @return     Hardware Region name"]
    pub fn furi_hal_version_get_hw_region_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get hardware display id"]
    #[doc = ""]
    #[doc = " @return     Display id"]
    pub fn furi_hal_version_get_hw_display() -> FuriHalVersionDisplay;
}
extern "C" {
    #[doc = " Get hardware timestamp"]
    #[doc = ""]
    #[doc = " @return     Hardware Manufacture timestamp"]
    pub fn furi_hal_version_get_hw_timestamp() -> u32;
}
extern "C" {
    #[doc = " Get pointer to target name"]
    #[doc = ""]
    #[doc = " @return     Hardware Name C-string"]
    pub fn furi_hal_version_get_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get pointer to target device name"]
    #[doc = ""]
    #[doc = " @return     Hardware Device Name C-string"]
    pub fn furi_hal_version_get_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get pointer to target ble local device name"]
    #[doc = ""]
    #[doc = " @return     Ble Device Name C-string"]
    pub fn furi_hal_version_get_ble_local_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get BLE MAC address"]
    #[doc = ""]
    #[doc = " @return     pointer to BLE MAC address"]
    pub fn furi_hal_version_get_ble_mac() -> *const u8;
}
extern "C" {
    #[doc = " Get address of version structure of firmware."]
    #[doc = ""]
    #[doc = " @return     Address of firmware version structure."]
    pub fn furi_hal_version_get_firmware_version() -> *const Version;
}
extern "C" {
    #[doc = " Get platform UID size in bytes"]
    #[doc = ""]
    #[doc = " @return     UID size in bytes"]
    pub fn furi_hal_version_uid_size() -> usize;
}
extern "C" {
    #[doc = " Get const pointer to UID"]
    #[doc = ""]
    #[doc = " @return     pointer to UID"]
    pub fn furi_hal_version_uid() -> *const u8;
}
pub const GapEventType_GapEventTypeConnected: GapEventType = 0;
pub const GapEventType_GapEventTypeDisconnected: GapEventType = 1;
pub const GapEventType_GapEventTypeStartAdvertising: GapEventType = 2;
pub const GapEventType_GapEventTypeStopAdvertising: GapEventType = 3;
pub const GapEventType_GapEventTypePinCodeShow: GapEventType = 4;
pub const GapEventType_GapEventTypePinCodeVerify: GapEventType = 5;
pub const GapEventType_GapEventTypeUpdateMTU: GapEventType = 6;
pub type GapEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub union GapEventData {
    pub pin_code: u32,
    pub max_packet_size: u16,
}
#[test]
fn bindgen_test_layout_GapEventData() {
    const UNINIT: ::core::mem::MaybeUninit<GapEventData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GapEventData>(),
        4usize,
        concat!("Size of: ", stringify!(GapEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<GapEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(GapEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEventData),
            "::",
            stringify!(pin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_packet_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEventData),
            "::",
            stringify!(max_packet_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GapEvent {
    pub type_: GapEventType,
    pub data: GapEventData,
}
#[test]
fn bindgen_test_layout_GapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<GapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GapEvent>(),
        8usize,
        concat!("Size of: ", stringify!(GapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<GapEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(GapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEvent),
            "::",
            stringify!(data)
        )
    );
}
pub type GapEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: GapEvent, context: *mut core::ffi::c_void) -> bool,
>;
pub const SerialServiceEventType_SerialServiceEventTypeDataReceived: SerialServiceEventType = 0;
pub const SerialServiceEventType_SerialServiceEventTypeDataSent: SerialServiceEventType = 1;
pub const SerialServiceEventType_SerialServiceEventTypesBleResetRequest: SerialServiceEventType = 2;
pub type SerialServiceEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceData {
    pub buffer: *mut u8,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_SerialServiceData() {
    const UNINIT: ::core::mem::MaybeUninit<SerialServiceData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SerialServiceData>(),
        16usize,
        concat!("Size of: ", stringify!(SerialServiceData))
    );
    assert_eq!(
        ::core::mem::align_of::<SerialServiceData>(),
        8usize,
        concat!("Alignment of ", stringify!(SerialServiceData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceData),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceData),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceEvent {
    pub event: SerialServiceEventType,
    pub data: SerialServiceData,
}
#[test]
fn bindgen_test_layout_SerialServiceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SerialServiceEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SerialServiceEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SerialServiceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SerialServiceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SerialServiceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceEvent),
            "::",
            stringify!(data)
        )
    );
}
pub type SerialServiceEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: SerialServiceEvent, context: *mut core::ffi::c_void) -> u16,
>;
pub const BleGlueC2Mode_BleGlueC2ModeUnknown: BleGlueC2Mode = 0;
pub const BleGlueC2Mode_BleGlueC2ModeFUS: BleGlueC2Mode = 1;
pub const BleGlueC2Mode_BleGlueC2ModeStack: BleGlueC2Mode = 2;
pub type BleGlueC2Mode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGlueC2Info {
    pub mode: BleGlueC2Mode,
    #[doc = " Wireless Info"]
    pub VersionMajor: u8,
    pub VersionMinor: u8,
    pub VersionSub: u8,
    pub VersionBranch: u8,
    pub VersionReleaseType: u8,
    pub MemorySizeSram2B: u8,
    pub MemorySizeSram2A: u8,
    pub MemorySizeSram1: u8,
    pub MemorySizeFlash: u8,
    pub StackType: u8,
    pub StackTypeString: [core::ffi::c_char; 20usize],
    #[doc = " Fus Info"]
    pub FusVersionMajor: u8,
    pub FusVersionMinor: u8,
    pub FusVersionSub: u8,
    pub FusMemorySizeSram2B: u8,
    pub FusMemorySizeSram2A: u8,
    pub FusMemorySizeFlash: u8,
}
#[test]
fn bindgen_test_layout_BleGlueC2Info() {
    const UNINIT: ::core::mem::MaybeUninit<BleGlueC2Info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BleGlueC2Info>(),
        37usize,
        concat!("Size of: ", stringify!(BleGlueC2Info))
    );
    assert_eq!(
        ::core::mem::align_of::<BleGlueC2Info>(),
        1usize,
        concat!("Alignment of ", stringify!(BleGlueC2Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionMajor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionMinor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionSub) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionSub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionBranch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionBranch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionReleaseType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionReleaseType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram2B) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram2A) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeFlash) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeFlash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackType) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(StackType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackTypeString) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(StackTypeString)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionMajor) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionMinor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionSub) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionSub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2B) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeSram2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2A) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeSram2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeFlash) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeFlash)
        )
    );
}
pub type BleGlueKeyStorageChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(change_addr_start: *mut u8, size: u16, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Initialize start core2 and initialize transport"]
    pub fn ble_glue_init();
}
extern "C" {
    #[doc = " Start Core2 Radio stack"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn ble_glue_start() -> bool;
}
extern "C" {
    #[doc = " Is core2 alive and at least FUS is running"]
    #[doc = ""]
    #[doc = " @return     true if core2 is alive"]
    pub fn ble_glue_is_alive() -> bool;
}
extern "C" {
    #[doc = " Waits for C2 to reports its mode to callback"]
    #[doc = ""]
    #[doc = " @return     true if it reported before reaching timeout"]
    pub fn ble_glue_wait_for_c2_start(timeout: i32) -> bool;
}
extern "C" {
    pub fn ble_glue_get_c2_info() -> *const BleGlueC2Info;
}
extern "C" {
    #[doc = " Is core2 radio stack present and ready"]
    #[doc = ""]
    #[doc = " @return     true if present and ready"]
    pub fn ble_glue_is_radio_stack_ready() -> bool;
}
extern "C" {
    #[doc = " Set callback for NVM in RAM changes"]
    #[doc = ""]
    #[doc = " @param[in]  callback  The callback to call on NVM change"]
    #[doc = " @param      context   The context for callback"]
    pub fn ble_glue_set_key_storage_changed_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Stop SHCI thread"]
    pub fn ble_glue_thread_stop();
}
extern "C" {
    pub fn ble_glue_reinit_c2() -> bool;
}
pub const BleGlueCommandResult_BleGlueCommandResultUnknown: BleGlueCommandResult = 0;
pub const BleGlueCommandResult_BleGlueCommandResultOK: BleGlueCommandResult = 1;
pub const BleGlueCommandResult_BleGlueCommandResultError: BleGlueCommandResult = 2;
pub const BleGlueCommandResult_BleGlueCommandResultRestartPending: BleGlueCommandResult = 3;
pub const BleGlueCommandResult_BleGlueCommandResultOperationOngoing: BleGlueCommandResult = 4;
pub type BleGlueCommandResult = core::ffi::c_uchar;
extern "C" {
    #[doc = " Restart MCU to launch radio stack firmware if necessary"]
    #[doc = ""]
    #[doc = " @return      true on radio stack start command"]
    pub fn ble_glue_force_c2_mode(mode: BleGlueC2Mode) -> BleGlueCommandResult;
}
extern "C" {
    pub fn ble_app_init() -> bool;
}
extern "C" {
    pub fn ble_app_get_key_storage_buff(addr: *mut *mut u8, size: *mut u16);
}
extern "C" {
    pub fn ble_app_thread_stop();
}
pub const FuriHalBtSerialRpcStatus_FuriHalBtSerialRpcStatusNotActive: FuriHalBtSerialRpcStatus = 0;
pub const FuriHalBtSerialRpcStatus_FuriHalBtSerialRpcStatusActive: FuriHalBtSerialRpcStatus = 1;
pub type FuriHalBtSerialRpcStatus = core::ffi::c_uchar;
#[doc = " Serial service callback type"]
pub type FuriHalBtSerialCallback = SerialServiceEventCallback;
extern "C" {
    #[doc = " Start Serial Profile"]
    pub fn furi_hal_bt_serial_start();
}
extern "C" {
    #[doc = " Stop Serial Profile"]
    pub fn furi_hal_bt_serial_stop();
}
extern "C" {
    #[doc = " Set Serial service events callback"]
    #[doc = ""]
    #[doc = " @param buffer_size   Applicaition buffer size"]
    #[doc = " @param calback       FuriHalBtSerialCallback instance"]
    #[doc = " @param context       pointer to context"]
    pub fn furi_hal_bt_serial_set_event_callback(
        buff_size: u16,
        callback: FuriHalBtSerialCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set BLE RPC status"]
    #[doc = ""]
    #[doc = " @param status        FuriHalBtSerialRpcStatus instance"]
    pub fn furi_hal_bt_serial_set_rpc_status(status: FuriHalBtSerialRpcStatus);
}
extern "C" {
    #[doc = " Notify that application buffer is empty"]
    pub fn furi_hal_bt_serial_notify_buffer_is_empty();
}
extern "C" {
    #[doc = " Send data through BLE"]
    #[doc = ""]
    #[doc = " @param data  data buffer"]
    #[doc = " @param size  data buffer size"]
    #[doc = ""]
    #[doc = " @return      true on success"]
    pub fn furi_hal_bt_serial_tx(data: *mut u8, size: u16) -> bool;
}
pub const FuriHalBtStack_FuriHalBtStackUnknown: FuriHalBtStack = 0;
pub const FuriHalBtStack_FuriHalBtStackLight: FuriHalBtStack = 1;
pub const FuriHalBtStack_FuriHalBtStackFull: FuriHalBtStack = 2;
pub type FuriHalBtStack = core::ffi::c_uchar;
pub const FuriHalBtProfile_FuriHalBtProfileSerial: FuriHalBtProfile = 0;
pub const FuriHalBtProfile_FuriHalBtProfileHidKeyboard: FuriHalBtProfile = 1;
pub const FuriHalBtProfile_FuriHalBtProfileNumber: FuriHalBtProfile = 2;
pub type FuriHalBtProfile = core::ffi::c_uchar;
extern "C" {
    #[doc = " Lock core2 state transition"]
    pub fn furi_hal_bt_lock_core2();
}
extern "C" {
    #[doc = " Lock core2 state transition"]
    pub fn furi_hal_bt_unlock_core2();
}
extern "C" {
    #[doc = " Start radio stack"]
    #[doc = ""]
    #[doc = " @return  true on successfull radio stack start"]
    pub fn furi_hal_bt_start_radio_stack() -> bool;
}
extern "C" {
    #[doc = " Get radio stack type"]
    #[doc = ""]
    #[doc = " @return  FuriHalBtStack instance"]
    pub fn furi_hal_bt_get_radio_stack() -> FuriHalBtStack;
}
extern "C" {
    #[doc = " Check if radio stack supports BLE GAT/GAP"]
    #[doc = ""]
    #[doc = " @return  true if supported"]
    pub fn furi_hal_bt_is_ble_gatt_gap_supported() -> bool;
}
extern "C" {
    #[doc = " Check if radio stack supports testing"]
    #[doc = ""]
    #[doc = " @return  true if supported"]
    pub fn furi_hal_bt_is_testing_supported() -> bool;
}
extern "C" {
    #[doc = " Start BLE app"]
    #[doc = ""]
    #[doc = " @param profile   FuriHalBtProfile instance"]
    #[doc = " @param event_cb  GapEventCallback instance"]
    #[doc = " @param context   pointer to context"]
    #[doc = ""]
    #[doc = " @return          true on success"]
    pub fn furi_hal_bt_start_app(
        profile: FuriHalBtProfile,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Reinitialize core2"]
    #[doc = ""]
    #[doc = " Also can be used to prepare core2 for stop modes"]
    pub fn furi_hal_bt_reinit();
}
extern "C" {
    #[doc = " Change BLE app"]
    #[doc = " Restarts 2nd core"]
    #[doc = ""]
    #[doc = " @param profile   FuriHalBtProfile instance"]
    #[doc = " @param event_cb  GapEventCallback instance"]
    #[doc = " @param context   pointer to context"]
    #[doc = ""]
    #[doc = " @return          true on success"]
    pub fn furi_hal_bt_change_app(
        profile: FuriHalBtProfile,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Update battery level"]
    #[doc = ""]
    #[doc = " @param battery_level battery level"]
    pub fn furi_hal_bt_update_battery_level(battery_level: u8);
}
extern "C" {
    #[doc = " Update battery power state"]
    pub fn furi_hal_bt_update_power_state();
}
extern "C" {
    #[doc = " Checks if BLE state is active"]
    #[doc = ""]
    #[doc = " @return          true if device is connected or advertising, false otherwise"]
    pub fn furi_hal_bt_is_active() -> bool;
}
extern "C" {
    #[doc = " Start advertising"]
    pub fn furi_hal_bt_start_advertising();
}
extern "C" {
    #[doc = " Stop advertising"]
    pub fn furi_hal_bt_stop_advertising();
}
extern "C" {
    #[doc = " Get BT/BLE system component state"]
    #[doc = ""]
    #[doc = " @param[in]  buffer  FuriString* buffer to write to"]
    pub fn furi_hal_bt_dump_state(buffer: *mut FuriString);
}
extern "C" {
    #[doc = " Get BT/BLE system component state"]
    #[doc = ""]
    #[doc = " @return     true if core2 is alive"]
    pub fn furi_hal_bt_is_alive() -> bool;
}
extern "C" {
    #[doc = " Get key storage buffer address and size"]
    #[doc = ""]
    #[doc = " @param      key_buff_addr  pointer to store buffer address"]
    #[doc = " @param      key_buff_size  pointer to store buffer size"]
    pub fn furi_hal_bt_get_key_storage_buff(key_buff_addr: *mut *mut u8, key_buff_size: *mut u16);
}
extern "C" {
    #[doc = " Get SRAM2 hardware semaphore"]
    #[doc = " @note Must be called before SRAM2 read/write operations"]
    pub fn furi_hal_bt_nvm_sram_sem_acquire();
}
extern "C" {
    #[doc = " Release SRAM2 hardware semaphore"]
    #[doc = " @note Must be called after SRAM2 read/write operations"]
    pub fn furi_hal_bt_nvm_sram_sem_release();
}
extern "C" {
    #[doc = " Clear key storage"]
    #[doc = ""]
    #[doc = " @return      true on success"]
    pub fn furi_hal_bt_clear_white_list() -> bool;
}
extern "C" {
    #[doc = " Set key storage change callback"]
    #[doc = ""]
    #[doc = " @param       callback    BleGlueKeyStorageChangedCallback instance"]
    #[doc = " @param       context     pointer to context"]
    pub fn furi_hal_bt_set_key_storage_change_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start ble tone tx at given channel and power"]
    #[doc = ""]
    #[doc = " @param[in]  channel  The channel"]
    #[doc = " @param[in]  power    The power"]
    pub fn furi_hal_bt_start_tone_tx(channel: u8, power: u8);
}
extern "C" {
    #[doc = " Stop ble tone tx"]
    pub fn furi_hal_bt_stop_tone_tx();
}
extern "C" {
    #[doc = " Start sending ble packets at a given frequency and datarate"]
    #[doc = ""]
    #[doc = " @param[in]  channel   The channel"]
    #[doc = " @param[in]  pattern   The pattern"]
    #[doc = " @param[in]  datarate  The datarate"]
    pub fn furi_hal_bt_start_packet_tx(channel: u8, pattern: u8, datarate: u8);
}
extern "C" {
    #[doc = " Stop sending ble packets"]
    #[doc = ""]
    #[doc = " @return     sent packet count"]
    pub fn furi_hal_bt_stop_packet_test() -> u16;
}
extern "C" {
    #[doc = " Start receiving packets"]
    #[doc = ""]
    #[doc = " @param[in]  channel   RX channel"]
    #[doc = " @param[in]  datarate  Datarate"]
    pub fn furi_hal_bt_start_packet_rx(channel: u8, datarate: u8);
}
extern "C" {
    #[doc = " Set up the RF to listen to a given RF channel"]
    #[doc = ""]
    #[doc = " @param[in]  channel  RX channel"]
    pub fn furi_hal_bt_start_rx(channel: u8);
}
extern "C" {
    #[doc = " Stop RF listenning"]
    pub fn furi_hal_bt_stop_rx();
}
extern "C" {
    #[doc = " Get RSSI"]
    #[doc = ""]
    #[doc = " @return     RSSI in dBm"]
    pub fn furi_hal_bt_get_rssi() -> f32;
}
extern "C" {
    #[doc = " Get number of transmitted packets"]
    #[doc = ""]
    #[doc = " @return     packet count"]
    pub fn furi_hal_bt_get_transmitted_packets() -> u32;
}
extern "C" {
    #[doc = " Check & switch C2 to given mode"]
    #[doc = ""]
    #[doc = " @param[in]  mode  mode to switch into"]
    pub fn furi_hal_bt_ensure_c2_mode(mode: BleGlueC2Mode) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LevelDuration {
    pub level: u32,
    pub duration: u32,
}
#[test]
fn bindgen_test_layout_LevelDuration() {
    const UNINIT: ::core::mem::MaybeUninit<LevelDuration> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LevelDuration>(),
        8usize,
        concat!("Size of: ", stringify!(LevelDuration))
    );
    assert_eq!(
        ::core::mem::align_of::<LevelDuration>(),
        4usize,
        concat!("Alignment of ", stringify!(LevelDuration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LevelDuration),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LevelDuration),
            "::",
            stringify!(duration)
        )
    );
}
#[doc = "< default configuration"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetIDLE: FuriHalSubGhzPreset = 0;
#[doc = "< OOK, bandwidth 270kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetOok270Async: FuriHalSubGhzPreset = 1;
#[doc = "< OOK, bandwidth 650kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetOok650Async: FuriHalSubGhzPreset = 2;
#[doc = "< FM, deviation 2.380371 kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPreset2FSKDev238Async: FuriHalSubGhzPreset = 3;
#[doc = "< FM, deviation 47.60742 kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPreset2FSKDev476Async: FuriHalSubGhzPreset = 4;
#[doc = "< MSK, deviation 47.60742 kHz, 99.97Kb/s, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetMSK99_97KbAsync: FuriHalSubGhzPreset = 5;
#[doc = "< GFSK, deviation 19.042969 kHz, 9.996Kb/s, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetGFSK9_99KbAsync: FuriHalSubGhzPreset = 6;
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetCustom: FuriHalSubGhzPreset = 7;
#[doc = " Radio Presets"]
pub type FuriHalSubGhzPreset = core::ffi::c_uchar;
#[doc = "< Isolate Radio from antenna"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPathIsolate: FuriHalSubGhzPath = 0;
#[doc = "< Center Frquency: 433MHz. Path 1: SW1RF1-SW2RF2, LCLCL"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath433: FuriHalSubGhzPath = 1;
#[doc = "< Center Frquency: 315MHz. Path 2: SW1RF2-SW2RF1, LCLCLCL"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath315: FuriHalSubGhzPath = 2;
#[doc = "< Center Frquency: 868MHz. Path 3: SW1RF3-SW2RF3, LCLC"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath868: FuriHalSubGhzPath = 3;
#[doc = " Switchable Radio Paths"]
pub type FuriHalSubGhzPath = core::ffi::c_uchar;
extern "C" {
    #[doc = " Send device to sleep mode"]
    pub fn furi_hal_subghz_sleep();
}
extern "C" {
    #[doc = " Load registers from preset by preset name"]
    #[doc = ""]
    #[doc = " @param      preset  to load"]
    pub fn furi_hal_subghz_load_preset(preset: FuriHalSubGhzPreset);
}
extern "C" {
    #[doc = " Load custom registers from preset"]
    #[doc = ""]
    #[doc = " @param      preset_data   registers to load"]
    pub fn furi_hal_subghz_load_custom_preset(preset_data: *mut u8);
}
extern "C" {
    #[doc = " Load registers"]
    #[doc = ""]
    #[doc = " @param      data  Registers data"]
    pub fn furi_hal_subghz_load_registers(data: *mut u8);
}
extern "C" {
    #[doc = " Load PATABLE"]
    #[doc = ""]
    #[doc = " @param      data  8 uint8_t values"]
    pub fn furi_hal_subghz_load_patable(data: *const u8);
}
extern "C" {
    #[doc = " Write packet to FIFO"]
    #[doc = ""]
    #[doc = " @param      data  bytes array"]
    #[doc = " @param      size  size"]
    pub fn furi_hal_subghz_write_packet(data: *const u8, size: u8);
}
extern "C" {
    #[doc = " Check if recieve pipe is not empty"]
    #[doc = ""]
    #[doc = " @return     true if not empty"]
    pub fn furi_hal_subghz_rx_pipe_not_empty() -> bool;
}
extern "C" {
    #[doc = " Check if recieved data crc is valid"]
    #[doc = ""]
    #[doc = " @return     true if valid"]
    pub fn furi_hal_subghz_is_rx_data_crc_valid() -> bool;
}
extern "C" {
    #[doc = " Read packet from FIFO"]
    #[doc = ""]
    #[doc = " @param      data  pointer"]
    #[doc = " @param      size  size"]
    pub fn furi_hal_subghz_read_packet(data: *mut u8, size: *mut u8);
}
extern "C" {
    #[doc = " Flush rx FIFO buffer"]
    pub fn furi_hal_subghz_flush_rx();
}
extern "C" {
    #[doc = " Flush tx FIFO buffer"]
    pub fn furi_hal_subghz_flush_tx();
}
extern "C" {
    #[doc = " Reset Issue reset command"]
    #[doc = " @warning    registers content will be lost"]
    pub fn furi_hal_subghz_reset();
}
extern "C" {
    #[doc = " Switch to Idle"]
    pub fn furi_hal_subghz_idle();
}
extern "C" {
    #[doc = " Switch to Recieve"]
    pub fn furi_hal_subghz_rx();
}
extern "C" {
    #[doc = " Switch to Transmit"]
    #[doc = ""]
    #[doc = " @return     true if the transfer is allowed by belonging to the region"]
    pub fn furi_hal_subghz_tx() -> bool;
}
extern "C" {
    #[doc = " Get RSSI value in dBm"]
    #[doc = ""]
    #[doc = " @return     RSSI value"]
    pub fn furi_hal_subghz_get_rssi() -> f32;
}
extern "C" {
    #[doc = " Get LQI"]
    #[doc = ""]
    #[doc = " @return     LQI value"]
    pub fn furi_hal_subghz_get_lqi() -> u8;
}
extern "C" {
    #[doc = " Check if frequency is in valid range"]
    #[doc = ""]
    #[doc = " @param      value  frequency in Hz"]
    #[doc = ""]
    #[doc = " @return     true if frequncy is valid, otherwise false"]
    pub fn furi_hal_subghz_is_frequency_valid(value: u32) -> bool;
}
extern "C" {
    #[doc = " Set frequency and path This function automatically selects antenna matching"]
    #[doc = " network"]
    #[doc = ""]
    #[doc = " @param      value  frequency in Hz"]
    #[doc = ""]
    #[doc = " @return     real frequency in herz"]
    pub fn furi_hal_subghz_set_frequency_and_path(value: u32) -> u32;
}
extern "C" {
    #[doc = " Set frequency"]
    #[doc = ""]
    #[doc = " @param      value  frequency in Hz"]
    #[doc = ""]
    #[doc = " @return     real frequency in herz"]
    pub fn furi_hal_subghz_set_frequency(value: u32) -> u32;
}
extern "C" {
    #[doc = " Set path"]
    #[doc = ""]
    #[doc = " @param      path  path to use"]
    pub fn furi_hal_subghz_set_path(path: FuriHalSubGhzPath);
}
#[doc = " Signal Timings Capture callback"]
pub type FuriHalSubGhzCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Enable signal timings capture Initializes GPIO and TIM2 for timings capture"]
    #[doc = ""]
    #[doc = " @param      callback  FuriHalSubGhzCaptureCallback"]
    #[doc = " @param      context   callback context"]
    pub fn furi_hal_subghz_start_async_rx(
        callback: FuriHalSubGhzCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Disable signal timings capture Resets GPIO and TIM2"]
    pub fn furi_hal_subghz_stop_async_rx();
}
#[doc = " Async TX callback type"]
#[doc = " @param      context  callback context"]
#[doc = " @return     LevelDuration"]
pub type FuriHalSubGhzAsyncTxCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
extern "C" {
    #[doc = " Start async TX Initializes GPIO, TIM2 and DMA1 for signal output"]
    #[doc = ""]
    #[doc = " @param      callback  FuriHalSubGhzAsyncTxCallback"]
    #[doc = " @param      context   callback context"]
    #[doc = ""]
    #[doc = " @return     true if the transfer is allowed by belonging to the region"]
    pub fn furi_hal_subghz_start_async_tx(
        callback: FuriHalSubGhzAsyncTxCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Wait for async transmission to complete"]
    #[doc = ""]
    #[doc = " @return     true if TX complete"]
    pub fn furi_hal_subghz_is_async_tx_complete() -> bool;
}
extern "C" {
    #[doc = " Stop async transmission and cleanup resources Resets GPIO, TIM2, and DMA1"]
    pub fn furi_hal_subghz_stop_async_tx();
}
extern "C" {
    #[doc = " Turn on/off vibro"]
    #[doc = ""]
    #[doc = " @param[in]  value  new state"]
    pub fn furi_hal_vibro_on(value: bool);
}
pub type FuriHalIbuttonEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn furi_hal_ibutton_emulate_start(
        period: u32,
        callback: FuriHalIbuttonEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_ibutton_emulate_set_next(period: u32);
}
extern "C" {
    pub fn furi_hal_ibutton_emulate_stop();
}
extern "C" {
    #[doc = " Sets the pin to normal mode (open collector), and sets it to float"]
    pub fn furi_hal_ibutton_start_drive();
}
extern "C" {
    #[doc = " Sets the pin to normal mode (open collector), and clears pin EXTI interrupt."]
    #[doc = " Used in EXTI interrupt context."]
    pub fn furi_hal_ibutton_start_drive_in_isr();
}
extern "C" {
    #[doc = " Sets the pin to interrupt mode (EXTI interrupt on rise or fall), and sets it to float"]
    pub fn furi_hal_ibutton_start_interrupt();
}
extern "C" {
    #[doc = " Sets the pin to interrupt mode (EXTI interrupt on rise or fall), and clears pin EXTI interrupt."]
    #[doc = " Used in EXTI interrupt context."]
    pub fn furi_hal_ibutton_start_interrupt_in_isr();
}
extern "C" {
    #[doc = " Sets the pin to analog mode, and sets it to float"]
    pub fn furi_hal_ibutton_stop();
}
extern "C" {
    #[doc = " Attach interrupt callback to iButton pin"]
    #[doc = " @param cb callback"]
    #[doc = " @param context context"]
    pub fn furi_hal_ibutton_add_interrupt(cb: GpioExtiCallback, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Remove interrupt callback from iButton pin"]
    pub fn furi_hal_ibutton_remove_interrupt();
}
extern "C" {
    #[doc = " Sets the pin to low"]
    pub fn furi_hal_ibutton_pin_low();
}
extern "C" {
    #[doc = " Sets the pin to high (float in iButton pin modes)"]
    pub fn furi_hal_ibutton_pin_high();
}
extern "C" {
    #[doc = " Get pin level"]
    #[doc = " @return true if level is high"]
    #[doc = " @return false if level is low"]
    pub fn furi_hal_ibutton_pin_get_level() -> bool;
}
extern "C" {
    #[doc = " Config rfid pins to reset state"]
    pub fn furi_hal_rfid_pins_reset();
}
extern "C" {
    #[doc = " Config rfid pins to emulate state"]
    pub fn furi_hal_rfid_pins_emulate();
}
extern "C" {
    #[doc = " Config rfid pins to read state"]
    pub fn furi_hal_rfid_pins_read();
}
extern "C" {
    #[doc = " Release rfid pull pin"]
    pub fn furi_hal_rfid_pin_pull_release();
}
extern "C" {
    #[doc = " Pulldown rfid pull pin"]
    pub fn furi_hal_rfid_pin_pull_pulldown();
}
extern "C" {
    #[doc = " Config rfid timer to read state"]
    #[doc = ""]
    #[doc = " @param      freq        timer frequency"]
    #[doc = " @param      duty_cycle  timer duty cycle, 0.0-1.0"]
    pub fn furi_hal_rfid_tim_read(freq: f32, duty_cycle: f32);
}
extern "C" {
    #[doc = " Start read timer"]
    pub fn furi_hal_rfid_tim_read_start();
}
extern "C" {
    #[doc = " Stop read timer"]
    pub fn furi_hal_rfid_tim_read_stop();
}
extern "C" {
    #[doc = " Config rfid timer to emulate state"]
    #[doc = ""]
    #[doc = " @param      freq  timer frequency"]
    pub fn furi_hal_rfid_tim_emulate(freq: f32);
}
pub type FuriHalRfidEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Start emulation timer"]
    pub fn furi_hal_rfid_tim_emulate_start(
        callback: FuriHalRfidEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
pub type FuriHalRfidReadCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_start(
        callback: FuriHalRfidReadCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_stop();
}
pub type FuriHalRfidDMACallback =
    ::core::option::Option<unsafe extern "C" fn(half: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_start(
        duration: *mut u32,
        pulse: *mut u32,
        length: usize,
        callback: FuriHalRfidDMACallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_stop();
}
extern "C" {
    #[doc = " Stop emulation timer"]
    pub fn furi_hal_rfid_tim_emulate_stop();
}
extern "C" {
    #[doc = " Config rfid timers to reset state"]
    pub fn furi_hal_rfid_tim_reset();
}
extern "C" {
    #[doc = " Set emulation timer period"]
    #[doc = ""]
    #[doc = " @param      period  overall duration"]
    pub fn furi_hal_rfid_set_emulate_period(period: u32);
}
extern "C" {
    #[doc = " Set emulation timer pulse"]
    #[doc = ""]
    #[doc = " @param      pulse  duration of high level"]
    pub fn furi_hal_rfid_set_emulate_pulse(pulse: u32);
}
extern "C" {
    #[doc = " Set read timer period"]
    #[doc = ""]
    #[doc = " @param      period  overall duration"]
    pub fn furi_hal_rfid_set_read_period(period: u32);
}
extern "C" {
    #[doc = " Set read timer pulse"]
    #[doc = ""]
    #[doc = " @param      pulse  duration of high level"]
    pub fn furi_hal_rfid_set_read_pulse(pulse: u32);
}
extern "C" {
    #[doc = " hanges the configuration of the RFID timer \"on a fly\""]
    #[doc = ""]
    #[doc = " @param      freq        new frequency"]
    #[doc = " @param      duty_cycle  new duty cycle"]
    pub fn furi_hal_rfid_change_read_config(freq: f32, duty_cycle: f32);
}
extern "C" {
    #[doc = " Start/Enable comparator"]
    pub fn furi_hal_rfid_comp_start();
}
extern "C" {
    #[doc = " Stop/Disable comparator"]
    pub fn furi_hal_rfid_comp_stop();
}
pub type FuriHalRfidCompCallback =
    ::core::option::Option<unsafe extern "C" fn(level: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Set comparator callback"]
    pub fn furi_hal_rfid_comp_set_callback(
        callback: FuriHalRfidCompCallback,
        context: *mut core::ffi::c_void,
    );
}
pub type ReturnCode = u16;
extern "C" {
    #[doc = " \\brief  Calculate Timer"]
    #[doc = ""]
    #[doc = " This method calculates when the timer will be expired given the amount"]
    #[doc = " time in milliseconds /a tOut."]
    #[doc = " Once the timer has been calculated it will then be used to check when"]
    #[doc = " it expires."]
    #[doc = ""]
    #[doc = " \\see timersIsExpired"]
    #[doc = ""]
    #[doc = " \\param[in]  time : time/duration in Milliseconds for the timer"]
    #[doc = ""]
    #[doc = " \\return u32 : The new timer calculated based on the given time"]
    #[doc = ""]
    pub fn timerCalculateTimer(time: u16) -> u32;
}
extern "C" {
    #[doc = " \\brief  Checks if a Timer is Expired"]
    #[doc = ""]
    #[doc = " This method checks if a timer has already expired."]
    #[doc = " Based on the given timer previously calculated it checks if this timer"]
    #[doc = " has already elapsed"]
    #[doc = ""]
    #[doc = " \\see timersCalculateTimer"]
    #[doc = ""]
    #[doc = " \\param[in]  timer : the timer to check"]
    #[doc = ""]
    #[doc = " \\return true  : timer has already expired"]
    #[doc = " \\return false : timer is still running"]
    #[doc = ""]
    pub fn timerIsExpired(timer: u32) -> bool;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: core::ffi::c_int) -> f32;
}
extern "C" {
    #[doc = " \\brief  RFAL Turn Field On and Start GT"]
    #[doc = ""]
    #[doc = " Turns the Field On, performing Initial Collision Avoidance"]
    #[doc = ""]
    #[doc = " After Field On, if GT was set before, it starts the GT timer to be"]
    #[doc = " used on the following communications."]
    #[doc = ""]
    #[doc = " \\return ERR_RF_COLLISION : External field detected"]
    #[doc = " \\return ERR_NONE         : Field turned On"]
    #[doc = ""]
    #[doc = ""]
    pub fn rfalFieldOnAndStartGT() -> ReturnCode;
}
extern "C" {
    #[doc = "  \\brief RFAL Worker"]
    #[doc = ""]
    #[doc = "  This runs RFAL layer, which drives the actual Transceive procedure"]
    #[doc = "  It MUST be executed frequently in order to execute the RFAL internal"]
    #[doc = "  states and perform the requested operations"]
    #[doc = ""]
    #[doc = ""]
    pub fn rfalWorker();
}
extern "C" {
    #[doc = " \\brief Low Power Mode Start"]
    #[doc = ""]
    #[doc = " Sets the RF Chip in Low Power Mode."]
    #[doc = " In this mode the RF Chip is placed in Low Power Mode, similar to Wake-up"]
    #[doc = " mode but no operation nor period measurement is performed."]
    #[doc = " Mode must be terminated by rfalLowPowerModeStop()"]
    #[doc = ""]
    #[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
    #[doc = " \\return ERR_PARAM       : Invalid parameter"]
    #[doc = " \\return ERR_NONE        : Done with no error"]
    #[doc = ""]
    #[doc = ""]
    pub fn rfalLowPowerModeStart() -> ReturnCode;
}
extern "C" {
    #[doc = " \\brief Low Power Mode Stop"]
    #[doc = ""]
    #[doc = " Stops the Low Power Mode re-enabling the device"]
    #[doc = ""]
    #[doc = " \\return ERR_WRONG_STATE : Not initialized properly"]
    #[doc = " \\return ERR_PARAM       : Invalid parameter"]
    #[doc = " \\return ERR_NONE        : Done with no error"]
    #[doc = ""]
    #[doc = ""]
    pub fn rfalLowPowerModeStop() -> ReturnCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DigitalSignal {
    pub start_level: bool,
    pub edge_cnt: u32,
    pub edges_max_cnt: u32,
    pub edge_timings: *mut u32,
    pub reload_reg_buff: *mut u32,
}
#[test]
fn bindgen_test_layout_DigitalSignal() {
    const UNINIT: ::core::mem::MaybeUninit<DigitalSignal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DigitalSignal>(),
        32usize,
        concat!("Size of: ", stringify!(DigitalSignal))
    );
    assert_eq!(
        ::core::mem::align_of::<DigitalSignal>(),
        8usize,
        concat!("Alignment of ", stringify!(DigitalSignal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(start_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edge_cnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(edge_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edges_max_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(edges_max_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edge_timings) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(edge_timings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reload_reg_buff) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(reload_reg_buff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcaSignal {
    pub one: *mut DigitalSignal,
    pub zero: *mut DigitalSignal,
    pub tx_signal: *mut DigitalSignal,
}
#[test]
fn bindgen_test_layout_NfcaSignal() {
    const UNINIT: ::core::mem::MaybeUninit<NfcaSignal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcaSignal>(),
        24usize,
        concat!("Size of: ", stringify!(NfcaSignal))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcaSignal>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcaSignal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcaSignal),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcaSignal),
            "::",
            stringify!(zero)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_signal) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcaSignal),
            "::",
            stringify!(tx_signal)
        )
    );
}
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeDefault: FuriHalNfcTxRxType = 0;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRxNoCrc: FuriHalNfcTxRxType = 1;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRxKeepPar: FuriHalNfcTxRxType = 2;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRaw: FuriHalNfcTxRxType = 3;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRxRaw: FuriHalNfcTxRxType = 4;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTransparent: FuriHalNfcTxRxType = 5;
pub type FuriHalNfcTxRxType = core::ffi::c_uchar;
pub type FuriHalNfcEmulateCallback = ::core::option::Option<
    unsafe extern "C" fn(
        buff_rx: *mut u8,
        buff_rx_len: u16,
        buff_tx: *mut u8,
        buff_tx_len: *mut u16,
        flags: *mut u32,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
pub const FuriHalNfcType_FuriHalNfcTypeA: FuriHalNfcType = 0;
pub const FuriHalNfcType_FuriHalNfcTypeB: FuriHalNfcType = 1;
pub const FuriHalNfcType_FuriHalNfcTypeF: FuriHalNfcType = 2;
pub const FuriHalNfcType_FuriHalNfcTypeV: FuriHalNfcType = 3;
pub type FuriHalNfcType = core::ffi::c_uchar;
pub const FuriHalNfcInterface_FuriHalNfcInterfaceRf: FuriHalNfcInterface = 0;
pub const FuriHalNfcInterface_FuriHalNfcInterfaceIsoDep: FuriHalNfcInterface = 1;
pub const FuriHalNfcInterface_FuriHalNfcInterfaceNfcDep: FuriHalNfcInterface = 2;
pub type FuriHalNfcInterface = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalNfcDevData {
    pub type_: FuriHalNfcType,
    pub interface: FuriHalNfcInterface,
    pub uid_len: u8,
    pub uid: [u8; 10usize],
    pub cuid: u32,
    pub atqa: [u8; 2usize],
    pub sak: u8,
}
#[test]
fn bindgen_test_layout_FuriHalNfcDevData() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalNfcDevData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalNfcDevData>(),
        24usize,
        concat!("Size of: ", stringify!(FuriHalNfcDevData))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalNfcDevData>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalNfcDevData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(uid_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atqa) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(atqa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(sak)
        )
    );
}
pub type FuriHalNfcTxRxSniffCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut u8,
        bits: u16,
        crc_dropped: bool,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalNfcTxRxContext {
    pub tx_data: [u8; 512usize],
    pub tx_parity: [u8; 64usize],
    pub tx_bits: u16,
    pub rx_data: [u8; 512usize],
    pub rx_parity: [u8; 64usize],
    pub rx_bits: u16,
    pub tx_rx_type: FuriHalNfcTxRxType,
    pub nfca_signal: *mut NfcaSignal,
    pub sniff_tx: FuriHalNfcTxRxSniffCallback,
    pub sniff_rx: FuriHalNfcTxRxSniffCallback,
    pub sniff_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalNfcTxRxContext() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalNfcTxRxContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalNfcTxRxContext>(),
        1192usize,
        concat!("Size of: ", stringify!(FuriHalNfcTxRxContext))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalNfcTxRxContext>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalNfcTxRxContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_parity) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bits) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_data) as usize - ptr as usize },
        578usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(rx_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_parity) as usize - ptr as usize },
        1090usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(rx_parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bits) as usize - ptr as usize },
        1154usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(rx_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_rx_type) as usize - ptr as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_rx_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nfca_signal) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(nfca_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniff_tx) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(sniff_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniff_rx) as usize - ptr as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(sniff_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniff_context) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(sniff_context)
        )
    );
}
extern "C" {
    #[doc = " Check if nfc worker is busy"]
    #[doc = ""]
    #[doc = " @return     true if busy"]
    pub fn furi_hal_nfc_is_busy() -> bool;
}
extern "C" {
    #[doc = " Check if nfc is initialized"]
    #[doc = ""]
    #[doc = " @return     true if initialized"]
    pub fn furi_hal_nfc_is_init() -> bool;
}
extern "C" {
    #[doc = " NFC field on"]
    pub fn furi_hal_nfc_field_on();
}
extern "C" {
    #[doc = " NFC field off"]
    pub fn furi_hal_nfc_field_off();
}
extern "C" {
    #[doc = " NFC start sleep"]
    pub fn furi_hal_nfc_start_sleep();
}
extern "C" {
    pub fn furi_hal_nfc_stop_cmd();
}
extern "C" {
    #[doc = " NFC stop sleep"]
    pub fn furi_hal_nfc_exit_sleep();
}
extern "C" {
    #[doc = " NFC poll"]
    #[doc = ""]
    #[doc = " @param      dev_list    pointer to rfalNfcDevice buffer"]
    #[doc = " @param      dev_cnt     pointer device count"]
    #[doc = " @param      timeout     timeout in ms"]
    #[doc = " @param      deactivate  deactivate flag"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_nfc_detect(nfc_data: *mut FuriHalNfcDevData, timeout: u32) -> bool;
}
extern "C" {
    #[doc = " Activate NFC-A tag"]
    #[doc = ""]
    #[doc = " @param      timeout      timeout in ms"]
    #[doc = " @param      cuid         pointer to 32bit uid"]
    #[doc = ""]
    #[doc = " @return     true on succeess"]
    pub fn furi_hal_nfc_activate_nfca(timeout: u32, cuid: *mut u32) -> bool;
}
extern "C" {
    #[doc = " NFC listen"]
    #[doc = ""]
    #[doc = " @param      uid                 pointer to uid buffer"]
    #[doc = " @param      uid_len             uid length"]
    #[doc = " @param      atqa                pointer to atqa"]
    #[doc = " @param      sak                 sak"]
    #[doc = " @param      activate_after_sak  activate after sak flag"]
    #[doc = " @param      timeout             timeout in ms"]
    #[doc = ""]
    #[doc = " @return     true on success"]
    pub fn furi_hal_nfc_listen(
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
        activate_after_sak: bool,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Start Target Listen mode"]
    #[doc = " @note RFAL free implementation"]
    #[doc = ""]
    #[doc = " @param       nfc_data            FuriHalNfcDevData instance"]
    pub fn furi_hal_nfc_listen_start(nfc_data: *mut FuriHalNfcDevData);
}
extern "C" {
    #[doc = " Read data in Target Listen mode"]
    #[doc = " @note Must be called only after furi_hal_nfc_listen_start()"]
    #[doc = ""]
    #[doc = " @param       tx_rx               FuriHalNfcTxRxContext instance"]
    #[doc = " @param       timeout_ms          timeout im ms"]
    #[doc = ""]
    #[doc = " @return      true on not empty receive"]
    pub fn furi_hal_nfc_listen_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u32) -> bool;
}
extern "C" {
    #[doc = " Set Target in Sleep state"]
    pub fn furi_hal_nfc_listen_sleep();
}
extern "C" {
    #[doc = " Emulate NFC-A Target"]
    #[doc = " @note RFAL based implementation"]
    #[doc = ""]
    #[doc = " @param       uid                 NFC-A UID"]
    #[doc = " @param       uid_len             NFC-A UID length"]
    #[doc = " @param       atqa                NFC-A ATQA"]
    #[doc = " @param       sak                 NFC-A SAK"]
    #[doc = " @param       callback            FuriHalNfcEmulateCallback instance"]
    #[doc = " @param       context             pointer to context for callback"]
    #[doc = " @param       timeout             timeout in ms"]
    #[doc = ""]
    #[doc = " @return      true on success"]
    pub fn furi_hal_nfc_emulate_nfca(
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
        callback: FuriHalNfcEmulateCallback,
        context: *mut core::ffi::c_void,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " NFC data exchange"]
    #[doc = ""]
    #[doc = " @param       tx_rx_ctx   FuriHalNfcTxRxContext instance"]
    #[doc = ""]
    #[doc = " @return      true on success"]
    pub fn furi_hal_nfc_tx_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u16) -> bool;
}
extern "C" {
    #[doc = " NFC data full exhange"]
    #[doc = ""]
    #[doc = " @param       tx_rx_ctx   FuriHalNfcTxRxContext instance"]
    #[doc = ""]
    #[doc = " @return      true on success"]
    pub fn furi_hal_nfc_tx_rx_full(tx_rx: *mut FuriHalNfcTxRxContext) -> bool;
}
extern "C" {
    #[doc = " NFC deactivate and start sleep"]
    pub fn furi_hal_nfc_sleep();
}
extern "C" {
    pub fn furi_hal_nfc_stop();
}
#[doc = "< no error occurred"]
pub const FuriHalNfcReturn_FuriHalNfcReturnOk: FuriHalNfcReturn = 0;
#[doc = "< not enough memory to perform the requested operation"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNomem: FuriHalNfcReturn = 1;
#[doc = "< device or resource busy"]
pub const FuriHalNfcReturn_FuriHalNfcReturnBusy: FuriHalNfcReturn = 2;
#[doc = "< generic IO error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIo: FuriHalNfcReturn = 3;
#[doc = "< error due to timeout"]
pub const FuriHalNfcReturn_FuriHalNfcReturnTimeout: FuriHalNfcReturn = 4;
pub const FuriHalNfcReturn_FuriHalNfcReturnRequest: FuriHalNfcReturn = 5;
#[doc = "< No message of desired type"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNomsg: FuriHalNfcReturn = 6;
#[doc = "< Parameter error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnParam: FuriHalNfcReturn = 7;
#[doc = "< System error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSystem: FuriHalNfcReturn = 8;
#[doc = "< Framing error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnFraming: FuriHalNfcReturn = 9;
#[doc = "< lost one or more received bytes"]
pub const FuriHalNfcReturn_FuriHalNfcReturnOverrun: FuriHalNfcReturn = 10;
#[doc = "< protocol error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnProto: FuriHalNfcReturn = 11;
#[doc = "< Internal Error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnInternal: FuriHalNfcReturn = 12;
#[doc = "< Call again"]
pub const FuriHalNfcReturn_FuriHalNfcReturnAgain: FuriHalNfcReturn = 13;
#[doc = "< memory corruption"]
pub const FuriHalNfcReturn_FuriHalNfcReturnMemCorrupt: FuriHalNfcReturn = 14;
#[doc = "< not implemented"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNotImplemented: FuriHalNfcReturn = 15;
pub const FuriHalNfcReturn_FuriHalNfcReturnPcCorrupt: FuriHalNfcReturn = 16;
#[doc = "< error sending"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSend: FuriHalNfcReturn = 17;
#[doc = "< indicates error detected but to be ignored"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIgnore: FuriHalNfcReturn = 18;
#[doc = "< indicates error in state machine (unexpected cmd)"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSemantic: FuriHalNfcReturn = 19;
#[doc = "< indicates error in state machine (unknown cmd)"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSyntax: FuriHalNfcReturn = 20;
#[doc = "< crc error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnCrc: FuriHalNfcReturn = 21;
#[doc = "< transponder not found"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNotfound: FuriHalNfcReturn = 22;
pub const FuriHalNfcReturn_FuriHalNfcReturnNotunique: FuriHalNfcReturn = 23;
#[doc = "< requested operation not supported"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNotsupp: FuriHalNfcReturn = 24;
#[doc = "< write error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnWrite: FuriHalNfcReturn = 25;
#[doc = "< fifo over or underflow error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnFifo: FuriHalNfcReturn = 26;
#[doc = "< parity error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnPar: FuriHalNfcReturn = 27;
#[doc = "< transfer has already finished"]
pub const FuriHalNfcReturn_FuriHalNfcReturnDone: FuriHalNfcReturn = 28;
pub const FuriHalNfcReturn_FuriHalNfcReturnRfCollision: FuriHalNfcReturn = 29;
#[doc = "< lost one or more received bytes"]
pub const FuriHalNfcReturn_FuriHalNfcReturnHwOverrun: FuriHalNfcReturn = 30;
#[doc = "< device requested release"]
pub const FuriHalNfcReturn_FuriHalNfcReturnReleaseReq: FuriHalNfcReturn = 31;
#[doc = "< device requested sleep"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSleepReq: FuriHalNfcReturn = 32;
#[doc = "< incorrent state for requested operation"]
pub const FuriHalNfcReturn_FuriHalNfcReturnWrongState: FuriHalNfcReturn = 33;
#[doc = "< blocking procedure reached maximum runs"]
pub const FuriHalNfcReturn_FuriHalNfcReturnMaxReruns: FuriHalNfcReturn = 34;
#[doc = "< operation aborted due to disabled configuration"]
pub const FuriHalNfcReturn_FuriHalNfcReturnDisabled: FuriHalNfcReturn = 35;
#[doc = "< expected hw do not match"]
pub const FuriHalNfcReturn_FuriHalNfcReturnHwMismatch: FuriHalNfcReturn = 36;
pub const FuriHalNfcReturn_FuriHalNfcReturnLinkLoss: FuriHalNfcReturn = 37;
#[doc = "< invalid or not initalized device handle"]
pub const FuriHalNfcReturn_FuriHalNfcReturnInvalidHandle: FuriHalNfcReturn = 38;
#[doc = "< Incomplete byte rcvd"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte: FuriHalNfcReturn = 40;
#[doc = "< Incomplete byte rcvd - 1 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte01: FuriHalNfcReturn = 41;
#[doc = "< Incomplete byte rcvd - 2 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte02: FuriHalNfcReturn = 42;
#[doc = "< Incomplete byte rcvd - 3 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte03: FuriHalNfcReturn = 43;
#[doc = "< Incomplete byte rcvd - 4 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte04: FuriHalNfcReturn = 44;
#[doc = "< Incomplete byte rcvd - 5 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte05: FuriHalNfcReturn = 45;
#[doc = "< Incomplete byte rcvd - 6 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte06: FuriHalNfcReturn = 46;
#[doc = "< Incomplete byte rcvd - 7 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte07: FuriHalNfcReturn = 47;
pub type FuriHalNfcReturn = core::ffi::c_uchar;
#[doc = "< No mode selected/defined"]
pub const FuriHalNfcMode_FuriHalNfcModeNone: FuriHalNfcMode = 0;
#[doc = "< Mode to perform as NFCA (ISO14443A) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfca: FuriHalNfcMode = 1;
#[doc = "< Mode to perform as NFCA T1T (Topaz) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcaT1t: FuriHalNfcMode = 2;
#[doc = "< Mode to perform as NFCB (ISO14443B) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcb: FuriHalNfcMode = 3;
#[doc = "< Mode to perform as B' Calypso (Innovatron) (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollBPrime: FuriHalNfcMode = 4;
#[doc = "< Mode to perform as CTS Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollBCts: FuriHalNfcMode = 5;
#[doc = "< Mode to perform as NFCF (FeliCa) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcf: FuriHalNfcMode = 6;
#[doc = "< Mode to perform as NFCV (ISO15963) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcv: FuriHalNfcMode = 7;
#[doc = "< Mode to perform as PicoPass / iClass Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollPicopass: FuriHalNfcMode = 8;
#[doc = "< Mode to perform as Active P2P (ISO18092) Initiator"]
pub const FuriHalNfcMode_FuriHalNfcModePollActiveP2p: FuriHalNfcMode = 9;
#[doc = "< Mode to perform as NFCA (ISO14443A) Listener (PICC)"]
pub const FuriHalNfcMode_FuriHalNfcModeListenNfca: FuriHalNfcMode = 10;
#[doc = "< Mode to perform as NFCA (ISO14443B) Listener (PICC)"]
pub const FuriHalNfcMode_FuriHalNfcModeListenNfcb: FuriHalNfcMode = 11;
#[doc = "< Mode to perform as NFCA (ISO15963) Listener (PICC)"]
pub const FuriHalNfcMode_FuriHalNfcModeListenNfcf: FuriHalNfcMode = 12;
#[doc = "< Mode to perform as Active P2P (ISO18092) Target"]
pub const FuriHalNfcMode_FuriHalNfcModeListenActiveP2p: FuriHalNfcMode = 13;
pub type FuriHalNfcMode = core::ffi::c_uchar;
#[doc = "< Bit Rate 106 kbit/s (fc/128)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate106: FuriHalNfcBitrate = 0;
#[doc = "< Bit Rate 212 kbit/s (fc/64)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate212: FuriHalNfcBitrate = 1;
#[doc = "< Bit Rate 424 kbit/s (fc/32)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate424: FuriHalNfcBitrate = 2;
#[doc = "< Bit Rate 848 kbit/s (fc/16)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate848: FuriHalNfcBitrate = 3;
#[doc = "< Bit Rate 1695 kbit/s (fc/8)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate1695: FuriHalNfcBitrate = 4;
#[doc = "< Bit Rate 3390 kbit/s (fc/4)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate3390: FuriHalNfcBitrate = 5;
#[doc = "< Bit Rate 6780 kbit/s (fc/2)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate6780: FuriHalNfcBitrate = 6;
#[doc = "< Bit Rate 13560 kbit/s (fc)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate13560: FuriHalNfcBitrate = 7;
#[doc = "< Bit Rate 52.97 kbit/s (fc/256) Fast Mode VICC->VCD"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate52p97: FuriHalNfcBitrate = 235;
pub const FuriHalNfcBitrate_FuriHalNfcBitrate26p48: FuriHalNfcBitrate = 236;
#[doc = "< Bit Rate 1,66 kbit/s (fc/8192) NFCV VCD->VICC 1of256"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate1p66: FuriHalNfcBitrate = 237;
#[doc = "< Value indicating to keep the same previous bit rate"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrateKeep: FuriHalNfcBitrate = 255;
pub type FuriHalNfcBitrate = core::ffi::c_uchar;
extern "C" {
    pub fn furi_hal_nfc_ll_set_mode(
        mode: FuriHalNfcMode,
        txBR: FuriHalNfcBitrate,
        rxBR: FuriHalNfcBitrate,
    ) -> FuriHalNfcReturn;
}
extern "C" {
    pub fn furi_hal_nfc_ll_set_guard_time(cycles: u32);
}
#[doc = "< No special error handling will be performed"]
pub const FuriHalNfcErrorHandling_FuriHalNfcErrorHandlingNone: FuriHalNfcErrorHandling = 0;
#[doc = "< Error handling set to perform as NFC compliant device"]
pub const FuriHalNfcErrorHandling_FuriHalNfcErrorHandlingNfc: FuriHalNfcErrorHandling = 1;
pub const FuriHalNfcErrorHandling_FuriHalNfcErrorHandlingEmvco: FuriHalNfcErrorHandling = 2;
pub type FuriHalNfcErrorHandling = core::ffi::c_uchar;
extern "C" {
    pub fn furi_hal_nfc_ll_set_error_handling(eHandling: FuriHalNfcErrorHandling);
}
extern "C" {
    pub fn furi_hal_nfc_ll_set_fdt_listen(cycles: u32);
}
extern "C" {
    pub fn furi_hal_nfc_ll_set_fdt_poll(FDTPoll: u32);
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx_on();
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx_off();
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx(
        txBuf: *mut u8,
        txBufLen: u16,
        rxBuf: *mut u8,
        rxBufLen: u16,
        actLen: *mut u16,
        flags: u32,
        fwt: u32,
    ) -> FuriHalNfcReturn;
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx_bits(
        txBuf: *mut u8,
        txBufLen: u16,
        rxBuf: *mut u8,
        rxBufLen: u16,
        actLen: *mut u16,
        flags: u32,
        fwt: u32,
    ) -> FuriHalNfcReturn;
}
extern "C" {
    pub fn furi_hal_nfc_ll_poll();
}
#[doc = "<\\brief Function has an error, STALLPID will be issued."]
pub const _usbd_respond_usbd_fail: _usbd_respond = 0;
#[doc = "<\\brief Function completes request accepted ZLP or data will be send."]
pub const _usbd_respond_usbd_ack: _usbd_respond = 1;
#[doc = "<\\brief Function is busy. NAK handshake."]
pub const _usbd_respond_usbd_nak: _usbd_respond = 2;
#[doc = "\\brief Reporting status results."]
pub type _usbd_respond = core::ffi::c_uchar;
#[doc = "\\brief Reporting status results."]
pub use self::_usbd_respond as usbd_respond;
#[doc = "\\brief Represents a USB device data."]
pub type usbd_device = _usbd_device;
#[doc = "\\brief Represents generic USB control request."]
#[repr(C)]
#[derive(Debug)]
pub struct usbd_ctlreq {
    #[doc = "<\\brief This bitmapped field identifies the characteristics of"]
    #[doc = " the specific request."]
    pub bmRequestType: u8,
    #[doc = "<\\brief This field specifies the particular request."]
    pub bRequest: u8,
    #[doc = "<\\brief It is used to pass a parameter to the device, specific to"]
    #[doc = " the request."]
    pub wValue: u16,
    #[doc = "<\\brief It is used to pass a parameter to the device, specific to"]
    #[doc = " the request."]
    pub wIndex: u16,
    #[doc = "<\\brief This field specifies the length of the data transferred"]
    #[doc = " during the second phase of the control transfer."]
    pub wLength: u16,
    #[doc = "<\\brief Data payload."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_usbd_ctlreq() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_ctlreq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_ctlreq>(),
        8usize,
        concat!("Size of: ", stringify!(usbd_ctlreq))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_ctlreq>(),
        2usize,
        concat!("Alignment of ", stringify!(usbd_ctlreq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " USB device status data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_status {
    #[doc = "<\\brief Pointer to data buffer used for control requests."]
    pub data_buf: *mut core::ffi::c_void,
    #[doc = "<\\brief Pointer to current data for control request."]
    pub data_ptr: *mut core::ffi::c_void,
    #[doc = "<\\brief Count remained data for control request."]
    pub data_count: u16,
    #[doc = "<\\brief Size of the data buffer for control requests."]
    pub data_maxsize: u16,
    #[doc = "<\\brief Size of the control endpoint."]
    pub ep0size: u8,
    #[doc = "<\\brief Current device configuration number."]
    pub device_cfg: u8,
    #[doc = "<\\brief Current \\ref usbd_machine_state."]
    pub device_state: u8,
    #[doc = "<\\brief Current \\ref usbd_ctl_state."]
    pub control_state: u8,
}
#[test]
fn bindgen_test_layout_usbd_status() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_status> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_status>(),
        24usize,
        concat!("Size of: ", stringify!(usbd_status))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_status>(),
        8usize,
        concat!("Alignment of ", stringify!(usbd_status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_maxsize) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_maxsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep0size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(ep0size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_cfg) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(device_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_state) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(device_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_state) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(control_state)
        )
    );
}
#[doc = "\\brief Generic USB device event callback for events and endpoints processing"]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param event \\ref USB_EVENTS \"USB event\""]
#[doc = " \\param ep active endpoint number"]
#[doc = " \\note endpoints with same indexes i.e. 0x01 and 0x81 shares same callback."]
pub type usbd_evt_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, event: u8, ep: u8)>;
#[doc = "\\brief USB control transfer completed callback function."]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param[in] req pointer to usb request structure"]
#[doc = " \\note usbd_device->complete_callback will be set to NULL after this callback completion."]
pub type usbd_rqc_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, req: *mut usbd_ctlreq)>;
#[doc = "\\brief USB control callback function."]
#[doc = " \\details Uses for the control request processing."]
#[doc = "          Some requests will be handled by core if callback don't process it (returns FALSE)."]
#[doc = "            If request was not processed STALL PID will be issued."]
#[doc = "          - GET_CONFIGURATION"]
#[doc = "          - SET_CONFIGURATION (passes to \\ref usbd_cfg_callback)"]
#[doc = "          - GET_DESCRIPTOR (passes to \\ref usbd_dsc_callback)"]
#[doc = "          - GET_STATUS"]
#[doc = "          - SET_FEATURE, CLEAR_FEATURE (endpoints only)"]
#[doc = "          - SET_ADDRESS"]
#[doc = " \\param[in] dev points to USB device"]
#[doc = " \\param[in] req points to usb control request"]
#[doc = " \\param[out] *callback USB control transfer completion callback, default is NULL (no callback)"]
#[doc = " \\return usbd_respond status."]
pub type usbd_ctl_callback = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut usbd_device,
        req: *mut usbd_ctlreq,
        callback: *mut usbd_rqc_callback,
    ) -> usbd_respond,
>;
#[doc = "\\brief USB get descriptor callback function"]
#[doc = " \\details Called when GET_DESCRIPTOR request issued"]
#[doc = " \\param[in] req pointer to usb control request structure"]
#[doc = " \\param[in,out] address pointer to the descriptor in memory. Points to req->data by default. You"]
#[doc = " can use this buffer."]
#[doc = " \\param[in,out] dsize descriptor size. maximum buffer size by default."]
#[doc = " \\return usbd_ack if you passed the correct descriptor, usbd_fail otherwise."]
pub type usbd_dsc_callback = ::core::option::Option<
    unsafe extern "C" fn(
        req: *mut usbd_ctlreq,
        address: *mut *mut core::ffi::c_void,
        dsize: *mut u16,
    ) -> usbd_respond,
>;
#[doc = "\\brief USB set configuration callback function"]
#[doc = " \\details called when SET_CONFIGURATION request issued"]
#[doc = " \\param[in] dev pointer to USB device"]
#[doc = " \\param[in] cfg configuration number."]
#[doc = " \\note if config is 0 device endpoints should be de-configured"]
#[doc = " \\return TRUE if success"]
pub type usbd_cfg_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, cfg: u8) -> usbd_respond>;
#[doc = "\\addtogroup USBD_HW"]
#[doc = " @{ */"]
#[doc = " \\return Hardware status and capabilities \\ref USBD_HW_CAPS"]
pub type usbd_hw_getinfo = ::core::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = "\\brief Enables or disables USB hardware"]
#[doc = " \\param enable Enables USB when TRUE disables otherwise."]
pub type usbd_hw_enable = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = " Connects or disconnects USB hardware to/from usb host"]
#[doc = " \\param connect Connects USB to host if TRUE, disconnects otherwise"]
#[doc = " \\return lanes connection status."]
pub type usbd_hw_connect = ::core::option::Option<unsafe extern "C" fn(connect: bool) -> u8>;
#[doc = "\\brief Sets USB hardware address"]
#[doc = " \\param address USB address"]
pub type usbd_hw_setaddr = ::core::option::Option<unsafe extern "C" fn(address: u8)>;
#[doc = "\\brief Configures endpoint"]
#[doc = " \\param ep endpoint address. Use USB_EPDIR_ macros to set endpoint direction"]
#[doc = " \\param eptype endpoint type. Use USB_EPTYPE_* macros."]
#[doc = " \\param epsize endpoint size in bytes"]
#[doc = " \\return TRUE if success"]
pub type usbd_hw_ep_config =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, eptype: u8, epsize: u16) -> bool>;
#[doc = "\\brief De-configures, cleans and disables endpoint"]
#[doc = " \\param ep endpoint index"]
#[doc = " \\note if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82)"]
#[doc = " both will be deconfigured."]
pub type usbd_hw_ep_deconfig = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = "\\brief Reads data from OUT or control endpoint"]
#[doc = " \\param ep endpoint index, should belong to OUT or CONTROL endpoint."]
#[doc = " \\param buf pointer to read buffer"]
#[doc = " \\param blen size of the read buffer in bytes"]
#[doc = " \\return size of the actually received data, -1 on error."]
#[doc = " \\note if data does not fit buffer it will be truncated"]
pub type usbd_hw_ep_read = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = "\\brief Writes data to IN or control endpoint"]
#[doc = " \\param ep endpoint index, hould belong to IN or CONTROL endpoint"]
#[doc = " \\param buf pointer to data buffer"]
#[doc = " \\param blen size of data will be written"]
#[doc = " \\return number of written bytes"]
pub type usbd_hw_ep_write = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = " Stalls and unstalls endpoint"]
#[doc = " \\param ep endpoint address"]
#[doc = " \\param stall endpoint will be stalled if TRUE and unstalled otherwise."]
#[doc = " \\note Has no effect on inactive endpoints."]
pub type usbd_hw_ep_setstall = ::core::option::Option<unsafe extern "C" fn(ep: u8, stall: bool)>;
#[doc = "\\brief Checks endpoint for stalled state"]
#[doc = " \\param ep endpoint address"]
#[doc = " \\return TRUE if endpoint is stalled"]
pub type usbd_hw_ep_isstalled = ::core::option::Option<unsafe extern "C" fn(ep: u8) -> bool>;
#[doc = "\\brief Polls USB hardware for the events"]
#[doc = " \\param[in] dev pointer to usb device structure"]
#[doc = " \\param callback callback to event processing subroutine"]
pub type usbd_hw_poll = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut usbd_device, callback: usbd_evt_callback),
>;
#[doc = "\\brief Gets frame number from usb hardware."]
pub type usbd_hw_get_frameno = ::core::option::Option<unsafe extern "C" fn() -> u16>;
#[doc = "\\brief Makes a string descriptor contains unique serial number from hardware ID's"]
#[doc = " \\param[in] buffer pointer to buffer for the descriptor"]
#[doc = " \\return of the descriptor in bytes"]
pub type usbd_hw_get_serialno =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut core::ffi::c_void) -> u16>;
#[doc = "\\brief Represents a hardware USB driver call table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_driver {
    #[doc = "<\\copybrief usbd_hw_getinfo"]
    pub getinfo: usbd_hw_getinfo,
    #[doc = "<\\copybrief usbd_hw_enable"]
    pub enable: usbd_hw_enable,
    #[doc = "<\\copybrief usbd_hw_connect"]
    pub connect: usbd_hw_connect,
    #[doc = "<\\copybrief usbd_hw_setaddr"]
    pub setaddr: usbd_hw_setaddr,
    #[doc = "<\\copybrief usbd_hw_ep_config"]
    pub ep_config: usbd_hw_ep_config,
    #[doc = "<\\copybrief usbd_hw_ep_deconfig"]
    pub ep_deconfig: usbd_hw_ep_deconfig,
    #[doc = "<\\copybrief usbd_hw_ep_read"]
    pub ep_read: usbd_hw_ep_read,
    #[doc = "<\\copybrief usbd_hw_ep_write"]
    pub ep_write: usbd_hw_ep_write,
    #[doc = "<\\copybrief usbd_hw_ep_setstall"]
    pub ep_setstall: usbd_hw_ep_setstall,
    #[doc = "<\\copybrief usbd_hw_ep_isstalled"]
    pub ep_isstalled: usbd_hw_ep_isstalled,
    #[doc = "<\\copybrief usbd_hw_poll"]
    pub poll: usbd_hw_poll,
    #[doc = "<\\copybrief usbd_hw_get_frameno"]
    pub frame_no: usbd_hw_get_frameno,
    #[doc = "<\\copybrief usbd_hw_get_serialno"]
    pub get_serialno_desc: usbd_hw_get_serialno,
}
#[test]
fn bindgen_test_layout_usbd_driver() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_driver> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_driver>(),
        104usize,
        concat!("Size of: ", stringify!(usbd_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(usbd_driver))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(getinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(setaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_config) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_deconfig) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_deconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_read) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_write) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_setstall) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_setstall)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_isstalled) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_isstalled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_no) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(frame_no)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_serialno_desc) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(get_serialno_desc)
        )
    );
}
#[doc = "\\brief Represents a USB device data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usbd_device {
    #[doc = "<\\copybrief usbd_driver"]
    pub driver: *const usbd_driver,
    #[doc = "<\\copybrief usbd_ctl_callback"]
    pub control_callback: usbd_ctl_callback,
    #[doc = "<\\copybrief usbd_rqc_callback"]
    pub complete_callback: usbd_rqc_callback,
    #[doc = "<\\copybrief usbd_cfg_callback"]
    pub config_callback: usbd_cfg_callback,
    #[doc = "<\\copybrief usbd_dsc_callback"]
    pub descriptor_callback: usbd_dsc_callback,
    #[doc = "<\\brief array of the event callbacks."]
    pub events: [usbd_evt_callback; 8usize],
    #[doc = "<\\brief array of the endpoint callbacks."]
    pub endpoint: [usbd_evt_callback; 8usize],
    #[doc = "<\\copybrief usbd_status"]
    pub status: usbd_status,
}
#[test]
fn bindgen_test_layout__usbd_device() {
    const UNINIT: ::core::mem::MaybeUninit<_usbd_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_usbd_device>(),
        192usize,
        concat!("Size of: ", stringify!(_usbd_device))
    );
    assert_eq!(
        ::core::mem::align_of::<_usbd_device>(),
        8usize,
        concat!("Alignment of ", stringify!(_usbd_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(control_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).complete_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(complete_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(config_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descriptor_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(descriptor_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "\\brief Represents a USB device descriptor"]
#[doc = " \\details A device descriptor describes general information about a USB device. It includes"]
#[doc = " information that applies globally to the device and all of the devices configurations. A USB"]
#[doc = " device has only one device descriptor. A high-speed capable device that has different device"]
#[doc = " information for full-speed and high-speed must also  have a \\ref usb_qualifier_descriptor."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_device_descriptor {
    #[doc = "<\\brief Size of the descriptor, in bytes."]
    pub bLength: u8,
    #[doc = "<\\brief \\ref USB_DTYPE_DEVICE Device descriptor."]
    pub bDescriptorType: u8,
    #[doc = "<\\brief BCD of the supported USB specification."]
    pub bcdUSB: u16,
    #[doc = "<\\brief USB device class."]
    pub bDeviceClass: u8,
    #[doc = "<\\brief USB device subclass."]
    pub bDeviceSubClass: u8,
    #[doc = "<\\brief USB device protocol."]
    pub bDeviceProtocol: u8,
    #[doc = "<\\brief Size of the control endpoint's bank in bytes."]
    pub bMaxPacketSize0: u8,
    #[doc = "<\\brief Vendor ID for the USB product."]
    pub idVendor: u16,
    #[doc = "<\\brief Unique product ID for the USB product."]
    pub idProduct: u16,
    #[doc = "<\\brief Product release (version) number."]
    pub bcdDevice: u16,
    #[doc = "<\\brief String index for the manufacturer's name."]
    pub iManufacturer: u8,
    #[doc = "<\\brief String index for the product name/details."]
    pub iProduct: u8,
    #[doc = "<\\brief String index for the product serial number."]
    pub iSerialNumber: u8,
    #[doc = "<\\brief Total number of configurations supported by the device."]
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<usb_device_descriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_device_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcdUSB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceClass) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceSubClass) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceProtocol) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bMaxPacketSize0) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idVendor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idProduct) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcdDevice) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iManufacturer) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iProduct) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iSerialNumber) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bNumConfigurations) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
extern "C" {
    pub static usbd_devfs: usbd_driver;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalUsbInterface {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut usbd_device,
            intf: *mut FuriHalUsbInterface,
            ctx: *mut core::ffi::c_void,
        ),
    >,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub wakeup: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub dev_descr: *mut usb_device_descriptor,
    pub str_manuf_descr: *mut core::ffi::c_void,
    pub str_prod_descr: *mut core::ffi::c_void,
    pub str_serial_descr: *mut core::ffi::c_void,
    pub cfg_descr: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalUsbInterface() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalUsbInterface> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalUsbInterface>(),
        72usize,
        concat!("Size of: ", stringify!(FuriHalUsbInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalUsbInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalUsbInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wakeup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_descr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(dev_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_manuf_descr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_manuf_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_prod_descr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_prod_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_serial_descr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_serial_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfg_descr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(cfg_descr)
        )
    );
}
extern "C" {
    #[doc = " USB device interface modes"]
    pub static mut usb_cdc_single: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_cdc_dual: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_hid: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_hid_u2f: FuriHalUsbInterface;
}
extern "C" {
    #[doc = " Set USB device configuration"]
    #[doc = ""]
    #[doc = " @param      mode new USB device mode"]
    #[doc = " @param      ctx context passed to device mode init function"]
    #[doc = " @return     true - mode switch started, false - mode switch is locked"]
    pub fn furi_hal_usb_set_config(
        new_if: *mut FuriHalUsbInterface,
        ctx: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Get USB device configuration"]
    #[doc = ""]
    #[doc = " @return    current USB device mode"]
    pub fn furi_hal_usb_get_config() -> *mut FuriHalUsbInterface;
}
extern "C" {
    #[doc = " Lock USB device mode switch"]
    pub fn furi_hal_usb_lock();
}
extern "C" {
    #[doc = " Unlock USB device mode switch"]
    pub fn furi_hal_usb_unlock();
}
extern "C" {
    #[doc = " Check if USB device mode switch locked"]
    #[doc = ""]
    #[doc = " @return    lock state"]
    pub fn furi_hal_usb_is_locked() -> bool;
}
extern "C" {
    #[doc = " Disable USB device"]
    pub fn furi_hal_usb_disable();
}
extern "C" {
    #[doc = " Enable USB device"]
    pub fn furi_hal_usb_enable();
}
extern "C" {
    #[doc = " Restart USB device"]
    pub fn furi_hal_usb_reinit();
}
pub type HidStateCallback =
    ::core::option::Option<unsafe extern "C" fn(state: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Get USB HID connection state"]
    #[doc = ""]
    #[doc = " @return      true / false"]
    pub fn furi_hal_hid_is_connected() -> bool;
}
extern "C" {
    #[doc = " Get USB HID keyboard leds state"]
    #[doc = ""]
    #[doc = " @return      leds state"]
    pub fn furi_hal_hid_get_led_state() -> u8;
}
extern "C" {
    #[doc = " Set USB HID connect/disconnect callback"]
    #[doc = ""]
    #[doc = " @param      cb  callback"]
    #[doc = " @param      ctx  callback context"]
    pub fn furi_hal_hid_set_state_callback(cb: HidStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set the following key to pressed state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_hid_kb_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set the following key to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_hid_kb_release(button: u16) -> bool;
}
extern "C" {
    #[doc = " Clear all pressed keys and send HID report"]
    #[doc = ""]
    pub fn furi_hal_hid_kb_release_all() -> bool;
}
extern "C" {
    #[doc = " Set mouse movement and send HID report"]
    #[doc = ""]
    #[doc = " @param      dx  x coordinate delta"]
    #[doc = " @param      dy  y coordinate delta"]
    pub fn furi_hal_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to pressed state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse wheel position and send HID report"]
    #[doc = ""]
    #[doc = " @param      delta  number of scroll steps"]
    pub fn furi_hal_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to pressed state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_hid_consumer_key_release(button: u16) -> bool;
}
#[doc = " Callback type called every time another key-value pair of device information is ready"]
#[doc = ""]
#[doc = " @param      key[in]      device information type identifier"]
#[doc = " @param      value[in]    device information value"]
#[doc = " @param      last[in]     whether the passed key-value pair is the last one"]
#[doc = " @param      context[in]  to pass to callback"]
pub type FuriHalInfoValueCallback = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        last: bool,
        context: *mut core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = " Get device information"]
    #[doc = ""]
    #[doc = " @param[in]  callback     callback to provide with new data"]
    #[doc = " @param[in]  context      context to pass to callback"]
    pub fn furi_hal_info_get(callback: FuriHalInfoValueCallback, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Get random value"]
    #[doc = ""]
    #[doc = " @return     random value"]
    pub fn furi_hal_random_get() -> u32;
}
extern "C" {
    #[doc = " Fill buffer with random data"]
    #[doc = ""]
    #[doc = " @param      buf  buffer pointer"]
    #[doc = " @param      data buffer len"]
    pub fn furi_hal_random_fill_buf(buf: *mut u8, len: u32);
}
extern "C" {
    #[doc = " Transfer execution to address"]
    #[doc = ""]
    #[doc = " @param[in]  address  pointer to new executable"]
    pub fn furi_hal_switch(address: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Start Hid Keyboard Profile"]
    pub fn furi_hal_bt_hid_start();
}
extern "C" {
    #[doc = " Stop Hid Keyboard Profile"]
    pub fn furi_hal_bt_hid_stop();
}
extern "C" {
    #[doc = " Press keyboard button"]
    #[doc = ""]
    #[doc = " @param button    button code from HID specification"]
    #[doc = ""]
    #[doc = " @return          true on success"]
    pub fn furi_hal_bt_hid_kb_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Release keyboard button"]
    #[doc = ""]
    #[doc = " @param button    button code from HID specification"]
    #[doc = ""]
    #[doc = " @return          true on success"]
    pub fn furi_hal_bt_hid_kb_release(button: u16) -> bool;
}
extern "C" {
    #[doc = " Release all keyboard buttons"]
    #[doc = ""]
    #[doc = " @return          true on success"]
    pub fn furi_hal_bt_hid_kb_release_all() -> bool;
}
extern "C" {
    #[doc = " Set mouse movement and send HID report"]
    #[doc = ""]
    #[doc = " @param      dx  x coordinate delta"]
    #[doc = " @param      dy  y coordinate delta"]
    pub fn furi_hal_bt_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to pressed state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_bt_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_bt_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_bt_hid_mouse_release_all() -> bool;
}
extern "C" {
    #[doc = " Set mouse wheel position and send HID report"]
    #[doc = ""]
    #[doc = " @param      delta  number of scroll steps"]
    pub fn furi_hal_bt_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to pressed state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_bt_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_bt_hid_consumer_key_release(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set consumer key to released state and send HID report"]
    #[doc = ""]
    #[doc = " @param      button  key code"]
    pub fn furi_hal_bt_hid_consumer_key_release_all() -> bool;
}
#[doc = "< New data obtained"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateOk:
    FuriHalInfraredTxGetDataState = 0;
#[doc = "< New data obtained, and this is end of package"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateDone:
    FuriHalInfraredTxGetDataState = 1;
#[doc = "< New data obtained, and this is end of package and no more data available"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateLastDone:
    FuriHalInfraredTxGetDataState = 2;
pub type FuriHalInfraredTxGetDataState = core::ffi::c_uchar;
#[doc = " Callback type for providing data to INFRARED DMA TX system. It is called every tim"]
pub type FuriHalInfraredTxGetDataISRCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        duration: *mut u32,
        level: *mut bool,
    ) -> FuriHalInfraredTxGetDataState,
>;
#[doc = " Callback type called every time signal is sent by DMA to Timer."]
#[doc = ""]
#[doc = " Actually, it means there are 2 timings left to send for this signal, which is"]
#[doc = " almost end. Don't use this callback to stop transmission, as far as there are"]
#[doc = " next signal is charged for transmission by DMA."]
pub type FuriHalInfraredTxSignalSentISRCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Signature of callback function for receiving continuous INFRARED rx signal."]
#[doc = ""]
#[doc = " @param      ctx[in]       context to pass to callback"]
#[doc = " @param      level[in]     level of input INFRARED rx signal"]
#[doc = " @param      duration[in]  duration of continuous rx signal level in us"]
pub type FuriHalInfraredRxCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut core::ffi::c_void, level: bool, duration: u32),
>;
#[doc = " Signature of callback function for reaching silence timeout on INFRARED port."]
#[doc = ""]
#[doc = " @param      ctx[in]  context to pass to callback"]
pub type FuriHalInfraredRxTimeoutCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Initialize INFRARED RX timer to receive interrupts."]
    #[doc = ""]
    #[doc = " It provides interrupts for every RX-signal edge changing with its duration."]
    pub fn furi_hal_infrared_async_rx_start();
}
extern "C" {
    #[doc = " Deinitialize INFRARED RX interrupt."]
    pub fn furi_hal_infrared_async_rx_stop();
}
extern "C" {
    #[doc = " Setup hal for receiving silence timeout."]
    #[doc = ""]
    #[doc = " Should be used with 'furi_hal_infrared_timeout_irq_set_callback()'."]
    #[doc = ""]
    #[doc = " @param[in]  timeout_us  time to wait for silence on INFRARED port before"]
    #[doc = "                         generating IRQ."]
    pub fn furi_hal_infrared_async_rx_set_timeout(timeout_us: u32);
}
extern "C" {
    #[doc = " Setup callback for previously initialized INFRARED RX interrupt."]
    #[doc = ""]
    #[doc = " @param[in]  callback  callback to call when RX signal edge changing occurs"]
    #[doc = " @param[in]  ctx       context for callback"]
    pub fn furi_hal_infrared_async_rx_set_capture_isr_callback(
        callback: FuriHalInfraredRxCaptureCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Setup callback for reaching silence timeout on INFRARED port."]
    #[doc = ""]
    #[doc = " Should setup hal with 'furi_hal_infrared_setup_rx_timeout_irq()' first."]
    #[doc = ""]
    #[doc = " @param[in]  callback  callback for silence timeout"]
    #[doc = " @param[in]  ctx       context to pass to callback"]
    pub fn furi_hal_infrared_async_rx_set_timeout_isr_callback(
        callback: FuriHalInfraredRxTimeoutCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Check if INFRARED is in use now."]
    #[doc = ""]
    #[doc = " @return     true if INFRARED is busy, false otherwise."]
    pub fn furi_hal_infrared_is_busy() -> bool;
}
extern "C" {
    #[doc = " Set callback providing new data."]
    #[doc = ""]
    #[doc = " This function has to be called before furi_hal_infrared_async_tx_start()."]
    #[doc = ""]
    #[doc = " @param[in]  callback  function to provide new data"]
    #[doc = " @param[in]  context   context for callback"]
    pub fn furi_hal_infrared_async_tx_set_data_isr_callback(
        callback: FuriHalInfraredTxGetDataISRCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start IR asynchronous transmission."]
    #[doc = ""]
    #[doc = " It can be stopped by 2 reasons:"]
    #[doc = " 1. implicit call for furi_hal_infrared_async_tx_stop()"]
    #[doc = " 2. callback can provide FuriHalInfraredTxGetDataStateLastDone response which"]
    #[doc = "    means no more data available for transmission."]
    #[doc = ""]
    #[doc = " Any func (furi_hal_infrared_async_tx_stop() or"]
    #[doc = " furi_hal_infrared_async_tx_wait_termination()) has to be called to wait end of"]
    #[doc = " transmission and free resources."]
    #[doc = ""]
    #[doc = " @param[in]  freq        frequency for PWM"]
    #[doc = " @param[in]  duty_cycle  duty cycle for PWM"]
    pub fn furi_hal_infrared_async_tx_start(freq: u32, duty_cycle: f32);
}
extern "C" {
    #[doc = " Stop IR asynchronous transmission and free resources."]
    #[doc = ""]
    #[doc = " Transmission will stop as soon as transmission reaches end of package"]
    #[doc = " (FuriHalInfraredTxGetDataStateDone or FuriHalInfraredTxGetDataStateLastDone)."]
    pub fn furi_hal_infrared_async_tx_stop();
}
extern "C" {
    #[doc = " Wait for end of IR asynchronous transmission and free resources."]
    #[doc = ""]
    #[doc = " Transmission will stop as soon as transmission reaches end of transmission"]
    #[doc = " (FuriHalInfraredTxGetDataStateLastDone)."]
    pub fn furi_hal_infrared_async_tx_wait_termination();
}
extern "C" {
    #[doc = " Set callback for end of signal transmission"]
    #[doc = ""]
    #[doc = " @param[in]  callback  function to call when signal is sent"]
    #[doc = " @param[in]  context   context for callback"]
    pub fn furi_hal_infrared_async_tx_set_signal_sent_isr_callback(
        callback: FuriHalInfraredTxSignalSentISRCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Init memory pool manager"]
    pub fn furi_hal_memory_init();
}
extern "C" {
    #[doc = " @brief Allocate memory from separate memory pool. That memory can't be freed."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = " @return void*"]
    pub fn furi_hal_memory_alloc(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Get free memory pool size"]
    #[doc = ""]
    #[doc = " @return size_t"]
    pub fn furi_hal_memory_get_free() -> usize;
}
extern "C" {
    #[doc = " @brief Get max free block size from memory pool"]
    #[doc = ""]
    #[doc = " @return size_t"]
    pub fn furi_hal_memory_max_pool_block() -> usize;
}
pub const FuriHalMpuRegion_FuriHalMpuRegionNULL: FuriHalMpuRegion = 0;
pub const FuriHalMpuRegion_FuriHalMpuRegionStack: FuriHalMpuRegion = 1;
pub const FuriHalMpuRegion_FuriHalMpuRegion2: FuriHalMpuRegion = 2;
pub const FuriHalMpuRegion_FuriHalMpuRegion3: FuriHalMpuRegion = 3;
pub const FuriHalMpuRegion_FuriHalMpuRegion4: FuriHalMpuRegion = 4;
pub const FuriHalMpuRegion_FuriHalMpuRegion5: FuriHalMpuRegion = 5;
pub const FuriHalMpuRegion_FuriHalMpuRegion6: FuriHalMpuRegion = 6;
pub const FuriHalMpuRegion_FuriHalMpuRegion7: FuriHalMpuRegion = 7;
pub type FuriHalMpuRegion = core::ffi::c_uchar;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32B: FuriHalMPURegionSize = 4;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64B: FuriHalMPURegionSize = 5;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128B: FuriHalMPURegionSize = 6;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256B: FuriHalMPURegionSize = 7;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512B: FuriHalMPURegionSize = 8;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1KB: FuriHalMPURegionSize = 9;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2KB: FuriHalMPURegionSize = 10;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4KB: FuriHalMPURegionSize = 11;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize8KB: FuriHalMPURegionSize = 12;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize16KB: FuriHalMPURegionSize = 13;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32KB: FuriHalMPURegionSize = 14;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64KB: FuriHalMPURegionSize = 15;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128KB: FuriHalMPURegionSize = 16;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256KB: FuriHalMPURegionSize = 17;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512KB: FuriHalMPURegionSize = 18;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1MB: FuriHalMPURegionSize = 19;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2MB: FuriHalMPURegionSize = 20;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4MB: FuriHalMPURegionSize = 21;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize8MB: FuriHalMPURegionSize = 22;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize16MB: FuriHalMPURegionSize = 23;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32MB: FuriHalMPURegionSize = 24;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64MB: FuriHalMPURegionSize = 25;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128MB: FuriHalMPURegionSize = 26;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256MB: FuriHalMPURegionSize = 27;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512MB: FuriHalMPURegionSize = 28;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1GB: FuriHalMPURegionSize = 29;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2GB: FuriHalMPURegionSize = 30;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4GB: FuriHalMPURegionSize = 31;
pub type FuriHalMPURegionSize = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Enable memory protection unit"]
    pub fn furi_hal_mpu_enable();
}
extern "C" {
    #[doc = " @brief Disable memory protection unit"]
    pub fn furi_hal_mpu_disable();
}
extern "C" {
    pub fn furi_hal_mpu_protect_no_access(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
extern "C" {
    pub fn furi_hal_mpu_protect_read_only(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
extern "C" {
    pub fn furi_hal_mpu_protect_disable(region: FuriHalMpuRegion);
}
pub const HidU2fEvent_HidU2fDisconnected: HidU2fEvent = 0;
pub const HidU2fEvent_HidU2fConnected: HidU2fEvent = 1;
pub const HidU2fEvent_HidU2fRequest: HidU2fEvent = 2;
pub type HidU2fEvent = core::ffi::c_uchar;
pub type HidU2fCallback =
    ::core::option::Option<unsafe extern "C" fn(ev: HidU2fEvent, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Get HID U2F connection state"]
    #[doc = ""]
    #[doc = " @return      true / false"]
    pub fn furi_hal_hid_u2f_is_connected() -> bool;
}
extern "C" {
    #[doc = " Set HID U2F event callback"]
    #[doc = ""]
    #[doc = " @param      cb  callback"]
    #[doc = " @param      ctx  callback context"]
    pub fn furi_hal_hid_u2f_set_callback(cb: HidU2fCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Get received U2F HID packet"]
    #[doc = ""]
    pub fn furi_hal_hid_u2f_get_request(data: *mut u8) -> u32;
}
extern "C" {
    #[doc = " Send U2F HID response packet"]
    #[doc = ""]
    #[doc = " @param      data  response data"]
    #[doc = " @param      len  packet length"]
    pub fn furi_hal_hid_u2f_send_response(data: *mut u8, len: u8);
}
#[doc = " @brief  Structure definition of some features of COMP instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_COMP_InitTypeDef {
    #[doc = "< Set comparator operating mode to adjust power and speed."]
    #[doc = "This parameter can be a value of @ref COMP_LL_EC_POWERMODE"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetPowerMode()."]
    pub PowerMode: u32,
    #[doc = "< Set comparator input plus (non-inverting input)."]
    #[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_PLUS"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputPlus()."]
    pub InputPlus: u32,
    #[doc = "< Set comparator input minus (inverting input)."]
    #[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_MINUS"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputMinus()."]
    pub InputMinus: u32,
    #[doc = "< Set comparator hysteresis mode of the input minus."]
    #[doc = "This parameter can be a value of @ref COMP_LL_EC_INPUT_HYSTERESIS"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetInputHysteresis()."]
    pub InputHysteresis: u32,
    #[doc = "< Set comparator output polarity."]
    #[doc = "This parameter can be a value of @ref COMP_LL_EC_OUTPUT_POLARITY"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputPolarity()."]
    pub OutputPolarity: u32,
    #[doc = "< Set comparator blanking source."]
    #[doc = "This parameter can be a value of @ref COMP_LL_EC_OUTPUT_BLANKING_SOURCE"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputBlankingSource()."]
    pub OutputBlankingSource: u32,
}
#[test]
fn bindgen_test_layout_LL_COMP_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_COMP_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_COMP_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(LL_COMP_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_COMP_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_COMP_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(PowerMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputPlus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputPlus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputMinus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputMinus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputHysteresis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputHysteresis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputPolarity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(OutputPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBlankingSource) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(OutputBlankingSource)
        )
    );
}
extern "C" {
    pub fn LL_COMP_Init(
        COMPx: *mut COMP_TypeDef,
        COMP_InitStruct: *mut LL_COMP_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " @defgroup DMA_LL_ES_INIT DMA Exported Init structure"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_DMA_InitTypeDef {
    #[doc = "< Specifies the peripheral base address for DMA transfer"]
    #[doc = "or as Source base address in case of memory to memory transfer direction."]
    #[doc = ""]
    #[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
    pub PeriphOrM2MSrcAddress: u32,
    #[doc = "< Specifies the memory base address for DMA transfer"]
    #[doc = "or as Destination base address in case of memory to memory transfer direction."]
    #[doc = ""]
    #[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
    pub MemoryOrM2MDstAddress: u32,
    #[doc = "< Specifies if the data will be transferred from memory to peripheral,"]
    #[doc = "from memory to memory or from peripheral to memory."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_DIRECTION"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataTransferDirection()."]
    pub Direction: u32,
    #[doc = "< Specifies the normal or circular operation mode."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_MODE"]
    #[doc = "@note: The circular buffer mode cannot be used if the memory to memory"]
    #[doc = "data transfer direction is configured on the selected Channel"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMode()."]
    pub Mode: u32,
    #[doc = "< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction"]
    #[doc = "is incremented or not."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_PERIPH"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphIncMode()."]
    pub PeriphOrM2MSrcIncMode: u32,
    #[doc = "< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction"]
    #[doc = "is incremented or not."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_MEMORY"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemoryIncMode()."]
    pub MemoryOrM2MDstIncMode: u32,
    #[doc = "< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)"]
    #[doc = "in case of memory to memory transfer direction."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_PDATAALIGN"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphSize()."]
    pub PeriphOrM2MSrcDataSize: u32,
    #[doc = "< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)"]
    #[doc = "in case of memory to memory transfer direction."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_MDATAALIGN"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetMemorySize()."]
    pub MemoryOrM2MDstDataSize: u32,
    #[doc = "< Specifies the number of data to transfer, in data unit."]
    #[doc = "The data unit is equal to the source buffer configuration set in PeripheralSize"]
    #[doc = "or MemorySize parameters depending in the transfer direction."]
    #[doc = "This parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetDataLength()."]
    pub NbData: u32,
    #[doc = "< Specifies the peripheral request."]
    #[doc = "This parameter can be a value of @ref DMAMUX_LL_EC_REQUEST"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphRequest()."]
    pub PeriphRequest: u32,
    #[doc = "< Specifies the channel priority level."]
    #[doc = "This parameter can be a value of @ref DMA_LL_EC_PRIORITY"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function @ref LL_DMA_SetChannelPriorityLevel()."]
    pub Priority: u32,
}
#[test]
fn bindgen_test_layout_LL_DMA_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_DMA_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_DMA_InitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(LL_DMA_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_DMA_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_DMA_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcIncMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcIncMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstIncMode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstIncMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcDataSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstDataSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(NbData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphRequest) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Priority)
        )
    );
}
extern "C" {
    #[doc = " @defgroup DMA_LL_EF_Init Initialization and de-initialization functions"]
    #[doc = " @{"]
    pub fn LL_DMA_Init(
        DMAx: *mut DMA_TypeDef,
        Channel: u32,
        DMA_InitStruct: *mut LL_DMA_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_DMA_DeInit(DMAx: *mut DMA_TypeDef, Channel: u32) -> ErrorStatus;
}
#[doc = " @brief LL LPUART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPUART_InitTypeDef {
    #[doc = "< Specifies the Prescaler to compute the communication baud rate."]
    #[doc = "This parameter can be a value of @ref LPUART_LL_EC_PRESCALER."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetPrescaler()."]
    pub PrescalerValue: u32,
    #[doc = "< This field defines expected LPUART communication baud rate."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetBaudRate()."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame."]
    #[doc = "This parameter can be a value of @ref LPUART_LL_EC_DATAWIDTH."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the number of stop bits transmitted."]
    #[doc = "This parameter can be a value of @ref LPUART_LL_EC_STOPBITS."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetStopBitsLength()."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode."]
    #[doc = "This parameter can be a value of @ref LPUART_LL_EC_PARITY."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetParity()."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref LPUART_LL_EC_DIRECTION."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref LPUART_LL_EC_HWCONTROL."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_LPUART_SetHWFlowCtrl()."]
    pub HardwareFlowControl: u32,
}
#[test]
fn bindgen_test_layout_LL_LPUART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_LPUART_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_LPUART_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(LL_LPUART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_LPUART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_LPUART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(PrescalerValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
}
extern "C" {
    pub fn LL_LPUART_Init(
        LPUARTx: *mut USART_TypeDef,
        LPUART_InitStruct: *mut LL_LPUART_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " @brief  RTC Init structures definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_RTC_InitTypeDef {
    #[doc = "< Specifies the RTC Hours Format."]
    #[doc = "This parameter can be a value of @ref RTC_LL_EC_HOURFORMAT"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_RTC_SetHourFormat()."]
    pub HourFormat: u32,
    #[doc = "< Specifies the RTC Asynchronous Predivider value."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_RTC_SetAsynchPrescaler()."]
    pub AsynchPrescaler: u32,
    #[doc = "< Specifies the RTC Synchronous Predivider value."]
    #[doc = "This parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF"]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary function"]
    #[doc = "@ref LL_RTC_SetSynchPrescaler()."]
    pub SynchPrescaler: u32,
}
#[test]
fn bindgen_test_layout_LL_RTC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_RTC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_RTC_InitTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(LL_RTC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_RTC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_RTC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HourFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(HourFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchPrescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(AsynchPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SynchPrescaler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(SynchPrescaler)
        )
    );
}
extern "C" {
    pub fn LL_RTC_Init(
        RTCx: *mut RTC_TypeDef,
        RTC_InitStruct: *mut LL_RTC_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_RTC_EnterInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
#[doc = " @brief LL USART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_USART_InitTypeDef {
    #[doc = "< Specifies the Prescaler to compute the communication baud rate."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_PRESCALER."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetPrescaler()."]
    pub PrescalerValue: u32,
    #[doc = "< This field defines expected Usart communication baud rate."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetBaudRate()."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_DATAWIDTH."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the number of stop bits transmitted."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_STOPBITS."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetStopBitsLength()."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_PARITY."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetParity()."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_DIRECTION."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_HWCONTROL."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetHWFlowCtrl()."]
    pub HardwareFlowControl: u32,
    #[doc = "< Specifies whether USART oversampling mode is 16 or 8."]
    #[doc = "This parameter can be a value of @ref USART_LL_EC_OVERSAMPLING."]
    #[doc = ""]
    #[doc = "This feature can be modified afterwards using unitary"]
    #[doc = "function @ref LL_USART_SetOverSampling()."]
    pub OverSampling: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_USART_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_USART_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LL_USART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_USART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_USART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(PrescalerValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OverSampling) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(OverSampling)
        )
    );
}
extern "C" {
    pub fn LL_USART_Init(
        USARTx: *mut USART_TypeDef,
        USART_InitStruct: *mut LL_USART_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    #[doc = " @defgroup UTILS_EF_SYSTEM SYSTEM"]
    #[doc = " @{"]
    pub fn LL_SetSystemCoreClock(HCLKFrequency: u32);
}
pub type Elf32_Addr = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ElfApiInterface {
    pub api_version_major: u16,
    pub api_version_minor: u16,
    pub resolver_callback: ::core::option::Option<
        unsafe extern "C" fn(name: *const core::ffi::c_char, address: *mut Elf32_Addr) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_ElfApiInterface() {
    const UNINIT: ::core::mem::MaybeUninit<ElfApiInterface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ElfApiInterface>(),
        16usize,
        concat!("Size of: ", stringify!(ElfApiInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<ElfApiInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(ElfApiInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(api_version_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(api_version_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolver_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(resolver_callback)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestBase {
    pub manifest_magic: u32,
    pub manifest_version: u32,
    pub api_version: FlipperApplicationManifestBase__bindgen_ty_1,
    pub hardware_target_id: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FlipperApplicationManifestBase__bindgen_ty_1 {
    pub __bindgen_anon_1: FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    pub version: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1 {
    pub minor: u16,
    pub major: u16,
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(major)
        )
    );
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestBase__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase>(),
        14usize,
        concat!("Size of: ", stringify!(FlipperApplicationManifestBase))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase>(),
        1usize,
        concat!("Alignment of ", stringify!(FlipperApplicationManifestBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manifest_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(manifest_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manifest_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(manifest_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(api_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardware_target_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(hardware_target_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestV1 {
    pub base: FlipperApplicationManifestBase,
    pub stack_size: u16,
    pub app_version: u32,
    pub name: [core::ffi::c_char; 32usize],
    pub has_icon: core::ffi::c_char,
    pub icon: [core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestV1() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestV1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestV1>(),
        85usize,
        concat!("Size of: ", stringify!(FlipperApplicationManifestV1))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestV1>(),
        1usize,
        concat!("Alignment of ", stringify!(FlipperApplicationManifestV1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(app_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_icon) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(has_icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(icon)
        )
    );
}
pub type FlipperApplicationManifest = FlipperApplicationManifestV1;
extern "C" {
    #[doc = " @brief Check if manifest is valid"]
    #[doc = ""]
    #[doc = " @param manifest"]
    #[doc = " @return bool"]
    pub fn flipper_application_manifest_is_valid(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if manifest is compatible with current ELF API interface"]
    #[doc = ""]
    #[doc = " @param manifest"]
    #[doc = " @param api_interface"]
    #[doc = " @return bool"]
    pub fn flipper_application_manifest_is_compatible(
        manifest: *const FlipperApplicationManifest,
        api_interface: *const ElfApiInterface,
    ) -> bool;
}
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusSuccess:
    FlipperApplicationPreloadStatus = 0;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusUnspecifiedError:
    FlipperApplicationPreloadStatus = 1;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusInvalidFile:
    FlipperApplicationPreloadStatus = 2;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusInvalidManifest:
    FlipperApplicationPreloadStatus = 3;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusApiMismatch:
    FlipperApplicationPreloadStatus = 4;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusTargetMismatch:
    FlipperApplicationPreloadStatus = 5;
pub type FlipperApplicationPreloadStatus = core::ffi::c_uchar;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusSuccess:
    FlipperApplicationLoadStatus = 0;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusUnspecifiedError:
    FlipperApplicationLoadStatus = 1;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusNoFreeMemory:
    FlipperApplicationLoadStatus = 2;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusMissingImports:
    FlipperApplicationLoadStatus = 3;
pub type FlipperApplicationLoadStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Get text description of load status"]
    #[doc = " @param status Status code"]
    #[doc = " @return String pointer to description"]
    pub fn flipper_application_load_status_to_string(
        status: FlipperApplicationLoadStatus,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplication {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Initialize FlipperApplication object"]
    #[doc = " @param storage Storage instance"]
    #[doc = " @param api_interface ELF API interface to use for pre-loading and symbol resolving"]
    #[doc = " @return Application instance"]
    pub fn flipper_application_alloc(
        storage: *mut Storage,
        api_interface: *const ElfApiInterface,
    ) -> *mut FlipperApplication;
}
extern "C" {
    #[doc = " @brief Destroy FlipperApplication object"]
    #[doc = " @param app Application pointer"]
    pub fn flipper_application_free(app: *mut FlipperApplication);
}
extern "C" {
    #[doc = " @brief Validate elf file and load application metadata"]
    #[doc = " @param app Application pointer"]
    #[doc = " @return Preload result code"]
    pub fn flipper_application_preload(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
extern "C" {
    #[doc = " @brief Validate elf file and load application manifest"]
    #[doc = " @param app Application pointer"]
    #[doc = " @return Preload result code"]
    pub fn flipper_application_preload_manifest(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
extern "C" {
    #[doc = " @brief Get pointer to application manifest for preloaded application"]
    #[doc = " @param app Application pointer"]
    #[doc = " @return Pointer to application manifest"]
    pub fn flipper_application_get_manifest(
        app: *mut FlipperApplication,
    ) -> *const FlipperApplicationManifest;
}
extern "C" {
    #[doc = " @brief Load sections and process relocations for already pre-loaded application"]
    #[doc = " @param app Application pointer"]
    #[doc = " @return Load result code"]
    pub fn flipper_application_map_to_memory(
        app: *mut FlipperApplication,
    ) -> FlipperApplicationLoadStatus;
}
extern "C" {
    #[doc = " @brief Create application thread at entry point address, using app name and"]
    #[doc = " stack size from metadata. Returned thread isn't started yet."]
    #[doc = " Can be only called once for application instance."]
    #[doc = " @param app Applicaiton pointer"]
    #[doc = " @param args Object to pass to app's entry point"]
    #[doc = " @return Created thread"]
    pub fn flipper_application_spawn(
        app: *mut FlipperApplication,
        args: *mut core::ffi::c_void,
    ) -> *mut FuriThread;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperFormat {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate FlipperFormat as string."]
    #[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_string_alloc() -> *mut FlipperFormat;
}
extern "C" {
    #[doc = " Allocate FlipperFormat as file."]
    #[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
    #[doc = " Allocate FlipperFormat as file, buffered mode."]
    #[doc = " @return FlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_buffered_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
    #[doc = " Open existing file."]
    #[doc = " Use only if FlipperFormat allocated as a file."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param path File path"]
    #[doc = " @return True on success"]
    pub fn flipper_format_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open existing file, buffered mode."]
    #[doc = " Use only if FlipperFormat allocated as a file."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param path File path"]
    #[doc = " @return True on success"]
    pub fn flipper_format_buffered_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open existing file for writing and add values to the end of file."]
    #[doc = " Use only if FlipperFormat allocated as a file."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param path File path"]
    #[doc = " @return True on success"]
    pub fn flipper_format_file_open_append(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open file. Creates a new file, or deletes the contents of the file if it already exists."]
    #[doc = " Use only if FlipperFormat allocated as a file."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param path File path"]
    #[doc = " @return True on success"]
    pub fn flipper_format_file_open_always(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open file. Creates a new file, fails if file already exists."]
    #[doc = " Use only if FlipperFormat allocated as a file."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param path File path"]
    #[doc = " @return True on success"]
    pub fn flipper_format_file_open_new(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Closes the file, use only if FlipperFormat allocated as a file."]
    #[doc = " @param flipper_format"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn flipper_format_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Closes the file, use only if FlipperFormat allocated as a buffered file."]
    #[doc = " @param flipper_format"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn flipper_format_buffered_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Free FlipperFormat."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    pub fn flipper_format_free(flipper_format: *mut FlipperFormat);
}
extern "C" {
    #[doc = " Set FlipperFormat mode."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param strict_mode True obligates not to skip valid fields. False by default."]
    pub fn flipper_format_set_strict_mode(flipper_format: *mut FlipperFormat, strict_mode: bool);
}
extern "C" {
    #[doc = " Rewind the RW pointer."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @return True on success"]
    pub fn flipper_format_rewind(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Move the RW pointer at the end. Can be useful if you want to add some data after reading."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @return True on success"]
    pub fn flipper_format_seek_to_end(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Check if the key exists."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @return true key exists"]
    #[doc = " @return false key is not exists"]
    pub fn flipper_format_key_exist(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Read the header (file type and version)."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param filetype File type string"]
    #[doc = " @param version Version Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Write the header (file type and version)."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param filetype File type string"]
    #[doc = " @param version Version Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Write the header (file type and version). Plain C string version."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param filetype File type string"]
    #[doc = " @param version Version Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_header_cstr(
        flipper_format: *mut FlipperFormat,
        filetype: *const core::ffi::c_char,
        version: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the count of values by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key"]
    #[doc = " @param count"]
    #[doc = " @return bool"]
    pub fn flipper_format_get_value_count(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        count: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Read a string by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and string"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and string. Plain C string version."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of uint64 in hex format by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u64,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of uint64 in hex format"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u64,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of uint32 by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of uint32"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of int32 by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of int32"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of bool by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of bool"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of float by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of float"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of hex-formatted bytes by key"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_read_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of hex-formatted bytes"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @param data_size Values count"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write comment"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param data Comment text"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_comment(
        flipper_format: *mut FlipperFormat,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Write comment. Plain C string version."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param data Comment text"]
    #[doc = " @return True on success"]
    pub fn flipper_format_write_comment_cstr(
        flipper_format: *mut FlipperFormat,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Removes the first matching key and its value. Sets the RW pointer to a position of deleted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @return True on success"]
    pub fn flipper_format_delete_key(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value. Plain C version. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a uint32 array value. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a int32 array value. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a bool array value. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a float array value. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to an array of hex-formatted bytes. Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist."]
    #[doc = " Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist."]
    #[doc = " Plain C version."]
    #[doc = " Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a uint32 array value, or adds the key and value if the key did not exist."]
    #[doc = "  Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a int32 array value, or adds the key and value if the key did not exist."]
    #[doc = " Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a bool array value, or adds the key and value if the key did not exist."]
    #[doc = " Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a float array value, or adds the key and value if the key did not exist."]
    #[doc = " Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to an array of hex-formatted bytes, or adds the key and value if the key did not exist."]
    #[doc = "Sets the RW pointer to a position at the end of inserted data."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param key Key"]
    #[doc = " @param data Value"]
    #[doc = " @return True on success"]
    pub fn flipper_format_insert_or_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stream {
    _unused: [u8; 0],
}
pub const StreamOffset_StreamOffsetFromCurrent: StreamOffset = 0;
pub const StreamOffset_StreamOffsetFromStart: StreamOffset = 1;
pub const StreamOffset_StreamOffsetFromEnd: StreamOffset = 2;
pub type StreamOffset = core::ffi::c_uchar;
pub type StreamWriteCB = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut Stream, context: *const core::ffi::c_void) -> bool,
>;
extern "C" {
    #[doc = " Free Stream"]
    #[doc = " @param stream Stream instance"]
    pub fn stream_free(stream: *mut Stream);
}
extern "C" {
    #[doc = " Clean (empty) Stream"]
    #[doc = " @param stream Stream instance"]
    pub fn stream_clean(stream: *mut Stream);
}
extern "C" {
    #[doc = " Indicates that the rw pointer is at the end of the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @return true if rw pointer is at the end of the stream"]
    #[doc = " @return false if rw pointer is not at the end of the stream"]
    pub fn stream_eof(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Moves the rw pointer."]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param offset how much to move the pointer"]
    #[doc = " @param offset_type starting from what"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn stream_seek(stream: *mut Stream, offset: i32, offset_type: StreamOffset) -> bool;
}
extern "C" {
    #[doc = " Gets the value of the rw pointer"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @return size_t value of the rw pointer"]
    pub fn stream_tell(stream: *mut Stream) -> usize;
}
extern "C" {
    #[doc = " Gets the size of the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @return size_t size of the stream"]
    pub fn stream_size(stream: *mut Stream) -> usize;
}
extern "C" {
    #[doc = " Write N bytes to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param data data to write"]
    #[doc = " @param size size of data to be written"]
    #[doc = " @return size_t how many bytes was written"]
    pub fn stream_write(stream: *mut Stream, data: *const u8, size: usize) -> usize;
}
extern "C" {
    #[doc = " Read N bytes from stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param data data to be read"]
    #[doc = " @param count size of data to be read"]
    #[doc = " @return size_t how many bytes was read"]
    pub fn stream_read(stream: *mut Stream, data: *mut u8, count: usize) -> usize;
}
extern "C" {
    #[doc = " Delete N chars from the stream and write data by calling write_callback(context)"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param delete_size size of data to be deleted"]
    #[doc = " @param write_callback write callback"]
    #[doc = " @param context write callback context"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete_and_insert(
        stream: *mut Stream,
        delete_size: usize,
        write_callback: StreamWriteCB,
        context: *const core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Read line from a stream (supports LF and CRLF line endings)"]
    #[doc = " @param stream"]
    #[doc = " @param str_result"]
    #[doc = " @return true if line lenght is not zero"]
    #[doc = " @return false otherwise"]
    pub fn stream_read_line(stream: *mut Stream, str_result: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = " Moves the rw pointer to the start"]
    #[doc = " @param stream Stream instance"]
    pub fn stream_rewind(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Write char to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param c char value"]
    #[doc = " @return size_t how many bytes was written"]
    pub fn stream_write_char(stream: *mut Stream, c: core::ffi::c_char) -> usize;
}
extern "C" {
    #[doc = " Write string to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param string string value"]
    #[doc = " @return size_t how many bytes was written"]
    pub fn stream_write_string(stream: *mut Stream, string: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " Write const char* to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param string c-string value"]
    #[doc = " @return size_t how many bytes was written"]
    pub fn stream_write_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> usize;
}
extern "C" {
    #[doc = " Write formatted string to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    #[doc = " @return size_t how many bytes was written"]
    pub fn stream_write_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
        -> usize;
}
extern "C" {
    #[doc = " Write formatted string to the stream, va_list version"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param format"]
    #[doc = " @param args"]
    #[doc = " @return size_t how many bytes was written"]
    pub fn stream_write_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> usize;
}
extern "C" {
    #[doc = " Insert N chars to the stream, starting at the current pointer."]
    #[doc = " Data will be inserted, not overwritte, so the stream will be increased in size."]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param data data to be inserted"]
    #[doc = " @param size size of data to be inserted"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_insert(stream: *mut Stream, data: *const u8, size: usize) -> bool;
}
extern "C" {
    #[doc = " Insert char to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param c char value"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_insert_char(stream: *mut Stream, c: core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Insert string to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param string string value"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_insert_string(stream: *mut Stream, string: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = " Insert const char* to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param string c-string value"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_insert_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Insert formatted string to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_insert_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
        -> bool;
}
extern "C" {
    #[doc = " Insert formatted string to the stream, va_list version"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param format"]
    #[doc = " @param args"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_insert_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert char to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param delete_size size of data to be deleted"]
    #[doc = " @param c char value"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete_and_insert_char(
        stream: *mut Stream,
        delete_size: usize,
        c: core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert string to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param delete_size size of data to be deleted"]
    #[doc = " @param string string value"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete_and_insert_string(
        stream: *mut Stream,
        delete_size: usize,
        string: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert const char* to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param delete_size size of data to be deleted"]
    #[doc = " @param string c-string value"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete_and_insert_cstring(
        stream: *mut Stream,
        delete_size: usize,
        string: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert formatted string to the stream"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param delete_size size of data to be deleted"]
    #[doc = " @param format"]
    #[doc = " @param ..."]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete_and_insert_format(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert formatted string to the stream, va_list version"]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param delete_size size of data to be deleted"]
    #[doc = " @param format"]
    #[doc = " @param args"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete_and_insert_vaformat(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove N chars from the stream, starting at the current pointer."]
    #[doc = " The size may be larger than stream size, the stream will be cleared from current rw pointer to the end."]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param size how many chars need to be deleted"]
    #[doc = " @return true if the operation was successful"]
    #[doc = " @return false on error"]
    pub fn stream_delete(stream: *mut Stream, size: usize) -> bool;
}
extern "C" {
    #[doc = " Copy data from one stream to another. Data will be copied from current rw pointer and to current rw pointer."]
    #[doc = " @param stream_from"]
    #[doc = " @param stream_to"]
    #[doc = " @param size"]
    #[doc = " @return size_t"]
    pub fn stream_copy(stream_from: *mut Stream, stream_to: *mut Stream, size: usize) -> usize;
}
extern "C" {
    #[doc = " Copy data from one stream to another. Data will be copied from start of one stream and to start of other stream."]
    #[doc = " @param stream_from"]
    #[doc = " @param stream_to"]
    #[doc = " @return size_t"]
    pub fn stream_copy_full(stream_from: *mut Stream, stream_to: *mut Stream) -> usize;
}
extern "C" {
    #[doc = " Splits one stream into two others. The original stream will remain untouched."]
    #[doc = " @param stream"]
    #[doc = " @param stream_left"]
    #[doc = " @param stream_right"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn stream_split(
        stream: *mut Stream,
        stream_left: *mut Stream,
        stream_right: *mut Stream,
    ) -> bool;
}
extern "C" {
    #[doc = " Loads data to the stream from a file. Data will be loaded to the current RW pointer. RW pointer will be moved to the end of the stream."]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param storage"]
    #[doc = " @param path"]
    #[doc = " @return size_t"]
    pub fn stream_load_from_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Writes data from a stream to a file. Data will be saved starting from the current RW pointer. RW pointer will be moved to the end of the stream."]
    #[doc = " @param stream Stream instance"]
    #[doc = " @param storage"]
    #[doc = " @param path"]
    #[doc = " @param mode"]
    #[doc = " @return size_t"]
    pub fn stream_save_to_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        mode: FS_OpenMode,
    ) -> usize;
}
extern "C" {
    #[doc = " Dump stream inner data (size, RW positiot, content)"]
    #[doc = " @param stream Stream instance"]
    pub fn stream_dump_data(stream: *mut Stream);
}
extern "C" {
    #[doc = " Returns the underlying stream instance."]
    #[doc = " Use only if you know what you are doing."]
    #[doc = " @param flipper_format"]
    #[doc = " @return Stream*"]
    pub fn flipper_format_get_raw_stream(flipper_format: *mut FlipperFormat) -> *mut Stream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredDecoderHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredEncoderHandler {
    _unused: [u8; 0],
}
pub const InfraredProtocol_InfraredProtocolUnknown: InfraredProtocol = -1;
pub const InfraredProtocol_InfraredProtocolNEC: InfraredProtocol = 0;
pub const InfraredProtocol_InfraredProtocolNECext: InfraredProtocol = 1;
pub const InfraredProtocol_InfraredProtocolNEC42: InfraredProtocol = 2;
pub const InfraredProtocol_InfraredProtocolNEC42ext: InfraredProtocol = 3;
pub const InfraredProtocol_InfraredProtocolSamsung32: InfraredProtocol = 4;
pub const InfraredProtocol_InfraredProtocolRC6: InfraredProtocol = 5;
pub const InfraredProtocol_InfraredProtocolRC5: InfraredProtocol = 6;
pub const InfraredProtocol_InfraredProtocolRC5X: InfraredProtocol = 7;
pub const InfraredProtocol_InfraredProtocolSIRC: InfraredProtocol = 8;
pub const InfraredProtocol_InfraredProtocolSIRC15: InfraredProtocol = 9;
pub const InfraredProtocol_InfraredProtocolSIRC20: InfraredProtocol = 10;
pub const InfraredProtocol_InfraredProtocolKaseikyo: InfraredProtocol = 11;
pub const InfraredProtocol_InfraredProtocolMAX: InfraredProtocol = 12;
pub type InfraredProtocol = core::ffi::c_schar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredMessage {
    pub protocol: InfraredProtocol,
    pub address: u32,
    pub command: u32,
    pub repeat: bool,
}
#[test]
fn bindgen_test_layout_InfraredMessage() {
    const UNINIT: ::core::mem::MaybeUninit<InfraredMessage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InfraredMessage>(),
        16usize,
        concat!("Size of: ", stringify!(InfraredMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<InfraredMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(InfraredMessage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(repeat)
        )
    );
}
pub const InfraredStatus_InfraredStatusError: InfraredStatus = 0;
pub const InfraredStatus_InfraredStatusOk: InfraredStatus = 1;
pub const InfraredStatus_InfraredStatusDone: InfraredStatus = 2;
pub const InfraredStatus_InfraredStatusReady: InfraredStatus = 3;
pub type InfraredStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = " Initialize decoder."]
    #[doc = ""]
    #[doc = " \\return      returns pointer to INFRARED decoder handler if success, otherwise - error."]
    pub fn infrared_alloc_decoder() -> *mut InfraredDecoderHandler;
}
extern "C" {
    #[doc = " Provide to decoder next timing."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder()."]
    #[doc = " \\param[in]   level       - high(true) or low(false) level of input signal to analyze."]
    #[doc = "                          it should alternate every call, otherwise it is an error case,"]
    #[doc = "                          and decoder resets its state and start decoding from the start."]
    #[doc = " \\param[in]   duration    - duration of steady high/low input signal."]
    #[doc = " \\return      if message is ready, returns pointer to decoded message, returns NULL."]
    #[doc = "              Note: ownership of returned ptr belongs to handler. So pointer is valid"]
    #[doc = "              up to next infrared_free_decoder(), infrared_reset_decoder(),"]
    #[doc = "              infrared_decode(), infrared_check_decoder_ready() calls."]
    pub fn infrared_decode(
        handler: *mut InfraredDecoderHandler,
        level: bool,
        duration: u32,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = " Check whether decoder is ready."]
    #[doc = " Functionality is quite similar to infrared_decode(), but with no timing providing."]
    #[doc = " Some protocols (e.g. Sony SIRC) has variable payload length, which means we"]
    #[doc = " can't recognize end of message right after receiving last bit. That's why"]
    #[doc = " application should call to infrared_check_decoder_ready() after some timeout to"]
    #[doc = " retrieve decoded message, if so."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder()."]
    #[doc = " \\return      if message is ready, returns pointer to decoded message, returns NULL."]
    #[doc = "              Note: ownership of returned ptr belongs to handler. So pointer is valid"]
    #[doc = "              up to next infrared_free_decoder(), infrared_reset_decoder(),"]
    #[doc = "              infrared_decode(), infrared_check_decoder_ready() calls."]
    pub fn infrared_check_decoder_ready(
        handler: *mut InfraredDecoderHandler,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = " Deinitialize decoder and free allocated memory."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder()."]
    pub fn infrared_free_decoder(handler: *mut InfraredDecoderHandler);
}
extern "C" {
    #[doc = " Reset INFRARED decoder."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder()."]
    pub fn infrared_reset_decoder(handler: *mut InfraredDecoderHandler);
}
extern "C" {
    #[doc = " Get protocol name by protocol enum."]
    #[doc = ""]
    #[doc = " \\param[in]   protocol    - protocol identifier."]
    #[doc = " \\return      string to protocol name."]
    pub fn infrared_get_protocol_name(protocol: InfraredProtocol) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get protocol enum by protocol name."]
    #[doc = ""]
    #[doc = " \\param[in]   protocol_name   - string to protocol name."]
    #[doc = " \\return      protocol identifier."]
    pub fn infrared_get_protocol_by_name(
        protocol_name: *const core::ffi::c_char,
    ) -> InfraredProtocol;
}
extern "C" {
    #[doc = " Get address length by protocol enum."]
    #[doc = ""]
    #[doc = " \\param[in]   protocol    - protocol identifier."]
    #[doc = " \\return      length of address in bits."]
    pub fn infrared_get_protocol_address_length(protocol: InfraredProtocol) -> u8;
}
extern "C" {
    #[doc = " Get command length by protocol enum."]
    #[doc = ""]
    #[doc = " \\param[in]   protocol    - protocol identifier."]
    #[doc = " \\return      length of command in bits."]
    pub fn infrared_get_protocol_command_length(protocol: InfraredProtocol) -> u8;
}
extern "C" {
    #[doc = " Checks whether protocol valid."]
    #[doc = ""]
    #[doc = " \\param[in]   protocol    - protocol identifier."]
    #[doc = " \\return      true if protocol is valid, false otherwise."]
    pub fn infrared_is_protocol_valid(protocol: InfraredProtocol) -> bool;
}
extern "C" {
    #[doc = " Allocate INFRARED encoder."]
    #[doc = ""]
    #[doc = " \\return      encoder handler."]
    pub fn infrared_alloc_encoder() -> *mut InfraredEncoderHandler;
}
extern "C" {
    #[doc = " Free encoder handler previously allocated with \\c infrared_alloc_encoder()."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder()."]
    pub fn infrared_free_encoder(handler: *mut InfraredEncoderHandler);
}
extern "C" {
    #[doc = " Encode previously set INFRARED message."]
    #[doc = " Usage:"]
    #[doc = "  1) alloc with \\c infrared_alloc_encoder()"]
    #[doc = "  2) set message to encode with \\c infrared_reset_encoder()"]
    #[doc = "  3) call for \\c infrared_encode() to continuously get one at a time timings."]
    #[doc = "  4) when \\c infrared_encode() returns InfraredStatusDone, it means new message is fully encoded."]
    #[doc = "  5) to encode additional timings, just continue calling \\c infrared_encode()."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder()."]
    #[doc = " \\param[out]  duration    - encoded timing."]
    #[doc = " \\param[out]  level       - encoded level."]
    #[doc = ""]
    #[doc = " \\return      status of encode operation."]
    pub fn infrared_encode(
        handler: *mut InfraredEncoderHandler,
        duration: *mut u32,
        level: *mut bool,
    ) -> InfraredStatus;
}
extern "C" {
    #[doc = " Reset INFRARED encoder and set new message to encode. If it's not called after receiveing"]
    #[doc = " InfraredStatusDone in \\c infrared_encode(), encoder will encode repeat messages"]
    #[doc = " till the end of time."]
    #[doc = ""]
    #[doc = " \\param[in]   handler     - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder()."]
    #[doc = " \\param[in]   message     - message to encode."]
    pub fn infrared_reset_encoder(
        handler: *mut InfraredEncoderHandler,
        message: *const InfraredMessage,
    );
}
extern "C" {
    #[doc = " Get PWM frequency value for selected protocol"]
    #[doc = ""]
    #[doc = " \\param[in]   protocol    - protocol to get from PWM frequency"]
    #[doc = ""]
    #[doc = " \\return      frequency"]
    pub fn infrared_get_protocol_frequency(protocol: InfraredProtocol) -> u32;
}
extern "C" {
    #[doc = " Get PWM duty cycle value for selected protocol"]
    #[doc = ""]
    #[doc = " \\param[in]   protocol    - protocol to get from PWM duty cycle"]
    #[doc = ""]
    #[doc = " \\return      duty cycle"]
    pub fn infrared_get_protocol_duty_cycle(protocol: InfraredProtocol) -> f32;
}
extern "C" {
    #[doc = " Send message over INFRARED."]
    #[doc = ""]
    #[doc = " \\param[in]   message     - message to send."]
    #[doc = " \\param[in]   times       - number of times message should be sent."]
    pub fn infrared_send(message: *const InfraredMessage, times: core::ffi::c_int);
}
extern "C" {
    #[doc = " Send raw data through infrared port."]
    #[doc = ""]
    #[doc = " \\param[in]   timings - array of timings to send."]
    #[doc = " \\param[in]   timings_cnt - timings array size."]
    #[doc = " \\param[in]   start_from_mark - true if timings starts from mark,"]
    #[doc = "              otherwise from space"]
    pub fn infrared_send_raw(timings: *const u32, timings_cnt: u32, start_from_mark: bool);
}
extern "C" {
    #[doc = " Send raw data through infrared port, with additional settings."]
    #[doc = ""]
    #[doc = " \\param[in]   timings - array of timings to send."]
    #[doc = " \\param[in]   timings_cnt - timings array size."]
    #[doc = " \\param[in]   start_from_mark - true if timings starts from mark,"]
    #[doc = "              otherwise from space"]
    #[doc = " \\param[in]   duty_cycle - duty cycle to generate on PWM"]
    #[doc = " \\param[in]   frequency - frequency to generate on PWM"]
    pub fn infrared_send_raw_ext(
        timings: *const u32,
        timings_cnt: u32,
        start_from_mark: bool,
        frequency: u32,
        duty_cycle: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorkerSignal {
    _unused: [u8; 0],
}
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseNew:
    InfraredWorkerGetSignalResponse = 0;
#[doc = " Signal, provided by callback is new and encoder should be reseted"]
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseSame:
    InfraredWorkerGetSignalResponse = 1;
#[doc = " Signal, provided by callback is same. No encoder resetting."]
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseStop:
    InfraredWorkerGetSignalResponse = 2;
pub type InfraredWorkerGetSignalResponse = core::ffi::c_uchar;
#[doc = " Callback type for providing next signal to send. Should be used with"]
#[doc = " infrared_worker_make_decoded_signal() or infrared_worker_make_raw_signal()"]
pub type InfraredWorkerGetSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse,
>;
#[doc = " Callback type for 'message is sent' event"]
pub type InfraredWorkerMessageSentCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback type to call by InfraredWorker thread when new signal is received"]
pub type InfraredWorkerReceivedSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        received_signal: *mut InfraredWorkerSignal,
    ),
>;
extern "C" {
    #[doc = " Allocate InfraredWorker"]
    #[doc = ""]
    #[doc = " @return just created instance of InfraredWorker"]
    pub fn infrared_worker_alloc() -> *mut InfraredWorker;
}
extern "C" {
    #[doc = " Free InfraredWorker"]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_free(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Start InfraredWorker thread, initialise furi_hal, prepare all work."]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_rx_start(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Stop InfraredWorker thread, deinitialize furi_hal."]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_rx_stop(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Set received data callback InfraredWorker"]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    #[doc = " @param[in]   context - context to pass to callbacks"]
    #[doc = " @param[in]   callback - InfraredWorkerReceivedSignalCallback callback"]
    pub fn infrared_worker_rx_set_received_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerReceivedSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Enable blinking on receiving any signal on IR port."]
    #[doc = ""]
    #[doc = " @param[in]   instance - instance of InfraredWorker"]
    #[doc = " @param[in]   enable - true if you want to enable blinking"]
    #[doc = "                       false otherwise"]
    pub fn infrared_worker_rx_enable_blink_on_receiving(
        instance: *mut InfraredWorker,
        enable: bool,
    );
}
extern "C" {
    #[doc = " Enable decoding of received infrared signals."]
    #[doc = ""]
    #[doc = " @param[in]   instance - instance of InfraredWorker"]
    #[doc = " @param[in]   enable - true if you want to enable decoding"]
    #[doc = "                       false otherwise"]
    pub fn infrared_worker_rx_enable_signal_decoding(instance: *mut InfraredWorker, enable: bool);
}
extern "C" {
    #[doc = " Clarify is received signal either decoded or raw"]
    #[doc = ""]
    #[doc = " @param[in]   signal - received signal"]
    #[doc = " @return      true if signal is decoded, false if signal is raw"]
    pub fn infrared_worker_signal_is_decoded(signal: *const InfraredWorkerSignal) -> bool;
}
extern "C" {
    #[doc = " Start transmitting signal. Callback InfraredWorkerGetSignalCallback should be"]
    #[doc = " set before this function is called, as it calls for it to fill buffer before"]
    #[doc = " starting transmission."]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_tx_start(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Stop transmitting signal. Waits for end of current signal and stops transmission."]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_tx_stop(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Set callback for providing next signal to send"]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    #[doc = " @param[in]   context - context to pass to callbacks"]
    #[doc = " @param[in]   callback - InfraredWorkerGetSignalCallback callback"]
    pub fn infrared_worker_tx_set_get_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerGetSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set callback for end of signal transmitting"]
    #[doc = ""]
    #[doc = " @param[in]   instance - InfraredWorker instance"]
    #[doc = " @param[in]   context - context to pass to callbacks"]
    #[doc = " @param[in]   callback - InfraredWorkerMessageSentCallback callback"]
    pub fn infrared_worker_tx_set_signal_sent_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerMessageSentCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Callback to pass to infrared_worker_tx_set_get_signal_callback() if signal"]
    #[doc = " is steady and will not be changed between infrared_worker start and stop."]
    #[doc = " Before starting transmission, desired steady signal must be set with"]
    #[doc = " infrared_worker_make_decoded_signal() or infrared_worker_make_raw_signal()."]
    #[doc = ""]
    #[doc = " This function should not be implicitly called."]
    #[doc = ""]
    #[doc = " @param[in]   context - context"]
    #[doc = " @param[out]  instance - InfraredWorker instance"]
    pub fn infrared_worker_tx_get_signal_steady_callback(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse;
}
extern "C" {
    #[doc = " Acquire raw signal from interface struct 'InfraredWorkerSignal'."]
    #[doc = " First, you have to ensure that signal is raw."]
    #[doc = ""]
    #[doc = " @param[in]   signal - received signal"]
    #[doc = " @param[out]  timings - pointer to array of timings"]
    #[doc = " @param[out]  timings_cnt - pointer to amount of timings"]
    pub fn infrared_worker_get_raw_signal(
        signal: *const InfraredWorkerSignal,
        timings: *mut *const u32,
        timings_cnt: *mut usize,
    );
}
extern "C" {
    #[doc = " Acquire decoded message from interface struct 'InfraredWorkerSignal'."]
    #[doc = " First, you have to ensure that signal is decoded."]
    #[doc = ""]
    #[doc = " @param[in]   signal - received signal"]
    #[doc = " @return      decoded INFRARED message"]
    pub fn infrared_worker_get_decoded_signal(
        signal: *const InfraredWorkerSignal,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = " Set current decoded signal for InfraredWorker instance"]
    #[doc = ""]
    #[doc = " @param[out]  instance - InfraredWorker instance"]
    #[doc = " @param[in]   message - decoded signal"]
    pub fn infrared_worker_set_decoded_signal(
        instance: *mut InfraredWorker,
        message: *const InfraredMessage,
    );
}
extern "C" {
    #[doc = " Set current raw signal for InfraredWorker instance"]
    #[doc = ""]
    #[doc = " @param[out]  instance - InfraredWorker instance"]
    #[doc = " @param[in]   timings - array of raw timings"]
    #[doc = " @param[in]   timings_cnt - size of array of raw timings"]
    pub fn infrared_worker_set_raw_signal(
        instance: *mut InfraredWorker,
        timings: *const u32,
        timings_cnt: usize,
    );
}
pub type ProtocolAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>;
pub type ProtocolFree =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolGetData =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> *mut u8>;
pub type ProtocolDecoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, level: bool, duration: u32) -> bool,
>;
pub type ProtocolEncoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> bool>;
pub type ProtocolEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> LevelDuration>;
pub type ProtocolRenderData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, result: *mut FuriString),
>;
pub type ProtocolWriteData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, data: *mut core::ffi::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDecoder {
    pub start: ProtocolDecoderStart,
    pub feed: ProtocolDecoderFeed,
}
#[test]
fn bindgen_test_layout_ProtocolDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolDecoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolDecoder>(),
        16usize,
        concat!("Size of: ", stringify!(ProtocolDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(ProtocolDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolDecoder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolDecoder),
            "::",
            stringify!(feed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolEncoder {
    pub start: ProtocolEncoderStart,
    pub yield_: ProtocolEncoderYield,
}
#[test]
fn bindgen_test_layout_ProtocolEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolEncoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolEncoder>(),
        16usize,
        concat!("Size of: ", stringify!(ProtocolEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(ProtocolEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolEncoder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolEncoder),
            "::",
            stringify!(yield_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolBase {
    pub data_size: usize,
    pub name: *const core::ffi::c_char,
    pub manufacturer: *const core::ffi::c_char,
    pub features: u32,
    pub validate_count: u8,
    pub alloc: ProtocolAlloc,
    pub free: ProtocolFree,
    pub get_data: ProtocolGetData,
    pub decoder: ProtocolDecoder,
    pub encoder: ProtocolEncoder,
    pub render_data: ProtocolRenderData,
    pub render_brief_data: ProtocolRenderData,
    pub write_data: ProtocolWriteData,
}
#[test]
fn bindgen_test_layout_ProtocolBase() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolBase> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolBase>(),
        112usize,
        concat!("Size of: ", stringify!(ProtocolBase))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolBase>(),
        8usize,
        concat!("Alignment of ", stringify!(ProtocolBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validate_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(validate_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(get_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(decoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).render_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(render_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).render_brief_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(render_brief_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(write_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDict {
    _unused: [u8; 0],
}
pub type ProtocolId = i32;
extern "C" {
    pub fn protocol_dict_alloc(
        protocols: *mut *const ProtocolBase,
        protocol_count: usize,
    ) -> *mut ProtocolDict;
}
extern "C" {
    pub fn protocol_dict_free(dict: *mut ProtocolDict);
}
extern "C" {
    pub fn protocol_dict_set_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *const u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_data_size(dict: *mut ProtocolDict, protocol_index: usize) -> usize;
}
extern "C" {
    pub fn protocol_dict_get_max_data_size(dict: *mut ProtocolDict) -> usize;
}
extern "C" {
    pub fn protocol_dict_get_name(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn protocol_dict_get_manufacturer(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn protocol_dict_decoders_start(dict: *mut ProtocolDict);
}
extern "C" {
    pub fn protocol_dict_get_features(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
    pub fn protocol_dict_decoders_feed(
        dict: *mut ProtocolDict,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_decoders_feed_by_feature(
        dict: *mut ProtocolDict,
        feature: u32,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_decoders_feed_by_id(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_encoder_start(dict: *mut ProtocolDict, protocol_index: usize) -> bool;
}
extern "C" {
    pub fn protocol_dict_encoder_yield(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> LevelDuration;
}
extern "C" {
    pub fn protocol_dict_render_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
extern "C" {
    pub fn protocol_dict_render_brief_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_validate_count(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
    pub fn protocol_dict_get_protocol_by_name(
        dict: *mut ProtocolDict,
        name: *const core::ffi::c_char,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_get_write_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDT5577 {
    pub block: [u32; 8usize],
    pub blocks_to_write: u32,
}
#[test]
fn bindgen_test_layout_LFRFIDT5577() {
    const UNINIT: ::core::mem::MaybeUninit<LFRFIDT5577> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LFRFIDT5577>(),
        36usize,
        concat!("Size of: ", stringify!(LFRFIDT5577))
    );
    assert_eq!(
        ::core::mem::align_of::<LFRFIDT5577>(),
        4usize,
        concat!("Alignment of ", stringify!(LFRFIDT5577))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LFRFIDT5577),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks_to_write) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LFRFIDT5577),
            "::",
            stringify!(blocks_to_write)
        )
    );
}
extern "C" {
    #[doc = " @brief Write T5577 tag data to tag"]
    #[doc = ""]
    #[doc = " @param data"]
    pub fn t5577_write(data: *mut LFRFIDT5577);
}
pub const LFRFIDProtocol_LFRFIDProtocolEM4100: LFRFIDProtocol = 0;
pub const LFRFIDProtocol_LFRFIDProtocolH10301: LFRFIDProtocol = 1;
pub const LFRFIDProtocol_LFRFIDProtocolIndala26: LFRFIDProtocol = 2;
pub const LFRFIDProtocol_LFRFIDProtocolIOProxXSF: LFRFIDProtocol = 3;
pub const LFRFIDProtocol_LFRFIDProtocolAwid: LFRFIDProtocol = 4;
pub const LFRFIDProtocol_LFRFIDProtocolFDXA: LFRFIDProtocol = 5;
pub const LFRFIDProtocol_LFRFIDProtocolFDXB: LFRFIDProtocol = 6;
pub const LFRFIDProtocol_LFRFIDProtocolHidGeneric: LFRFIDProtocol = 7;
pub const LFRFIDProtocol_LFRFIDProtocolHidExGeneric: LFRFIDProtocol = 8;
pub const LFRFIDProtocol_LFRFIDProtocolPyramid: LFRFIDProtocol = 9;
pub const LFRFIDProtocol_LFRFIDProtocolViking: LFRFIDProtocol = 10;
pub const LFRFIDProtocol_LFRFIDProtocolJablotron: LFRFIDProtocol = 11;
pub const LFRFIDProtocol_LFRFIDProtocolParadox: LFRFIDProtocol = 12;
pub const LFRFIDProtocol_LFRFIDProtocolPACStanley: LFRFIDProtocol = 13;
pub const LFRFIDProtocol_LFRFIDProtocolKeri: LFRFIDProtocol = 14;
pub const LFRFIDProtocol_LFRFIDProtocolGallagher: LFRFIDProtocol = 15;
pub const LFRFIDProtocol_LFRFIDProtocolMax: LFRFIDProtocol = 16;
pub type LFRFIDProtocol = core::ffi::c_uchar;
extern "C" {
    pub static mut lfrfid_protocols: [*const ProtocolBase; 0usize];
}
extern "C" {
    #[doc = " @brief Save protocol from dictionary to file"]
    #[doc = ""]
    #[doc = " @param dict"]
    #[doc = " @param protocol"]
    #[doc = " @param filename"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn lfrfid_dict_file_save(
        dict: *mut ProtocolDict,
        protocol: ProtocolId,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Load protocol from file to dictionary"]
    #[doc = ""]
    #[doc = " @param dict"]
    #[doc = " @param filename"]
    #[doc = " @return ProtocolId"]
    pub fn lfrfid_dict_file_load(
        dict: *mut ProtocolDict,
        filename: *const core::ffi::c_char,
    ) -> ProtocolId;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawFile {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Allocate a new LFRFIDRawFile instance"]
    #[doc = ""]
    #[doc = " @param storage"]
    #[doc = " @return LFRFIDRawFile*"]
    pub fn lfrfid_raw_file_alloc(storage: *mut Storage) -> *mut LFRFIDRawFile;
}
extern "C" {
    #[doc = " @brief Free a LFRFIDRawFile instance"]
    #[doc = ""]
    #[doc = " @param file"]
    pub fn lfrfid_raw_file_free(file: *mut LFRFIDRawFile);
}
extern "C" {
    #[doc = " @brief Open RAW file for writing"]
    #[doc = ""]
    #[doc = " @param file"]
    #[doc = " @param file_path"]
    #[doc = " @return bool"]
    pub fn lfrfid_raw_file_open_write(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Open RAW file for reading"]
    #[doc = " @param file"]
    #[doc = " @param file_path"]
    #[doc = " @return bool"]
    pub fn lfrfid_raw_file_open_read(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Write RAW file header"]
    #[doc = ""]
    #[doc = " @param file"]
    #[doc = " @param frequency"]
    #[doc = " @param duty_cycle"]
    #[doc = " @param max_buffer_size"]
    #[doc = " @return bool"]
    pub fn lfrfid_raw_file_write_header(
        file: *mut LFRFIDRawFile,
        frequency: f32,
        duty_cycle: f32,
        max_buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Write data to RAW file"]
    #[doc = ""]
    #[doc = " @param file"]
    #[doc = " @param buffer_data"]
    #[doc = " @param buffer_size"]
    #[doc = " @return bool"]
    pub fn lfrfid_raw_file_write_buffer(
        file: *mut LFRFIDRawFile,
        buffer_data: *mut u8,
        buffer_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Read RAW file header"]
    #[doc = ""]
    #[doc = " @param file"]
    #[doc = " @param frequency"]
    #[doc = " @param duty_cycle"]
    #[doc = " @return bool"]
    pub fn lfrfid_raw_file_read_header(
        file: *mut LFRFIDRawFile,
        frequency: *mut f32,
        duty_cycle: *mut f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Read varint-encoded pair from RAW file"]
    #[doc = ""]
    #[doc = " @param file"]
    #[doc = " @param duration"]
    #[doc = " @param pulse"]
    #[doc = " @param pass_end file was wrapped around, can be NULL"]
    #[doc = " @return bool"]
    pub fn lfrfid_raw_file_read_pair(
        file: *mut LFRFIDRawFile,
        duration: *mut u32,
        pulse: *mut u32,
        pass_end: *mut bool,
    ) -> bool;
}
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteOK: LFRFIDWorkerWriteResult = 0;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteProtocolCannotBeWritten:
    LFRFIDWorkerWriteResult = 1;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteFobCannotBeWritten: LFRFIDWorkerWriteResult = 2;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteTooLongToWrite: LFRFIDWorkerWriteResult = 3;
pub type LFRFIDWorkerWriteResult = core::ffi::c_uchar;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypeAuto: LFRFIDWorkerReadType = 0;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypeASKOnly: LFRFIDWorkerReadType = 1;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypePSKOnly: LFRFIDWorkerReadType = 2;
pub type LFRFIDWorkerReadType = core::ffi::c_uchar;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseStart: LFRFIDWorkerReadResult = 0;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseEnd: LFRFIDWorkerReadResult = 1;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseCardStart: LFRFIDWorkerReadResult = 2;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseCardEnd: LFRFIDWorkerReadResult = 3;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadStartASK: LFRFIDWorkerReadResult = 4;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadStartPSK: LFRFIDWorkerReadResult = 5;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadDone: LFRFIDWorkerReadResult = 6;
pub type LFRFIDWorkerReadResult = core::ffi::c_uchar;
pub const LFRFIDWorkerReadRawResult_LFRFIDWorkerReadRawFileError: LFRFIDWorkerReadRawResult = 0;
pub const LFRFIDWorkerReadRawResult_LFRFIDWorkerReadRawOverrun: LFRFIDWorkerReadRawResult = 1;
pub type LFRFIDWorkerReadRawResult = core::ffi::c_uchar;
pub const LFRFIDWorkerEmulateRawResult_LFRFIDWorkerEmulateRawFileError:
    LFRFIDWorkerEmulateRawResult = 0;
pub const LFRFIDWorkerEmulateRawResult_LFRFIDWorkerEmulateRawOverrun: LFRFIDWorkerEmulateRawResult =
    1;
pub type LFRFIDWorkerEmulateRawResult = core::ffi::c_uchar;
pub type LFRFIDWorkerReadCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: LFRFIDWorkerReadResult,
        protocol: ProtocolId,
        context: *mut core::ffi::c_void,
    ),
>;
pub type LFRFIDWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerWriteResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerReadRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerReadRawResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerEmulateRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerEmulateRawResult, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate LF-RFID worker"]
    #[doc = " @return LFRFIDWorker*"]
    pub fn lfrfid_worker_alloc(dict: *mut ProtocolDict) -> *mut LFRFIDWorker;
}
extern "C" {
    #[doc = " Free LF-RFID worker"]
    #[doc = " @param worker"]
    pub fn lfrfid_worker_free(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = " Start LF-RFID worker thread"]
    #[doc = " @param worker"]
    pub fn lfrfid_worker_start_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = " Stop LF-RFID worker thread"]
    #[doc = " @param worker"]
    pub fn lfrfid_worker_stop_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = " @brief Start read mode"]
    #[doc = ""]
    #[doc = " @param worker"]
    #[doc = " @param type"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn lfrfid_worker_read_start(
        worker: *mut LFRFIDWorker,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Start write mode"]
    #[doc = ""]
    #[doc = " @param worker"]
    #[doc = " @param protocol"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn lfrfid_worker_write_start(
        worker: *mut LFRFIDWorker,
        protocol: LFRFIDProtocol,
        callback: LFRFIDWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start emulate mode"]
    #[doc = " @param worker"]
    pub fn lfrfid_worker_emulate_start(worker: *mut LFRFIDWorker, protocol: LFRFIDProtocol);
}
extern "C" {
    #[doc = " @brief Start raw read mode"]
    #[doc = ""]
    #[doc = " @param worker"]
    #[doc = " @param filename"]
    #[doc = " @param type"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn lfrfid_worker_read_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Emulate raw read mode"]
    #[doc = " @param worker"]
    #[doc = " @param filename"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn lfrfid_worker_emulate_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Stop all modes"]
    #[doc = " @param worker"]
    pub fn lfrfid_worker_stop(worker: *mut LFRFIDWorker);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Allocate a new LFRFIDRawWorker instance"]
    #[doc = ""]
    #[doc = " @return LFRFIDRawWorker*"]
    pub fn lfrfid_raw_worker_alloc() -> *mut LFRFIDRawWorker;
}
extern "C" {
    #[doc = " @brief Free a LFRFIDRawWorker instance"]
    #[doc = ""]
    #[doc = " @param worker LFRFIDRawWorker instance"]
    pub fn lfrfid_raw_worker_free(worker: *mut LFRFIDRawWorker);
}
extern "C" {
    #[doc = " @brief Start reading"]
    #[doc = ""]
    #[doc = " @param worker LFRFIDRawWorker instance"]
    #[doc = " @param file_path path where file will be saved"]
    #[doc = " @param frequency HW frequency"]
    #[doc = " @param duty_cycle HW duty cycle"]
    #[doc = " @param callback callback for read event"]
    #[doc = " @param context context for callback"]
    pub fn lfrfid_raw_worker_start_read(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        frequency: f32,
        duty_cycle: f32,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Start emulate"]
    #[doc = ""]
    #[doc = " @param worker LFRFIDRawWorker instance"]
    #[doc = " @param file_path path to file that will be emulated"]
    #[doc = " @param callback callback for emulate event"]
    #[doc = " @param context context for callback"]
    pub fn lfrfid_raw_worker_start_emulate(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Stop worker"]
    #[doc = ""]
    #[doc = " @param worker"]
    pub fn lfrfid_raw_worker_stop(worker: *mut LFRFIDRawWorker);
}
pub const BitLibParity_BitLibParityEven: BitLibParity = 0;
pub const BitLibParity_BitLibParityOdd: BitLibParity = 1;
pub const BitLibParity_BitLibParityAlways0: BitLibParity = 2;
pub const BitLibParity_BitLibParityAlways1: BitLibParity = 3;
pub type BitLibParity = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Push a bit into a byte array."]
    #[doc = "  @param data array to push bit into"]
    #[doc = "  @param data_size array size"]
    #[doc = "  @param bit bit to push"]
    pub fn bit_lib_push_bit(data: *mut u8, data_size: usize, bit: bool);
}
extern "C" {
    #[doc = " @brief Set a bit in a byte array."]
    #[doc = "  @param data array to set bit in"]
    #[doc = "  @param position The position of the bit to set."]
    #[doc = "  @param bit bit value to set"]
    pub fn bit_lib_set_bit(data: *mut u8, position: usize, bit: bool);
}
extern "C" {
    #[doc = " @brief Set the bit at the given position to the given value."]
    #[doc = " @param data The data to set the bit in."]
    #[doc = " @param position The position of the bit to set."]
    #[doc = " @param byte The data to set the bit to."]
    #[doc = " @param length The length of the data."]
    pub fn bit_lib_set_bits(data: *mut u8, position: usize, byte: u8, length: u8);
}
extern "C" {
    #[doc = " @brief Get the bit of a byte."]
    #[doc = " @param data The byte to get the bits from."]
    #[doc = " @param position The position of the bit."]
    #[doc = " @return The bit."]
    pub fn bit_lib_get_bit(data: *const u8, position: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Get the bits of a data, as uint8_t."]
    #[doc = " @param data The data to get the bits from."]
    #[doc = " @param position The position of the first bit."]
    #[doc = " @param length The length of the bits."]
    #[doc = " @return The bits."]
    pub fn bit_lib_get_bits(data: *const u8, position: usize, length: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Get the bits of a data, as uint16_t."]
    #[doc = " @param data The data to get the bits from."]
    #[doc = " @param position The position of the first bit."]
    #[doc = " @param length The length of the bits."]
    #[doc = " @return The bits."]
    pub fn bit_lib_get_bits_16(data: *const u8, position: usize, length: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Get the bits of a data, as uint32_t."]
    #[doc = " @param data The data to get the bits from."]
    #[doc = " @param position The position of the first bit."]
    #[doc = " @param length The length of the bits."]
    #[doc = " @return The bits."]
    pub fn bit_lib_get_bits_32(data: *const u8, position: usize, length: u8) -> u32;
}
extern "C" {
    #[doc = " @brief Test parity of given bits"]
    #[doc = " @param bits Bits to test parity of"]
    #[doc = " @param parity Parity to test against"]
    #[doc = " @return true if parity is correct, false otherwise"]
    pub fn bit_lib_test_parity_32(bits: u32, parity: BitLibParity) -> bool;
}
extern "C" {
    #[doc = " @brief Test parity of bit array, check parity for every parity_length block from start"]
    #[doc = ""]
    #[doc = " @param data Bit array"]
    #[doc = " @param position Start position"]
    #[doc = " @param length Bit count"]
    #[doc = " @param parity Parity to test against"]
    #[doc = " @param parity_length Parity block length"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn bit_lib_test_parity(
        data: *const u8,
        position: usize,
        length: u8,
        parity: BitLibParity,
        parity_length: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Add parity to bit array"]
    #[doc = ""]
    #[doc = " @param data Source bit array"]
    #[doc = " @param position Start position"]
    #[doc = " @param dest Destination bit array"]
    #[doc = " @param dest_position Destination position"]
    #[doc = " @param source_length Source bit count"]
    #[doc = " @param parity_length Parity block length"]
    #[doc = " @param parity Parity to test against"]
    #[doc = " @return size_t"]
    pub fn bit_lib_add_parity(
        data: *const u8,
        position: usize,
        dest: *mut u8,
        dest_position: usize,
        source_length: u8,
        parity_length: u8,
        parity: BitLibParity,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Remove bit every n in array and shift array left. Useful to remove parity."]
    #[doc = ""]
    #[doc = " @param data Bit array"]
    #[doc = " @param position Start position"]
    #[doc = " @param length Bit count"]
    #[doc = " @param n every n bit will be removed"]
    #[doc = " @return size_t"]
    pub fn bit_lib_remove_bit_every_nth(data: *mut u8, position: usize, length: u8, n: u8)
        -> usize;
}
extern "C" {
    #[doc = " @brief Copy bits from source to destination."]
    #[doc = ""]
    #[doc = " @param data destination array"]
    #[doc = " @param position position in destination array"]
    #[doc = " @param length length of bits to copy"]
    #[doc = " @param source source array"]
    #[doc = " @param source_position position in source array"]
    pub fn bit_lib_copy_bits(
        data: *mut u8,
        position: usize,
        length: usize,
        source: *const u8,
        source_position: usize,
    );
}
extern "C" {
    #[doc = " @brief Reverse bits in bit array"]
    #[doc = ""]
    #[doc = " @param data Bit array"]
    #[doc = " @param position start position"]
    #[doc = " @param length length of bits to reverse"]
    pub fn bit_lib_reverse_bits(data: *mut u8, position: usize, length: u8);
}
extern "C" {
    #[doc = " @brief Count 1 bits in data"]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = " @return uint8_t set bit count"]
    pub fn bit_lib_get_bit_count(data: u32) -> u8;
}
extern "C" {
    #[doc = " @brief Print data as bit array"]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = " @param length"]
    pub fn bit_lib_print_bits(data: *const u8, length: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitLibRegion {
    pub mark: core::ffi::c_char,
    pub start: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_BitLibRegion() {
    const UNINIT: ::core::mem::MaybeUninit<BitLibRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BitLibRegion>(),
        24usize,
        concat!("Size of: ", stringify!(BitLibRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<BitLibRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(BitLibRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mark) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " @brief Print data as bit array and mark regions. Regions needs to be sorted by start position."]
    #[doc = ""]
    #[doc = " @param regions"]
    #[doc = " @param region_count"]
    #[doc = " @param data"]
    #[doc = " @param length"]
    pub fn bit_lib_print_regions(
        regions: *const BitLibRegion,
        region_count: usize,
        data: *const u8,
        length: usize,
    );
}
extern "C" {
    #[doc = " @brief Reverse bits in uint16_t, faster than generic bit_lib_reverse_bits."]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = " @return uint16_t"]
    pub fn bit_lib_reverse_16_fast(data: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Reverse bits in uint8_t, faster than generic bit_lib_reverse_bits."]
    #[doc = ""]
    #[doc = " @param byte Byte"]
    #[doc = " @return uint8_t the reversed byte"]
    pub fn bit_lib_reverse_8_fast(byte: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Slow, but generic CRC8 implementation"]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = " @param data_size"]
    #[doc = " @param polynom CRC polynom"]
    #[doc = " @param init init value"]
    #[doc = " @param ref_in true if the right bit is older"]
    #[doc = " @param ref_out true to reverse output"]
    #[doc = " @param xor_out xor output with this value"]
    #[doc = " @return uint8_t"]
    pub fn bit_lib_crc8(
        data: *const u8,
        data_size: usize,
        polynom: u8,
        init: u8,
        ref_in: bool,
        ref_out: bool,
        xor_out: u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Slow, but generic CRC16 implementation"]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = " @param data_size"]
    #[doc = " @param polynom CRC polynom"]
    #[doc = " @param init init value"]
    #[doc = " @param ref_in true if the right bit is older"]
    #[doc = " @param ref_out true to reverse output"]
    #[doc = " @param xor_out xor output with this value"]
    #[doc = " @return uint16_t"]
    pub fn bit_lib_crc16(
        data: *const u8,
        data_size: usize,
        polynom: u16,
        init: u16,
        ref_in: bool,
        ref_out: bool,
        xor_out: u16,
    ) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uECC_Curve_t {
    _unused: [u8; 0],
}
pub type uECC_Curve = *const uECC_Curve_t;
extern "C" {
    pub fn uECC_secp256r1() -> uECC_Curve;
}
pub type uECC_RNG_Function = ::core::option::Option<
    unsafe extern "C" fn(dest: *mut u8, size: core::ffi::c_uint) -> core::ffi::c_int,
>;
extern "C" {
    pub fn uECC_set_rng(rng_function: uECC_RNG_Function);
}
extern "C" {
    pub fn uECC_compute_public_key(
        private_key: *const u8,
        public_key: *mut u8,
        curve: uECC_Curve,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uECC_sign(
        private_key: *const u8,
        message_hash: *const u8,
        hash_size: core::ffi::c_uint,
        signature: *mut u8,
        curve: uECC_Curve,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Allocate file stream"]
    #[doc = " @return Stream*"]
    pub fn file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
    #[doc = " Opens an existing file or create a new one."]
    #[doc = " @param stream pointer to file stream object."]
    #[doc = " @param path path to file"]
    #[doc = " @param access_mode access mode from FS_AccessMode"]
    #[doc = " @param open_mode open mode from FS_OpenMode"]
    #[doc = " @return success flag. You need to close the file even if the open operation failed."]
    pub fn file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Closes the file."]
    #[doc = " @param stream"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Retrieves the error id from the file object"]
    #[doc = " @param stream pointer to stream object."]
    #[doc = " @return FS_Error error id"]
    pub fn file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
    #[doc = " Allocate a file stream with buffered read operations"]
    #[doc = " @return Stream*"]
    pub fn buffered_file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
    #[doc = " Opens an existing file or creates a new one."]
    #[doc = " @param stream pointer to file stream object."]
    #[doc = " @param path path to file"]
    #[doc = " @param access_mode access mode from FS_AccessMode"]
    #[doc = " @param open_mode open mode from FS_OpenMode"]
    #[doc = " @return True on success, False on failure. You need to close the file even if the open operation failed."]
    pub fn buffered_file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Closes the file."]
    #[doc = " @param stream pointer to file stream object."]
    #[doc = " @return True on success, False on failure."]
    pub fn buffered_file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Forces write from cache to the underlying file."]
    #[doc = " @param stream pointer to file stream object."]
    #[doc = " @return True on success, False on failure."]
    pub fn buffered_file_stream_sync(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Retrieves the error id from the file object"]
    #[doc = " @param stream pointer to stream object."]
    #[doc = " @return FS_Error error id"]
    pub fn buffered_file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicDict {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmvData {
    pub name: [core::ffi::c_char; 32usize],
    pub aid: [u8; 16usize],
    pub aid_len: u16,
    pub number: [u8; 10usize],
    pub number_len: u8,
    pub exp_mon: u8,
    pub exp_year: u8,
    pub country_code: u16,
    pub currency_code: u16,
}
#[test]
fn bindgen_test_layout_EmvData() {
    const UNINIT: ::core::mem::MaybeUninit<EmvData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EmvData>(),
        68usize,
        concat!("Size of: ", stringify!(EmvData))
    );
    assert_eq!(
        ::core::mem::align_of::<EmvData>(),
        2usize,
        concat!("Alignment of ", stringify!(EmvData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(aid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aid_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(aid_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_len) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(number_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exp_mon) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(exp_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exp_year) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(exp_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currency_code) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(currency_code)
        )
    );
}
pub const MfUltralightAuthMethod_MfUltralightAuthMethodManual: MfUltralightAuthMethod = 0;
pub const MfUltralightAuthMethod_MfUltralightAuthMethodAmeebo: MfUltralightAuthMethod = 1;
pub const MfUltralightAuthMethod_MfUltralightAuthMethodXiaomi: MfUltralightAuthMethod = 2;
pub type MfUltralightAuthMethod = core::ffi::c_uchar;
pub const MfUltralightType_MfUltralightTypeUnknown: MfUltralightType = 0;
pub const MfUltralightType_MfUltralightTypeNTAG203: MfUltralightType = 1;
pub const MfUltralightType_MfUltralightTypeUL11: MfUltralightType = 2;
pub const MfUltralightType_MfUltralightTypeUL21: MfUltralightType = 3;
pub const MfUltralightType_MfUltralightTypeNTAG213: MfUltralightType = 4;
pub const MfUltralightType_MfUltralightTypeNTAG215: MfUltralightType = 5;
pub const MfUltralightType_MfUltralightTypeNTAG216: MfUltralightType = 6;
pub const MfUltralightType_MfUltralightTypeNTAGI2C1K: MfUltralightType = 7;
pub const MfUltralightType_MfUltralightTypeNTAGI2C2K: MfUltralightType = 8;
pub const MfUltralightType_MfUltralightTypeNTAGI2CPlus1K: MfUltralightType = 9;
pub const MfUltralightType_MfUltralightTypeNTAGI2CPlus2K: MfUltralightType = 10;
pub const MfUltralightType_MfUltralightTypeNum: MfUltralightType = 11;
pub type MfUltralightType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightVersion {
    pub header: u8,
    pub vendor_id: u8,
    pub prod_type: u8,
    pub prod_subtype: u8,
    pub prod_ver_major: u8,
    pub prod_ver_minor: u8,
    pub storage_size: u8,
    pub protocol_type: u8,
}
#[test]
fn bindgen_test_layout_MfUltralightVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightVersion>(),
        8usize,
        concat!("Size of: ", stringify!(MfUltralightVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_subtype) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_ver_major) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_ver_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_ver_minor) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_ver_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).storage_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(storage_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(protocol_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightData {
    pub type_: MfUltralightType,
    pub version: MfUltralightVersion,
    pub signature: [u8; 32usize],
    pub counter: [u32; 3usize],
    pub tearing: [u8; 3usize],
    pub has_auth: bool,
    pub auth_method: MfUltralightAuthMethod,
    pub auth_key: [u8; 4usize],
    pub auth_success: bool,
    pub curr_authlim: u16,
    pub data_size: u16,
    pub data: [u8; 2040usize],
    pub data_read: u16,
}
#[test]
fn bindgen_test_layout_MfUltralightData() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightData>(),
        2112usize,
        concat!("Size of: ", stringify!(MfUltralightData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightData>(),
        4usize,
        concat!("Alignment of ", stringify!(MfUltralightData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tearing) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(tearing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_auth) as usize - ptr as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(has_auth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_method) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_key) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_success) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_success)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curr_authlim) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(curr_authlim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_read) as usize - ptr as usize },
        2110usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(data_read)
        )
    );
}
pub const MfClassicType_MfClassicType1k: MfClassicType = 0;
pub const MfClassicType_MfClassicType4k: MfClassicType = 1;
pub type MfClassicType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicBlock {
    pub value: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_MfClassicBlock() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicBlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicBlock>(),
        16usize,
        concat!("Size of: ", stringify!(MfClassicBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicBlock>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicBlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicBlock),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicData {
    pub type_: MfClassicType,
    pub block_read_mask: [u32; 8usize],
    pub key_a_mask: u64,
    pub key_b_mask: u64,
    pub block: [MfClassicBlock; 256usize],
}
#[test]
fn bindgen_test_layout_MfClassicData() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicData>(),
        4152usize,
        concat!("Size of: ", stringify!(MfClassicData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicData>(),
        8usize,
        concat!("Alignment of ", stringify!(MfClassicData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_read_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(block_read_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_a_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(key_a_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_b_mask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(key_b_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireVersion {
    pub hw_vendor: u8,
    pub hw_type: u8,
    pub hw_subtype: u8,
    pub hw_major: u8,
    pub hw_minor: u8,
    pub hw_storage: u8,
    pub hw_proto: u8,
    pub sw_vendor: u8,
    pub sw_type: u8,
    pub sw_subtype: u8,
    pub sw_major: u8,
    pub sw_minor: u8,
    pub sw_storage: u8,
    pub sw_proto: u8,
    pub uid: [u8; 7usize],
    pub batch: [u8; 5usize],
    pub prod_week: u8,
    pub prod_year: u8,
}
#[test]
fn bindgen_test_layout_MifareDesfireVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireVersion>(),
        28usize,
        concat!("Size of: ", stringify!(MifareDesfireVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(MifareDesfireVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_vendor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_subtype) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_major) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_storage) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_proto) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_vendor) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_subtype) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_major) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_minor) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_storage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_proto) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).batch) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_week) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(prod_week)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_year) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(prod_year)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFreeMemory {
    pub bytes: u32,
}
#[test]
fn bindgen_test_layout_MifareDesfireFreeMemory() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFreeMemory> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFreeMemory>(),
        4usize,
        concat!("Size of: ", stringify!(MifareDesfireFreeMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFreeMemory>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireFreeMemory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFreeMemory),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireKeyVersion {
    pub id: u8,
    pub version: u8,
    pub next: *mut MifareDesfireKeyVersion,
}
#[test]
fn bindgen_test_layout_MifareDesfireKeyVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireKeyVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireKeyVersion>(),
        16usize,
        concat!("Size of: ", stringify!(MifareDesfireKeyVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireKeyVersion>(),
        8usize,
        concat!("Alignment of ", stringify!(MifareDesfireKeyVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeyVersion),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeyVersion),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeyVersion),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireKeySettings {
    pub change_key_id: u8,
    pub config_changeable: bool,
    pub free_create_delete: bool,
    pub free_directory_list: bool,
    pub master_key_changeable: bool,
    pub flags: u8,
    pub max_keys: u8,
    pub key_version_head: *mut MifareDesfireKeyVersion,
}
#[test]
fn bindgen_test_layout_MifareDesfireKeySettings() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireKeySettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireKeySettings>(),
        16usize,
        concat!("Size of: ", stringify!(MifareDesfireKeySettings))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireKeySettings>(),
        8usize,
        concat!("Alignment of ", stringify!(MifareDesfireKeySettings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).change_key_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(change_key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_changeable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(config_changeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_create_delete) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(free_create_delete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_directory_list) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(free_directory_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_key_changeable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(master_key_changeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_keys) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(max_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_version_head) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(key_version_head)
        )
    );
}
pub const MifareDesfireFileType_MifareDesfireFileTypeStandard: MifareDesfireFileType = 0;
pub const MifareDesfireFileType_MifareDesfireFileTypeBackup: MifareDesfireFileType = 1;
pub const MifareDesfireFileType_MifareDesfireFileTypeValue: MifareDesfireFileType = 2;
pub const MifareDesfireFileType_MifareDesfireFileTypeLinearRecord: MifareDesfireFileType = 3;
pub const MifareDesfireFileType_MifareDesfireFileTypeCyclicRecord: MifareDesfireFileType = 4;
pub type MifareDesfireFileType = core::ffi::c_uchar;
pub const MifareDesfireFileCommunicationSettings_MifareDesfireFileCommunicationSettingsPlaintext:
    MifareDesfireFileCommunicationSettings = 0;
pub const MifareDesfireFileCommunicationSettings_MifareDesfireFileCommunicationSettingsAuthenticated : MifareDesfireFileCommunicationSettings = 1 ;
pub const MifareDesfireFileCommunicationSettings_MifareDesfireFileCommunicationSettingsEnciphered : MifareDesfireFileCommunicationSettings = 3 ;
pub type MifareDesfireFileCommunicationSettings = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MifareDesfireFile {
    pub id: u8,
    pub type_: MifareDesfireFileType,
    pub comm: MifareDesfireFileCommunicationSettings,
    pub access_rights: u16,
    pub settings: MifareDesfireFile__bindgen_ty_1,
    pub contents: *mut u8,
    pub next: *mut MifareDesfireFile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MifareDesfireFile__bindgen_ty_1 {
    pub data: MifareDesfireFile__bindgen_ty_1__bindgen_ty_1,
    pub value: MifareDesfireFile__bindgen_ty_1__bindgen_ty_2,
    pub record: MifareDesfireFile__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFile__bindgen_ty_1__bindgen_ty_1 {
    pub size: u32,
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFile__bindgen_ty_1__bindgen_ty_2 {
    pub lo_limit: u32,
    pub hi_limit: u32,
    pub limited_credit_value: u32,
    pub limited_credit_enabled: bool,
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lo_limit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lo_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hi_limit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hi_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limited_credit_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(limited_credit_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limited_credit_enabled) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(limited_credit_enabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFile__bindgen_ty_1__bindgen_ty_3 {
    pub size: u32,
    pub max: u32,
    pub cur: u32,
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(cur)
        )
    );
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MifareDesfireFile__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireFile__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1),
            "::",
            stringify!(record)
        )
    );
}
#[test]
fn bindgen_test_layout_MifareDesfireFile() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile>(),
        40usize,
        concat!("Size of: ", stringify!(MifareDesfireFile))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile>(),
        8usize,
        concat!("Alignment of ", stringify!(MifareDesfireFile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comm) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).access_rights) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(access_rights)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).settings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).contents) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireApplication {
    pub id: [u8; 3usize],
    pub key_settings: *mut MifareDesfireKeySettings,
    pub file_head: *mut MifareDesfireFile,
    pub next: *mut MifareDesfireApplication,
}
#[test]
fn bindgen_test_layout_MifareDesfireApplication() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireApplication> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireApplication>(),
        32usize,
        concat!("Size of: ", stringify!(MifareDesfireApplication))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(MifareDesfireApplication))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_settings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(key_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_head) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(file_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireData {
    pub version: MifareDesfireVersion,
    pub free_memory: *mut MifareDesfireFreeMemory,
    pub master_key_settings: *mut MifareDesfireKeySettings,
    pub app_head: *mut MifareDesfireApplication,
}
#[test]
fn bindgen_test_layout_MifareDesfireData() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireData>(),
        56usize,
        concat!("Size of: ", stringify!(MifareDesfireData))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireData>(),
        8usize,
        concat!("Alignment of ", stringify!(MifareDesfireData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_memory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(free_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_key_settings) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(master_key_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_head) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(app_head)
        )
    );
}
pub type NfcLoadingCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: bool)>;
pub const NfcProtocol_NfcDeviceProtocolUnknown: NfcProtocol = 0;
pub const NfcProtocol_NfcDeviceProtocolEMV: NfcProtocol = 1;
pub const NfcProtocol_NfcDeviceProtocolMifareUl: NfcProtocol = 2;
pub const NfcProtocol_NfcDeviceProtocolMifareClassic: NfcProtocol = 3;
pub const NfcProtocol_NfcDeviceProtocolMifareDesfire: NfcProtocol = 4;
pub type NfcProtocol = core::ffi::c_uchar;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatUid: NfcDeviceSaveFormat = 0;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatBankCard: NfcDeviceSaveFormat = 1;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatMifareUl: NfcDeviceSaveFormat = 2;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatMifareClassic: NfcDeviceSaveFormat = 3;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatMifareDesfire: NfcDeviceSaveFormat = 4;
pub type NfcDeviceSaveFormat = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcReaderRequestData {
    pub data: [u8; 64usize],
    pub size: u16,
}
#[test]
fn bindgen_test_layout_NfcReaderRequestData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcReaderRequestData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcReaderRequestData>(),
        66usize,
        concat!("Size of: ", stringify!(NfcReaderRequestData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcReaderRequestData>(),
        2usize,
        concat!("Alignment of ", stringify!(NfcReaderRequestData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcReaderRequestData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcReaderRequestData),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcMfClassicDictAttackData {
    pub dict: *mut MfClassicDict,
}
#[test]
fn bindgen_test_layout_NfcMfClassicDictAttackData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcMfClassicDictAttackData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcMfClassicDictAttackData>(),
        8usize,
        concat!("Size of: ", stringify!(NfcMfClassicDictAttackData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcMfClassicDictAttackData>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcMfClassicDictAttackData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcMfClassicDictAttackData),
            "::",
            stringify!(dict)
        )
    );
}
pub const NfcReadMode_NfcReadModeAuto: NfcReadMode = 0;
pub const NfcReadMode_NfcReadModeMfClassic: NfcReadMode = 1;
pub const NfcReadMode_NfcReadModeMfUltralight: NfcReadMode = 2;
pub const NfcReadMode_NfcReadModeMfDesfire: NfcReadMode = 3;
pub const NfcReadMode_NfcReadModeEMV: NfcReadMode = 4;
pub const NfcReadMode_NfcReadModeNFCA: NfcReadMode = 5;
pub type NfcReadMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NfcDeviceData {
    pub nfc_data: FuriHalNfcDevData,
    pub protocol: NfcProtocol,
    pub read_mode: NfcReadMode,
    pub __bindgen_anon_1: NfcDeviceData__bindgen_ty_1,
    pub __bindgen_anon_2: NfcDeviceData__bindgen_ty_2,
    pub parsed_data: *mut FuriString,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NfcDeviceData__bindgen_ty_1 {
    pub reader_data: NfcReaderRequestData,
    pub mf_classic_dict_attack_data: NfcMfClassicDictAttackData,
}
#[test]
fn bindgen_test_layout_NfcDeviceData__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDeviceData__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDeviceData__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(NfcDeviceData__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDeviceData__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDeviceData__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reader_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_1),
            "::",
            stringify!(reader_data)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).mf_classic_dict_attack_data) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_1),
            "::",
            stringify!(mf_classic_dict_attack_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NfcDeviceData__bindgen_ty_2 {
    pub emv_data: EmvData,
    pub mf_ul_data: MfUltralightData,
    pub mf_classic_data: MfClassicData,
    pub mf_df_data: MifareDesfireData,
}
#[test]
fn bindgen_test_layout_NfcDeviceData__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDeviceData__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDeviceData__bindgen_ty_2>(),
        4152usize,
        concat!("Size of: ", stringify!(NfcDeviceData__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDeviceData__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDeviceData__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).emv_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(emv_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_ul_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(mf_ul_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_classic_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(mf_classic_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_df_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(mf_df_data)
        )
    );
}
#[test]
fn bindgen_test_layout_NfcDeviceData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDeviceData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDeviceData>(),
        4264usize,
        concat!("Size of: ", stringify!(NfcDeviceData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDeviceData>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDeviceData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nfc_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(nfc_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_mode) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(read_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parsed_data) as usize - ptr as usize },
        4256usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(parsed_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NfcDevice {
    pub storage: *mut Storage,
    pub dialogs: *mut DialogsApp,
    pub dev_data: NfcDeviceData,
    pub dev_name: [core::ffi::c_char; 23usize],
    pub load_path: *mut FuriString,
    pub format: NfcDeviceSaveFormat,
    pub shadow_file_exist: bool,
    pub loading_cb: NfcLoadingCallback,
    pub loading_cb_ctx: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_NfcDevice() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDevice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDevice>(),
        4336usize,
        concat!("Size of: ", stringify!(NfcDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDevice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dialogs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(dialogs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(dev_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        4280usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).load_path) as usize - ptr as usize },
        4304usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(load_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4312usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shadow_file_exist) as usize - ptr as usize },
        4313usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(shadow_file_exist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loading_cb) as usize - ptr as usize },
        4320usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(loading_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loading_cb_ctx) as usize - ptr as usize },
        4328usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(loading_cb_ctx)
        )
    );
}
extern "C" {
    pub fn nfc_device_alloc() -> *mut NfcDevice;
}
extern "C" {
    pub fn nfc_device_free(nfc_dev: *mut NfcDevice);
}
extern "C" {
    pub fn nfc_device_set_name(dev: *mut NfcDevice, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn nfc_device_save(dev: *mut NfcDevice, dev_name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn nfc_device_save_shadow(dev: *mut NfcDevice, dev_name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn nfc_device_load(
        dev: *mut NfcDevice,
        file_path: *const core::ffi::c_char,
        show_dialog: bool,
    ) -> bool;
}
extern "C" {
    pub fn nfc_device_load_key_cache(dev: *mut NfcDevice) -> bool;
}
extern "C" {
    pub fn nfc_file_select(dev: *mut NfcDevice) -> bool;
}
extern "C" {
    pub fn nfc_device_data_clear(dev: *mut NfcDeviceData);
}
extern "C" {
    pub fn nfc_device_clear(dev: *mut NfcDevice);
}
extern "C" {
    pub fn nfc_device_delete(dev: *mut NfcDevice, use_load_path: bool) -> bool;
}
extern "C" {
    pub fn nfc_device_restore(dev: *mut NfcDevice, use_load_path: bool) -> bool;
}
extern "C" {
    pub fn nfc_device_set_loading_callback(
        dev: *mut NfcDevice,
        callback: NfcLoadingCallback,
        context: *mut core::ffi::c_void,
    );
}
pub const iButtonKeyType_iButtonKeyDS1990: iButtonKeyType = 0;
pub const iButtonKeyType_iButtonKeyCyfral: iButtonKeyType = 1;
pub const iButtonKeyType_iButtonKeyMetakom: iButtonKeyType = 2;
pub type iButtonKeyType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonKey {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate key"]
    #[doc = " @return iButtonKey*"]
    pub fn ibutton_key_alloc() -> *mut iButtonKey;
}
extern "C" {
    #[doc = " Free key"]
    #[doc = " @param key"]
    pub fn ibutton_key_free(key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Copy key"]
    #[doc = " @param to"]
    #[doc = " @param from"]
    pub fn ibutton_key_set(to: *mut iButtonKey, from: *const iButtonKey);
}
extern "C" {
    #[doc = " Set key data"]
    #[doc = " @param key"]
    #[doc = " @param data"]
    #[doc = " @param data_count"]
    pub fn ibutton_key_set_data(key: *mut iButtonKey, data: *mut u8, data_count: u8);
}
extern "C" {
    #[doc = " Clear key data"]
    #[doc = " @param key"]
    pub fn ibutton_key_clear_data(key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Get pointer to key data"]
    #[doc = " @param key"]
    #[doc = " @return const uint8_t*"]
    pub fn ibutton_key_get_data_p(key: *mut iButtonKey) -> *const u8;
}
extern "C" {
    #[doc = " Get key data size"]
    #[doc = " @param key"]
    #[doc = " @return uint8_t"]
    pub fn ibutton_key_get_data_size(key: *mut iButtonKey) -> u8;
}
extern "C" {
    #[doc = " Set key type"]
    #[doc = " @param key"]
    #[doc = " @param key_type"]
    pub fn ibutton_key_set_type(key: *mut iButtonKey, key_type: iButtonKeyType);
}
extern "C" {
    #[doc = " Get key type"]
    #[doc = " @param key"]
    #[doc = " @return iButtonKeyType"]
    pub fn ibutton_key_get_type(key: *mut iButtonKey) -> iButtonKeyType;
}
extern "C" {
    #[doc = " Get type string from key type"]
    #[doc = " @param key_type"]
    #[doc = " @return const char*"]
    pub fn ibutton_key_get_string_by_type(key_type: iButtonKeyType) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get key type from string"]
    #[doc = " @param type_string"]
    #[doc = " @param key_type"]
    #[doc = " @return bool"]
    pub fn ibutton_key_get_type_by_string(
        type_string: *const core::ffi::c_char,
        key_type: *mut iButtonKeyType,
    ) -> bool;
}
extern "C" {
    #[doc = " Get key data size from type"]
    #[doc = " @param key_type"]
    #[doc = " @return uint8_t"]
    pub fn ibutton_key_get_size_by_type(key_type: iButtonKeyType) -> u8;
}
extern "C" {
    #[doc = " Get max key size"]
    #[doc = " @return uint8_t"]
    pub fn ibutton_key_get_max_size() -> u8;
}
extern "C" {
    #[doc = " Check if CRC for onewire key is valid"]
    #[doc = " @param key"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn ibutton_key_dallas_crc_is_valid(key: *mut iButtonKey) -> bool;
}
extern "C" {
    #[doc = " Check if onewire key is a DS1990 key"]
    #[doc = " @param key"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn ibutton_key_dallas_is_1990_key(key: *mut iButtonKey) -> bool;
}
pub const iButtonWorkerWriteResult_iButtonWorkerWriteOK: iButtonWorkerWriteResult = 0;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteSameKey: iButtonWorkerWriteResult = 1;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteNoDetect: iButtonWorkerWriteResult = 2;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteCannotWrite: iButtonWorkerWriteResult = 3;
pub type iButtonWorkerWriteResult = core::ffi::c_uchar;
pub type iButtonWorkerReadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type iButtonWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, result: iButtonWorkerWriteResult),
>;
pub type iButtonWorkerEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, emulated: bool)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate ibutton worker"]
    #[doc = " @return iButtonWorker*"]
    pub fn ibutton_worker_alloc() -> *mut iButtonWorker;
}
extern "C" {
    #[doc = " Free ibutton worker"]
    #[doc = " @param worker"]
    pub fn ibutton_worker_free(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = " Start ibutton worker thread"]
    #[doc = " @param worker"]
    pub fn ibutton_worker_start_thread(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = " Stop ibutton worker thread"]
    #[doc = " @param worker"]
    pub fn ibutton_worker_stop_thread(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = " Set \"read success\" callback"]
    #[doc = " @param worker"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn ibutton_worker_read_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start read mode"]
    #[doc = " @param worker"]
    #[doc = " @param key"]
    pub fn ibutton_worker_read_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Set \"write event\" callback"]
    #[doc = " @param worker"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn ibutton_worker_write_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start write mode"]
    #[doc = " @param worker"]
    #[doc = " @param key"]
    pub fn ibutton_worker_write_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Set \"emulate success\" callback"]
    #[doc = " @param worker"]
    #[doc = " @param callback"]
    #[doc = " @param context"]
    pub fn ibutton_worker_emulate_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start emulate mode"]
    #[doc = " @param worker"]
    #[doc = " @param key"]
    pub fn ibutton_worker_emulate_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Stop all modes"]
    #[doc = " @param worker"]
    pub fn ibutton_worker_stop(worker: *mut iButtonWorker);
}
extern "C" {
    pub fn maxim_crc8(data: *const u8, data_size: u8, crc_init: u8) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireSlave {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireDevice {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate onewire device with ID"]
    #[doc = " @param id_1"]
    #[doc = " @param id_2"]
    #[doc = " @param id_3"]
    #[doc = " @param id_4"]
    #[doc = " @param id_5"]
    #[doc = " @param id_6"]
    #[doc = " @param id_7"]
    #[doc = " @param id_8"]
    #[doc = " @return OneWireDevice*"]
    pub fn onewire_device_alloc(
        id_1: u8,
        id_2: u8,
        id_3: u8,
        id_4: u8,
        id_5: u8,
        id_6: u8,
        id_7: u8,
        id_8: u8,
    ) -> *mut OneWireDevice;
}
extern "C" {
    #[doc = " Deallocate onewire device"]
    #[doc = " @param device"]
    pub fn onewire_device_free(device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Send ID report, called from onewire slave"]
    #[doc = " @param device"]
    pub fn onewire_device_send_id(device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Attach device to onewire slave bus"]
    #[doc = " @param device"]
    #[doc = " @param bus"]
    pub fn onewire_device_attach(device: *mut OneWireDevice, bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Attach device from onewire slave bus"]
    #[doc = " @param device"]
    pub fn onewire_device_detach(device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Get pointer to device id array"]
    #[doc = " @param device"]
    #[doc = " @return uint8_t*"]
    pub fn onewire_device_get_id_p(device: *mut OneWireDevice) -> *mut u8;
}
#[doc = "< Search for alarmed device"]
pub const OneWireHostSearchMode_CONDITIONAL_SEARCH: OneWireHostSearchMode = 0;
#[doc = "< Search all devices"]
pub const OneWireHostSearchMode_NORMAL_SEARCH: OneWireHostSearchMode = 1;
pub type OneWireHostSearchMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireHost {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate onewire host bus"]
    #[doc = " @param gpio"]
    #[doc = " @return OneWireHost*"]
    pub fn onewire_host_alloc() -> *mut OneWireHost;
}
extern "C" {
    #[doc = " Deallocate onewire host bus"]
    #[doc = " @param host"]
    pub fn onewire_host_free(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " Reset bus"]
    #[doc = " @param host"]
    #[doc = " @return bool"]
    pub fn onewire_host_reset(host: *mut OneWireHost) -> bool;
}
extern "C" {
    #[doc = " Read one bit"]
    #[doc = " @param host"]
    #[doc = " @return bool"]
    pub fn onewire_host_read_bit(host: *mut OneWireHost) -> bool;
}
extern "C" {
    #[doc = " Read one byte"]
    #[doc = " @param host"]
    #[doc = " @return uint8_t"]
    pub fn onewire_host_read(host: *mut OneWireHost) -> u8;
}
extern "C" {
    #[doc = " Read many bytes"]
    #[doc = " @param host"]
    #[doc = " @param buffer"]
    #[doc = " @param count"]
    pub fn onewire_host_read_bytes(host: *mut OneWireHost, buffer: *mut u8, count: u16);
}
extern "C" {
    #[doc = " Write one bit"]
    #[doc = " @param host"]
    #[doc = " @param value"]
    pub fn onewire_host_write_bit(host: *mut OneWireHost, value: bool);
}
extern "C" {
    #[doc = " Write one byte"]
    #[doc = " @param host"]
    #[doc = " @param value"]
    pub fn onewire_host_write(host: *mut OneWireHost, value: u8);
}
extern "C" {
    #[doc = " Skip ROM command"]
    #[doc = " @param host"]
    pub fn onewire_host_skip(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " Start working with the bus"]
    #[doc = " @param host"]
    pub fn onewire_host_start(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " Stop working with the bus"]
    #[doc = " @param host"]
    pub fn onewire_host_stop(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " @param host"]
    pub fn onewire_host_reset_search(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " @param host"]
    #[doc = " @param family_code"]
    pub fn onewire_host_target_search(host: *mut OneWireHost, family_code: u8);
}
extern "C" {
    #[doc = " @param host"]
    #[doc = " @param newAddr"]
    #[doc = " @param mode"]
    #[doc = " @return uint8_t"]
    pub fn onewire_host_search(
        host: *mut OneWireHost,
        newAddr: *mut u8,
        mode: OneWireHostSearchMode,
    ) -> u8;
}
pub type OneWireSlaveResultCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate onewire slave"]
    #[doc = " @param pin"]
    #[doc = " @return OneWireSlave*"]
    pub fn onewire_slave_alloc() -> *mut OneWireSlave;
}
extern "C" {
    #[doc = " Free onewire slave"]
    #[doc = " @param bus"]
    pub fn onewire_slave_free(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Start working with the bus"]
    #[doc = " @param bus"]
    pub fn onewire_slave_start(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Stop working with the bus"]
    #[doc = " @param bus"]
    pub fn onewire_slave_stop(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Attach device for emulation"]
    #[doc = " @param bus"]
    #[doc = " @param device"]
    pub fn onewire_slave_attach(bus: *mut OneWireSlave, device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Detach device from bus"]
    #[doc = " @param bus"]
    pub fn onewire_slave_detach(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Set a callback to report emulation success"]
    #[doc = " @param bus"]
    #[doc = " @param result_cb"]
    #[doc = " @param context"]
    pub fn onewire_slave_set_result_callback(
        bus: *mut OneWireSlave,
        result_cb: OneWireSlaveResultCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wrap_printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_vsnprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_puts(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_putchar(ch: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_putc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_snprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_fflush(stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap___assert(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        e: *const core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __wrap___assert_func(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        e: *const core::ffi::c_char,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockDecoder {
    pub parser_step: u32,
    pub te_last: u32,
    pub decode_data: u64,
    pub decode_count_bit: u8,
}
#[test]
fn bindgen_test_layout_SubGhzBlockDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzBlockDecoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzBlockDecoder>(),
        24usize,
        concat!("Size of: ", stringify!(SubGhzBlockDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzBlockDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzBlockDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parser_step) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(parser_step)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).te_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(te_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decode_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(decode_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decode_count_bit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(decode_count_bit)
        )
    );
}
extern "C" {
    #[doc = " Add data bit when decoding."]
    #[doc = " @param decoder Pointer to a SubGhzBlockDecoder instance"]
    #[doc = " @param bit data, 1bit"]
    pub fn subghz_protocol_blocks_add_bit(decoder: *mut SubGhzBlockDecoder, bit: u8);
}
extern "C" {
    #[doc = " Add data to_128 bit when decoding."]
    #[doc = " @param decoder Pointer to a SubGhzBlockDecoder instance"]
    #[doc = " @param head_64_bit Pointer to a head_64_bit"]
    #[doc = " @param bit data, 1bit"]
    pub fn subghz_protocol_blocks_add_to_128_bit(
        decoder: *mut SubGhzBlockDecoder,
        bit: u8,
        head_64_bit: *mut u64,
    );
}
extern "C" {
    #[doc = " Getting the hash sum of the last randomly received parcel."]
    #[doc = " @param decoder Pointer to a SubGhzBlockDecoder instance"]
    #[doc = " @return hash Hash sum"]
    pub fn subghz_protocol_blocks_get_hash_data(decoder: *mut SubGhzBlockDecoder, len: usize)
        -> u8;
}
extern "C" {
    #[doc = " Set data bit when encoding HEX array."]
    #[doc = " @param bit_value The value of the bit to be set"]
    #[doc = " @param data_array Pointer to a HEX array"]
    #[doc = " @param set_index_bit Number set a bit in the array starting from the left"]
    #[doc = " @param max_size_array array size, check not to overflow"]
    pub fn subghz_protocol_blocks_set_bit_array(
        bit_value: bool,
        data_array: *mut u8,
        set_index_bit: usize,
        max_size_array: usize,
    );
}
extern "C" {
    #[doc = " Get data bit when encoding HEX array."]
    #[doc = " @param data_array Pointer to a HEX array"]
    #[doc = " @param read_index_bit Number get a bit in the array starting from the left"]
    #[doc = " @return bool value bit"]
    pub fn subghz_protocol_blocks_get_bit_array(data_array: *mut u8, read_index_bit: usize)
        -> bool;
}
extern "C" {
    #[doc = " Generating an upload from data."]
    #[doc = " @param data_array Pointer to a HEX array"]
    #[doc = " @param count_bit_data_array How many bits in the array are processed"]
    #[doc = " @param upload Pointer to a LevelDuration"]
    #[doc = " @param max_size_upload upload size, check not to overflow"]
    #[doc = " @param duration_bit duration 1 bit"]
    pub fn subghz_protocol_blocks_get_upload(
        data_array: *mut u8,
        count_bit_data_array: usize,
        upload: *mut LevelDuration,
        max_size_upload: usize,
        duration_bit: u32,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKeystore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzEnvironment {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate SubGhzEnvironment."]
    #[doc = " @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_alloc() -> *mut SubGhzEnvironment;
}
extern "C" {
    #[doc = " Free SubGhzEnvironment."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_free(instance: *mut SubGhzEnvironment);
}
extern "C" {
    #[doc = " Downloading the manufacture key file."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @param filename Full path to the file"]
    #[doc = " @return true On succes"]
    pub fn subghz_environment_load_keystore(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get pointer to a SubGhzKeystore* instance."]
    #[doc = " @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_get_keystore(instance: *mut SubGhzEnvironment)
        -> *mut SubGhzKeystore;
}
extern "C" {
    #[doc = " Set filename to work with Came Atomo."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @param filename Full path to the file"]
    pub fn subghz_environment_set_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get filename to work with Came Atomo."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return Full path to the file"]
    pub fn subghz_environment_get_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Set filename to work with Nice Flor-S."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @param filename Full path to the file"]
    pub fn subghz_environment_set_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get filename to work with Nice Flor-S."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return Full path to the file"]
    pub fn subghz_environment_get_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Set list of protocols to work."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @param protocol_registry_items Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_set_protocol_registry(
        instance: *mut SubGhzEnvironment,
        protocol_registry_items: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get list of protocols to work."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_get_protocol_registry(
        instance: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Get list of protocols names."]
    #[doc = " @param instance Pointer to a SubGhzEnvironment instance"]
    #[doc = " @param idx index protocols"]
    #[doc = " @return Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_get_protocol_name_registry(
        instance: *mut SubGhzEnvironment,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzRadioPreset {
    pub name: *mut FuriString,
    pub frequency: u32,
    pub data: *mut u8,
    pub data_size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzRadioPreset() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzRadioPreset> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzRadioPreset>(),
        32usize,
        concat!("Size of: ", stringify!(SubGhzRadioPreset))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzRadioPreset>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzRadioPreset))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(data_size)
        )
    );
}
pub type SubGhzAlloc = ::core::option::Option<
    unsafe extern "C" fn(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void,
>;
pub type SubGhzFree = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzSerialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> bool,
>;
pub type SubGhzDeserialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> bool,
>;
pub type SubGhzDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, level: bool, duration: u32),
>;
pub type SubGhzDecoderReset =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void)>;
pub type SubGhzGetHashData =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void) -> u8>;
pub type SubGhzGetString = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, output: *mut FuriString),
>;
pub type SubGhzEncoderStop =
    ::core::option::Option<unsafe extern "C" fn(encoder: *mut core::ffi::c_void)>;
pub type SubGhzEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub feed: SubGhzDecoderFeed,
    pub reset: SubGhzDecoderReset,
    pub get_hash_data: SubGhzGetHashData,
    pub get_string: SubGhzGetString,
    pub serialize: SubGhzSerialize,
    pub deserialize: SubGhzDeserialize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolDecoder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolDecoder>(),
        64usize,
        concat!("Size of: ", stringify!(SubGhzProtocolDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(feed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_hash_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(get_hash_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(get_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(deserialize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub deserialize: SubGhzDeserialize,
    pub stop: SubGhzEncoderStop,
    pub yield_: SubGhzEncoderYield,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolEncoder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolEncoder>(),
        40usize,
        concat!("Size of: ", stringify!(SubGhzProtocolEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(yield_)
        )
    );
}
pub const SubGhzProtocolType_SubGhzProtocolTypeUnknown: SubGhzProtocolType = 0;
pub const SubGhzProtocolType_SubGhzProtocolTypeStatic: SubGhzProtocolType = 1;
pub const SubGhzProtocolType_SubGhzProtocolTypeDynamic: SubGhzProtocolType = 2;
pub const SubGhzProtocolType_SubGhzProtocolTypeRAW: SubGhzProtocolType = 3;
pub const SubGhzProtocolType_SubGhzProtocolWeatherStation: SubGhzProtocolType = 4;
pub const SubGhzProtocolType_SubGhzProtocolCustom: SubGhzProtocolType = 5;
pub type SubGhzProtocolType = core::ffi::c_uchar;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_RAW: SubGhzProtocolFlag = 1;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Decodable: SubGhzProtocolFlag = 2;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_315: SubGhzProtocolFlag = 4;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_433: SubGhzProtocolFlag = 8;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_868: SubGhzProtocolFlag = 16;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_AM: SubGhzProtocolFlag = 32;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_FM: SubGhzProtocolFlag = 64;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Save: SubGhzProtocolFlag = 128;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Load: SubGhzProtocolFlag = 256;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Send: SubGhzProtocolFlag = 512;
pub type SubGhzProtocolFlag = core::ffi::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocol {
    pub name: *const core::ffi::c_char,
    pub type_: SubGhzProtocolType,
    pub flag: SubGhzProtocolFlag,
    pub encoder: *const SubGhzProtocolEncoder,
    pub decoder: *const SubGhzProtocolDecoder,
}
#[test]
fn bindgen_test_layout_SubGhzProtocol() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocol> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocol>(),
        32usize,
        concat!("Size of: ", stringify!(SubGhzProtocol))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocol>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzProtocol))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(decoder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockGeneric {
    pub protocol_name: *const core::ffi::c_char,
    pub data: u64,
    pub serial: u32,
    pub data_count_bit: u8,
    pub btn: u8,
    pub cnt: u32,
}
#[test]
fn bindgen_test_layout_SubGhzBlockGeneric() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzBlockGeneric> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzBlockGeneric>(),
        32usize,
        concat!("Size of: ", stringify!(SubGhzBlockGeneric))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzBlockGeneric>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzBlockGeneric))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(protocol_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_count_bit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data_count_bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).btn) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(btn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(cnt)
        )
    );
}
extern "C" {
    #[doc = " Get name preset."]
    #[doc = " @param preset_name name preset"]
    #[doc = " @param preset_str Output name preset"]
    pub fn subghz_block_generic_get_preset_name(
        preset_name: *const core::ffi::c_char,
        preset_str: *mut FuriString,
    );
}
extern "C" {
    #[doc = " Serialize data SubGhzBlockGeneric."]
    #[doc = " @param instance Pointer to a SubGhzBlockGeneric instance"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param preset The modulation on which the signal was received, SubGhzRadioPreset"]
    #[doc = " @return true On success"]
    pub fn subghz_block_generic_serialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = " Deserialize data SubGhzBlockGeneric."]
    #[doc = " @param instance Pointer to a SubGhzBlockGeneric instance"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @return true On success"]
    pub fn subghz_block_generic_deserialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Flip the data bitwise"]
    #[doc = ""]
    #[doc = " @param      key        In data"]
    #[doc = " @param      bit_count  number of data bits"]
    #[doc = ""]
    #[doc = " @return     Reverse data"]
    pub fn subghz_protocol_blocks_reverse_key(key: u64, bit_count: u8) -> u64;
}
extern "C" {
    #[doc = " Get parity the data bitwise"]
    #[doc = ""]
    #[doc = " @param      key        In data"]
    #[doc = " @param      bit_count  number of data bits"]
    #[doc = ""]
    #[doc = " @return     parity"]
    pub fn subghz_protocol_blocks_get_parity(key: u64, bit_count: u8) -> u8;
}
extern "C" {
    #[doc = " CRC-4"]
    #[doc = ""]
    #[doc = " @param      message     array of bytes to check"]
    #[doc = " @param      size        number of bytes in message"]
    #[doc = " @param      polynomial  CRC polynomial"]
    #[doc = " @param      init        starting crc value"]
    #[doc = ""]
    #[doc = " @return     CRC value"]
    pub fn subghz_protocol_blocks_crc4(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " CRC-7"]
    #[doc = ""]
    #[doc = " @param      message     array of bytes to check"]
    #[doc = " @param      size        number of bytes in message"]
    #[doc = " @param      polynomial  CRC polynomial"]
    #[doc = " @param      init        starting crc value"]
    #[doc = ""]
    #[doc = " @return     CRC value"]
    pub fn subghz_protocol_blocks_crc7(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Generic Cyclic Redundancy Check CRC-8. Example polynomial: 0x31 = x8 + x5 +"]
    #[doc = " x4 + 1 (x8 is implicit) Example polynomial: 0x80 = x8 + x7 (a normal"]
    #[doc = " bit-by-bit parity XOR)"]
    #[doc = ""]
    #[doc = " @param      message     array of bytes to check"]
    #[doc = " @param      size        number of bytes in message"]
    #[doc = " @param      polynomial  byte is from x^7 to x^0 (x^8 is implicitly one)"]
    #[doc = " @param      init        starting crc value"]
    #[doc = ""]
    #[doc = " @return     CRC value"]
    pub fn subghz_protocol_blocks_crc8(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " \"Little-endian\" Cyclic Redundancy Check CRC-8 LE Input and output are"]
    #[doc = " reflected, i.e. least significant bit is shifted in first"]
    #[doc = ""]
    #[doc = " @param      message     array of bytes to check"]
    #[doc = " @param      size        number of bytes in message"]
    #[doc = " @param      polynomial  CRC polynomial"]
    #[doc = " @param      init        starting crc value"]
    #[doc = ""]
    #[doc = " @return     CRC value"]
    pub fn subghz_protocol_blocks_crc8le(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " CRC-16 LSB. Input and output are reflected, i.e. least significant bit is"]
    #[doc = " shifted in first. Note that poly and init already need to be reflected"]
    #[doc = ""]
    #[doc = " @param      message     array of bytes to check"]
    #[doc = " @param      size        number of bytes in message"]
    #[doc = " @param      polynomial  CRC polynomial"]
    #[doc = " @param      init        starting crc value"]
    #[doc = ""]
    #[doc = " @return     CRC value"]
    pub fn subghz_protocol_blocks_crc16lsb(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " CRC-16"]
    #[doc = ""]
    #[doc = " @param      message     array of bytes to check"]
    #[doc = " @param      size        number of bytes in message"]
    #[doc = " @param      polynomial  CRC polynomial"]
    #[doc = " @param      init        starting crc value"]
    #[doc = ""]
    #[doc = " @return     CRC value"]
    pub fn subghz_protocol_blocks_crc16(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Digest-8 by \"LFSR-based Toeplitz hash\""]
    #[doc = ""]
    #[doc = " @param      message  bytes of message data"]
    #[doc = " @param      size     number of bytes to digest"]
    #[doc = " @param      gen      key stream generator, needs to includes the MSB if the"]
    #[doc = "                      LFSR is rolling"]
    #[doc = " @param      key      initial key"]
    #[doc = ""]
    #[doc = " @return     digest value"]
    pub fn subghz_protocol_blocks_lfsr_digest8(
        message: *const u8,
        size: usize,
        gen: u8,
        key: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Digest-8 by \"LFSR-based Toeplitz hash\", byte reflect, bit reflect"]
    #[doc = ""]
    #[doc = " @param      message  bytes of message data"]
    #[doc = " @param      size     number of bytes to digest"]
    #[doc = " @param      gen      key stream generator, needs to includes the MSB if the"]
    #[doc = "                      LFSR is rolling"]
    #[doc = " @param      key      initial key"]
    #[doc = ""]
    #[doc = " @return     digest value"]
    pub fn subghz_protocol_blocks_lfsr_digest8_reflect(
        message: *const u8,
        size: usize,
        gen: u8,
        key: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Digest-16 by \"LFSR-based Toeplitz hash\""]
    #[doc = ""]
    #[doc = " @param      message  bytes of message data"]
    #[doc = " @param      size     number of bytes to digest"]
    #[doc = " @param      gen      key stream generator, needs to includes the MSB if the"]
    #[doc = "                      LFSR is rolling"]
    #[doc = " @param      key      initial key"]
    #[doc = ""]
    #[doc = " @return     digest value"]
    pub fn subghz_protocol_blocks_lfsr_digest16(
        message: *const u8,
        size: usize,
        gen: u16,
        key: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Compute Addition of a number of bytes"]
    #[doc = ""]
    #[doc = " @param      message  bytes of message data"]
    #[doc = " @param      size     number of bytes to sum"]
    #[doc = ""]
    #[doc = " @return     summation value"]
    pub fn subghz_protocol_blocks_add_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    #[doc = " Compute bit parity of a single byte (8 bits)"]
    #[doc = ""]
    #[doc = " @param      byte  single byte to check"]
    #[doc = ""]
    #[doc = " @return     1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_parity8(byte: u8) -> u8;
}
extern "C" {
    #[doc = " Compute bit parity of a number of bytes"]
    #[doc = ""]
    #[doc = " @param      message  bytes of message data"]
    #[doc = " @param      size     number of bytes to sum"]
    #[doc = ""]
    #[doc = " @return     1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_parity_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    #[doc = " Compute XOR (byte-wide parity) of a number of bytes"]
    #[doc = ""]
    #[doc = " @param      message  bytes of message data"]
    #[doc = " @param      size     number of bytes to sum"]
    #[doc = ""]
    #[doc = " @return     summation value, per bit-position 1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_xor_bytes(message: *const u8, size: usize) -> u8;
}
pub type SubGhzProtocolDecoderBaseRxCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut SubGhzProtocolDecoderBase, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderBase {
    pub protocol: *const SubGhzProtocol,
    pub callback: SubGhzProtocolDecoderBaseRxCallback,
    pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoderBase() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolDecoderBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolDecoderBase>(),
        24usize,
        concat!("Size of: ", stringify!(SubGhzProtocolDecoderBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolDecoderBase>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolDecoderBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = " Getting a textual representation of the received data."]
    #[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
    #[doc = " @param output Resulting text"]
    pub fn subghz_protocol_decoder_base_get_string(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        output: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Serialize data SubGhzProtocolDecoderBase."]
    #[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param preset The modulation on which the signal was received, SubGhzRadioPreset"]
    #[doc = " @return true On success"]
    pub fn subghz_protocol_decoder_base_serialize(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting the hash sum of the last randomly received parcel."]
    #[doc = " @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance"]
    #[doc = " @return hash Hash sum"]
    pub fn subghz_protocol_decoder_base_get_hash_data(
        decoder_base: *mut SubGhzProtocolDecoderBase,
    ) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderBase {
    pub protocol: *const SubGhzProtocol,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoderBase() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolEncoderBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolEncoderBase>(),
        8usize,
        concat!("Size of: ", stringify!(SubGhzProtocolEncoderBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolEncoderBase>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolEncoderBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoderBase),
            "::",
            stringify!(protocol)
        )
    );
}
pub type SubGhzProtocolEncoderRAWCallbackEnd =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderRAW {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderRAW {
    _unused: [u8; 0],
}
extern "C" {
    pub static subghz_protocol_raw_decoder: SubGhzProtocolDecoder;
}
extern "C" {
    pub static subghz_protocol_raw_encoder: SubGhzProtocolEncoder;
}
extern "C" {
    pub static subghz_protocol_raw: SubGhzProtocol;
}
extern "C" {
    #[doc = " Open file for writing"]
    #[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
    #[doc = " @param dev_name  File name"]
    #[doc = " @param preset The modulation on which the signal was received, SubGhzRadioPreset"]
    #[doc = " @return true On success"]
    pub fn subghz_protocol_raw_save_to_file_init(
        instance: *mut SubGhzProtocolDecoderRAW,
        dev_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = " Stop writing file to flash"]
    #[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_raw_save_to_file_stop(instance: *mut SubGhzProtocolDecoderRAW);
}
extern "C" {
    #[doc = " Get the number of samples received SubGhzProtocolDecoderRAW."]
    #[doc = " @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
    #[doc = " @return count of samples"]
    pub fn subghz_protocol_raw_get_sample_write(instance: *mut SubGhzProtocolDecoderRAW) -> usize;
}
extern "C" {
    #[doc = " Allocate SubGhzProtocolDecoderRAW."]
    #[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return SubGhzProtocolDecoderRAW* pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Free SubGhzProtocolDecoderRAW."]
    #[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Reset decoder SubGhzProtocolDecoderRAW."]
    #[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_reset(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Parse a raw sequence of levels and durations received from the air."]
    #[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    #[doc = " @param level Signal level true-high false-low"]
    #[doc = " @param duration Duration of this level in, us"]
    pub fn subghz_protocol_decoder_raw_feed(
        context: *mut core::ffi::c_void,
        level: bool,
        duration: u32,
    );
}
extern "C" {
    #[doc = " Deserialize data SubGhzProtocolDecoderRAW."]
    #[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @return true On success"]
    pub fn subghz_protocol_decoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting a textual representation of the received data."]
    #[doc = " @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    #[doc = " @param output Resulting text"]
    pub fn subghz_protocol_decoder_raw_get_string(
        context: *mut core::ffi::c_void,
        output: *mut FuriString,
    );
}
extern "C" {
    #[doc = " Allocate SubGhzProtocolEncoderRAW."]
    #[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return SubGhzProtocolEncoderRAW* pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Free SubGhzProtocolEncoderRAW."]
    #[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Forced transmission stop."]
    #[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_stop(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " pause writing to flash."]
    #[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    #[doc = " @param pause pause writing"]
    pub fn subghz_protocol_raw_save_to_file_pause(
        instance: *mut SubGhzProtocolDecoderRAW,
        pause: bool,
    );
}
extern "C" {
    #[doc = " Set callback on completion of file transfer."]
    #[doc = " @param instance Pointer to a SubGhzProtocolEncoderRAW instance"]
    #[doc = " @param callback_end Callback, SubGhzProtocolEncoderRAWCallbackEnd"]
    #[doc = " @param context_end Context"]
    pub fn subghz_protocol_raw_file_encoder_worker_set_callback_end(
        instance: *mut SubGhzProtocolEncoderRAW,
        callback_end: SubGhzProtocolEncoderRAWCallbackEnd,
        context_end: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " File generation for RAW work."]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @param file_path File path"]
    pub fn subghz_protocol_raw_gen_fff_data(
        flipper_format: *mut FlipperFormat,
        file_path: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Deserialize and generating an upload to send."]
    #[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @return true On success"]
    pub fn subghz_protocol_encoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting the level and duration of the upload to be loaded into DMA."]
    #[doc = " @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    #[doc = " @return LevelDuration"]
    pub fn subghz_protocol_encoder_raw_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzReceiver {
    _unused: [u8; 0],
}
pub type SubGhzReceiverCallback = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut SubGhzReceiver,
        decoder_base: *mut SubGhzProtocolDecoderBase,
        context: *mut core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = " Allocate and init SubGhzReceiver."]
    #[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return SubGhzReceiver* pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_alloc_init(environment: *mut SubGhzEnvironment) -> *mut SubGhzReceiver;
}
extern "C" {
    #[doc = " Free SubGhzReceiver."]
    #[doc = " @param instance Pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_free(instance: *mut SubGhzReceiver);
}
extern "C" {
    #[doc = " Parse a raw sequence of levels and durations received from the air."]
    #[doc = " @param instance Pointer to a SubGhzReceiver instance"]
    #[doc = " @param level Signal level true-high false-low"]
    #[doc = " @param duration Duration of this level in, us"]
    pub fn subghz_receiver_decode(instance: *mut SubGhzReceiver, level: bool, duration: u32);
}
extern "C" {
    #[doc = " Reset decoder SubGhzReceiver."]
    #[doc = " @param instance Pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_reset(instance: *mut SubGhzReceiver);
}
extern "C" {
    #[doc = " Set a callback upon completion of successful decoding of one of the protocols."]
    #[doc = " @param instance Pointer to a SubGhzReceiver instance"]
    #[doc = " @param callback Callback, SubGhzReceiverCallback"]
    #[doc = " @param context Context"]
    pub fn subghz_receiver_set_rx_callback(
        instance: *mut SubGhzReceiver,
        callback: SubGhzReceiverCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set the filter of receivers that will work at the moment."]
    #[doc = " @param instance Pointer to a SubGhzReceiver instance"]
    #[doc = " @param filter Filter, SubGhzProtocolFlag"]
    pub fn subghz_receiver_set_filter(instance: *mut SubGhzReceiver, filter: SubGhzProtocolFlag);
}
extern "C" {
    #[doc = " Search for a cattery by his name."]
    #[doc = " @param instance Pointer to a SubGhzReceiver instance"]
    #[doc = " @param decoder_name Receiver name"]
    #[doc = " @return SubGhzProtocolDecoderBase* pointer to a SubGhzProtocolDecoderBase instance"]
    pub fn subghz_receiver_search_decoder_base_by_name(
        instance: *mut SubGhzReceiver,
        decoder_name: *const core::ffi::c_char,
    ) -> *mut SubGhzProtocolDecoderBase;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolRegistry {
    pub items: *mut *const SubGhzProtocol,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolRegistry() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolRegistry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolRegistry>(),
        16usize,
        concat!("Size of: ", stringify!(SubGhzProtocolRegistry))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolRegistry>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolRegistry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolRegistry),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolRegistry),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Registration by name SubGhzProtocol."]
    #[doc = " @param protocol_registry SubGhzProtocolRegistry"]
    #[doc = " @param name Protocol name"]
    #[doc = " @return SubGhzProtocol* pointer to a SubGhzProtocol instance"]
    pub fn subghz_protocol_registry_get_by_name(
        protocol_registry: *const SubGhzProtocolRegistry,
        name: *const core::ffi::c_char,
    ) -> *const SubGhzProtocol;
}
extern "C" {
    #[doc = " Registration protocol by index in array SubGhzProtocol."]
    #[doc = " @param protocol_registry SubGhzProtocolRegistry"]
    #[doc = " @param index Protocol by index in array"]
    #[doc = " @return SubGhzProtocol* pointer to a SubGhzProtocol instance"]
    pub fn subghz_protocol_registry_get_by_index(
        protocol_registry: *const SubGhzProtocolRegistry,
        index: usize,
    ) -> *const SubGhzProtocol;
}
extern "C" {
    #[doc = " Getting the number of registered protocols."]
    #[doc = " @param protocol_registry SubGhzProtocolRegistry"]
    #[doc = " @return Number of protocols"]
    pub fn subghz_protocol_registry_count(
        protocol_registry: *const SubGhzProtocolRegistry,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzSetting {
    _unused: [u8; 0],
}
extern "C" {
    pub fn subghz_setting_alloc() -> *mut SubGhzSetting;
}
extern "C" {
    pub fn subghz_setting_free(instance: *mut SubGhzSetting);
}
extern "C" {
    pub fn subghz_setting_load(instance: *mut SubGhzSetting, file_path: *const core::ffi::c_char);
}
extern "C" {
    pub fn subghz_setting_get_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_hopper_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_name(
        instance: *mut SubGhzSetting,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn subghz_setting_get_inx_preset_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subghz_setting_get_preset_data(instance: *mut SubGhzSetting, idx: usize) -> *mut u8;
}
extern "C" {
    pub fn subghz_setting_get_preset_data_size(instance: *mut SubGhzSetting, idx: usize) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_data_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> *mut u8;
}
extern "C" {
    pub fn subghz_setting_load_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
        fff_data_file: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    pub fn subghz_setting_delete_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn subghz_setting_get_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_hopper_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_frequency_default_index(instance: *mut SubGhzSetting) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_default_frequency(instance: *mut SubGhzSetting) -> u32;
}
pub type SubGhzTxRxWorkerCallbackHaveRead =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTxRxWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " SubGhzTxRxWorker, add data to transfer"]
    #[doc = " @param instance  Pointer to a SubGhzTxRxWorker instance"]
    #[doc = " @param data      *data"]
    #[doc = " @param size      data size"]
    #[doc = " @return bool     true if ok"]
    pub fn subghz_tx_rx_worker_write(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " SubGhzTxRxWorker, get available data"]
    #[doc = " @param instance   Pointer to a SubGhzTxRxWorker instance"]
    #[doc = " @return size_t    data size"]
    pub fn subghz_tx_rx_worker_available(instance: *mut SubGhzTxRxWorker) -> usize;
}
extern "C" {
    #[doc = " SubGhzTxRxWorker, read data"]
    #[doc = " @param instance   Pointer to a SubGhzTxRxWorker instance"]
    #[doc = " @param data       *data"]
    #[doc = " @param size       max data size, which can be read"]
    #[doc = " @return size_t    data size, how much is actually read"]
    pub fn subghz_tx_rx_worker_read(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " allback SubGhzTxRxWorker when there is data to read in an empty buffer"]
    #[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
    #[doc = " @param callback SubGhzTxRxWorkerCallbackHaveRead callback"]
    #[doc = " @param context"]
    pub fn subghz_tx_rx_worker_set_callback_have_read(
        instance: *mut SubGhzTxRxWorker,
        callback: SubGhzTxRxWorkerCallbackHaveRead,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Allocate SubGhzTxRxWorker"]
    #[doc = " @return SubGhzTxRxWorker* Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_alloc() -> *mut SubGhzTxRxWorker;
}
extern "C" {
    #[doc = " Free SubGhzTxRxWorker"]
    #[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_free(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
    #[doc = " Start SubGhzTxRxWorker"]
    #[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
    #[doc = " @return bool - true if ok"]
    pub fn subghz_tx_rx_worker_start(instance: *mut SubGhzTxRxWorker, frequency: u32) -> bool;
}
extern "C" {
    #[doc = " Stop SubGhzTxRxWorker"]
    #[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_stop(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
    #[doc = " Check if worker is running"]
    #[doc = " @param instance Pointer to a SubGhzTxRxWorker instance"]
    #[doc = " @return bool - true if running"]
    pub fn subghz_tx_rx_worker_is_running(instance: *mut SubGhzTxRxWorker) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzWorker {
    _unused: [u8; 0],
}
pub type SubGhzWorkerOverrunCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzWorkerPairCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, level: bool, duration: u32),
>;
extern "C" {
    pub fn subghz_worker_rx_callback(level: bool, duration: u32, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Allocate SubGhzWorker."]
    #[doc = " @return SubGhzWorker* Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_alloc() -> *mut SubGhzWorker;
}
extern "C" {
    #[doc = " Free SubGhzWorker."]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_free(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = " Overrun callback SubGhzWorker."]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    #[doc = " @param callback SubGhzWorkerOverrunCallback callback"]
    pub fn subghz_worker_set_overrun_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerOverrunCallback,
    );
}
extern "C" {
    #[doc = " Pair callback SubGhzWorker."]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    #[doc = " @param callback SubGhzWorkerOverrunCallback callback"]
    pub fn subghz_worker_set_pair_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerPairCallback,
    );
}
extern "C" {
    #[doc = " Context callback SubGhzWorker."]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    #[doc = " @param context"]
    pub fn subghz_worker_set_context(instance: *mut SubGhzWorker, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Start SubGhzWorker."]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_start(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = " Stop SubGhzWorker"]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_stop(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = " Check if worker is running."]
    #[doc = " @param instance Pointer to a SubGhzWorker instance"]
    #[doc = " @return bool - true if running"]
    pub fn subghz_worker_is_running(instance: *mut SubGhzWorker) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTransmitter {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and init SubGhzTransmitter."]
    #[doc = " @param environment Pointer to a SubGhzEnvironment instance"]
    #[doc = " @return SubGhzTransmitter* pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_alloc_init(
        environment: *mut SubGhzEnvironment,
        protocol_name: *const core::ffi::c_char,
    ) -> *mut SubGhzTransmitter;
}
extern "C" {
    #[doc = " Free SubGhzTransmitter."]
    #[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_free(instance: *mut SubGhzTransmitter);
}
extern "C" {
    #[doc = " Get protocol instance."]
    #[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_get_protocol_instance(
        instance: *mut SubGhzTransmitter,
    ) -> *mut SubGhzProtocolEncoderBase;
}
extern "C" {
    #[doc = " Forced transmission stop."]
    #[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_stop(instance: *mut SubGhzTransmitter) -> bool;
}
extern "C" {
    #[doc = " Deserialize and generating an upload to send."]
    #[doc = " @param instance Pointer to a SubGhzTransmitter instance"]
    #[doc = " @param flipper_format Pointer to a FlipperFormat instance"]
    #[doc = " @return true On success"]
    pub fn subghz_transmitter_deserialize(
        instance: *mut SubGhzTransmitter,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting the level and duration of the upload to be loaded into DMA."]
    #[doc = " @param context Pointer to a SubGhzTransmitter instance"]
    #[doc = " @return LevelDuration"]
    pub fn subghz_transmitter_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
extern "C" {
    #[doc = " Extract int value and trim arguments string"]
    #[doc = ""]
    #[doc = " @param args - arguments string"]
    #[doc = " @param word first argument, output"]
    #[doc = " @return true - success"]
    #[doc = " @return false - arguments string does not contain int"]
    pub fn args_read_int_and_trim(args: *mut FuriString, value: *mut core::ffi::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Extract first argument from arguments string and trim arguments string"]
    #[doc = ""]
    #[doc = " @param args arguments string"]
    #[doc = " @param word first argument, output"]
    #[doc = " @return true - success"]
    #[doc = " @return false - arguments string does not contain anything"]
    pub fn args_read_string_and_trim(args: *mut FuriString, word: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Extract the first quoted argument from the argument string and trim the argument string. If the argument is not quoted, calls args_read_string_and_trim."]
    #[doc = ""]
    #[doc = " @param args arguments string"]
    #[doc = " @param word first argument, output, without quotes"]
    #[doc = " @return true - success"]
    #[doc = " @return false - arguments string does not contain anything"]
    pub fn args_read_probably_quoted_string_and_trim(
        args: *mut FuriString,
        word: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert hex ASCII values to byte array"]
    #[doc = ""]
    #[doc = " @param args arguments string"]
    #[doc = " @param bytes byte array pointer, output"]
    #[doc = " @param bytes_count needed bytes count"]
    #[doc = " @return true - success"]
    #[doc = " @return false - arguments string does not contain enough values, or contain non-hex ASCII values"]
    pub fn args_read_hex_bytes(args: *mut FuriString, bytes: *mut u8, bytes_count: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Get length of first word from arguments string"]
    #[doc = ""]
    #[doc = " @param args arguments string"]
    #[doc = " @return size_t length of first word"]
    pub fn args_get_first_word_length(args: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Get length of arguments string"]
    #[doc = ""]
    #[doc = " @param args arguments string"]
    #[doc = " @return size_t length of arguments string"]
    pub fn args_length(args: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Convert ASCII hex values to byte"]
    #[doc = ""]
    #[doc = " @param hi_nibble ASCII hi nibble character"]
    #[doc = " @param low_nibble ASCII low nibble character"]
    #[doc = " @param byte byte pointer, output"]
    #[doc = " @return bool conversion status"]
    pub fn args_char_to_hex(
        hi_nibble: core::ffi::c_char,
        low_nibble: core::ffi::c_char,
        byte: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn crc32_calc_buffer(crc: u32, buffer: *const core::ffi::c_void, size: usize) -> u32;
}
pub type FileCrcProgressCb =
    ::core::option::Option<unsafe extern "C" fn(progress: u8, context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn crc32_calc_file(
        file: *mut File,
        progress_cb: FileCrcProgressCb,
        context: *mut core::ffi::c_void,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DirWalk {
    _unused: [u8; 0],
}
#[doc = "< OK"]
pub const DirWalkResult_DirWalkOK: DirWalkResult = 0;
#[doc = "< Error"]
pub const DirWalkResult_DirWalkError: DirWalkResult = 1;
#[doc = "< Last element"]
pub const DirWalkResult_DirWalkLast: DirWalkResult = 2;
pub type DirWalkResult = core::ffi::c_uchar;
pub type DirWalkFilterCb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
        ctx: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Allocate DirWalk"]
    #[doc = " @param storage"]
    #[doc = " @return DirWalk*"]
    pub fn dir_walk_alloc(storage: *mut Storage) -> *mut DirWalk;
}
extern "C" {
    #[doc = " Free DirWalk"]
    #[doc = " @param dir_walk"]
    pub fn dir_walk_free(dir_walk: *mut DirWalk);
}
extern "C" {
    #[doc = " Set recursive mode (true by default)"]
    #[doc = " @param dir_walk"]
    #[doc = " @param recursive"]
    pub fn dir_walk_set_recursive(dir_walk: *mut DirWalk, recursive: bool);
}
extern "C" {
    #[doc = " Set filter callback (Should return true if the data is valid)"]
    #[doc = " @param dir_walk"]
    #[doc = " @param cb"]
    #[doc = " @param context"]
    pub fn dir_walk_set_filter_cb(
        dir_walk: *mut DirWalk,
        cb: DirWalkFilterCb,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Open directory"]
    #[doc = " @param dir_walk"]
    #[doc = " @param path"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn dir_walk_open(dir_walk: *mut DirWalk, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Get error id"]
    #[doc = " @param dir_walk"]
    #[doc = " @return FS_Error"]
    pub fn dir_walk_get_error(dir_walk: *mut DirWalk) -> FS_Error;
}
extern "C" {
    #[doc = " Read next element from directory"]
    #[doc = " @param dir_walk"]
    #[doc = " @param return_path"]
    #[doc = " @param fileinfo"]
    #[doc = " @return DirWalkResult"]
    pub fn dir_walk_read(
        dir_walk: *mut DirWalk,
        return_path: *mut FuriString,
        fileinfo: *mut FileInfo,
    ) -> DirWalkResult;
}
extern "C" {
    #[doc = " Close directory"]
    #[doc = " @param dir_walk"]
    pub fn dir_walk_close(dir_walk: *mut DirWalk);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha256_context {
    pub total: [u32; 2usize],
    pub state: [u32; 8usize],
    pub wbuf: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<sha256_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sha256_context>(),
        104usize,
        concat!("Size of: ", stringify!(sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wbuf) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(wbuf)
        )
    );
}
extern "C" {
    pub fn sha256(
        input: *const core::ffi::c_uchar,
        ilen: core::ffi::c_uint,
        output: *mut core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn sha256_start(ctx: *mut sha256_context);
}
extern "C" {
    pub fn sha256_finish(ctx: *mut sha256_context, output: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn sha256_update(
        ctx: *mut sha256_context,
        input: *const core::ffi::c_uchar,
        ilen: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sha256_process(ctx: *mut sha256_context);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_context {
    pub init_hash: ::core::option::Option<unsafe extern "C" fn(context: *const hmac_context)>,
    pub update_hash: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const hmac_context,
            message: *const u8,
            message_size: core::ffi::c_uint,
        ),
    >,
    pub finish_hash: ::core::option::Option<
        unsafe extern "C" fn(context: *const hmac_context, hash_result: *mut u8),
    >,
    pub block_size: core::ffi::c_uint,
    pub result_size: core::ffi::c_uint,
    pub tmp: *mut u8,
}
#[test]
fn bindgen_test_layout_hmac_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_context>(),
        40usize,
        concat!("Size of: ", stringify!(hmac_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_context>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(init_hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(update_hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finish_hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(finish_hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(tmp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_sha256_context {
    pub hmac_ctx: hmac_context,
    pub sha_ctx: sha256_context,
    pub tmp: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_hmac_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_sha256_context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_sha256_context>(),
        272usize,
        concat!("Size of: ", stringify!(hmac_sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_sha256_context>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmac_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_sha256_context),
            "::",
            stringify!(hmac_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha_ctx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_sha256_context),
            "::",
            stringify!(sha_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_sha256_context),
            "::",
            stringify!(tmp)
        )
    );
}
extern "C" {
    pub fn hmac_sha256_init(ctx: *mut hmac_sha256_context, K: *const u8);
}
extern "C" {
    pub fn hmac_sha256_update(
        ctx: *const hmac_sha256_context,
        message: *const u8,
        message_size: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn hmac_sha256_finish(ctx: *const hmac_sha256_context, K: *const u8, hash_result: *mut u8);
}
pub const ManchesterEvent_ManchesterEventShortLow: ManchesterEvent = 0;
pub const ManchesterEvent_ManchesterEventShortHigh: ManchesterEvent = 2;
pub const ManchesterEvent_ManchesterEventLongLow: ManchesterEvent = 4;
pub const ManchesterEvent_ManchesterEventLongHigh: ManchesterEvent = 6;
pub const ManchesterEvent_ManchesterEventReset: ManchesterEvent = 8;
pub type ManchesterEvent = core::ffi::c_uchar;
pub const ManchesterState_ManchesterStateStart1: ManchesterState = 0;
pub const ManchesterState_ManchesterStateMid1: ManchesterState = 1;
pub const ManchesterState_ManchesterStateMid0: ManchesterState = 2;
pub const ManchesterState_ManchesterStateStart0: ManchesterState = 3;
pub type ManchesterState = core::ffi::c_uchar;
extern "C" {
    pub fn manchester_advance(
        state: ManchesterState,
        event: ManchesterEvent,
        next_state: *mut ManchesterState,
        data: *mut bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ManchesterEncoderState {
    pub prev_bit: bool,
    pub step: u8,
}
#[test]
fn bindgen_test_layout_ManchesterEncoderState() {
    const UNINIT: ::core::mem::MaybeUninit<ManchesterEncoderState> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ManchesterEncoderState>(),
        2usize,
        concat!("Size of: ", stringify!(ManchesterEncoderState))
    );
    assert_eq!(
        ::core::mem::align_of::<ManchesterEncoderState>(),
        1usize,
        concat!("Alignment of ", stringify!(ManchesterEncoderState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ManchesterEncoderState),
            "::",
            stringify!(prev_bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ManchesterEncoderState),
            "::",
            stringify!(step)
        )
    );
}
pub const ManchesterEncoderResult_ManchesterEncoderResultShortLow: ManchesterEncoderResult = 0;
pub const ManchesterEncoderResult_ManchesterEncoderResultLongLow: ManchesterEncoderResult = 1;
pub const ManchesterEncoderResult_ManchesterEncoderResultLongHigh: ManchesterEncoderResult = 2;
pub const ManchesterEncoderResult_ManchesterEncoderResultShortHigh: ManchesterEncoderResult = 3;
pub type ManchesterEncoderResult = core::ffi::c_uchar;
extern "C" {
    pub fn manchester_encoder_reset(state: *mut ManchesterEncoderState);
}
extern "C" {
    pub fn manchester_encoder_advance(
        state: *mut ManchesterEncoderState,
        curr_bit: bool,
        result: *mut ManchesterEncoderResult,
    ) -> bool;
}
extern "C" {
    pub fn manchester_encoder_finish(state: *mut ManchesterEncoderState)
        -> ManchesterEncoderResult;
}
#[doc = " \\brief          MD5 context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md5_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 4usize],
    #[doc = "< data block being processed"]
    pub buffer: [core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
    const UNINIT: ::core::mem::MaybeUninit<md5_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md5_context>(),
        88usize,
        concat!("Size of: ", stringify!(md5_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md5_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[doc = " \\brief          MD5 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param input    buffer holding the  data"]
    #[doc = " \\param ilen     length of the input data"]
    pub fn md5_update(ctx: *mut md5_context, input: *const core::ffi::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = " \\brief          MD5 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param output   MD5 checksum result"]
    pub fn md5_finish(ctx: *mut md5_context, output: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn md5_process(ctx: *mut md5_context, data: *const core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the  data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD5 checksum result"]
    pub fn md5(input: *const core::ffi::c_uchar, ilen: usize, output: *mut core::ffi::c_uchar);
}
extern "C" {
    #[doc = " @brief Extract filename without extension from path."]
    #[doc = ""]
    #[doc = " @param path path string"]
    #[doc = " @param filename output filename string. Must be initialized before."]
    pub fn path_extract_filename_no_ext(path: *const core::ffi::c_char, filename: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Extract filename string from path."]
    #[doc = ""]
    #[doc = " @param path path string"]
    #[doc = " @param filename output filename string. Must be initialized before."]
    #[doc = " @param trim_ext true - get filename without extension"]
    pub fn path_extract_filename(path: *mut FuriString, filename: *mut FuriString, trim_ext: bool);
}
extern "C" {
    #[doc = " @brief Extract file extension from path."]
    #[doc = ""]
    #[doc = " @param path path string"]
    #[doc = " @param ext output extension string"]
    #[doc = " @param ext_len_max maximum extension string length"]
    pub fn path_extract_extension(
        path: *mut FuriString,
        ext: *mut core::ffi::c_char,
        ext_len_max: usize,
    );
}
extern "C" {
    #[doc = " @brief Extract last path component"]
    #[doc = ""]
    #[doc = " @param path path string"]
    #[doc = " @param filename output string. Must be initialized before."]
    pub fn path_extract_basename(path: *const core::ffi::c_char, basename: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Extract path, except for last component"]
    #[doc = ""]
    #[doc = " @param path path string"]
    #[doc = " @param filename output string. Must be initialized before."]
    pub fn path_extract_dirname(path: *const core::ffi::c_char, dirname: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Appends new component to path, adding path delimiter"]
    #[doc = ""]
    #[doc = " @param path path string"]
    #[doc = " @param suffix path part to apply"]
    pub fn path_append(path: *mut FuriString, suffix: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Appends new component to path, adding path delimiter"]
    #[doc = ""]
    #[doc = " @param path first path part"]
    #[doc = " @param suffix second path part"]
    #[doc = " @param out_path output string to combine parts into. Must be initialized"]
    pub fn path_concat(
        path: *const core::ffi::c_char,
        suffix: *const core::ffi::c_char,
        out_path: *mut FuriString,
    );
}
extern "C" {
    #[doc = " @brief Check that path contains only ascii characters"]
    #[doc = ""]
    #[doc = " @param path"]
    #[doc = " @return true"]
    #[doc = " @return false"]
    pub fn path_contains_only_ascii(path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Generates random name"]
    #[doc = " @param name buffer to write random name"]
    #[doc = " @param max_name_size length of given buffer"]
    pub fn set_random_name(name: *mut core::ffi::c_char, max_name_size: u8);
}
extern "C" {
    pub fn saved_struct_load(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
extern "C" {
    pub fn saved_struct_save(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Allocate string stream"]
    #[doc = " @return Stream*"]
    pub fn string_stream_alloc() -> *mut Stream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TarArchive {
    _unused: [u8; 0],
}
pub const TarOpenMode_TAR_OPEN_MODE_READ: TarOpenMode = 114;
pub const TarOpenMode_TAR_OPEN_MODE_WRITE: TarOpenMode = 119;
pub const TarOpenMode_TAR_OPEN_MODE_STDOUT: TarOpenMode = 115;
pub type TarOpenMode = core::ffi::c_uchar;
extern "C" {
    pub fn tar_archive_alloc(storage: *mut Storage) -> *mut TarArchive;
}
extern "C" {
    pub fn tar_archive_open(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        mode: TarOpenMode,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_free(archive: *mut TarArchive);
}
extern "C" {
    pub fn tar_archive_unpack_to(
        archive: *mut TarArchive,
        destination: *const core::ffi::c_char,
        converter: Storage_name_converter,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_add_file(
        archive: *mut TarArchive,
        fs_file_path: *const core::ffi::c_char,
        archive_fname: *const core::ffi::c_char,
        file_size: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_add_dir(
        archive: *mut TarArchive,
        fs_full_path: *const core::ffi::c_char,
        path_prefix: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_get_entries_count(archive: *mut TarArchive) -> i32;
}
extern "C" {
    pub fn tar_archive_unpack_file(
        archive: *mut TarArchive,
        archive_fname: *const core::ffi::c_char,
        destination: *const core::ffi::c_char,
    ) -> bool;
}
pub type tar_unpack_file_cb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        is_directory: bool,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn tar_archive_set_file_callback(
        archive: *mut TarArchive,
        callback: tar_unpack_file_cb,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn tar_archive_dir_add_element(
        archive: *mut TarArchive,
        dirpath: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_add_header(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_add_data_block(
        archive: *mut TarArchive,
        data_block: *const u8,
        block_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
    pub fn tar_archive_store_data(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data: *const u8,
        data_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_finalize(archive: *mut TarArchive) -> bool;
}
pub type __builtin_va_list = *mut core::ffi::c_char;
