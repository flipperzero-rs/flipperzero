/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        unsafe { ::core::slice::from_raw_parts(self.as_ptr(), len) }
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        unsafe { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const API_VERSION: u32 = 5177346;
pub const LFRFID_T5577_BLOCK_COUNT: u32 = 8;
pub const LFRFID_T5577_POR_DELAY: u32 = 1;
pub const LFRFID_T5577_ST_TERMINATOR: u32 = 8;
pub const LFRFID_T5577_PWD: u32 = 16;
pub const LFRFID_T5577_MAXBLOCK_SHIFT: u32 = 5;
pub const LFRFID_T5577_AOR: u32 = 512;
pub const LFRFID_T5577_PSKCF_RF_2: u32 = 0;
pub const LFRFID_T5577_PSKCF_RF_4: u32 = 1024;
pub const LFRFID_T5577_PSKCF_RF_8: u32 = 2048;
pub const LFRFID_T5577_MODULATION_DIRECT: u32 = 0;
pub const LFRFID_T5577_MODULATION_PSK1: u32 = 4096;
pub const LFRFID_T5577_MODULATION_PSK2: u32 = 8192;
pub const LFRFID_T5577_MODULATION_PSK3: u32 = 12288;
pub const LFRFID_T5577_MODULATION_FSK1: u32 = 16384;
pub const LFRFID_T5577_MODULATION_FSK2: u32 = 20480;
pub const LFRFID_T5577_MODULATION_FSK1a: u32 = 24576;
pub const LFRFID_T5577_MODULATION_FSK2a: u32 = 28672;
pub const LFRFID_T5577_MODULATION_MANCHESTER: u32 = 32768;
pub const LFRFID_T5577_MODULATION_BIPHASE: u32 = 65536;
pub const LFRFID_T5577_MODULATION_DIPHASE: u32 = 98304;
pub const LFRFID_T5577_X_MODE: u32 = 131072;
pub const LFRFID_T5577_BITRATE_RF_8: u32 = 0;
pub const LFRFID_T5577_BITRATE_RF_16: u32 = 262144;
pub const LFRFID_T5577_BITRATE_RF_32: u32 = 524288;
pub const LFRFID_T5577_BITRATE_RF_40: u32 = 786432;
pub const LFRFID_T5577_BITRATE_RF_50: u32 = 1048576;
pub const LFRFID_T5577_BITRATE_RF_64: u32 = 1310720;
pub const LFRFID_T5577_BITRATE_RF_100: u32 = 1572864;
pub const LFRFID_T5577_BITRATE_RF_128: u32 = 1835008;
pub const LFRFID_T5577_TESTMODE_DISABLED: u32 = 1610612736;
pub type wint_t = core::ffi::c_int;
pub type __uint_least8_t = core::ffi::c_uchar;
pub type __int_least16_t = core::ffi::c_short;
pub type __uint_least16_t = core::ffi::c_ushort;
pub type _off_t = core::ffi::c_long;
pub type _fpos_t = core::ffi::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [core::ffi::c_uchar; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _mbstate_t__bindgen_ty_1"]
        [::core::mem::size_of::<_mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _mbstate_t__bindgen_ty_1"]
        [::core::mem::align_of::<_mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _mbstate_t__bindgen_ty_1::__wch"]
        [::core::mem::offset_of!(_mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: _mbstate_t__bindgen_ty_1::__wchb"]
        [::core::mem::offset_of!(_mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _mbstate_t"][::core::mem::size_of::<_mbstate_t>() - 8usize];
    ["Alignment of _mbstate_t"][::core::mem::align_of::<_mbstate_t>() - 4usize];
    ["Offset of field: _mbstate_t::__count"][::core::mem::offset_of!(_mbstate_t, __count) - 0usize];
    ["Offset of field: _mbstate_t::__value"][::core::mem::offset_of!(_mbstate_t, __value) - 4usize];
};
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
unsafe extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: core::ffi::c_int,
    pub _maxwds: core::ffi::c_int,
    pub _sign: core::ffi::c_int,
    pub _wds: core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Bigint"][::core::mem::size_of::<_Bigint>() - 24usize];
    ["Alignment of _Bigint"][::core::mem::align_of::<_Bigint>() - 4usize];
    ["Offset of field: _Bigint::_next"][::core::mem::offset_of!(_Bigint, _next) - 0usize];
    ["Offset of field: _Bigint::_k"][::core::mem::offset_of!(_Bigint, _k) - 4usize];
    ["Offset of field: _Bigint::_maxwds"][::core::mem::offset_of!(_Bigint, _maxwds) - 8usize];
    ["Offset of field: _Bigint::_sign"][::core::mem::offset_of!(_Bigint, _sign) - 12usize];
    ["Offset of field: _Bigint::_wds"][::core::mem::offset_of!(_Bigint, _wds) - 16usize];
    ["Offset of field: _Bigint::_x"][::core::mem::offset_of!(_Bigint, _x) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: core::ffi::c_int,
    pub __tm_min: core::ffi::c_int,
    pub __tm_hour: core::ffi::c_int,
    pub __tm_mday: core::ffi::c_int,
    pub __tm_mon: core::ffi::c_int,
    pub __tm_year: core::ffi::c_int,
    pub __tm_wday: core::ffi::c_int,
    pub __tm_yday: core::ffi::c_int,
    pub __tm_isdst: core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __tm"][::core::mem::size_of::<__tm>() - 36usize];
    ["Alignment of __tm"][::core::mem::align_of::<__tm>() - 4usize];
    ["Offset of field: __tm::__tm_sec"][::core::mem::offset_of!(__tm, __tm_sec) - 0usize];
    ["Offset of field: __tm::__tm_min"][::core::mem::offset_of!(__tm, __tm_min) - 4usize];
    ["Offset of field: __tm::__tm_hour"][::core::mem::offset_of!(__tm, __tm_hour) - 8usize];
    ["Offset of field: __tm::__tm_mday"][::core::mem::offset_of!(__tm, __tm_mday) - 12usize];
    ["Offset of field: __tm::__tm_mon"][::core::mem::offset_of!(__tm, __tm_mon) - 16usize];
    ["Offset of field: __tm::__tm_year"][::core::mem::offset_of!(__tm, __tm_year) - 20usize];
    ["Offset of field: __tm::__tm_wday"][::core::mem::offset_of!(__tm, __tm_wday) - 24usize];
    ["Offset of field: __tm::__tm_yday"][::core::mem::offset_of!(__tm, __tm_yday) - 28usize];
    ["Offset of field: __tm::__tm_isdst"][::core::mem::offset_of!(__tm, __tm_isdst) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut core::ffi::c_uchar,
    pub _size: core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::core::mem::size_of::<__sbuf>() - 8usize];
    ["Alignment of __sbuf"][::core::mem::align_of::<__sbuf>() - 4usize];
    ["Offset of field: __sbuf::_base"][::core::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::core::mem::offset_of!(__sbuf, _size) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut core::ffi::c_uchar,
    pub _r: core::ffi::c_int,
    pub _w: core::ffi::c_int,
    pub _flags: core::ffi::c_short,
    pub _file: core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: core::ffi::c_int,
    pub _cookie: *mut core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *mut core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *const core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: _fpos_t,
            arg4: core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut core::ffi::c_uchar,
    pub _ur: core::ffi::c_int,
    pub _ubuf: [core::ffi::c_uchar; 3usize],
    pub _nbuf: [core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::core::mem::size_of::<__sFILE>() - 104usize];
    ["Alignment of __sFILE"][::core::mem::align_of::<__sFILE>() - 4usize];
    ["Offset of field: __sFILE::_p"][::core::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::core::mem::offset_of!(__sFILE, _r) - 4usize];
    ["Offset of field: __sFILE::_w"][::core::mem::offset_of!(__sFILE, _w) - 8usize];
    ["Offset of field: __sFILE::_flags"][::core::mem::offset_of!(__sFILE, _flags) - 12usize];
    ["Offset of field: __sFILE::_file"][::core::mem::offset_of!(__sFILE, _file) - 14usize];
    ["Offset of field: __sFILE::_bf"][::core::mem::offset_of!(__sFILE, _bf) - 16usize];
    ["Offset of field: __sFILE::_lbfsize"][::core::mem::offset_of!(__sFILE, _lbfsize) - 24usize];
    ["Offset of field: __sFILE::_cookie"][::core::mem::offset_of!(__sFILE, _cookie) - 28usize];
    ["Offset of field: __sFILE::_read"][::core::mem::offset_of!(__sFILE, _read) - 32usize];
    ["Offset of field: __sFILE::_write"][::core::mem::offset_of!(__sFILE, _write) - 36usize];
    ["Offset of field: __sFILE::_seek"][::core::mem::offset_of!(__sFILE, _seek) - 40usize];
    ["Offset of field: __sFILE::_close"][::core::mem::offset_of!(__sFILE, _close) - 44usize];
    ["Offset of field: __sFILE::_ub"][::core::mem::offset_of!(__sFILE, _ub) - 48usize];
    ["Offset of field: __sFILE::_up"][::core::mem::offset_of!(__sFILE, _up) - 56usize];
    ["Offset of field: __sFILE::_ur"][::core::mem::offset_of!(__sFILE, _ur) - 60usize];
    ["Offset of field: __sFILE::_ubuf"][::core::mem::offset_of!(__sFILE, _ubuf) - 64usize];
    ["Offset of field: __sFILE::_nbuf"][::core::mem::offset_of!(__sFILE, _nbuf) - 67usize];
    ["Offset of field: __sFILE::_lb"][::core::mem::offset_of!(__sFILE, _lb) - 68usize];
    ["Offset of field: __sFILE::_blksize"][::core::mem::offset_of!(__sFILE, _blksize) - 76usize];
    ["Offset of field: __sFILE::_offset"][::core::mem::offset_of!(__sFILE, _offset) - 80usize];
    ["Offset of field: __sFILE::_data"][::core::mem::offset_of!(__sFILE, _data) - 84usize];
    ["Offset of field: __sFILE::_lock"][::core::mem::offset_of!(__sFILE, _lock) - 88usize];
    ["Offset of field: __sFILE::_mbstate"][::core::mem::offset_of!(__sFILE, _mbstate) - 92usize];
    ["Offset of field: __sFILE::_flags2"][::core::mem::offset_of!(__sFILE, _flags2) - 100usize];
};
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [core::ffi::c_ushort; 3usize],
    pub _mult: [core::ffi::c_ushort; 3usize],
    pub _add: core::ffi::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rand48"][::core::mem::size_of::<_rand48>() - 14usize];
    ["Alignment of _rand48"][::core::mem::align_of::<_rand48>() - 2usize];
    ["Offset of field: _rand48::_seed"][::core::mem::offset_of!(_rand48, _seed) - 0usize];
    ["Offset of field: _rand48::_mult"][::core::mem::offset_of!(_rand48, _mult) - 6usize];
    ["Offset of field: _rand48::_add"][::core::mem::offset_of!(_rand48, _add) - 12usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: core::ffi::c_int,
    pub _emergency: [core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: core::ffi::c_int,
    pub _cvtbuf: *mut core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut core::ffi::c_char,
    pub _asctime_buf: [core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: core::ffi::c_int,
    pub _rand_next: core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [core::ffi::c_char; 8usize],
    pub _signal_buf: [core::ffi::c_char; 24usize],
    pub _getdate_err: core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>() - 200usize];
    ["Alignment of _reent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_strtok_last"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _strtok_last) - 0usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_asctime_buf"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _asctime_buf) - 4usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_localtime_buf"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _localtime_buf) - 32usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_gamma_signgam"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _gamma_signgam) - 68usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_rand_next"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _rand_next) - 72usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_r48"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _r48) - 80usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_mblen_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _mblen_state) - 96usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_mbtowc_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _mbtowc_state) - 104usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_wctomb_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _wctomb_state) - 112usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_l64a_buf"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _l64a_buf) - 120usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_signal_buf"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _signal_buf) - 128usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_getdate_err"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _getdate_err) - 152usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_mbrlen_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _mbrlen_state) - 156usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_mbrtowc_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _mbrtowc_state) - 164usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_mbsrtowcs_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _mbsrtowcs_state) - 172usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_wcrtomb_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _wcrtomb_state) - 180usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_wcsrtombs_state"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _wcsrtombs_state) - 188usize];
    ["Offset of field: _reent__bindgen_ty_1__bindgen_ty_1::_h_errno"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1__bindgen_ty_1, _h_errno) - 196usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent__bindgen_ty_1"][::core::mem::size_of::<_reent__bindgen_ty_1>() - 200usize];
    ["Alignment of _reent__bindgen_ty_1"][::core::mem::align_of::<_reent__bindgen_ty_1>() - 8usize];
    ["Offset of field: _reent__bindgen_ty_1::_reent"]
        [::core::mem::offset_of!(_reent__bindgen_ty_1, _reent) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent"][::core::mem::size_of::<_reent>() - 288usize];
    ["Alignment of _reent"][::core::mem::align_of::<_reent>() - 8usize];
    ["Offset of field: _reent::_errno"][::core::mem::offset_of!(_reent, _errno) - 0usize];
    ["Offset of field: _reent::_stdin"][::core::mem::offset_of!(_reent, _stdin) - 4usize];
    ["Offset of field: _reent::_stdout"][::core::mem::offset_of!(_reent, _stdout) - 8usize];
    ["Offset of field: _reent::_stderr"][::core::mem::offset_of!(_reent, _stderr) - 12usize];
    ["Offset of field: _reent::_inc"][::core::mem::offset_of!(_reent, _inc) - 16usize];
    ["Offset of field: _reent::_emergency"][::core::mem::offset_of!(_reent, _emergency) - 20usize];
    ["Offset of field: _reent::_locale"][::core::mem::offset_of!(_reent, _locale) - 48usize];
    ["Offset of field: _reent::__cleanup"][::core::mem::offset_of!(_reent, __cleanup) - 52usize];
    ["Offset of field: _reent::_result"][::core::mem::offset_of!(_reent, _result) - 56usize];
    ["Offset of field: _reent::_result_k"][::core::mem::offset_of!(_reent, _result_k) - 60usize];
    ["Offset of field: _reent::_p5s"][::core::mem::offset_of!(_reent, _p5s) - 64usize];
    ["Offset of field: _reent::_freelist"][::core::mem::offset_of!(_reent, _freelist) - 68usize];
    ["Offset of field: _reent::_cvtlen"][::core::mem::offset_of!(_reent, _cvtlen) - 72usize];
    ["Offset of field: _reent::_cvtbuf"][::core::mem::offset_of!(_reent, _cvtbuf) - 76usize];
    ["Offset of field: _reent::_new"][::core::mem::offset_of!(_reent, _new) - 80usize];
    ["Offset of field: _reent::_sig_func"][::core::mem::offset_of!(_reent, _sig_func) - 280usize];
};
unsafe extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
unsafe extern "C" {
    pub static mut _impure_data: _reent;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn calloc(arg1: core::ffi::c_uint, arg2: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn free(arg1: *mut core::ffi::c_void);
}
unsafe extern "C" {
    pub fn malloc(arg1: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn rand() -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn realloc(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint)
    -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn srand(__seed: core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn strtod(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn strtof(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn itoa(
        arg1: core::ffi::c_int,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn random() -> core::ffi::c_long;
}
unsafe extern "C" {
    pub fn strtoull(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __FuriCriticalInfo {
    pub isrm: u32,
    pub from_isr: bool,
    pub kernel_running: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __FuriCriticalInfo"][::core::mem::size_of::<__FuriCriticalInfo>() - 8usize];
    ["Alignment of __FuriCriticalInfo"][::core::mem::align_of::<__FuriCriticalInfo>() - 4usize];
    ["Offset of field: __FuriCriticalInfo::isrm"]
        [::core::mem::offset_of!(__FuriCriticalInfo, isrm) - 0usize];
    ["Offset of field: __FuriCriticalInfo::from_isr"]
        [::core::mem::offset_of!(__FuriCriticalInfo, from_isr) - 4usize];
    ["Offset of field: __FuriCriticalInfo::kernel_running"]
        [::core::mem::offset_of!(__FuriCriticalInfo, kernel_running) - 5usize];
};
unsafe extern "C" {
    pub fn __furi_critical_enter() -> __FuriCriticalInfo;
}
unsafe extern "C" {
    pub fn __furi_critical_exit(info: __FuriCriticalInfo);
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
    -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub fn strlcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
unsafe extern "C" {
    pub static _ctype_: [core::ffi::c_char; 0usize];
}
unsafe extern "C" {
    pub fn __assert_func(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
        arg4: *const core::ffi::c_char,
    ) -> !;
}
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type FILE = __FILE;
unsafe extern "C" {
    pub fn sscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_uint,
        arg3: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Crash system"]
    pub fn __furi_crash_implementation();
}
unsafe extern "C" {
    #[doc = "Halt system"]
    pub fn __furi_halt_implementation();
}
pub const FuriWaitForever: FuriWait = FuriWait(4294967295);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriWait(pub core::ffi::c_uint);
#[doc = "< Wait for any flag (default)."]
pub const FuriFlagWaitAny: FuriFlag = FuriFlag(0);
#[doc = "< Wait for all flags."]
pub const FuriFlagWaitAll: FuriFlag = FuriFlag(1);
#[doc = "< Do not clear flags which have been specified to wait for."]
pub const FuriFlagNoClear: FuriFlag = FuriFlag(2);
#[doc = "< Error indicator."]
pub const FuriFlagError: FuriFlag = FuriFlag(2147483648);
#[doc = "< FuriStatusError (-1)."]
pub const FuriFlagErrorUnknown: FuriFlag = FuriFlag(4294967295);
#[doc = "< FuriStatusErrorTimeout (-2)."]
pub const FuriFlagErrorTimeout: FuriFlag = FuriFlag(4294967294);
#[doc = "< FuriStatusErrorResource (-3)."]
pub const FuriFlagErrorResource: FuriFlag = FuriFlag(4294967293);
#[doc = "< FuriStatusErrorParameter (-4)."]
pub const FuriFlagErrorParameter: FuriFlag = FuriFlag(4294967292);
#[doc = "< FuriStatusErrorISR (-6)."]
pub const FuriFlagErrorISR: FuriFlag = FuriFlag(4294967290);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriFlag(pub core::ffi::c_uint);
#[doc = "< Operation completed successfully."]
pub const FuriStatusOk: FuriStatus = FuriStatus(0);
pub const FuriStatusError: FuriStatus = FuriStatus(-1);
#[doc = "< Operation not completed within the timeout period."]
pub const FuriStatusErrorTimeout: FuriStatus = FuriStatus(-2);
#[doc = "< Resource not available."]
pub const FuriStatusErrorResource: FuriStatus = FuriStatus(-3);
#[doc = "< Parameter error."]
pub const FuriStatusErrorParameter: FuriStatus = FuriStatus(-4);
pub const FuriStatusErrorNoMemory: FuriStatus = FuriStatus(-5);
pub const FuriStatusErrorISR: FuriStatus = FuriStatus(-6);
#[doc = "< Prevents enum down-size compiler optimization."]
pub const FuriStatusReserved: FuriStatus = FuriStatus(2147483647);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriStatus(pub core::ffi::c_int);
#[doc = "< Request (graceful) exit."]
pub const FuriSignalExit: FuriSignal = FuriSignal(0);
#[doc = "< Custom signal values start from here."]
pub const FuriSignalCustom: FuriSignal = FuriSignal(100);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriSignal(pub core::ffi::c_uchar);
#[doc = "Subscribe to In events.\n\n In events occur on the following conditions:\n - One or more items were inserted into a FuriMessageQueue,\n - Enough data has been written to a FuriStreamBuffer,\n - A FuriSemaphore has been released at least once,\n - A FuriMutex has been released."]
pub const FuriEventLoopEventIn: FuriEventLoopEvent = FuriEventLoopEvent(1);
#[doc = "Subscribe to Out events.\n\n Out events occur on the following conditions:\n - One or more items were removed from a FuriMessageQueue,\n - Any amount of data has been read out of a FuriStreamBuffer,\n - A FuriSemaphore has been acquired at least once,\n - A FuriMutex has been acquired."]
pub const FuriEventLoopEventOut: FuriEventLoopEvent = FuriEventLoopEvent(2);
#[doc = "Special value containing the event direction bits, used internally."]
pub const FuriEventLoopEventMask: FuriEventLoopEvent = FuriEventLoopEvent(3);
#[doc = "Use edge triggered events.\n\n By default, level triggered events are used. A level above zero\n is reported based on the following conditions:\n\n In events:\n - a FuriMessageQueue contains one or more items,\n - a FuriStreamBuffer contains one or more bytes,\n - a FuriSemaphore can be acquired at least once,\n - a FuriMutex can be acquired.\n\n Out events:\n - a FuriMessageQueue has at least one item of free space,\n - a FuriStreamBuffer has at least one byte of free space,\n - a FuriSemaphore has been acquired at least once,\n - a FuriMutex has been acquired.\n\n If this flag is NOT set, the event will be generated repeatedly until\n the level becomes zero (e.g. all items have been removed from\n a FuriMessageQueue in case of the \"In\" event, etc.)\n\n If this flag IS set, then the above check is skipped and the event\n is generated ONLY when a change occurs, with the event direction\n (In or Out) taken into account."]
pub const FuriEventLoopEventFlagEdge: FuriEventLoopEvent = FuriEventLoopEvent(4);
#[doc = "Automatically unsubscribe from events after one time.\n\n By default, events will be generated each time the specified conditions\n have been met. If this flag IS set, the event subscription will be cancelled\n upon the first occurred event and no further events will be generated."]
pub const FuriEventLoopEventFlagOnce: FuriEventLoopEvent = FuriEventLoopEvent(8);
#[doc = "Special value containing the event flag bits, used internally."]
pub const FuriEventLoopEventFlagMask: FuriEventLoopEvent = FuriEventLoopEvent(4294967292);
#[doc = "Special value to force the enum to 32-bit values."]
pub const FuriEventLoopEventReserved: FuriEventLoopEvent = FuriEventLoopEvent(4294967295);
#[repr(transparent)]
#[doc = "Enumeration of event types, flags and masks.\n\n Only one event direction (In or Out) can be used per subscription.\n An object can have no more than one subscription for each direction.\n\n Additional flags that modify the behaviour can be\n set using the bitwise OR operation (see flag description)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriEventLoopEvent(pub core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriEventLoop {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate Event Loop instance\n\n Couple things to keep in mind:\n - You can have 1 event_loop per 1 thread\n - You can not use event_loop instance in the other thread\n - Do not use blocking API to query object delegated to Event Loop\n\n # Returns\n\nThe Event Loop instance"]
    pub fn furi_event_loop_alloc() -> *mut FuriEventLoop;
}
unsafe extern "C" {
    #[doc = "Free Event Loop instance\n\n # Arguments\n\n* `instance` - The Event Loop instance"]
    pub fn furi_event_loop_free(instance: *mut FuriEventLoop);
}
unsafe extern "C" {
    #[doc = "Continuously poll for events\n\n Can be stopped with `furi_event_loop_stop`\n\n # Arguments\n\n* `instance` - The Event Loop instance"]
    pub fn furi_event_loop_run(instance: *mut FuriEventLoop);
}
unsafe extern "C" {
    #[doc = "Stop Event Loop instance\n\n # Arguments\n\n* `instance` - The Event Loop instance"]
    pub fn furi_event_loop_stop(instance: *mut FuriEventLoop);
}
#[doc = "Tick callback type\n\n # Arguments\n\n* `context` - The context for callback"]
pub type FuriEventLoopTickCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Set Event Loop tick callback\n\n Tick callback is called periodically after specified inactivity time.\n It acts like a low-priority timer: it will only fire if there is time\n left after processing the synchronization primitives and the regular timers.\n Therefore, it is not monotonic: ticks will be skipped if the event loop is busy.\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `interval` (direction in) - The tick interval\n * `callback` (direction in) - The callback to call\n * `context` - The context for callback"]
    pub fn furi_event_loop_tick_set(
        instance: *mut FuriEventLoop,
        interval: u32,
        callback: FuriEventLoopTickCallback,
        context: *mut core::ffi::c_void,
    );
}
#[doc = "Timer callback type for functions to be called in a deferred manner.\n\n # Arguments\n\n* `context` (direction in, out) - pointer to a user-specific object that was provided during\n furi_event_loop_pend_callback() call"]
pub type FuriEventLoopPendingCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Call a function when all preceding timer commands are processed\n\n This function may be useful to call another function when the event loop has been started.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the current FuriEventLoop instance\n * `callback` (direction in) - pointer to the callback to be executed when previous commands have been processed\n * `context` (direction in, out) - pointer to a user-specific object (will be passed to the callback)"]
    pub fn furi_event_loop_pend_callback(
        instance: *mut FuriEventLoop,
        callback: FuriEventLoopPendingCallback,
        context: *mut core::ffi::c_void,
    );
}
pub type FuriEventLoopObject = core::ffi::c_void;
#[doc = "Callback type for event loop events\n\n # Arguments\n\n* `object` - The object that triggered the event\n * `context` - The context that was provided upon subscription"]
pub type FuriEventLoopEventCallback = ::core::option::Option<
    unsafe extern "C" fn(object: *mut FuriEventLoopObject, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriEventFlag {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Subscribe to event flag events\n\n you can only have one subscription for one event type.\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `event_flag` - The event flag to add\n * `event` (direction in) - The Event Loop event to trigger on\n * `callback` (direction in) - The callback to call on event\n * `context` - The context for callback"]
    pub fn furi_event_loop_subscribe_event_flag(
        instance: *mut FuriEventLoop,
        event_flag: *mut FuriEventFlag,
        event: FuriEventLoopEvent,
        callback: FuriEventLoopEventCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriMessageQueue {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Subscribe to message queue events\n\n you can only have one subscription for one event type.\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `message_queue` - The message queue to add\n * `event` (direction in) - The Event Loop event to trigger on\n * `callback` (direction in) - The callback to call on event\n * `context` - The context for callback"]
    pub fn furi_event_loop_subscribe_message_queue(
        instance: *mut FuriEventLoop,
        message_queue: *mut FuriMessageQueue,
        event: FuriEventLoopEvent,
        callback: FuriEventLoopEventCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriStreamBuffer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Subscribe to stream buffer events\n\n you can only have one subscription for one event type.\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `stream_buffer` - The stream buffer to add\n * `event` (direction in) - The Event Loop event to trigger on\n * `callback` (direction in) - The callback to call on event\n * `context` - The context for callback"]
    pub fn furi_event_loop_subscribe_stream_buffer(
        instance: *mut FuriEventLoop,
        stream_buffer: *mut FuriStreamBuffer,
        event: FuriEventLoopEvent,
        callback: FuriEventLoopEventCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriSemaphore {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Subscribe to semaphore events\n\n you can only have one subscription for one event type.\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `semaphore` - The semaphore to add\n * `event` (direction in) - The Event Loop event to trigger on\n * `callback` (direction in) - The callback to call on event\n * `context` - The context for callback"]
    pub fn furi_event_loop_subscribe_semaphore(
        instance: *mut FuriEventLoop,
        semaphore: *mut FuriSemaphore,
        event: FuriEventLoopEvent,
        callback: FuriEventLoopEventCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriMutex {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Subscribe to mutex events\n\n you can only have one subscription for one event type.\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `mutex` - The mutex to add\n * `event` (direction in) - The Event Loop event to trigger on\n * `callback` (direction in) - The callback to call on event\n * `context` - The context for callback"]
    pub fn furi_event_loop_subscribe_mutex(
        instance: *mut FuriEventLoop,
        mutex: *mut FuriMutex,
        event: FuriEventLoopEvent,
        callback: FuriEventLoopEventCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Unsubscribe from events (common)\n\n # Arguments\n\n* `instance` - The Event Loop instance\n * `object` - The object to unsubscribe from"]
    pub fn furi_event_loop_unsubscribe(
        instance: *mut FuriEventLoop,
        object: *mut FuriEventLoopObject,
    );
}
unsafe extern "C" {
    #[doc = "Checks if the loop is subscribed to an object of any kind\n\n # Arguments\n\n* `instance` - Event Loop instance\n * `object` - Object to check"]
    pub fn furi_event_loop_is_subscribed(
        instance: *mut FuriEventLoop,
        object: *mut FuriEventLoopObject,
    ) -> bool;
}
#[doc = "< One-shot timer."]
pub const FuriEventLoopTimerTypeOnce: FuriEventLoopTimerType = FuriEventLoopTimerType(0);
#[doc = "< Repeating timer."]
pub const FuriEventLoopTimerTypePeriodic: FuriEventLoopTimerType = FuriEventLoopTimerType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible timer types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriEventLoopTimerType(pub core::ffi::c_uchar);
#[doc = "Timer callback type for functions to be called when a timer expires.\n\n In the timer callback, it is ALLOWED:\n - To start, stop, or restart an existing timer,\n - To create new timers using furi_event_loop_timer_alloc(),\n - To delete timers using furi_event_loop_timer_free().\n\n # Arguments\n\n* `context` (direction in, out) - pointer to a user-specific object that was provided during timer creation"]
pub type FuriEventLoopTimerCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriEventLoopTimer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Create a new event loop timer instance.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the current FuriEventLoop instance\n * `callback` (direction in) - pointer to the callback function to be executed upon timer timeout\n * `type` (direction in) - timer type value to determine its behavior (single-shot or periodic)\n * `context` (direction in, out) - pointer to a user-specific object (will be passed to the callback)\n # Returns\n\npointer to the created timer instance"]
    pub fn furi_event_loop_timer_alloc(
        instance: *mut FuriEventLoop,
        callback: FuriEventLoopTimerCallback,
        type_: FuriEventLoopTimerType,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriEventLoopTimer;
}
unsafe extern "C" {
    #[doc = "Delete an event loop timer instance.\n\n The user code MUST call furi_event_loop_timer_free() on ALL instances\n associated with the current event loop BEFORE calling furi_event_loop_free().\n The event loop may EITHER be running OR stopped when the timers are being deleted.\n\n # Arguments\n\n* `timer` (direction in, out) - pointer to the timer instance to be deleted"]
    pub fn furi_event_loop_timer_free(timer: *mut FuriEventLoopTimer);
}
unsafe extern "C" {
    #[doc = "Start a timer or restart it with a new interval.\n\n # Arguments\n\n* `timer` (direction in, out) - pointer to the timer instance to be (re)started\n * `interval` (direction in) - timer interval in ticks"]
    pub fn furi_event_loop_timer_start(timer: *mut FuriEventLoopTimer, interval: u32);
}
unsafe extern "C" {
    #[doc = "Restart a timer with the previously set interval.\n\n # Arguments\n\n* `timer` (direction in, out) - pointer to the timer instance to be restarted"]
    pub fn furi_event_loop_timer_restart(timer: *mut FuriEventLoopTimer);
}
unsafe extern "C" {
    #[doc = "Stop a timer without firing its callback.\n\n It is safe to call this function on an already stopped timer (it will do nothing).\n\n # Arguments\n\n* `timer` (direction in, out) - pointer to the timer instance to be stopped"]
    pub fn furi_event_loop_timer_stop(timer: *mut FuriEventLoopTimer);
}
unsafe extern "C" {
    #[doc = "Get the time remaining before the timer becomes expires.\n\n For stopped or expired timers, this function returns 0.\n\n # Arguments\n\n* `timer` (direction in) - pointer to the timer to be queried\n # Returns\n\nremaining time in ticks"]
    pub fn furi_event_loop_timer_get_remaining_time(timer: *const FuriEventLoopTimer) -> u32;
}
unsafe extern "C" {
    #[doc = "Get the timer interval.\n\n # Arguments\n\n* `timer` (direction in) - pointer to the timer to be queried\n # Returns\n\ntimer interval in ticks"]
    pub fn furi_event_loop_timer_get_interval(timer: *const FuriEventLoopTimer) -> u32;
}
unsafe extern "C" {
    #[doc = "Check if the timer is currently running.\n\n A timer is considered running if it has not expired yet.\n # Arguments\n\n* `timer` (direction in) - pointer to the timer to be queried\n # Returns\n\ntrue if the timer is running, false otherwise"]
    pub fn furi_event_loop_timer_is_running(timer: *const FuriEventLoopTimer) -> bool;
}
unsafe extern "C" {
    #[doc = "Allocate FuriEventFlag\n\n # Returns\n\npointer to FuriEventFlag"]
    pub fn furi_event_flag_alloc() -> *mut FuriEventFlag;
}
unsafe extern "C" {
    #[doc = "Deallocate FuriEventFlag\n\n # Arguments\n\n* `instance` - pointer to FuriEventFlag"]
    pub fn furi_event_flag_free(instance: *mut FuriEventFlag);
}
unsafe extern "C" {
    #[doc = "Set flags\n\n result of this function can be flags that you've just asked to\n set or not if someone was waiting for them and asked to clear it.\n It is highly recommended to read this function and\n xEventGroupSetBits source code.\n\n # Arguments\n\n* `instance` - pointer to FuriEventFlag\n * `flags` (direction in) - The flags to set\n\n # Returns\n\nResulting flags(see warning) or error (FuriStatus)"]
    pub fn furi_event_flag_set(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Clear flags\n\n # Arguments\n\n* `instance` - pointer to FuriEventFlag\n * `flags` (direction in) - The flags\n\n # Returns\n\nResulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_clear(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Get flags\n\n # Arguments\n\n* `instance` - pointer to FuriEventFlag\n\n # Returns\n\nResulting flags"]
    pub fn furi_event_flag_get(instance: *mut FuriEventFlag) -> u32;
}
unsafe extern "C" {
    #[doc = "Wait flags\n\n # Arguments\n\n* `instance` - pointer to FuriEventFlag\n * `flags` (direction in) - The flags\n * `options` (direction in) - The option flags\n * `timeout` (direction in) - The timeout\n\n # Returns\n\nResulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_wait(
        instance: *mut FuriEventFlag,
        flags: u32,
        options: u32,
        timeout: u32,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = "Check if CPU is in IRQ or kernel running and IRQ is masked\n\n Originally this primitive was born as a workaround for FreeRTOS kernel primitives shenanigans with PRIMASK.\n\n Meaningful use cases are:\n\n - When kernel is started and you want to ensure that you are not in IRQ or IRQ is not masked(like in critical section)\n - When kernel is not started and you want to make sure that you are not in IRQ mode, ignoring PRIMASK.\n\n As you can see there will be edge case when kernel is not started and PRIMASK is not 0 that may cause some funky behavior.\n Most likely it will happen after kernel primitives being used, but control not yet passed to kernel.\n It's up to you to figure out if it is safe for your code or not.\n\n # Returns\n\ntrue if CPU is in IRQ or kernel running and IRQ is masked"]
    pub fn furi_kernel_is_irq_or_masked() -> bool;
}
unsafe extern "C" {
    #[doc = "Check if kernel is running\n\n # Returns\n\ntrue if running, false otherwise"]
    pub fn furi_kernel_is_running() -> bool;
}
unsafe extern "C" {
    #[doc = "Lock kernel, pause process scheduling\n\n This should never be called in interrupt request context.\n\n # Returns\n\nprevious lock state(0 - unlocked, 1 - locked)"]
    pub fn furi_kernel_lock() -> i32;
}
unsafe extern "C" {
    #[doc = "Unlock kernel, resume process scheduling\n\n This should never be called in interrupt request context.\n\n # Returns\n\nprevious lock state(0 - unlocked, 1 - locked)"]
    pub fn furi_kernel_unlock() -> i32;
}
unsafe extern "C" {
    #[doc = "Restore kernel lock state\n\n This should never be called in interrupt request context.\n\n # Arguments\n\n* `lock` (direction in) - The lock state\n\n # Returns\n\nnew lock state or error"]
    pub fn furi_kernel_restore_lock(lock: i32) -> i32;
}
unsafe extern "C" {
    #[doc = "Get kernel systick frequency\n\n # Returns\n\nsystick counts per second"]
    pub fn furi_kernel_get_tick_frequency() -> u32;
}
unsafe extern "C" {
    #[doc = "Delay execution\n\n This should never be called in interrupt request context.\n\n Also keep in mind delay is aliased to scheduler timer intervals.\n\n # Arguments\n\n* `ticks` (direction in) - The ticks count to pause"]
    pub fn furi_delay_tick(ticks: u32);
}
unsafe extern "C" {
    #[doc = "Delay until tick\n\n This should never be called in interrupt request context.\n\n # Arguments\n\n* `tick` (direction in) - The tick until which kernel should delay task execution\n\n # Returns\n\nThe furi status."]
    pub fn furi_delay_until_tick(tick: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get current tick counter\n\n System uptime, may overflow.\n\n # Returns\n\nCurrent ticks in milliseconds"]
    pub fn furi_get_tick() -> u32;
}
unsafe extern "C" {
    #[doc = "Convert milliseconds to ticks\n\n # Arguments\n\n* `milliseconds` (direction in) - time in milliseconds\n # Returns\n\ntime in ticks"]
    pub fn furi_ms_to_ticks(milliseconds: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Delay in milliseconds\n\n This method uses kernel ticks on the inside, which causes delay to be aliased to scheduler timer intervals.\n Real wait time will be between X+ milliseconds.\n Special value: 0, will cause task yield.\n Also if used when kernel is not running will fall back to `furi_delay_us`.\n\n Cannot be used from ISR\n\n # Arguments\n\n* `milliseconds` (direction in) - milliseconds to wait"]
    pub fn furi_delay_ms(milliseconds: u32);
}
unsafe extern "C" {
    #[doc = "Delay in microseconds\n\n Implemented using Cortex DWT counter. Blocking and non aliased.\n\n # Arguments\n\n* `microseconds` (direction in) - microseconds to wait"]
    pub fn furi_delay_us(microseconds: u32);
}
pub const FuriLogLevelDefault: FuriLogLevel = FuriLogLevel(0);
pub const FuriLogLevelNone: FuriLogLevel = FuriLogLevel(1);
pub const FuriLogLevelError: FuriLogLevel = FuriLogLevel(2);
pub const FuriLogLevelWarn: FuriLogLevel = FuriLogLevel(3);
pub const FuriLogLevelInfo: FuriLogLevel = FuriLogLevel(4);
pub const FuriLogLevelDebug: FuriLogLevel = FuriLogLevel(5);
pub const FuriLogLevelTrace: FuriLogLevel = FuriLogLevel(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriLogLevel(pub core::ffi::c_uchar);
pub type FuriLogHandlerCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *const u8, size: usize, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriLogHandler {
    pub callback: FuriLogHandlerCallback,
    pub context: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriLogHandler"][::core::mem::size_of::<FuriLogHandler>() - 8usize];
    ["Alignment of FuriLogHandler"][::core::mem::align_of::<FuriLogHandler>() - 4usize];
    ["Offset of field: FuriLogHandler::callback"]
        [::core::mem::offset_of!(FuriLogHandler, callback) - 0usize];
    ["Offset of field: FuriLogHandler::context"]
        [::core::mem::offset_of!(FuriLogHandler, context) - 4usize];
};
unsafe extern "C" {
    #[doc = "Add log TX callback\n\n # Arguments\n\n* `handler` (direction in) - The callback and its context\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn furi_log_add_handler(handler: FuriLogHandler) -> bool;
}
unsafe extern "C" {
    #[doc = "Remove log TX callback\n\n # Arguments\n\n* `handler` (direction in) - The callback and its context\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn furi_log_remove_handler(handler: FuriLogHandler) -> bool;
}
unsafe extern "C" {
    #[doc = "Transmit data through log IO callbacks\n\n # Arguments\n\n* `data` (direction in) - The data\n * `size` (direction in) - The size"]
    pub fn furi_log_tx(data: *const u8, size: usize);
}
unsafe extern "C" {
    #[doc = "Transmit data through log IO callbacks\n\n # Arguments\n\n* `data` (direction in) - The data, null-terminated C-string"]
    pub fn furi_log_puts(data: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Print log record\n\n # Arguments\n\n* `level` -\n * `tag` -\n * `format` -\n * `...` -"]
    pub fn furi_log_print_format(
        level: FuriLogLevel,
        tag: *const core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = "Print log record\n\n # Arguments\n\n* `level` -\n * `format` -\n * `...` -"]
    pub fn furi_log_print_raw_format(level: FuriLogLevel, format: *const core::ffi::c_char, ...);
}
unsafe extern "C" {
    #[doc = "Set log level\n\n # Arguments\n\n* `level` (direction in) - The level"]
    pub fn furi_log_set_level(level: FuriLogLevel);
}
unsafe extern "C" {
    #[doc = "Get log level\n\n # Returns\n\nThe furi log level."]
    pub fn furi_log_get_level() -> FuriLogLevel;
}
unsafe extern "C" {
    #[doc = "Log level to string\n\n # Arguments\n\n* `level` (direction in) - The level\n * `str` (direction out) - String representation of the level\n\n # Returns\n\nTrue if success, False otherwise"]
    pub fn furi_log_level_to_string(
        level: FuriLogLevel,
        str_: *mut *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Log level from string\n\n # Arguments\n\n* `str` (direction in) - The string\n * `level` (direction out) - The level\n\n # Returns\n\nTrue if success, False otherwise"]
    pub fn furi_log_level_from_string(
        str_: *const core::ffi::c_char,
        level: *mut FuriLogLevel,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get free heap size\n\n # Returns\n\nfree heap size in bytes"]
    pub fn memmgr_get_free_heap() -> usize;
}
unsafe extern "C" {
    #[doc = "Get total heap size\n\n # Returns\n\ntotal heap size in bytes"]
    pub fn memmgr_get_total_heap() -> usize;
}
unsafe extern "C" {
    #[doc = "Get heap watermark\n\n # Returns\n\nminimum heap in bytes"]
    pub fn memmgr_get_minimum_free_heap() -> usize;
}
unsafe extern "C" {
    #[doc = "An aligned version of malloc, used when you need to get the aligned space on the heap\n Freeing the received address is performed ONLY through the aligned_free function\n # Arguments\n\n* `size` -\n * `alignment` -\n # Returns\n\nvoid*"]
    pub fn aligned_malloc(size: usize, alignment: usize) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Freed space obtained through the aligned_malloc function\n # Arguments\n\n* `p` - pointer to result of aligned_malloc"]
    pub fn aligned_free(p: *mut core::ffi::c_void);
}
#[doc = "< Thread is stopped and is safe to release. Event delivered from system init thread(TCB cleanup routine). It is safe to release thread instance."]
pub const FuriThreadStateStopped: FuriThreadState = FuriThreadState(0);
#[doc = "< Thread is stopping. Event delivered from child thread."]
pub const FuriThreadStateStopping: FuriThreadState = FuriThreadState(1);
#[doc = "< Thread is starting. Event delivered from parent(self) thread."]
pub const FuriThreadStateStarting: FuriThreadState = FuriThreadState(2);
#[doc = "< Thread is running. Event delivered from child thread."]
pub const FuriThreadStateRunning: FuriThreadState = FuriThreadState(3);
#[repr(transparent)]
#[doc = "Enumeration of possible FuriThread states.\n\n Many of the FuriThread functions MUST ONLY be called when the thread is STOPPED."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriThreadState(pub core::ffi::c_uchar);
#[doc = "< Idle priority"]
pub const FuriThreadPriorityIdle: FuriThreadPriority = FuriThreadPriority(0);
#[doc = "< Init System Thread Priority"]
pub const FuriThreadPriorityInit: FuriThreadPriority = FuriThreadPriority(4);
#[doc = "< Lowest"]
pub const FuriThreadPriorityLowest: FuriThreadPriority = FuriThreadPriority(14);
#[doc = "< Low"]
pub const FuriThreadPriorityLow: FuriThreadPriority = FuriThreadPriority(15);
#[doc = "< Normal, system default"]
pub const FuriThreadPriorityNormal: FuriThreadPriority = FuriThreadPriority(16);
#[doc = "< High"]
pub const FuriThreadPriorityHigh: FuriThreadPriority = FuriThreadPriority(17);
#[doc = "< Highest"]
pub const FuriThreadPriorityHighest: FuriThreadPriority = FuriThreadPriority(18);
pub const FuriThreadPriorityIsr: FuriThreadPriority = FuriThreadPriority(31);
#[repr(transparent)]
#[doc = "Enumeration of possible FuriThread priorities."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriThreadPriority(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriThread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriThreadList {
    _unused: [u8; 0],
}
#[doc = "Unique thread identifier type (used by the OS kernel)."]
pub type FuriThreadId = *mut core::ffi::c_void;
#[doc = "Thread callback function pointer type.\n\n The function to be used as a thread callback MUST follow this signature.\n\n # Arguments\n\n* `context` (direction in, out) - pointer to a user-specified object\n # Returns\n\nvalue to be used as the thread return code"]
pub type FuriThreadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> i32>;
#[doc = "Standard output callback function pointer type.\n\n The function to be used as a standard output callback MUST follow this signature.\n\n The handler MUST process ALL of the provided data before returning.\n\n # Arguments\n\n* `data` (direction in) - pointer to the data to be written to the standard out\n * `size` (direction in) - size of the data in bytes\n * `context` (direction in) - optional context"]
pub type FuriThreadStdoutWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const core::ffi::c_char,
        size: usize,
        context: *mut core::ffi::c_void,
    ),
>;
#[doc = "Standard input callback function pointer type\n\n The function to be used as a standard input callback MUST follow this signature.\n\n # Arguments\n\n* `buffer` (direction out) - buffer to read data into\n * `size` (direction in) - maximum number of bytes to read into the buffer\n * `timeout` (direction in) - how long to wait for (in ticks) before giving up\n * `context` (direction in) - optional context\n # Returns\n\nnumber of bytes that was actually read into the buffer"]
pub type FuriThreadStdinReadCallback = ::core::option::Option<
    unsafe extern "C" fn(
        buffer: *mut core::ffi::c_char,
        size: usize,
        timeout: FuriWait,
        context: *mut core::ffi::c_void,
    ) -> usize,
>;
#[doc = "State change callback function pointer type.\n\n The function to be used as a state callback MUST follow this\n signature.\n\n # Arguments\n\n* `thread` (direction in) - to the FuriThread instance that changed the state\n * `state` (direction in) - identifier of the state the thread has transitioned\n to\n * `context` (direction in, out) - pointer to a user-specified object"]
pub type FuriThreadStateCallback = ::core::option::Option<
    unsafe extern "C" fn(
        thread: *mut FuriThread,
        state: FuriThreadState,
        context: *mut core::ffi::c_void,
    ),
>;
#[doc = "Signal handler callback function pointer type.\n\n The function to be used as a signal handler callback MUS follow this signature.\n\n # Arguments\n\n* `signal` (direction in) - value of the signal to be handled by the recipient\n * `arg` (direction in, out) - optional argument (can be of any value, including NULL)\n * `context` (direction in, out) - pointer to a user-specified object\n # Returns\n\ntrue if the signal was handled, false otherwise"]
pub type FuriThreadSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        signal: u32,
        arg: *mut core::ffi::c_void,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = "Create a FuriThread instance.\n\n # Returns\n\npointer to the created FuriThread instance"]
    pub fn furi_thread_alloc() -> *mut FuriThread;
}
unsafe extern "C" {
    #[doc = "Create a FuriThread instance w/ extra parameters.\n\n # Arguments\n\n* `name` (direction in) - human-readable thread name (can be NULL)\n * `stack_size` (direction in) - stack size in bytes (can be changed later)\n * `callback` (direction in) - pointer to a function to be executed in this thread\n * `context` (direction in) - pointer to a user-specified object (will be passed to the callback)\n # Returns\n\npointer to the created FuriThread instance"]
    pub fn furi_thread_alloc_ex(
        name: *const core::ffi::c_char,
        stack_size: u32,
        callback: FuriThreadCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriThread;
}
unsafe extern "C" {
    #[doc = "Delete a FuriThread instance.\n\n The thread MUST be stopped when calling this function.\n\n see furi_thread_join for caveats on stopping a thread.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be deleted"]
    pub fn furi_thread_free(thread: *mut FuriThread);
}
unsafe extern "C" {
    #[doc = "Set the name of a FuriThread instance.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `name` (direction in) - human-readable thread name (can be NULL)"]
    pub fn furi_thread_set_name(thread: *mut FuriThread, name: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set the application ID of a FuriThread instance.\n\n The thread MUST be stopped when calling this function.\n\n Technically, it is like a \"process id\", but it is not a system-wide unique identifier.\n All threads spawned by the same app will have the same appid.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `appid` (direction in) - thread application ID (can be NULL)"]
    pub fn furi_thread_set_appid(thread: *mut FuriThread, appid: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set the stack size of a FuriThread instance.\n\n The thread MUST be stopped when calling this function. Additionally, it is NOT possible\n to change the stack size of a service thread under any circumstances.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `stack_size` (direction in) - stack size in bytes"]
    pub fn furi_thread_set_stack_size(thread: *mut FuriThread, stack_size: usize);
}
unsafe extern "C" {
    #[doc = "Set the user callback function to be executed in a FuriThread.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `callback` (direction in) - pointer to a user-specified function to be executed in this thread"]
    pub fn furi_thread_set_callback(thread: *mut FuriThread, callback: FuriThreadCallback);
}
unsafe extern "C" {
    #[doc = "Set the callback function context.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `context` (direction in) - pointer to a user-specified object (will be passed to the callback, can be NULL)"]
    pub fn furi_thread_set_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set the priority of a FuriThread.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `priority` (direction in) - priority level value"]
    pub fn furi_thread_set_priority(thread: *mut FuriThread, priority: FuriThreadPriority);
}
unsafe extern "C" {
    #[doc = "Get the priority of a FuriThread.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be queried\n # Returns\n\npriority level value"]
    pub fn furi_thread_get_priority(thread: *mut FuriThread) -> FuriThreadPriority;
}
unsafe extern "C" {
    #[doc = "Set the priority of the current FuriThread.\n\n # Arguments\n\n* `priority` - priority level value"]
    pub fn furi_thread_set_current_priority(priority: FuriThreadPriority);
}
unsafe extern "C" {
    #[doc = "Get the priority of the current FuriThread.\n\n # Returns\n\npriority level value"]
    pub fn furi_thread_get_current_priority() -> FuriThreadPriority;
}
unsafe extern "C" {
    #[doc = "Set the callback function to be executed upon a state thransition of a FuriThread.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `callback` (direction in) - pointer to a user-specified callback function"]
    pub fn furi_thread_set_state_callback(
        thread: *mut FuriThread,
        callback: FuriThreadStateCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set the state change callback context.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `context` (direction in) - pointer to a user-specified object (will be passed to the callback, can be NULL)"]
    pub fn furi_thread_set_state_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Get the state of a FuriThread isntance.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be queried\n # Returns\n\nthread state value"]
    pub fn furi_thread_get_state(thread: *mut FuriThread) -> FuriThreadState;
}
unsafe extern "C" {
    #[doc = "Set a signal handler callback for a FuriThread instance.\n\n The thread MUST be stopped when calling this function if calling it from another thread.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified\n * `callback` (direction in) - pointer to a user-specified callback function\n * `context` (direction in) - pointer to a user-specified object (will be passed to the callback, can be NULL)"]
    pub fn furi_thread_set_signal_callback(
        thread: *mut FuriThread,
        callback: FuriThreadSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get a signal callback for a FuriThread instance.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be queried\n # Returns\n\npointer to the callback function or NULL if none has been set"]
    pub fn furi_thread_get_signal_callback(thread: *const FuriThread) -> FuriThreadSignalCallback;
}
unsafe extern "C" {
    #[doc = "Send a signal to a FuriThread instance.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be signaled\n * `signal` (direction in) - signal value to be sent\n * `arg` (direction in, out) - optional argument (can be of any value, including NULL)"]
    pub fn furi_thread_signal(
        thread: *const FuriThread,
        signal: u32,
        arg: *mut core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Start a FuriThread instance.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be started"]
    pub fn furi_thread_start(thread: *mut FuriThread);
}
unsafe extern "C" {
    #[doc = "Wait for a FuriThread to exit.\n\n The thread callback function must return in order for the FuriThread instance to become joinable.\n\n Use this method only when the CPU is not busy (i.e. when the\n Idle task receives control), otherwise it will wait forever.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be joined\n # Returns\n\nalways true"]
    pub fn furi_thread_join(thread: *mut FuriThread) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the unique identifier of a FuriThread instance.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be queried\n # Returns\n\nunique identifier value or NULL if thread is not running"]
    pub fn furi_thread_get_id(thread: *mut FuriThread) -> FuriThreadId;
}
unsafe extern "C" {
    #[doc = "Enable heap usage tracing for a FuriThread.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in, out) - pointer to the FuriThread instance to be modified"]
    pub fn furi_thread_enable_heap_trace(thread: *mut FuriThread);
}
unsafe extern "C" {
    #[doc = "Get heap usage by a FuriThread instance.\n\n The heap trace MUST be enabled before callgin this function.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be queried\n # Returns\n\nheap usage in bytes"]
    pub fn furi_thread_get_heap_size(thread: *mut FuriThread) -> usize;
}
unsafe extern "C" {
    #[doc = "Get the return code of a FuriThread instance.\n\n This value is equal to the return value of the thread callback function.\n\n The thread MUST be stopped when calling this function.\n\n # Arguments\n\n* `thread` (direction in) - pointer to the FuriThread instance to be queried\n # Returns\n\nreturn code value"]
    pub fn furi_thread_get_return_code(thread: *mut FuriThread) -> i32;
}
unsafe extern "C" {
    #[doc = "Get the unique identifier of the current FuriThread.\n\n # Returns\n\nunique identifier value"]
    pub fn furi_thread_get_current_id() -> FuriThreadId;
}
unsafe extern "C" {
    #[doc = "Get the FuriThread instance associated with the current thread.\n\n # Returns\n\npointer to a FuriThread instance or NULL if this thread does not belong to Furi"]
    pub fn furi_thread_get_current() -> *mut FuriThread;
}
unsafe extern "C" {
    #[doc = "Return control to the scheduler."]
    pub fn furi_thread_yield();
}
unsafe extern "C" {
    #[doc = "Set the thread flags of a FuriThread.\n\n Can be used as a simple inter-thread communication mechanism.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be notified\n * `flags` (direction in) - bitmask of thread flags to set\n # Returns\n\nbitmask combination of previous and newly set flags"]
    pub fn furi_thread_flags_set(thread_id: FuriThreadId, flags: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Clear the thread flags of the current FuriThread.\n\n # Arguments\n\n* `flags` (direction in) - bitmask of thread flags to clear\n # Returns\n\nbitmask of thread flags before clearing"]
    pub fn furi_thread_flags_clear(flags: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Get the thread flags of the current FuriThread.\n # Returns\n\ncurrent bitmask of thread flags"]
    pub fn furi_thread_flags_get() -> u32;
}
unsafe extern "C" {
    #[doc = "Wait for some thread flags to be set.\n\n [`FuriFlag`] for option and error flags.\n\n # Arguments\n\n* `flags` (direction in) - bitmask of thread flags to wait for\n * `options` (direction in) - combination of option flags determining the behavior of the function\n * `timeout` (direction in) - maximum time to wait in milliseconds (use FuriWaitForever to wait forever)\n # Returns\n\nbitmask combination of received thread and error flags"]
    pub fn furi_thread_flags_wait(flags: u32, options: u32, timeout: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Enumerate all threads.\n\n # Arguments\n\n* `thread_list` (direction out) - pointer to the FuriThreadList container\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn furi_thread_enumerate(thread_list: *mut FuriThreadList) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the name of a thread based on its unique identifier.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be queried\n # Returns\n\npointer to a zero-terminated string or NULL"]
    pub fn furi_thread_get_name(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get the application id of a thread based on its unique identifier.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be queried\n # Returns\n\npointer to a zero-terminated string"]
    pub fn furi_thread_get_appid(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get thread stack watermark.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be queried\n # Returns\n\nstack watermark value"]
    pub fn furi_thread_get_stack_space(thread_id: FuriThreadId) -> u32;
}
unsafe extern "C" {
    #[doc = "Get the standard output callback for the current thead.\n\n # Returns\n\npointer to the standard out callback function"]
    pub fn furi_thread_get_stdout_callback() -> FuriThreadStdoutWriteCallback;
}
unsafe extern "C" {
    #[doc = "Get the standard input callback for the current thead.\n\n # Returns\n\npointer to the standard in callback function"]
    pub fn furi_thread_get_stdin_callback() -> FuriThreadStdinReadCallback;
}
unsafe extern "C" {
    #[doc = "Set standard output callback for the current thread.\n\n # Arguments\n\n* `callback` (direction in) - pointer to the callback function or NULL to clear\n * `context` (direction in) - context to be passed to the callback"]
    pub fn furi_thread_set_stdout_callback(
        callback: FuriThreadStdoutWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set standard input callback for the current thread.\n\n # Arguments\n\n* `callback` (direction in) - pointer to the callback function or NULL to clear\n * `context` (direction in) - context to be passed to the callback"]
    pub fn furi_thread_set_stdin_callback(
        callback: FuriThreadStdinReadCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Write data to buffered standard output.\n\n > **Note:** You can also use the standard C `putc`, `puts`, `printf` and friends.\n\n # Arguments\n\n* `data` (direction in) - pointer to the data to be written\n * `size` (direction in) - data size in bytes\n # Returns\n\nnumber of bytes that was actually written"]
    pub fn furi_thread_stdout_write(data: *const core::ffi::c_char, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Flush buffered data to standard output.\n\n # Returns\n\nerror code value"]
    pub fn furi_thread_stdout_flush() -> i32;
}
unsafe extern "C" {
    #[doc = "Read data from the standard input\n\n > **Note:** You can also use the standard C `getc`, `gets` and friends.\n\n # Arguments\n\n* `buffer` (direction in) - pointer to the buffer to read data into\n * `size` (direction in) - how many bytes to read into the buffer\n * `timeout` (direction in) - how long to wait for (in ticks) before giving up\n # Returns\n\nnumber of bytes that was actually read"]
    pub fn furi_thread_stdin_read(
        buffer: *mut core::ffi::c_char,
        size: usize,
        timeout: FuriWait,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Puts data back into the standard input buffer\n\n `furi_thread_stdin_read` will return the bytes in the same order that they\n were supplied to this function.\n\n > **Note:** You can also use the standard C `ungetc`.\n\n # Arguments\n\n* `buffer` (direction in) - pointer to the buffer to get data from\n * `size` (direction in) - how many bytes to read from the buffer"]
    pub fn furi_thread_stdin_unread(buffer: *mut core::ffi::c_char, size: usize);
}
unsafe extern "C" {
    #[doc = "Suspend a thread.\n\n Suspended threads are no more receiving any of the processor time.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be suspended"]
    pub fn furi_thread_suspend(thread_id: FuriThreadId);
}
unsafe extern "C" {
    #[doc = "Resume a thread.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be resumed"]
    pub fn furi_thread_resume(thread_id: FuriThreadId);
}
unsafe extern "C" {
    #[doc = "Test if a thread is suspended.\n\n # Arguments\n\n* `thread_id` (direction in) - unique identifier of the thread to be queried\n # Returns\n\ntrue if thread is suspended, false otherwise"]
    pub fn furi_thread_is_suspended(thread_id: FuriThreadId) -> bool;
}
unsafe extern "C" {
    #[doc = "Memmgr heap enable thread allocation tracking\n\n # Arguments\n\n* `thread_id` - - thread id to track"]
    pub fn memmgr_heap_enable_thread_trace(thread_id: FuriThreadId);
}
unsafe extern "C" {
    #[doc = "Memmgr heap disable thread allocation tracking\n\n # Arguments\n\n* `thread_id` - - thread id to track"]
    pub fn memmgr_heap_disable_thread_trace(thread_id: FuriThreadId);
}
unsafe extern "C" {
    #[doc = "Memmgr heap get allocatred thread memory\n\n # Arguments\n\n* `thread_id` - - thread id to track\n\n # Returns\n\nbytes allocated right now"]
    pub fn memmgr_heap_get_thread_memory(thread_id: FuriThreadId) -> usize;
}
unsafe extern "C" {
    #[doc = "Memmgr heap get the max contiguous block size on the heap\n\n # Returns\n\nsize_t max contiguous block size"]
    pub fn memmgr_heap_get_max_free_block() -> usize;
}
unsafe extern "C" {
    #[doc = "Print the address and size of all free blocks to stdout"]
    pub fn memmgr_heap_printf_free_blocks();
}
unsafe extern "C" {
    #[doc = "Allocate furi message queue\n\n # Arguments\n\n* `msg_count` (direction in) - The message count\n * `msg_size` (direction in) - The message size\n\n # Returns\n\npointer to FuriMessageQueue instance"]
    pub fn furi_message_queue_alloc(msg_count: u32, msg_size: u32) -> *mut FuriMessageQueue;
}
unsafe extern "C" {
    #[doc = "Free queue\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance"]
    pub fn furi_message_queue_free(instance: *mut FuriMessageQueue);
}
unsafe extern "C" {
    #[doc = "Put message into queue\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n * `msg_ptr` (direction in) - The message pointer\n * `timeout` (direction in) - The timeout\n\n # Returns\n\nThe furi status."]
    pub fn furi_message_queue_put(
        instance: *mut FuriMessageQueue,
        msg_ptr: *const core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get message from queue\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n * `msg_ptr` - The message pointer\n * `timeout` (direction in) - The timeout\n\n # Returns\n\nThe furi status."]
    pub fn furi_message_queue_get(
        instance: *mut FuriMessageQueue,
        msg_ptr: *mut core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get queue capacity\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n # Returns\n\ncapacity in object count"]
    pub fn furi_message_queue_get_capacity(instance: *mut FuriMessageQueue) -> u32;
}
unsafe extern "C" {
    #[doc = "Get message size\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n # Returns\n\nMessage size in bytes"]
    pub fn furi_message_queue_get_message_size(instance: *mut FuriMessageQueue) -> u32;
}
unsafe extern "C" {
    #[doc = "Get message count in queue\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n # Returns\n\nMessage count"]
    pub fn furi_message_queue_get_count(instance: *mut FuriMessageQueue) -> u32;
}
unsafe extern "C" {
    #[doc = "Get queue available space\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n # Returns\n\nMessage count"]
    pub fn furi_message_queue_get_space(instance: *mut FuriMessageQueue) -> u32;
}
unsafe extern "C" {
    #[doc = "Reset queue\n\n # Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n # Returns\n\nThe furi status."]
    pub fn furi_message_queue_reset(instance: *mut FuriMessageQueue) -> FuriStatus;
}
pub const FuriMutexTypeNormal: FuriMutexType = FuriMutexType(0);
pub const FuriMutexTypeRecursive: FuriMutexType = FuriMutexType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriMutexType(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Allocate FuriMutex\n\n # Arguments\n\n* `type` (direction in) - The mutex type\n\n # Returns\n\npointer to FuriMutex instance"]
    pub fn furi_mutex_alloc(type_: FuriMutexType) -> *mut FuriMutex;
}
unsafe extern "C" {
    #[doc = "Free FuriMutex\n\n # Arguments\n\n* `instance` - The pointer to FuriMutex instance"]
    pub fn furi_mutex_free(instance: *mut FuriMutex);
}
unsafe extern "C" {
    #[doc = "Acquire mutex\n\n # Arguments\n\n* `instance` - The pointer to FuriMutex instance\n * `timeout` (direction in) - The timeout\n\n # Returns\n\nThe furi status."]
    pub fn furi_mutex_acquire(instance: *mut FuriMutex, timeout: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Release mutex\n\n # Arguments\n\n* `instance` - The pointer to FuriMutex instance\n\n # Returns\n\nThe furi status."]
    pub fn furi_mutex_release(instance: *mut FuriMutex) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get mutex owner thread id\n\n # Arguments\n\n* `instance` - The pointer to FuriMutex instance\n\n # Returns\n\nThe furi thread identifier."]
    pub fn furi_mutex_get_owner(instance: *mut FuriMutex) -> FuriThreadId;
}
#[doc = "FuriPubSub Callback type"]
pub type FuriPubSubCallback = ::core::option::Option<
    unsafe extern "C" fn(message: *const core::ffi::c_void, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSubSubscription {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate FuriPubSub\n\n Reentrable, Not threadsafe, one owner\n\n # Returns\n\npointer to FuriPubSub instance"]
    pub fn furi_pubsub_alloc() -> *mut FuriPubSub;
}
unsafe extern "C" {
    #[doc = "Free FuriPubSub\n\n # Arguments\n\n* `pubsub` - FuriPubSub instance"]
    pub fn furi_pubsub_free(pubsub: *mut FuriPubSub);
}
unsafe extern "C" {
    #[doc = "Subscribe to FuriPubSub\n\n Threadsafe, Reentrable\n\n # Arguments\n\n* `pubsub` - pointer to FuriPubSub instance\n * `callback` (direction in) - The callback\n * `callback_context` - The callback context\n\n # Returns\n\npointer to FuriPubSubSubscription instance"]
    pub fn furi_pubsub_subscribe(
        pubsub: *mut FuriPubSub,
        callback: FuriPubSubCallback,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut FuriPubSubSubscription;
}
unsafe extern "C" {
    #[doc = "Unsubscribe from FuriPubSub\n\n No use of `pubsub_subscription` allowed after call of this method\n Threadsafe, Reentrable.\n\n # Arguments\n\n* `pubsub` - pointer to FuriPubSub instance\n * `pubsub_subscription` - pointer to FuriPubSubSubscription instance"]
    pub fn furi_pubsub_unsubscribe(
        pubsub: *mut FuriPubSub,
        pubsub_subscription: *mut FuriPubSubSubscription,
    );
}
unsafe extern "C" {
    #[doc = "Publish message to FuriPubSub\n\n Threadsafe, Reentrable.\n\n # Arguments\n\n* `pubsub` - pointer to FuriPubSub instance\n * `message` - message pointer to publish"]
    pub fn furi_pubsub_publish(pubsub: *mut FuriPubSub, message: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Check if record exists\n\n # Arguments\n\n* `name` - record name\n > **Note:** Thread safe. Create and destroy must be executed from the same\n thread."]
    pub fn furi_record_exists(name: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Create record\n\n # Arguments\n\n* `name` - record name\n * `data` - data pointer\n > **Note:** Thread safe. Create and destroy must be executed from the same\n thread."]
    pub fn furi_record_create(name: *const core::ffi::c_char, data: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Destroy record\n\n # Arguments\n\n* `name` - record name\n\n # Returns\n\ntrue if successful, false if still have holders or thread is not\n owner.\n > **Note:** Thread safe. Create and destroy must be executed from the same\n thread."]
    pub fn furi_record_destroy(name: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Open record\n\n # Arguments\n\n* `name` - record name\n\n # Returns\n\npointer to the record\n > **Note:** Thread safe. Open and close must be executed from the same\n thread. Suspends caller thread till record is available"]
    pub fn furi_record_open(name: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Close record\n\n # Arguments\n\n* `name` - record name\n > **Note:** Thread safe. Open and close must be executed from the same\n thread."]
    pub fn furi_record_close(name: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Allocate semaphore\n\n # Arguments\n\n* `max_count` (direction in) - The maximum count\n * `initial_count` (direction in) - The initial count\n\n # Returns\n\npointer to FuriSemaphore instance"]
    pub fn furi_semaphore_alloc(max_count: u32, initial_count: u32) -> *mut FuriSemaphore;
}
unsafe extern "C" {
    #[doc = "Free semaphore\n\n # Arguments\n\n* `instance` - The pointer to FuriSemaphore instance"]
    pub fn furi_semaphore_free(instance: *mut FuriSemaphore);
}
unsafe extern "C" {
    #[doc = "Acquire semaphore\n\n # Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n * `timeout` (direction in) - The timeout\n\n # Returns\n\nThe furi status."]
    pub fn furi_semaphore_acquire(instance: *mut FuriSemaphore, timeout: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Release semaphore\n\n # Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n\n # Returns\n\nThe furi status."]
    pub fn furi_semaphore_release(instance: *mut FuriSemaphore) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get semaphore count\n\n # Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n\n # Returns\n\nSemaphore count"]
    pub fn furi_semaphore_get_count(instance: *mut FuriSemaphore) -> u32;
}
unsafe extern "C" {
    #[doc = "Get available space\n\n # Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n\n # Returns\n\nSemaphore available space"]
    pub fn furi_semaphore_get_space(instance: *mut FuriSemaphore) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriThreadListItem {
    #[doc = "< Pointer to FuriThread, valid while it is running"]
    pub thread: *mut FuriThread,
    #[doc = "< Thread application id, valid while it is running"]
    pub app_id: *const core::ffi::c_char,
    #[doc = "< Thread name, valid while it is running"]
    pub name: *const core::ffi::c_char,
    #[doc = "< Thread priority"]
    pub priority: FuriThreadPriority,
    #[doc = "< Thread stack address"]
    pub stack_address: u32,
    #[doc = "< Thread heap size if tracking enabled, 0 - otherwise"]
    pub heap: usize,
    #[doc = "< Thread stack size"]
    pub stack_size: u32,
    #[doc = "< Thread minimum of the stack size ever reached"]
    pub stack_min_free: u32,
    #[doc = "< Thread state, can be: \"Running\", \"Ready\", \"Blocked\", \"Suspended\", \"Deleted\", \"Invalid\""]
    pub state: *const core::ffi::c_char,
    #[doc = "< Thread CPU usage time in percents (including interrupts happened while running)"]
    pub cpu: f32,
    #[doc = "< Thread previous runtime counter"]
    pub counter_previous: u32,
    #[doc = "< Thread current runtime counter"]
    pub counter_current: u32,
    #[doc = "< Thread last seen tick"]
    pub tick: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriThreadListItem"][::core::mem::size_of::<FuriThreadListItem>() - 52usize];
    ["Alignment of FuriThreadListItem"][::core::mem::align_of::<FuriThreadListItem>() - 4usize];
    ["Offset of field: FuriThreadListItem::thread"]
        [::core::mem::offset_of!(FuriThreadListItem, thread) - 0usize];
    ["Offset of field: FuriThreadListItem::app_id"]
        [::core::mem::offset_of!(FuriThreadListItem, app_id) - 4usize];
    ["Offset of field: FuriThreadListItem::name"]
        [::core::mem::offset_of!(FuriThreadListItem, name) - 8usize];
    ["Offset of field: FuriThreadListItem::priority"]
        [::core::mem::offset_of!(FuriThreadListItem, priority) - 12usize];
    ["Offset of field: FuriThreadListItem::stack_address"]
        [::core::mem::offset_of!(FuriThreadListItem, stack_address) - 16usize];
    ["Offset of field: FuriThreadListItem::heap"]
        [::core::mem::offset_of!(FuriThreadListItem, heap) - 20usize];
    ["Offset of field: FuriThreadListItem::stack_size"]
        [::core::mem::offset_of!(FuriThreadListItem, stack_size) - 24usize];
    ["Offset of field: FuriThreadListItem::stack_min_free"]
        [::core::mem::offset_of!(FuriThreadListItem, stack_min_free) - 28usize];
    ["Offset of field: FuriThreadListItem::state"]
        [::core::mem::offset_of!(FuriThreadListItem, state) - 32usize];
    ["Offset of field: FuriThreadListItem::cpu"]
        [::core::mem::offset_of!(FuriThreadListItem, cpu) - 36usize];
    ["Offset of field: FuriThreadListItem::counter_previous"]
        [::core::mem::offset_of!(FuriThreadListItem, counter_previous) - 40usize];
    ["Offset of field: FuriThreadListItem::counter_current"]
        [::core::mem::offset_of!(FuriThreadListItem, counter_current) - 44usize];
    ["Offset of field: FuriThreadListItem::tick"]
        [::core::mem::offset_of!(FuriThreadListItem, tick) - 48usize];
};
unsafe extern "C" {
    #[doc = "Allocate FuriThreadList instance\n\n # Returns\n\nFuriThreadList instance"]
    pub fn furi_thread_list_alloc() -> *mut FuriThreadList;
}
unsafe extern "C" {
    #[doc = "Free FuriThreadList instance\n\n # Arguments\n\n* `instance` - The FuriThreadList instance to free"]
    pub fn furi_thread_list_free(instance: *mut FuriThreadList);
}
unsafe extern "C" {
    #[doc = "Get FuriThreadList instance size\n\n # Arguments\n\n* `instance` - The instance\n\n # Returns\n\nItem count"]
    pub fn furi_thread_list_size(instance: *mut FuriThreadList) -> usize;
}
unsafe extern "C" {
    #[doc = "Get item at position\n\n # Arguments\n\n* `instance` - The FuriThreadList instance\n * `position` (direction in) - The position of the item\n\n # Returns\n\nThe FuriThreadListItem instance"]
    pub fn furi_thread_list_get_at(
        instance: *mut FuriThreadList,
        position: usize,
    ) -> *mut FuriThreadListItem;
}
unsafe extern "C" {
    #[doc = "Get item by thread FuriThread pointer\n\n # Arguments\n\n* `instance` - The FuriThreadList instance\n * `thread` - The FuriThread pointer\n\n # Returns\n\nThe FuriThreadListItem instance"]
    pub fn furi_thread_list_get_or_insert(
        instance: *mut FuriThreadList,
        thread: *mut FuriThread,
    ) -> *mut FuriThreadListItem;
}
unsafe extern "C" {
    #[doc = "Get percent of time spent in ISR\n\n # Arguments\n\n* `instance` - The instance\n\n # Returns\n\npercent of time spent in ISR"]
    pub fn furi_thread_list_get_isr_time(instance: *mut FuriThreadList) -> f32;
}
pub type FuriTimerCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "< One-shot timer."]
pub const FuriTimerTypeOnce: FuriTimerType = FuriTimerType(0);
#[doc = "< Repeating timer."]
pub const FuriTimerTypePeriodic: FuriTimerType = FuriTimerType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriTimerType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriTimer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate timer\n\n # Arguments\n\n* `func` (direction in) - The callback function\n * `type` (direction in) - The timer type\n * `context` - The callback context\n\n # Returns\n\nThe pointer to FuriTimer instance"]
    pub fn furi_timer_alloc(
        func: FuriTimerCallback,
        type_: FuriTimerType,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriTimer;
}
unsafe extern "C" {
    #[doc = "Free timer\n\n # Arguments\n\n* `instance` - The pointer to FuriTimer instance"]
    pub fn furi_timer_free(instance: *mut FuriTimer);
}
unsafe extern "C" {
    #[doc = "Flush timer task control message queue\n\n Ensures that all commands before this point was processed."]
    pub fn furi_timer_flush();
}
unsafe extern "C" {
    #[doc = "Start timer\n\n This is asynchronous call, real operation will happen as soon as\n timer service process this request.\n\n # Arguments\n\n* `instance` - The pointer to FuriTimer instance\n * `ticks` (direction in) - The interval in ticks\n\n # Returns\n\nThe furi status."]
    pub fn furi_timer_start(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Restart timer with previous timeout value\n\n This is asynchronous call, real operation will happen as soon as\n timer service process this request.\n\n # Arguments\n\n* `instance` - The pointer to FuriTimer instance\n * `ticks` (direction in) - The interval in ticks\n\n # Returns\n\nThe furi status."]
    pub fn furi_timer_restart(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Stop timer\n\n This is synchronous call that will be blocked till timer queue processed.\n\n # Arguments\n\n* `instance` - The pointer to FuriTimer instance\n\n # Returns\n\nThe furi status."]
    pub fn furi_timer_stop(instance: *mut FuriTimer) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Is timer running\n\n This cal may and will return obsolete timer state if timer\n commands are still in the queue. Please read FreeRTOS timer\n documentation first.\n\n # Arguments\n\n* `instance` - The pointer to FuriTimer instance\n\n # Returns\n\n0: not running, 1: running"]
    pub fn furi_timer_is_running(instance: *mut FuriTimer) -> u32;
}
unsafe extern "C" {
    #[doc = "Get timer expire time\n\n # Arguments\n\n* `instance` - The Timer instance\n\n # Returns\n\nexpire tick"]
    pub fn furi_timer_get_expire_time(instance: *mut FuriTimer) -> u32;
}
pub type FuriTimerPendigCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, arg: u32)>;
unsafe extern "C" {
    pub fn furi_timer_pending_callback(
        callback: FuriTimerPendigCallback,
        context: *mut core::ffi::c_void,
        arg: u32,
    );
}
#[doc = "< Lower then other threads"]
pub const FuriTimerThreadPriorityNormal: FuriTimerThreadPriority = FuriTimerThreadPriority(0);
#[doc = "< Same as other threads"]
pub const FuriTimerThreadPriorityElevated: FuriTimerThreadPriority = FuriTimerThreadPriority(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriTimerThreadPriority(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Set Timer thread priority\n\n # Arguments\n\n* `priority` (direction in) - The priority"]
    pub fn furi_timer_set_thread_priority(priority: FuriTimerThreadPriority);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriString {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate new FuriString.\n\n # Returns\n\npointer to the instance of FuriString"]
    pub fn furi_string_alloc() -> *mut FuriString;
}
unsafe extern "C" {
    #[doc = "Allocate new FuriString and set it to string.\n\n Allocate & Set the string a to the string.\n\n # Arguments\n\n* `source` - The source FuriString instance\n\n # Returns\n\npointer to the new instance of FuriString"]
    pub fn furi_string_alloc_set(source: *const FuriString) -> *mut FuriString;
}
unsafe extern "C" {
    #[doc = "Allocate new FuriString and set it to C string.\n\n Allocate & Set the string a to the C string.\n\n # Arguments\n\n* `cstr_source` - The C-string instance\n\n # Returns\n\npointer to the new instance of FuriString"]
    pub fn furi_string_alloc_set_str(cstr_source: *const core::ffi::c_char) -> *mut FuriString;
}
unsafe extern "C" {
    #[doc = "Allocate new FuriString and printf to it.\n\n Initialize and set a string to the given formatted value.\n\n # Arguments\n\n* `format` - The printf format\n * `...` (direction in) - args to format\n\n # Returns\n\npointer to the new instance of FuriString"]
    pub fn furi_string_alloc_printf(format: *const core::ffi::c_char, ...) -> *mut FuriString;
}
unsafe extern "C" {
    #[doc = "Allocate new FuriString and printf to it.\n\n Initialize and set a string to the given formatted value.\n\n # Arguments\n\n* `format` - The printf format\n * `args` - The format arguments\n\n # Returns\n\npointer to the new instance of FuriString"]
    pub fn furi_string_alloc_vprintf(
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> *mut FuriString;
}
unsafe extern "C" {
    #[doc = "Allocate new FuriString and move source string content to it.\n\n Allocate the string, set it to the other one, and destroy the other one.\n\n # Arguments\n\n* `source` - The source FuriString instance\n\n # Returns\n\npointer to the new instance of FuriString"]
    pub fn furi_string_alloc_move(source: *mut FuriString) -> *mut FuriString;
}
unsafe extern "C" {
    #[doc = "Free FuriString.\n\n # Arguments\n\n* `string` - The FuriString instance to free"]
    pub fn furi_string_free(string: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Reserve memory for string.\n\n Modify the string capacity to be able to handle at least 'alloc' characters\n (including final null char).\n\n # Arguments\n\n* `string` - The FuriString instance\n * `size` - The size to reserve"]
    pub fn furi_string_reserve(string: *mut FuriString, size: usize);
}
unsafe extern "C" {
    #[doc = "Reset string.\n\n Make the string empty.\n\n # Arguments\n\n* `string` - The FuriString instance"]
    pub fn furi_string_reset(string: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Swap two strings.\n\n Swap the two strings string_1 and string_2.\n\n # Arguments\n\n* `string_1` - The FuriString instance 1\n * `string_2` - The FuriString instance 2"]
    pub fn furi_string_swap(string_1: *mut FuriString, string_2: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Move string_2 content to string_1.\n\n Copy data from one string to another and destroy the source.\n\n # Arguments\n\n* `destination` - The destination FuriString\n * `source` - The source FuriString"]
    pub fn furi_string_move(destination: *mut FuriString, source: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Compute a hash for the string.\n\n # Arguments\n\n* `string` - The FuriString instance\n\n # Returns\n\nhash value"]
    pub fn furi_string_hash(string: *const FuriString) -> usize;
}
unsafe extern "C" {
    #[doc = "Get string size (usually length, but not for UTF-8)\n\n # Arguments\n\n* `string` - The FuriString instance\n\n # Returns\n\nsize of the string"]
    pub fn furi_string_size(string: *const FuriString) -> usize;
}
unsafe extern "C" {
    #[doc = "Check that string is empty or not\n\n # Arguments\n\n* `string` - The FuriString instance\n\n # Returns\n\ntrue if empty otherwise false"]
    pub fn furi_string_empty(string: *const FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the character at the given index.\n\n Return the selected character of the string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `index` - The index\n\n # Returns\n\ncharacter at index"]
    pub fn furi_string_get_char(string: *const FuriString, index: usize) -> core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Return the string view a classic C string.\n\n # Arguments\n\n* `string` - The FuriString instance\n\n # Returns\n\nconst C-string, usable till first container change"]
    pub fn furi_string_get_cstr(string: *const FuriString) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Set the string to the other string.\n\n Set the string to the source string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `source` - The source"]
    pub fn furi_string_set(string: *mut FuriString, source: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Set the string to the other C string.\n\n Set the string to the source C string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `source` - The source"]
    pub fn furi_string_set_str(string: *mut FuriString, source: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set the string to the n first characters of the C string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `source` - The source\n * `length` - The length"]
    pub fn furi_string_set_strn(
        string: *mut FuriString,
        source: *const core::ffi::c_char,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Set the character at the given index.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `index` - The index\n * `c` - The character"]
    pub fn furi_string_set_char(string: *mut FuriString, index: usize, c: core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set the string to the n first characters of other one.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `source` - The source\n * `offset` - The offset\n * `length` - The length"]
    pub fn furi_string_set_n(
        string: *mut FuriString,
        source: *const FuriString,
        offset: usize,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Format in the string the given printf format\n\n # Arguments\n\n* `string` - The string\n * `format` - The format\n * `...` (direction in) - The args\n\n # Returns\n\nnumber of characters printed or negative value on error"]
    pub fn furi_string_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Format in the string the given printf format\n\n # Arguments\n\n* `string` - The FuriString instance\n * `format` - The format\n * `args` - The arguments\n\n # Returns\n\nnumber of characters printed or negative value on error"]
    pub fn furi_string_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Append a character to the string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `c` - The character"]
    pub fn furi_string_push_back(string: *mut FuriString, c: core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Append a string to the string.\n\n Concatenate the string with the other string.\n\n # Arguments\n\n* `string_1` - The string 1\n * `string_2` - The string 2"]
    pub fn furi_string_cat(string_1: *mut FuriString, string_2: *const FuriString);
}
unsafe extern "C" {
    #[doc = "Append a C string to the string.\n\n Concatenate the string with the C string.\n\n # Arguments\n\n* `string_1` - The string 1\n * `cstring_2` - The cstring 2"]
    pub fn furi_string_cat_str(string_1: *mut FuriString, cstring_2: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Append to the string the formatted string of the given printf format.\n\n # Arguments\n\n* `string` - The string\n * `format` - The format\n * `...` (direction in) - The args\n\n # Returns\n\nnumber of characters printed or negative value on error"]
    pub fn furi_string_cat_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Append to the string the formatted string of the given printf format.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `format` - The format\n * `args` - The arguments\n\n # Returns\n\nnumber of characters printed or negative value on error"]
    pub fn furi_string_cat_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Compare two strings and return the sort order.\n\n # Arguments\n\n* `string_1` - The string 1\n * `string_2` - The string 2\n\n # Returns\n\nzero if equal"]
    pub fn furi_string_cmp(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Compare string with C string and return the sort order.\n\n # Arguments\n\n* `string_1` - The string 1\n * `cstring_2` - The cstring 2\n\n # Returns\n\nzero if equal"]
    pub fn furi_string_cmp_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Compare two strings (case insensitive according to the current locale) and\n return the sort order.\n\n Note: doesn't work with UTF-8 strings.\n\n # Arguments\n\n* `string_1` - The string 1\n * `string_2` - The string 2\n\n # Returns\n\nzero if equal"]
    pub fn furi_string_cmpi(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Compare string with C string (case insensitive according to the current\n locale) and return the sort order.\n\n Note: doesn't work with UTF-8 strings.\n\n # Arguments\n\n* `string_1` - The string 1\n * `cstring_2` - The cstring 2\n\n # Returns\n\nzero if equal"]
    pub fn furi_string_cmpi_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = "Search the first occurrence of the needle in the string from the position\n start.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `needle` - The needle\n * `start` - The start (By default, start is zero)\n\n # Returns\n\nposition or FURI_STRING_FAILURE if not found"]
    pub fn furi_string_search(
        string: *const FuriString,
        needle: *const FuriString,
        start: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Search the first occurrence of the needle in the string from the position\n start.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `needle` - The needle\n * `start` - The start (By default, start is zero)\n\n # Returns\n\nposition or FURI_STRING_FAILURE if not found"]
    pub fn furi_string_search_str(
        string: *const FuriString,
        needle: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Search for the position of the character c from the position start (include)\n in the string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `c` - The character\n * `start` - The start (By default, start is zero)\n\n # Returns\n\nposition or FURI_STRING_FAILURE if not found"]
    pub fn furi_string_search_char(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Reverse search for the position of the character c from the position start\n (include) in the string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `c` - The character\n * `start` - The start (By default, start is zero)\n\n # Returns\n\nposition or FURI_STRING_FAILURE if not found"]
    pub fn furi_string_search_rchar(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Test if two strings are equal.\n\n # Arguments\n\n* `string_1` - The string 1\n * `string_2` - The string 2\n\n # Returns\n\ntrue if equal false otherwise"]
    pub fn furi_string_equal(string_1: *const FuriString, string_2: *const FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Test if the string is equal to the C string.\n\n # Arguments\n\n* `string_1` - The string 1\n * `cstring_2` - The cstring 2\n\n # Returns\n\ntrue if equal false otherwise"]
    pub fn furi_string_equal_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Replace in the string the sub-string at position 'pos' for 'len' bytes into\n the C string 'replace'.\n\n # Arguments\n\n* `string` - The string\n * `pos` - The position\n * `len` - The length\n * `replace` - The replace"]
    pub fn furi_string_replace_at(
        string: *mut FuriString,
        pos: usize,
        len: usize,
        replace: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Replace a string 'needle' to string 'replace' in a string from 'start'\n position.\n\n # Arguments\n\n* `string` - The string\n * `needle` - The needle\n * `replace` - The replace\n * `start` - The start (By default, start is zero)\n\n # Returns\n\nReturn FURI_STRING_FAILURE if 'needle' not found or replace position."]
    pub fn furi_string_replace(
        string: *mut FuriString,
        needle: *mut FuriString,
        replace: *mut FuriString,
        start: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Replace a C string 'needle' to C string 'replace' in a string from 'start'\n position.\n\n # Arguments\n\n* `string` - The string\n * `needle` - The needle\n * `replace` - The replace\n * `start` - The start (By default, start is zero)\n\n # Returns\n\nReturn FURI_STRING_FAILURE if 'needle' not found or replace position."]
    pub fn furi_string_replace_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Replace all occurrences of 'needle' string into 'replace' string.\n\n # Arguments\n\n* `string` - The string\n * `needle` - The needle\n * `replace` - The replace"]
    pub fn furi_string_replace_all(
        string: *mut FuriString,
        needle: *const FuriString,
        replace: *const FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Replace all occurrences of 'needle' C string into 'replace' C string.\n\n # Arguments\n\n* `string` - The string\n * `needle` - The needle\n * `replace` - The replace"]
    pub fn furi_string_replace_all_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Test if the string starts with the given string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `start` - The FuriString instance\n\n # Returns\n\ntrue if string starts with"]
    pub fn furi_string_start_with(string: *const FuriString, start: *const FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Test if the string starts with the given C string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `start` - The start\n\n # Returns\n\ntrue if string starts with"]
    pub fn furi_string_start_with_str(
        string: *const FuriString,
        start: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Test if the string ends with the given string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `end` - The end\n\n # Returns\n\ntrue if string ends with"]
    pub fn furi_string_end_with(string: *const FuriString, end: *const FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Test if the string ends with the given string (case insensitive according to the current locale).\n\n # Arguments\n\n* `string` - The FuriString instance\n * `end` - The end\n\n # Returns\n\ntrue if string ends with"]
    pub fn furi_string_end_withi(string: *const FuriString, end: *const FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Test if the string ends with the given C string.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `end` - The end\n\n # Returns\n\ntrue if string ends with"]
    pub fn furi_string_end_with_str(
        string: *const FuriString,
        end: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Test if the string ends with the given C string (case insensitive according to the current locale).\n\n # Arguments\n\n* `string` - The FuriString instance\n * `end` - The end\n\n # Returns\n\ntrue if string ends with"]
    pub fn furi_string_end_withi_str(
        string: *const FuriString,
        end: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Trim the string left to the first 'index' bytes.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `index` - The index"]
    pub fn furi_string_left(string: *mut FuriString, index: usize);
}
unsafe extern "C" {
    #[doc = "Trim the string right from the 'index' position to the last position.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `index` - The index"]
    pub fn furi_string_right(string: *mut FuriString, index: usize);
}
unsafe extern "C" {
    #[doc = "Trim the string from position index to size bytes.\n\n See also furi_string_set_n.\n\n # Arguments\n\n* `string` - The FuriString instance\n * `index` - The index\n * `size` - The size"]
    pub fn furi_string_mid(string: *mut FuriString, index: usize, size: usize);
}
unsafe extern "C" {
    #[doc = "Trim a string from the given set of characters (default is \" # Arguments\n\n* `string` - The FuriString instance\n * `chars` - The characters"]
    pub fn furi_string_trim(string: *mut FuriString, chars: *const core::ffi::c_char);
}
#[doc = "An unicode value"]
pub type FuriStringUnicodeValue = core::ffi::c_uint;
unsafe extern "C" {
    #[doc = "Compute the length in UTF8 characters in the string.\n\n # Arguments\n\n* `string` - The FuriString instance\n\n # Returns\n\nstrings size"]
    pub fn furi_string_utf8_length(string: *mut FuriString) -> usize;
}
unsafe extern "C" {
    #[doc = "Push unicode into string, encoding it in UTF8.\n\n # Arguments\n\n* `string` - The string\n * `unicode` - The unicode"]
    pub fn furi_string_utf8_push(string: *mut FuriString, unicode: FuriStringUnicodeValue);
}
pub const FuriStringUTF8StateStarting: FuriStringUTF8State = FuriStringUTF8State(0);
pub const FuriStringUTF8StateDecoding1: FuriStringUTF8State = FuriStringUTF8State(1);
pub const FuriStringUTF8StateDecoding2: FuriStringUTF8State = FuriStringUTF8State(2);
pub const FuriStringUTF8StateDecoding3: FuriStringUTF8State = FuriStringUTF8State(3);
pub const FuriStringUTF8StateError: FuriStringUTF8State = FuriStringUTF8State(4);
#[repr(transparent)]
#[doc = "State of the UTF8 decoding machine state"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriStringUTF8State(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Main generic UTF8 decoder\n\n It takes a character, and the previous state and the previous value of the\n unicode value. It updates the state and the decoded unicode value. A decoded\n unicode encoded value is valid only when the state is\n FuriStringUTF8StateStarting.\n\n # Arguments\n\n* `c` - The character\n * `state` - The state\n * `unicode` - The unicode"]
    pub fn furi_string_utf8_decode(
        c: core::ffi::c_char,
        state: *mut FuriStringUTF8State,
        unicode: *mut FuriStringUnicodeValue,
    );
}
unsafe extern "C" {
    #[doc = "Allocate stream buffer instance.\n Stream buffer implementation assumes there is only one task or\n interrupt that will write to the buffer (the writer), and only one task or\n interrupt that will read from the buffer (the reader).\n\n # Arguments\n\n* `size` - The total number of bytes the stream buffer will be able to hold at any one time.\n * `trigger_level` - The number of bytes that must be in the stream buffer\n before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state.\n # Returns\n\nThe stream buffer instance."]
    pub fn furi_stream_buffer_alloc(size: usize, trigger_level: usize) -> *mut FuriStreamBuffer;
}
unsafe extern "C" {
    #[doc = "Free stream buffer instance\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance."]
    pub fn furi_stream_buffer_free(stream_buffer: *mut FuriStreamBuffer);
}
unsafe extern "C" {
    #[doc = "Set trigger level for stream buffer.\n A stream buffer's trigger level is the number of bytes that must be in the\n stream buffer before a task that is blocked on the stream buffer to\n wait for data is moved out of the blocked state.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance\n * `trigger_level` - The new trigger level for the stream buffer.\n # Returns\n\ntrue if trigger level can be be updated (new trigger level was less than or equal to the stream buffer's length).\n false if trigger level can't be be updated (new trigger level was greater than the stream buffer's length)."]
    pub fn furi_stream_set_trigger_level(
        stream_buffer: *mut FuriStreamBuffer,
        trigger_level: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get trigger level for stream buffer.\n A stream buffer's trigger level is the number of bytes that must be in the\n stream buffer before a task that is blocked on the stream buffer to\n wait for data is moved out of the blocked state.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance\n # Returns\n\nThe trigger level for the stream buffer"]
    pub fn furi_stream_get_trigger_level(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
unsafe extern "C" {
    #[doc = "Sends bytes to a stream buffer. The bytes are copied into the stream buffer.\n Wakes up task waiting for data to become available if called from ISR.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance.\n * `data` - A pointer to the data that is to be copied into the stream buffer.\n * `length` - The maximum number of bytes to copy from data into the stream buffer.\n * `timeout` - The maximum amount of time the task should remain in the\n Blocked state to wait for space to become available if the stream buffer is full.\n Will return immediately if timeout is zero.\n Setting timeout to FuriWaitForever will cause the task to wait indefinitely.\n Ignored if called from ISR.\n # Returns\n\nThe number of bytes actually written to the stream buffer."]
    pub fn furi_stream_buffer_send(
        stream_buffer: *mut FuriStreamBuffer,
        data: *const core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Receives bytes from a stream buffer.\n Wakes up task waiting for space to become available if called from ISR.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance.\n * `data` - A pointer to the buffer into which the received bytes will be\n copied.\n * `length` - The length of the buffer pointed to by the data parameter.\n * `timeout` - The maximum amount of time the task should remain in the\n Blocked state to wait for data to become available if the stream buffer is empty.\n Will return immediately if timeout is zero.\n Setting timeout to FuriWaitForever will cause the task to wait indefinitely.\n Ignored if called from ISR.\n # Returns\n\nThe number of bytes read from the stream buffer, if any."]
    pub fn furi_stream_buffer_receive(
        stream_buffer: *mut FuriStreamBuffer,
        data: *mut core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Queries a stream buffer to see how much data it contains, which is equal to\n the number of bytes that can be read from the stream buffer before the stream\n buffer would be empty.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance.\n # Returns\n\nThe number of bytes that can be read from the stream buffer before\n the stream buffer would be empty."]
    pub fn furi_stream_buffer_bytes_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
unsafe extern "C" {
    #[doc = "Queries a stream buffer to see how much free space it contains, which is\n equal to the amount of data that can be sent to the stream buffer before it\n is full.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance.\n # Returns\n\nThe number of bytes that can be written to the stream buffer before\n the stream buffer would be full."]
    pub fn furi_stream_buffer_spaces_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
unsafe extern "C" {
    #[doc = "Queries a stream buffer to see if it is full.\n\n # Arguments\n\n* `stream_buffer` - stream buffer instance.\n # Returns\n\ntrue if the stream buffer is full.\n false if the stream buffer is not full."]
    pub fn furi_stream_buffer_is_full(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
unsafe extern "C" {
    #[doc = "Queries a stream buffer to see if it is empty.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance.\n # Returns\n\ntrue if the stream buffer is empty.\n false if the stream buffer is not empty."]
    pub fn furi_stream_buffer_is_empty(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
unsafe extern "C" {
    #[doc = "Resets a stream buffer to its initial, empty, state. Any data that was\n in the stream buffer is discarded. A stream buffer can only be reset if there\n are no tasks blocked waiting to either send to or receive from the stream buffer.\n\n # Arguments\n\n* `stream_buffer` - The stream buffer instance.\n # Returns\n\nFuriStatusOk if the stream buffer is reset.\n FuriStatusError if there was a task blocked waiting to send to or read\n from the stream buffer then the stream buffer is not reset."]
    pub fn furi_stream_buffer_reset(stream_buffer: *mut FuriStreamBuffer) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "< System Clock Frequency"]
    pub static mut SystemCoreClock: u32;
}
#[doc = "Comparator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_TypeDef {
    #[doc = "< COMP control and status register, Address offset: 0x00"]
    pub CSR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of COMP_TypeDef"][::core::mem::size_of::<COMP_TypeDef>() - 4usize];
    ["Alignment of COMP_TypeDef"][::core::mem::align_of::<COMP_TypeDef>() - 4usize];
    ["Offset of field: COMP_TypeDef::CSR"][::core::mem::offset_of!(COMP_TypeDef, CSR) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "< DMA interrupt status register, Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< DMA interrupt flag clear register, Address offset: 0x04"]
    pub IFCR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DMA_TypeDef"][::core::mem::size_of::<DMA_TypeDef>() - 8usize];
    ["Alignment of DMA_TypeDef"][::core::mem::align_of::<DMA_TypeDef>() - 4usize];
    ["Offset of field: DMA_TypeDef::ISR"][::core::mem::offset_of!(DMA_TypeDef, ISR) - 0usize];
    ["Offset of field: DMA_TypeDef::IFCR"][::core::mem::offset_of!(DMA_TypeDef, IFCR) - 4usize];
};
#[doc = "General Purpose I/O"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_TypeDef {
    #[doc = "< GPIO port mode register, Address offset: 0x00"]
    pub MODER: u32,
    #[doc = "< GPIO port output type register, Address offset: 0x04"]
    pub OTYPER: u32,
    #[doc = "< GPIO port output speed register, Address offset: 0x08"]
    pub OSPEEDR: u32,
    #[doc = "< GPIO port pull-up/pull-down register, Address offset: 0x0C"]
    pub PUPDR: u32,
    #[doc = "< GPIO port input data register, Address offset: 0x10"]
    pub IDR: u32,
    #[doc = "< GPIO port output data register, Address offset: 0x14"]
    pub ODR: u32,
    #[doc = "< GPIO port bit set/reset register, Address offset: 0x18"]
    pub BSRR: u32,
    #[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
    pub LCKR: u32,
    #[doc = "< GPIO alternate function registers, Address offset: 0x20-0x24"]
    pub AFR: [u32; 2usize],
    #[doc = "< GPIO Bit Reset register, Address offset: 0x28"]
    pub BRR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GPIO_TypeDef"][::core::mem::size_of::<GPIO_TypeDef>() - 44usize];
    ["Alignment of GPIO_TypeDef"][::core::mem::align_of::<GPIO_TypeDef>() - 4usize];
    ["Offset of field: GPIO_TypeDef::MODER"][::core::mem::offset_of!(GPIO_TypeDef, MODER) - 0usize];
    ["Offset of field: GPIO_TypeDef::OTYPER"]
        [::core::mem::offset_of!(GPIO_TypeDef, OTYPER) - 4usize];
    ["Offset of field: GPIO_TypeDef::OSPEEDR"]
        [::core::mem::offset_of!(GPIO_TypeDef, OSPEEDR) - 8usize];
    ["Offset of field: GPIO_TypeDef::PUPDR"]
        [::core::mem::offset_of!(GPIO_TypeDef, PUPDR) - 12usize];
    ["Offset of field: GPIO_TypeDef::IDR"][::core::mem::offset_of!(GPIO_TypeDef, IDR) - 16usize];
    ["Offset of field: GPIO_TypeDef::ODR"][::core::mem::offset_of!(GPIO_TypeDef, ODR) - 20usize];
    ["Offset of field: GPIO_TypeDef::BSRR"][::core::mem::offset_of!(GPIO_TypeDef, BSRR) - 24usize];
    ["Offset of field: GPIO_TypeDef::LCKR"][::core::mem::offset_of!(GPIO_TypeDef, LCKR) - 28usize];
    ["Offset of field: GPIO_TypeDef::AFR"][::core::mem::offset_of!(GPIO_TypeDef, AFR) - 32usize];
    ["Offset of field: GPIO_TypeDef::BRR"][::core::mem::offset_of!(GPIO_TypeDef, BRR) - 40usize];
};
#[doc = "Inter-integrated Circuit Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_TypeDef {
    #[doc = "< I2C Control register 1, Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< I2C Control register 2, Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< I2C Own address 1 register, Address offset: 0x08"]
    pub OAR1: u32,
    #[doc = "< I2C Own address 2 register, Address offset: 0x0C"]
    pub OAR2: u32,
    #[doc = "< I2C Timing register, Address offset: 0x10"]
    pub TIMINGR: u32,
    #[doc = "< I2C Timeout register, Address offset: 0x14"]
    pub TIMEOUTR: u32,
    #[doc = "< I2C Interrupt and status register, Address offset: 0x18"]
    pub ISR: u32,
    #[doc = "< I2C Interrupt clear register, Address offset: 0x1C"]
    pub ICR: u32,
    #[doc = "< I2C PEC register, Address offset: 0x20"]
    pub PECR: u32,
    #[doc = "< I2C Receive data register, Address offset: 0x24"]
    pub RXDR: u32,
    #[doc = "< I2C Transmit data register, Address offset: 0x28"]
    pub TXDR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of I2C_TypeDef"][::core::mem::size_of::<I2C_TypeDef>() - 44usize];
    ["Alignment of I2C_TypeDef"][::core::mem::align_of::<I2C_TypeDef>() - 4usize];
    ["Offset of field: I2C_TypeDef::CR1"][::core::mem::offset_of!(I2C_TypeDef, CR1) - 0usize];
    ["Offset of field: I2C_TypeDef::CR2"][::core::mem::offset_of!(I2C_TypeDef, CR2) - 4usize];
    ["Offset of field: I2C_TypeDef::OAR1"][::core::mem::offset_of!(I2C_TypeDef, OAR1) - 8usize];
    ["Offset of field: I2C_TypeDef::OAR2"][::core::mem::offset_of!(I2C_TypeDef, OAR2) - 12usize];
    ["Offset of field: I2C_TypeDef::TIMINGR"]
        [::core::mem::offset_of!(I2C_TypeDef, TIMINGR) - 16usize];
    ["Offset of field: I2C_TypeDef::TIMEOUTR"]
        [::core::mem::offset_of!(I2C_TypeDef, TIMEOUTR) - 20usize];
    ["Offset of field: I2C_TypeDef::ISR"][::core::mem::offset_of!(I2C_TypeDef, ISR) - 24usize];
    ["Offset of field: I2C_TypeDef::ICR"][::core::mem::offset_of!(I2C_TypeDef, ICR) - 28usize];
    ["Offset of field: I2C_TypeDef::PECR"][::core::mem::offset_of!(I2C_TypeDef, PECR) - 32usize];
    ["Offset of field: I2C_TypeDef::RXDR"][::core::mem::offset_of!(I2C_TypeDef, RXDR) - 36usize];
    ["Offset of field: I2C_TypeDef::TXDR"][::core::mem::offset_of!(I2C_TypeDef, TXDR) - 40usize];
};
#[doc = "LPTIMER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_TypeDef {
    #[doc = "< LPTIM Interrupt and Status register, Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< LPTIM Interrupt Clear register, Address offset: 0x04"]
    pub ICR: u32,
    #[doc = "< LPTIM Interrupt Enable register, Address offset: 0x08"]
    pub IER: u32,
    #[doc = "< LPTIM Configuration register, Address offset: 0x0C"]
    pub CFGR: u32,
    #[doc = "< LPTIM Control register, Address offset: 0x10"]
    pub CR: u32,
    #[doc = "< LPTIM Compare register, Address offset: 0x14"]
    pub CMP: u32,
    #[doc = "< LPTIM Autoreload register, Address offset: 0x18"]
    pub ARR: u32,
    #[doc = "< LPTIM Counter register, Address offset: 0x1C"]
    pub CNT: u32,
    #[doc = "< LPTIM Option register, Address offset: 0x20"]
    pub OR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LPTIM_TypeDef"][::core::mem::size_of::<LPTIM_TypeDef>() - 36usize];
    ["Alignment of LPTIM_TypeDef"][::core::mem::align_of::<LPTIM_TypeDef>() - 4usize];
    ["Offset of field: LPTIM_TypeDef::ISR"][::core::mem::offset_of!(LPTIM_TypeDef, ISR) - 0usize];
    ["Offset of field: LPTIM_TypeDef::ICR"][::core::mem::offset_of!(LPTIM_TypeDef, ICR) - 4usize];
    ["Offset of field: LPTIM_TypeDef::IER"][::core::mem::offset_of!(LPTIM_TypeDef, IER) - 8usize];
    ["Offset of field: LPTIM_TypeDef::CFGR"]
        [::core::mem::offset_of!(LPTIM_TypeDef, CFGR) - 12usize];
    ["Offset of field: LPTIM_TypeDef::CR"][::core::mem::offset_of!(LPTIM_TypeDef, CR) - 16usize];
    ["Offset of field: LPTIM_TypeDef::CMP"][::core::mem::offset_of!(LPTIM_TypeDef, CMP) - 20usize];
    ["Offset of field: LPTIM_TypeDef::ARR"][::core::mem::offset_of!(LPTIM_TypeDef, ARR) - 24usize];
    ["Offset of field: LPTIM_TypeDef::CNT"][::core::mem::offset_of!(LPTIM_TypeDef, CNT) - 28usize];
    ["Offset of field: LPTIM_TypeDef::OR"][::core::mem::offset_of!(LPTIM_TypeDef, OR) - 32usize];
};
#[doc = "Real-Time Clock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TypeDef {
    #[doc = "< RTC time register, Address offset: 0x00"]
    pub TR: u32,
    #[doc = "< RTC date register, Address offset: 0x04"]
    pub DR: u32,
    #[doc = "< RTC control register, Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< RTC initialization and status register, Address offset: 0x0C"]
    pub ISR: u32,
    #[doc = "< RTC prescaler register, Address offset: 0x10"]
    pub PRER: u32,
    #[doc = "< RTC wakeup timer register, Address offset: 0x14"]
    pub WUTR: u32,
    #[doc = "< Reserved, Address offset: 0x18"]
    pub RESERVED: u32,
    #[doc = "< RTC alarm A register, Address offset: 0x1C"]
    pub ALRMAR: u32,
    #[doc = "< RTC alarm B register, Address offset: 0x20"]
    pub ALRMBR: u32,
    #[doc = "< RTC write protection register, Address offset: 0x24"]
    pub WPR: u32,
    #[doc = "< RTC sub second register, Address offset: 0x28"]
    pub SSR: u32,
    #[doc = "< RTC shift control register, Address offset: 0x2C"]
    pub SHIFTR: u32,
    #[doc = "< RTC time stamp time register, Address offset: 0x30"]
    pub TSTR: u32,
    #[doc = "< RTC time stamp date register, Address offset: 0x34"]
    pub TSDR: u32,
    #[doc = "< RTC time-stamp sub second register, Address offset: 0x38"]
    pub TSSSR: u32,
    #[doc = "< RTC calibration register, Address offset: 0x3C"]
    pub CALR: u32,
    #[doc = "< RTC tamper configuration register, Address offset: 0x40"]
    pub TAMPCR: u32,
    #[doc = "< RTC alarm A sub second register, Address offset: 0x44"]
    pub ALRMASSR: u32,
    #[doc = "< RTC alarm B sub second register, Address offset: 0x48"]
    pub ALRMBSSR: u32,
    #[doc = "< RTC option register, Address offset 0x4C"]
    pub OR: u32,
    #[doc = "< RTC backup register 0, Address offset: 0x50"]
    pub BKP0R: u32,
    #[doc = "< RTC backup register 1, Address offset: 0x54"]
    pub BKP1R: u32,
    #[doc = "< RTC backup register 2, Address offset: 0x58"]
    pub BKP2R: u32,
    #[doc = "< RTC backup register 3, Address offset: 0x5C"]
    pub BKP3R: u32,
    #[doc = "< RTC backup register 4, Address offset: 0x60"]
    pub BKP4R: u32,
    #[doc = "< RTC backup register 5, Address offset: 0x64"]
    pub BKP5R: u32,
    #[doc = "< RTC backup register 6, Address offset: 0x68"]
    pub BKP6R: u32,
    #[doc = "< RTC backup register 7, Address offset: 0x6C"]
    pub BKP7R: u32,
    #[doc = "< RTC backup register 8, Address offset: 0x70"]
    pub BKP8R: u32,
    #[doc = "< RTC backup register 9, Address offset: 0x74"]
    pub BKP9R: u32,
    #[doc = "< RTC backup register 10, Address offset: 0x78"]
    pub BKP10R: u32,
    #[doc = "< RTC backup register 11, Address offset: 0x7C"]
    pub BKP11R: u32,
    #[doc = "< RTC backup register 12, Address offset: 0x80"]
    pub BKP12R: u32,
    #[doc = "< RTC backup register 13, Address offset: 0x84"]
    pub BKP13R: u32,
    #[doc = "< RTC backup register 14, Address offset: 0x88"]
    pub BKP14R: u32,
    #[doc = "< RTC backup register 15, Address offset: 0x8C"]
    pub BKP15R: u32,
    #[doc = "< RTC backup register 16, Address offset: 0x90"]
    pub BKP16R: u32,
    #[doc = "< RTC backup register 17, Address offset: 0x94"]
    pub BKP17R: u32,
    #[doc = "< RTC backup register 18, Address offset: 0x98"]
    pub BKP18R: u32,
    #[doc = "< RTC backup register 19, Address offset: 0x9C"]
    pub BKP19R: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RTC_TypeDef"][::core::mem::size_of::<RTC_TypeDef>() - 160usize];
    ["Alignment of RTC_TypeDef"][::core::mem::align_of::<RTC_TypeDef>() - 4usize];
    ["Offset of field: RTC_TypeDef::TR"][::core::mem::offset_of!(RTC_TypeDef, TR) - 0usize];
    ["Offset of field: RTC_TypeDef::DR"][::core::mem::offset_of!(RTC_TypeDef, DR) - 4usize];
    ["Offset of field: RTC_TypeDef::CR"][::core::mem::offset_of!(RTC_TypeDef, CR) - 8usize];
    ["Offset of field: RTC_TypeDef::ISR"][::core::mem::offset_of!(RTC_TypeDef, ISR) - 12usize];
    ["Offset of field: RTC_TypeDef::PRER"][::core::mem::offset_of!(RTC_TypeDef, PRER) - 16usize];
    ["Offset of field: RTC_TypeDef::WUTR"][::core::mem::offset_of!(RTC_TypeDef, WUTR) - 20usize];
    ["Offset of field: RTC_TypeDef::RESERVED"]
        [::core::mem::offset_of!(RTC_TypeDef, RESERVED) - 24usize];
    ["Offset of field: RTC_TypeDef::ALRMAR"]
        [::core::mem::offset_of!(RTC_TypeDef, ALRMAR) - 28usize];
    ["Offset of field: RTC_TypeDef::ALRMBR"]
        [::core::mem::offset_of!(RTC_TypeDef, ALRMBR) - 32usize];
    ["Offset of field: RTC_TypeDef::WPR"][::core::mem::offset_of!(RTC_TypeDef, WPR) - 36usize];
    ["Offset of field: RTC_TypeDef::SSR"][::core::mem::offset_of!(RTC_TypeDef, SSR) - 40usize];
    ["Offset of field: RTC_TypeDef::SHIFTR"]
        [::core::mem::offset_of!(RTC_TypeDef, SHIFTR) - 44usize];
    ["Offset of field: RTC_TypeDef::TSTR"][::core::mem::offset_of!(RTC_TypeDef, TSTR) - 48usize];
    ["Offset of field: RTC_TypeDef::TSDR"][::core::mem::offset_of!(RTC_TypeDef, TSDR) - 52usize];
    ["Offset of field: RTC_TypeDef::TSSSR"][::core::mem::offset_of!(RTC_TypeDef, TSSSR) - 56usize];
    ["Offset of field: RTC_TypeDef::CALR"][::core::mem::offset_of!(RTC_TypeDef, CALR) - 60usize];
    ["Offset of field: RTC_TypeDef::TAMPCR"]
        [::core::mem::offset_of!(RTC_TypeDef, TAMPCR) - 64usize];
    ["Offset of field: RTC_TypeDef::ALRMASSR"]
        [::core::mem::offset_of!(RTC_TypeDef, ALRMASSR) - 68usize];
    ["Offset of field: RTC_TypeDef::ALRMBSSR"]
        [::core::mem::offset_of!(RTC_TypeDef, ALRMBSSR) - 72usize];
    ["Offset of field: RTC_TypeDef::OR"][::core::mem::offset_of!(RTC_TypeDef, OR) - 76usize];
    ["Offset of field: RTC_TypeDef::BKP0R"][::core::mem::offset_of!(RTC_TypeDef, BKP0R) - 80usize];
    ["Offset of field: RTC_TypeDef::BKP1R"][::core::mem::offset_of!(RTC_TypeDef, BKP1R) - 84usize];
    ["Offset of field: RTC_TypeDef::BKP2R"][::core::mem::offset_of!(RTC_TypeDef, BKP2R) - 88usize];
    ["Offset of field: RTC_TypeDef::BKP3R"][::core::mem::offset_of!(RTC_TypeDef, BKP3R) - 92usize];
    ["Offset of field: RTC_TypeDef::BKP4R"][::core::mem::offset_of!(RTC_TypeDef, BKP4R) - 96usize];
    ["Offset of field: RTC_TypeDef::BKP5R"][::core::mem::offset_of!(RTC_TypeDef, BKP5R) - 100usize];
    ["Offset of field: RTC_TypeDef::BKP6R"][::core::mem::offset_of!(RTC_TypeDef, BKP6R) - 104usize];
    ["Offset of field: RTC_TypeDef::BKP7R"][::core::mem::offset_of!(RTC_TypeDef, BKP7R) - 108usize];
    ["Offset of field: RTC_TypeDef::BKP8R"][::core::mem::offset_of!(RTC_TypeDef, BKP8R) - 112usize];
    ["Offset of field: RTC_TypeDef::BKP9R"][::core::mem::offset_of!(RTC_TypeDef, BKP9R) - 116usize];
    ["Offset of field: RTC_TypeDef::BKP10R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP10R) - 120usize];
    ["Offset of field: RTC_TypeDef::BKP11R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP11R) - 124usize];
    ["Offset of field: RTC_TypeDef::BKP12R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP12R) - 128usize];
    ["Offset of field: RTC_TypeDef::BKP13R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP13R) - 132usize];
    ["Offset of field: RTC_TypeDef::BKP14R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP14R) - 136usize];
    ["Offset of field: RTC_TypeDef::BKP15R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP15R) - 140usize];
    ["Offset of field: RTC_TypeDef::BKP16R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP16R) - 144usize];
    ["Offset of field: RTC_TypeDef::BKP17R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP17R) - 148usize];
    ["Offset of field: RTC_TypeDef::BKP18R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP18R) - 152usize];
    ["Offset of field: RTC_TypeDef::BKP19R"]
        [::core::mem::offset_of!(RTC_TypeDef, BKP19R) - 156usize];
};
#[doc = "Serial Peripheral Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_TypeDef {
    #[doc = "< SPI Control register 1, Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< SPI Control register 2, Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< SPI Status register, Address offset: 0x08"]
    pub SR: u32,
    #[doc = "< SPI data register, Address offset: 0x0C"]
    pub DR: u32,
    #[doc = "< SPI CRC polynomial register, Address offset: 0x10"]
    pub CRCPR: u32,
    #[doc = "< SPI Rx CRC register, Address offset: 0x14"]
    pub RXCRCR: u32,
    #[doc = "< SPI Tx CRC register, Address offset: 0x18"]
    pub TXCRCR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SPI_TypeDef"][::core::mem::size_of::<SPI_TypeDef>() - 28usize];
    ["Alignment of SPI_TypeDef"][::core::mem::align_of::<SPI_TypeDef>() - 4usize];
    ["Offset of field: SPI_TypeDef::CR1"][::core::mem::offset_of!(SPI_TypeDef, CR1) - 0usize];
    ["Offset of field: SPI_TypeDef::CR2"][::core::mem::offset_of!(SPI_TypeDef, CR2) - 4usize];
    ["Offset of field: SPI_TypeDef::SR"][::core::mem::offset_of!(SPI_TypeDef, SR) - 8usize];
    ["Offset of field: SPI_TypeDef::DR"][::core::mem::offset_of!(SPI_TypeDef, DR) - 12usize];
    ["Offset of field: SPI_TypeDef::CRCPR"][::core::mem::offset_of!(SPI_TypeDef, CRCPR) - 16usize];
    ["Offset of field: SPI_TypeDef::RXCRCR"]
        [::core::mem::offset_of!(SPI_TypeDef, RXCRCR) - 20usize];
    ["Offset of field: SPI_TypeDef::TXCRCR"]
        [::core::mem::offset_of!(SPI_TypeDef, TXCRCR) - 24usize];
};
#[doc = "TIM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_TypeDef {
    #[doc = "< TIM control register 1, Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< TIM control register 2, Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< TIM slave mode control register, Address offset: 0x08"]
    pub SMCR: u32,
    #[doc = "< TIM DMA/interrupt enable register, Address offset: 0x0C"]
    pub DIER: u32,
    #[doc = "< TIM status register, Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< TIM event generation register, Address offset: 0x14"]
    pub EGR: u32,
    #[doc = "< TIM capture/compare mode register 1, Address offset: 0x18"]
    pub CCMR1: u32,
    #[doc = "< TIM capture/compare mode register 2, Address offset: 0x1C"]
    pub CCMR2: u32,
    #[doc = "< TIM capture/compare enable register, Address offset: 0x20"]
    pub CCER: u32,
    #[doc = "< TIM counter register, Address offset: 0x24"]
    pub CNT: u32,
    #[doc = "< TIM prescaler register, Address offset: 0x28"]
    pub PSC: u32,
    #[doc = "< TIM auto-reload register, Address offset: 0x2C"]
    pub ARR: u32,
    #[doc = "< TIM repetition counter register, Address offset: 0x30"]
    pub RCR: u32,
    #[doc = "< TIM capture/compare register 1, Address offset: 0x34"]
    pub CCR1: u32,
    #[doc = "< TIM capture/compare register 2, Address offset: 0x38"]
    pub CCR2: u32,
    #[doc = "< TIM capture/compare register 3, Address offset: 0x3C"]
    pub CCR3: u32,
    #[doc = "< TIM capture/compare register 4, Address offset: 0x40"]
    pub CCR4: u32,
    #[doc = "< TIM break and dead-time register, Address offset: 0x44"]
    pub BDTR: u32,
    #[doc = "< TIM DMA control register, Address offset: 0x48"]
    pub DCR: u32,
    #[doc = "< TIM DMA address for full transfer, Address offset: 0x4C"]
    pub DMAR: u32,
    #[doc = "< TIM option register Address offset: 0x50"]
    pub OR: u32,
    #[doc = "< TIM capture/compare mode register 3, Address offset: 0x54"]
    pub CCMR3: u32,
    #[doc = "< TIM capture/compare register5, Address offset: 0x58"]
    pub CCR5: u32,
    #[doc = "< TIM capture/compare register6, Address offset: 0x5C"]
    pub CCR6: u32,
    #[doc = "< TIM Alternate function option register 1, Address offset: 0x60"]
    pub AF1: u32,
    #[doc = "< TIM Alternate function option register 2, Address offset: 0x64"]
    pub AF2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of TIM_TypeDef"][::core::mem::size_of::<TIM_TypeDef>() - 104usize];
    ["Alignment of TIM_TypeDef"][::core::mem::align_of::<TIM_TypeDef>() - 4usize];
    ["Offset of field: TIM_TypeDef::CR1"][::core::mem::offset_of!(TIM_TypeDef, CR1) - 0usize];
    ["Offset of field: TIM_TypeDef::CR2"][::core::mem::offset_of!(TIM_TypeDef, CR2) - 4usize];
    ["Offset of field: TIM_TypeDef::SMCR"][::core::mem::offset_of!(TIM_TypeDef, SMCR) - 8usize];
    ["Offset of field: TIM_TypeDef::DIER"][::core::mem::offset_of!(TIM_TypeDef, DIER) - 12usize];
    ["Offset of field: TIM_TypeDef::SR"][::core::mem::offset_of!(TIM_TypeDef, SR) - 16usize];
    ["Offset of field: TIM_TypeDef::EGR"][::core::mem::offset_of!(TIM_TypeDef, EGR) - 20usize];
    ["Offset of field: TIM_TypeDef::CCMR1"][::core::mem::offset_of!(TIM_TypeDef, CCMR1) - 24usize];
    ["Offset of field: TIM_TypeDef::CCMR2"][::core::mem::offset_of!(TIM_TypeDef, CCMR2) - 28usize];
    ["Offset of field: TIM_TypeDef::CCER"][::core::mem::offset_of!(TIM_TypeDef, CCER) - 32usize];
    ["Offset of field: TIM_TypeDef::CNT"][::core::mem::offset_of!(TIM_TypeDef, CNT) - 36usize];
    ["Offset of field: TIM_TypeDef::PSC"][::core::mem::offset_of!(TIM_TypeDef, PSC) - 40usize];
    ["Offset of field: TIM_TypeDef::ARR"][::core::mem::offset_of!(TIM_TypeDef, ARR) - 44usize];
    ["Offset of field: TIM_TypeDef::RCR"][::core::mem::offset_of!(TIM_TypeDef, RCR) - 48usize];
    ["Offset of field: TIM_TypeDef::CCR1"][::core::mem::offset_of!(TIM_TypeDef, CCR1) - 52usize];
    ["Offset of field: TIM_TypeDef::CCR2"][::core::mem::offset_of!(TIM_TypeDef, CCR2) - 56usize];
    ["Offset of field: TIM_TypeDef::CCR3"][::core::mem::offset_of!(TIM_TypeDef, CCR3) - 60usize];
    ["Offset of field: TIM_TypeDef::CCR4"][::core::mem::offset_of!(TIM_TypeDef, CCR4) - 64usize];
    ["Offset of field: TIM_TypeDef::BDTR"][::core::mem::offset_of!(TIM_TypeDef, BDTR) - 68usize];
    ["Offset of field: TIM_TypeDef::DCR"][::core::mem::offset_of!(TIM_TypeDef, DCR) - 72usize];
    ["Offset of field: TIM_TypeDef::DMAR"][::core::mem::offset_of!(TIM_TypeDef, DMAR) - 76usize];
    ["Offset of field: TIM_TypeDef::OR"][::core::mem::offset_of!(TIM_TypeDef, OR) - 80usize];
    ["Offset of field: TIM_TypeDef::CCMR3"][::core::mem::offset_of!(TIM_TypeDef, CCMR3) - 84usize];
    ["Offset of field: TIM_TypeDef::CCR5"][::core::mem::offset_of!(TIM_TypeDef, CCR5) - 88usize];
    ["Offset of field: TIM_TypeDef::CCR6"][::core::mem::offset_of!(TIM_TypeDef, CCR6) - 92usize];
    ["Offset of field: TIM_TypeDef::AF1"][::core::mem::offset_of!(TIM_TypeDef, AF1) - 96usize];
    ["Offset of field: TIM_TypeDef::AF2"][::core::mem::offset_of!(TIM_TypeDef, AF2) - 100usize];
};
#[doc = "Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "< USART Control register 1, Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< USART Control register 2, Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< USART Control register 3, Address offset: 0x08"]
    pub CR3: u32,
    #[doc = "< USART Baud rate register, Address offset: 0x0C"]
    pub BRR: u32,
    #[doc = "< USART Guard time and prescaler register, Address offset: 0x10"]
    pub GTPR: u32,
    #[doc = "< USART Receiver Time Out register, Address offset: 0x14"]
    pub RTOR: u32,
    #[doc = "< USART Request register, Address offset: 0x18"]
    pub RQR: u32,
    #[doc = "< USART Interrupt and status register, Address offset: 0x1C"]
    pub ISR: u32,
    #[doc = "< USART Interrupt flag Clear register, Address offset: 0x20"]
    pub ICR: u32,
    #[doc = "< USART Receive Data register, Address offset: 0x24"]
    pub RDR: u32,
    #[doc = "< USART Transmit Data register, Address offset: 0x28"]
    pub TDR: u32,
    #[doc = "< USART Prescaler register, Address offset: 0x2C"]
    pub PRESC: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of USART_TypeDef"][::core::mem::size_of::<USART_TypeDef>() - 48usize];
    ["Alignment of USART_TypeDef"][::core::mem::align_of::<USART_TypeDef>() - 4usize];
    ["Offset of field: USART_TypeDef::CR1"][::core::mem::offset_of!(USART_TypeDef, CR1) - 0usize];
    ["Offset of field: USART_TypeDef::CR2"][::core::mem::offset_of!(USART_TypeDef, CR2) - 4usize];
    ["Offset of field: USART_TypeDef::CR3"][::core::mem::offset_of!(USART_TypeDef, CR3) - 8usize];
    ["Offset of field: USART_TypeDef::BRR"][::core::mem::offset_of!(USART_TypeDef, BRR) - 12usize];
    ["Offset of field: USART_TypeDef::GTPR"]
        [::core::mem::offset_of!(USART_TypeDef, GTPR) - 16usize];
    ["Offset of field: USART_TypeDef::RTOR"]
        [::core::mem::offset_of!(USART_TypeDef, RTOR) - 20usize];
    ["Offset of field: USART_TypeDef::RQR"][::core::mem::offset_of!(USART_TypeDef, RQR) - 24usize];
    ["Offset of field: USART_TypeDef::ISR"][::core::mem::offset_of!(USART_TypeDef, ISR) - 28usize];
    ["Offset of field: USART_TypeDef::ICR"][::core::mem::offset_of!(USART_TypeDef, ICR) - 32usize];
    ["Offset of field: USART_TypeDef::RDR"][::core::mem::offset_of!(USART_TypeDef, RDR) - 36usize];
    ["Offset of field: USART_TypeDef::TDR"][::core::mem::offset_of!(USART_TypeDef, TDR) - 40usize];
    ["Offset of field: USART_TypeDef::PRESC"]
        [::core::mem::offset_of!(USART_TypeDef, PRESC) - 44usize];
};
pub const SUCCESS: ErrorStatus = ErrorStatus(0);
pub const ERROR: ErrorStatus = ErrorStatus(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ErrorStatus(pub core::ffi::c_uchar);
#[doc = "LL GPIO Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_GPIO_InitTypeDef {
    #[doc = "< Specifies the GPIO pins to be configured.\nThis parameter can be any value of GPIO_LL_EC_PIN"]
    pub Pin: u32,
    #[doc = "< Specifies the operating mode for the selected pins.\nThis parameter can be a value of GPIO_LL_EC_MODE.\n\nGPIO HW configuration can be modified afterwards using unitary function LL_GPIO_SetPinMode()."]
    pub Mode: u32,
    #[doc = "< Specifies the speed for the selected pins.\nThis parameter can be a value of GPIO_LL_EC_SPEED.\n\nGPIO HW configuration can be modified afterwards using unitary function LL_GPIO_SetPinSpeed()."]
    pub Speed: u32,
    #[doc = "< Specifies the operating output type for the selected pins.\nThis parameter can be a value of GPIO_LL_EC_OUTPUT.\n\nGPIO HW configuration can be modified afterwards using unitary function LL_GPIO_SetPinOutputType()."]
    pub OutputType: u32,
    #[doc = "< Specifies the operating Pull-up/Pull down for the selected pins.\nThis parameter can be a value of GPIO_LL_EC_PULL.\n\nGPIO HW configuration can be modified afterwards using unitary function LL_GPIO_SetPinPull()."]
    pub Pull: u32,
    #[doc = "< Specifies the Peripheral to be connected to the selected pins.\nThis parameter can be a value of GPIO_LL_EC_AF.\n\nGPIO HW configuration can be modified afterwards using unitary function LL_GPIO_SetAFPin_0_7() and LL_GPIO_SetAFPin_8_15()."]
    pub Alternate: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_GPIO_InitTypeDef"][::core::mem::size_of::<LL_GPIO_InitTypeDef>() - 24usize];
    ["Alignment of LL_GPIO_InitTypeDef"][::core::mem::align_of::<LL_GPIO_InitTypeDef>() - 4usize];
    ["Offset of field: LL_GPIO_InitTypeDef::Pin"]
        [::core::mem::offset_of!(LL_GPIO_InitTypeDef, Pin) - 0usize];
    ["Offset of field: LL_GPIO_InitTypeDef::Mode"]
        [::core::mem::offset_of!(LL_GPIO_InitTypeDef, Mode) - 4usize];
    ["Offset of field: LL_GPIO_InitTypeDef::Speed"]
        [::core::mem::offset_of!(LL_GPIO_InitTypeDef, Speed) - 8usize];
    ["Offset of field: LL_GPIO_InitTypeDef::OutputType"]
        [::core::mem::offset_of!(LL_GPIO_InitTypeDef, OutputType) - 12usize];
    ["Offset of field: LL_GPIO_InitTypeDef::Pull"]
        [::core::mem::offset_of!(LL_GPIO_InitTypeDef, Pull) - 16usize];
    ["Offset of field: LL_GPIO_InitTypeDef::Alternate"]
        [::core::mem::offset_of!(LL_GPIO_InitTypeDef, Alternate) - 20usize];
};
unsafe extern "C" {
    pub fn LL_GPIO_Init(
        GPIOx: *mut GPIO_TypeDef,
        GPIO_InitStruct: *mut LL_GPIO_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "Interrupt callback prototype"]
pub type GpioExtiCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
#[doc = "Gpio interrupt type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioInterrupt {
    pub callback: GpioExtiCallback,
    pub context: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GpioInterrupt"][::core::mem::size_of::<GpioInterrupt>() - 8usize];
    ["Alignment of GpioInterrupt"][::core::mem::align_of::<GpioInterrupt>() - 4usize];
    ["Offset of field: GpioInterrupt::callback"]
        [::core::mem::offset_of!(GpioInterrupt, callback) - 0usize];
    ["Offset of field: GpioInterrupt::context"]
        [::core::mem::offset_of!(GpioInterrupt, context) - 4usize];
};
pub const GpioModeInput: GpioMode = GpioMode(0);
pub const GpioModeOutputPushPull: GpioMode = GpioMode(1);
pub const GpioModeOutputOpenDrain: GpioMode = GpioMode(2);
pub const GpioModeAltFunctionPushPull: GpioMode = GpioMode(3);
pub const GpioModeAltFunctionOpenDrain: GpioMode = GpioMode(4);
pub const GpioModeAnalog: GpioMode = GpioMode(5);
pub const GpioModeInterruptRise: GpioMode = GpioMode(6);
pub const GpioModeInterruptFall: GpioMode = GpioMode(7);
pub const GpioModeInterruptRiseFall: GpioMode = GpioMode(8);
pub const GpioModeEventRise: GpioMode = GpioMode(9);
pub const GpioModeEventFall: GpioMode = GpioMode(10);
pub const GpioModeEventRiseFall: GpioMode = GpioMode(11);
#[repr(transparent)]
#[doc = "Gpio modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GpioMode(pub core::ffi::c_uchar);
pub const GpioPullNo: GpioPull = GpioPull(0);
pub const GpioPullUp: GpioPull = GpioPull(1);
pub const GpioPullDown: GpioPull = GpioPull(2);
#[repr(transparent)]
#[doc = "Gpio pull modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GpioPull(pub core::ffi::c_uchar);
pub const GpioSpeedLow: GpioSpeed = GpioSpeed(0);
pub const GpioSpeedMedium: GpioSpeed = GpioSpeed(1);
pub const GpioSpeedHigh: GpioSpeed = GpioSpeed(2);
pub const GpioSpeedVeryHigh: GpioSpeed = GpioSpeed(3);
#[repr(transparent)]
#[doc = "Gpio speed modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GpioSpeed(pub core::ffi::c_uchar);
#[doc = "< MCO Alternate Function mapping"]
pub const GpioAltFn0MCO: GpioAltFn = GpioAltFn(0);
#[doc = "< LSCO Alternate Function mapping"]
pub const GpioAltFn0LSCO: GpioAltFn = GpioAltFn(0);
#[doc = "< JTMS-SWDIO Alternate Function mapping"]
pub const GpioAltFn0JTMS_SWDIO: GpioAltFn = GpioAltFn(0);
#[doc = "< JTCK-SWCLK Alternate Function mapping"]
pub const GpioAltFn0JTCK_SWCLK: GpioAltFn = GpioAltFn(0);
#[doc = "< JTDI Alternate Function mapping"]
pub const GpioAltFn0JTDI: GpioAltFn = GpioAltFn(0);
#[doc = "< RCT_OUT Alternate Function mapping"]
pub const GpioAltFn0RTC_OUT: GpioAltFn = GpioAltFn(0);
#[doc = "< JTDO-TRACESWO Alternate Function mapping"]
pub const GpioAltFn0JTD_TRACE: GpioAltFn = GpioAltFn(0);
#[doc = "< NJTRST Alternate Function mapping"]
pub const GpioAltFn0NJTRST: GpioAltFn = GpioAltFn(0);
#[doc = "< RTC_REFIN Alternate Function mapping"]
pub const GpioAltFn0RTC_REFIN: GpioAltFn = GpioAltFn(0);
#[doc = "< TRACED0 Alternate Function mapping"]
pub const GpioAltFn0TRACED0: GpioAltFn = GpioAltFn(0);
#[doc = "< TRACED1 Alternate Function mapping"]
pub const GpioAltFn0TRACED1: GpioAltFn = GpioAltFn(0);
#[doc = "< TRACED2 Alternate Function mapping"]
pub const GpioAltFn0TRACED2: GpioAltFn = GpioAltFn(0);
#[doc = "< TRACED3 Alternate Function mapping"]
pub const GpioAltFn0TRACED3: GpioAltFn = GpioAltFn(0);
#[doc = "< TRIG_INOUT Alternate Function mapping"]
pub const GpioAltFn0TRIG_INOUT: GpioAltFn = GpioAltFn(0);
#[doc = "< TRACECK Alternate Function mapping"]
pub const GpioAltFn0TRACECK: GpioAltFn = GpioAltFn(0);
#[doc = "< System Function mapping"]
pub const GpioAltFn0SYS: GpioAltFn = GpioAltFn(0);
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn1TIM1: GpioAltFn = GpioAltFn(1);
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn1TIM2: GpioAltFn = GpioAltFn(1);
#[doc = "< LPTIM1 Alternate Function mapping"]
pub const GpioAltFn1LPTIM1: GpioAltFn = GpioAltFn(1);
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn2TIM2: GpioAltFn = GpioAltFn(2);
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn2TIM1: GpioAltFn = GpioAltFn(2);
#[doc = "< SAI1_CK1 Alternate Function mapping"]
pub const GpioAltFn3SAI1: GpioAltFn = GpioAltFn(3);
#[doc = "< SPI2 Alternate Function mapping"]
pub const GpioAltFn3SPI2: GpioAltFn = GpioAltFn(3);
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn3TIM1: GpioAltFn = GpioAltFn(3);
#[doc = "< I2C1 Alternate Function mapping"]
pub const GpioAltFn4I2C1: GpioAltFn = GpioAltFn(4);
#[doc = "< I2C3 Alternate Function mapping"]
pub const GpioAltFn4I2C3: GpioAltFn = GpioAltFn(4);
#[doc = "< SPI1 Alternate Function mapping"]
pub const GpioAltFn5SPI1: GpioAltFn = GpioAltFn(5);
#[doc = "< SPI2 Alternate Function mapping"]
pub const GpioAltFn5SPI2: GpioAltFn = GpioAltFn(5);
#[doc = "< MCO Alternate Function mapping"]
pub const GpioAltFn6MCO: GpioAltFn = GpioAltFn(6);
#[doc = "< LSCO Alternate Function mapping"]
pub const GpioAltFn6LSCO: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB0 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB0: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB1 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB1: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB2 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB2: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB3 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB3: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB4 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB4: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB5 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB5: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB6 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB6: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB7 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB7: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB8 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB8: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB9 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB9: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB10 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB10: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB11 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB11: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB12 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB12: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB13 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB13: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB14 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB14: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB15 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB15: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB16 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB16: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB17 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB17: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_DTB18 Alternate Function mapping"]
pub const GpioAltFn6RF_DTB18: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_MISO Alternate Function mapping"]
pub const GpioAltFn6RF_MISO: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_MOSI Alternate Function mapping"]
pub const GpioAltFn6RF_MOSI: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_SCK Alternate Function mapping"]
pub const GpioAltFn6RF_SCK: GpioAltFn = GpioAltFn(6);
#[doc = "< RF_NSS Alternate Function mapping"]
pub const GpioAltFn6RF_NSS: GpioAltFn = GpioAltFn(6);
#[doc = "< USART1 Alternate Function mapping"]
pub const GpioAltFn7USART1: GpioAltFn = GpioAltFn(7);
#[doc = "< LPUART1 Alternate Function mapping"]
pub const GpioAltFn8LPUART1: GpioAltFn = GpioAltFn(8);
#[doc = "< IR Alternate Function mapping"]
pub const GpioAltFn8IR: GpioAltFn = GpioAltFn(8);
#[doc = "< TSC Alternate Function mapping"]
pub const GpioAltFn9TSC: GpioAltFn = GpioAltFn(9);
#[doc = "< QUADSPI Alternate Function mapping"]
pub const GpioAltFn10QUADSPI: GpioAltFn = GpioAltFn(10);
#[doc = "< USB Alternate Function mapping"]
pub const GpioAltFn10USB: GpioAltFn = GpioAltFn(10);
#[doc = "< LCD Alternate Function mapping"]
pub const GpioAltFn11LCD: GpioAltFn = GpioAltFn(11);
#[doc = "< COMP1 Alternate Function mapping"]
pub const GpioAltFn12COMP1: GpioAltFn = GpioAltFn(12);
#[doc = "< COMP2 Alternate Function mapping"]
pub const GpioAltFn12COMP2: GpioAltFn = GpioAltFn(12);
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn12TIM1: GpioAltFn = GpioAltFn(12);
#[doc = "< SAI1 Alternate Function mapping"]
pub const GpioAltFn13SAI1: GpioAltFn = GpioAltFn(13);
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn14TIM2: GpioAltFn = GpioAltFn(14);
#[doc = "< TIM16 Alternate Function mapping"]
pub const GpioAltFn14TIM16: GpioAltFn = GpioAltFn(14);
#[doc = "< TIM17 Alternate Function mapping"]
pub const GpioAltFn14TIM17: GpioAltFn = GpioAltFn(14);
#[doc = "< LPTIM2 Alternate Function mapping"]
pub const GpioAltFn14LPTIM2: GpioAltFn = GpioAltFn(14);
#[doc = "< EVENTOUT Alternate Function mapping"]
pub const GpioAltFn15EVENTOUT: GpioAltFn = GpioAltFn(15);
#[doc = "< just dummy value"]
pub const GpioAltFnUnused: GpioAltFn = GpioAltFn(16);
#[repr(transparent)]
#[doc = "Gpio alternate functions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GpioAltFn(pub core::ffi::c_uchar);
#[doc = "Gpio structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPin {
    pub port: *mut GPIO_TypeDef,
    pub pin: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GpioPin"][::core::mem::size_of::<GpioPin>() - 8usize];
    ["Alignment of GpioPin"][::core::mem::align_of::<GpioPin>() - 4usize];
    ["Offset of field: GpioPin::port"][::core::mem::offset_of!(GpioPin, port) - 0usize];
    ["Offset of field: GpioPin::pin"][::core::mem::offset_of!(GpioPin, pin) - 4usize];
};
unsafe extern "C" {
    #[doc = "GPIO initialization function, simple version\n # Arguments\n\n* `gpio` - GpioPin\n * `mode` - GpioMode"]
    pub fn furi_hal_gpio_init_simple(gpio: *const GpioPin, mode: GpioMode);
}
unsafe extern "C" {
    #[doc = "GPIO initialization function, normal version\n # Arguments\n\n* `gpio` - GpioPin\n * `mode` - GpioMode\n * `pull` - GpioPull\n * `speed` - GpioSpeed"]
    pub fn furi_hal_gpio_init(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
    );
}
unsafe extern "C" {
    #[doc = "GPIO initialization function, extended version\n # Arguments\n\n* `gpio` - GpioPin\n * `mode` - GpioMode\n * `pull` - GpioPull\n * `speed` - GpioSpeed\n * `alt_fn` - GpioAltFn"]
    pub fn furi_hal_gpio_init_ex(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
        alt_fn: GpioAltFn,
    );
}
unsafe extern "C" {
    #[doc = "Add and enable interrupt\n # Arguments\n\n* `gpio` - GpioPin\n * `cb` - GpioExtiCallback\n * `ctx` - context for callback"]
    pub fn furi_hal_gpio_add_int_callback(
        gpio: *const GpioPin,
        cb: GpioExtiCallback,
        ctx: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Enable interrupt\n # Arguments\n\n* `gpio` - GpioPin"]
    pub fn furi_hal_gpio_enable_int_callback(gpio: *const GpioPin);
}
unsafe extern "C" {
    #[doc = "Disable interrupt\n # Arguments\n\n* `gpio` - GpioPin"]
    pub fn furi_hal_gpio_disable_int_callback(gpio: *const GpioPin);
}
unsafe extern "C" {
    #[doc = "Remove interrupt\n # Arguments\n\n* `gpio` - GpioPin"]
    pub fn furi_hal_gpio_remove_int_callback(gpio: *const GpioPin);
}
unsafe extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(arg1: f32, arg2: core::ffi::c_int) -> f32;
}
unsafe extern "C" {
    pub fn furi_run();
}
#[doc = "Cortex timer provides high precision low level expiring timer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCortexTimer {
    pub start: u32,
    pub value: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalCortexTimer"][::core::mem::size_of::<FuriHalCortexTimer>() - 8usize];
    ["Alignment of FuriHalCortexTimer"][::core::mem::align_of::<FuriHalCortexTimer>() - 4usize];
    ["Offset of field: FuriHalCortexTimer::start"]
        [::core::mem::offset_of!(FuriHalCortexTimer, start) - 0usize];
    ["Offset of field: FuriHalCortexTimer::value"]
        [::core::mem::offset_of!(FuriHalCortexTimer, value) - 4usize];
};
unsafe extern "C" {
    #[doc = "Microseconds delay\n\n # Arguments\n\n* `microseconds` (direction in) - The microseconds to wait"]
    pub fn furi_hal_cortex_delay_us(microseconds: u32);
}
unsafe extern "C" {
    #[doc = "Get instructions per microsecond count\n\n # Returns\n\ninstructions per microsecond count"]
    pub fn furi_hal_cortex_instructions_per_microsecond() -> u32;
}
unsafe extern "C" {
    #[doc = "Get Timer\n\n # Arguments\n\n* `timeout_us` (direction in) - The expire timeout in us\n\n # Returns\n\nThe FuriHalCortexTimer"]
    pub fn furi_hal_cortex_timer_get(timeout_us: u32) -> FuriHalCortexTimer;
}
unsafe extern "C" {
    #[doc = "Check if timer expired\n\n # Arguments\n\n* `cortex_timer` (direction in) - The FuriHalCortexTimer\n\n # Returns\n\ntrue if expired"]
    pub fn furi_hal_cortex_timer_is_expired(cortex_timer: FuriHalCortexTimer) -> bool;
}
unsafe extern "C" {
    #[doc = "Wait for timer expire\n\n # Arguments\n\n* `cortex_timer` (direction in) - The FuriHalCortexTimer"]
    pub fn furi_hal_cortex_timer_wait(cortex_timer: FuriHalCortexTimer);
}
pub const FuriHalCortexComp0: FuriHalCortexComp = FuriHalCortexComp(0);
pub const FuriHalCortexComp1: FuriHalCortexComp = FuriHalCortexComp(1);
pub const FuriHalCortexComp2: FuriHalCortexComp = FuriHalCortexComp(2);
pub const FuriHalCortexComp3: FuriHalCortexComp = FuriHalCortexComp(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalCortexComp(pub core::ffi::c_uchar);
pub const FuriHalCortexCompSizeWord: FuriHalCortexCompSize = FuriHalCortexCompSize(2);
pub const FuriHalCortexCompSizeHalfWord: FuriHalCortexCompSize = FuriHalCortexCompSize(1);
pub const FuriHalCortexCompSizeByte: FuriHalCortexCompSize = FuriHalCortexCompSize(0);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalCortexCompSize(pub core::ffi::c_uchar);
pub const FuriHalCortexCompFunctionPC: FuriHalCortexCompFunction = FuriHalCortexCompFunction(4);
pub const FuriHalCortexCompFunctionRead: FuriHalCortexCompFunction = FuriHalCortexCompFunction(5);
pub const FuriHalCortexCompFunctionWrite: FuriHalCortexCompFunction = FuriHalCortexCompFunction(6);
pub const FuriHalCortexCompFunctionReadWrite: FuriHalCortexCompFunction =
    FuriHalCortexCompFunction(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalCortexCompFunction(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Enable DWT comparator\n\n Allows to programmatically set instruction/data breakpoints.\n\n More details on how it works can be found in armv7m official documentation:\n https://developer.arm.com/documentation/ddi0403/d/Debug-Architecture/ARMv7-M-Debug/The-Data-Watchpoint-and-Trace-unit/The-DWT-comparators\n https://developer.arm.com/documentation/ddi0403/d/Debug-Architecture/ARMv7-M-Debug/The-Data-Watchpoint-and-Trace-unit/Comparator-Function-registers--DWT-FUNCTIONn\n\n # Arguments\n\n* `comp` (direction in) - The Comparator\n * `function` (direction in) - The Comparator Function to use\n * `value` (direction in) - The value\n * `mask` (direction in) - The mask\n * `size` (direction in) - The size"]
    pub fn furi_hal_cortex_comp_enable(
        comp: FuriHalCortexComp,
        function: FuriHalCortexCompFunction,
        value: u32,
        mask: u32,
        size: FuriHalCortexCompSize,
    );
}
unsafe extern "C" {
    #[doc = "Reset DWT comparator\n\n # Arguments\n\n* `comp` (direction in) - The Comparator"]
    pub fn furi_hal_cortex_comp_reset(comp: FuriHalCortexComp);
}
unsafe extern "C" {
    pub fn LL_RCC_GetUSARTClockFreq(USARTxSource: u32) -> u32;
}
unsafe extern "C" {
    pub fn LL_RCC_GetLPUARTClockFreq(LPUARTxSource: u32) -> u32;
}
pub const FuriHalClockMcoLse: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(0);
pub const FuriHalClockMcoSysclk: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(1);
pub const FuriHalClockMcoMsi100k: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(2);
pub const FuriHalClockMcoMsi200k: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(3);
pub const FuriHalClockMcoMsi400k: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(4);
pub const FuriHalClockMcoMsi800k: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(5);
pub const FuriHalClockMcoMsi1m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(6);
pub const FuriHalClockMcoMsi2m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(7);
pub const FuriHalClockMcoMsi4m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(8);
pub const FuriHalClockMcoMsi8m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(9);
pub const FuriHalClockMcoMsi16m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(10);
pub const FuriHalClockMcoMsi24m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(11);
pub const FuriHalClockMcoMsi32m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(12);
pub const FuriHalClockMcoMsi48m: FuriHalClockMcoSourceId = FuriHalClockMcoSourceId(13);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalClockMcoSourceId(pub core::ffi::c_uchar);
pub const FuriHalClockMcoDiv1: FuriHalClockMcoDivisorId = FuriHalClockMcoDivisorId(0);
pub const FuriHalClockMcoDiv2: FuriHalClockMcoDivisorId = FuriHalClockMcoDivisorId(268435456);
pub const FuriHalClockMcoDiv4: FuriHalClockMcoDivisorId = FuriHalClockMcoDivisorId(536870912);
pub const FuriHalClockMcoDiv8: FuriHalClockMcoDivisorId = FuriHalClockMcoDivisorId(805306368);
pub const FuriHalClockMcoDiv16: FuriHalClockMcoDivisorId = FuriHalClockMcoDivisorId(1073741824);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalClockMcoDivisorId(pub core::ffi::c_uint);
unsafe extern "C" {
    #[doc = "Enable clock output on MCO pin\n\n # Arguments\n\n* `source` - MCO clock source\n * `div` - MCO clock division"]
    pub fn furi_hal_clock_mco_enable(
        source: FuriHalClockMcoSourceId,
        div: FuriHalClockMcoDivisorId,
    );
}
unsafe extern "C" {
    #[doc = "Disable clock output on MCO pin"]
    pub fn furi_hal_clock_mco_disable();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalAdcHandle {
    _unused: [u8; 0],
}
#[doc = "< 2.048V scale"]
pub const FuriHalAdcScale2048: FuriHalAdcScale = FuriHalAdcScale(0);
#[doc = "< 2.5V scale"]
pub const FuriHalAdcScale2500: FuriHalAdcScale = FuriHalAdcScale(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalAdcScale(pub core::ffi::c_uchar);
#[doc = "< 16MHZ, synchronous"]
pub const FuriHalAdcClockSync16: FuriHalAdcClock = FuriHalAdcClock(0);
#[doc = "< 32MHZ, synchronous"]
pub const FuriHalAdcClockSync32: FuriHalAdcClock = FuriHalAdcClock(1);
#[doc = "< 64MHz, synchronous"]
pub const FuriHalAdcClockSync64: FuriHalAdcClock = FuriHalAdcClock(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalAdcClock(pub core::ffi::c_uchar);
#[doc = "< ADC will take 2 samples per each value"]
pub const FuriHalAdcOversample2: FuriHalAdcOversample = FuriHalAdcOversample(0);
#[doc = "< ADC will take 4 samples per each value"]
pub const FuriHalAdcOversample4: FuriHalAdcOversample = FuriHalAdcOversample(1);
#[doc = "< ADC will take 8 samples per each value"]
pub const FuriHalAdcOversample8: FuriHalAdcOversample = FuriHalAdcOversample(2);
#[doc = "< ADC will take 16 samples per each value"]
pub const FuriHalAdcOversample16: FuriHalAdcOversample = FuriHalAdcOversample(3);
#[doc = "< ADC will take 32 samples per each value"]
pub const FuriHalAdcOversample32: FuriHalAdcOversample = FuriHalAdcOversample(4);
#[doc = "< ADC will take 64 samples per each value"]
pub const FuriHalAdcOversample64: FuriHalAdcOversample = FuriHalAdcOversample(5);
#[doc = "< ADC will take 128 samples per each value"]
pub const FuriHalAdcOversample128: FuriHalAdcOversample = FuriHalAdcOversample(6);
#[doc = "< ADC will take 256 samples per each value"]
pub const FuriHalAdcOversample256: FuriHalAdcOversample = FuriHalAdcOversample(7);
#[doc = "< disable oversampling"]
pub const FuriHalAdcOversampleNone: FuriHalAdcOversample = FuriHalAdcOversample(8);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalAdcOversample(pub core::ffi::c_uchar);
#[doc = "< Sampling time 2.5 ADC clock"]
pub const FuriHalAdcSamplingtime2_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(0);
#[doc = "< Sampling time 6.5 ADC clock"]
pub const FuriHalAdcSamplingtime6_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(1);
#[doc = "< Sampling time 12.5 ADC clock"]
pub const FuriHalAdcSamplingtime12_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(2);
#[doc = "< Sampling time 24.5 ADC clock"]
pub const FuriHalAdcSamplingtime24_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(3);
#[doc = "< Sampling time 47.5 ADC clock"]
pub const FuriHalAdcSamplingtime47_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(4);
#[doc = "< Sampling time 92.5 ADC clock"]
pub const FuriHalAdcSamplingtime92_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(5);
#[doc = "< Sampling time 247.5 ADC clock"]
pub const FuriHalAdcSamplingtime247_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(6);
#[doc = "< Sampling time 640.5 ADC clock"]
pub const FuriHalAdcSamplingtime640_5: FuriHalAdcSamplingTime = FuriHalAdcSamplingTime(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalAdcSamplingTime(pub core::ffi::c_uchar);
#[doc = "< Internal channel, see `FuriHalAdcChannelVREFINT`."]
pub const FuriHalAdcChannel0: FuriHalAdcChannel = FuriHalAdcChannel(0);
#[doc = "< Channel 1p"]
pub const FuriHalAdcChannel1: FuriHalAdcChannel = FuriHalAdcChannel(1);
#[doc = "< Channel 2p or 1n"]
pub const FuriHalAdcChannel2: FuriHalAdcChannel = FuriHalAdcChannel(2);
#[doc = "< Channel 3p or 2n"]
pub const FuriHalAdcChannel3: FuriHalAdcChannel = FuriHalAdcChannel(3);
#[doc = "< Channel 4p or 3n"]
pub const FuriHalAdcChannel4: FuriHalAdcChannel = FuriHalAdcChannel(4);
#[doc = "< Channel 5p or 4n"]
pub const FuriHalAdcChannel5: FuriHalAdcChannel = FuriHalAdcChannel(5);
#[doc = "< Channel 6p or 5n"]
pub const FuriHalAdcChannel6: FuriHalAdcChannel = FuriHalAdcChannel(6);
#[doc = "< Channel 7p or 6n"]
pub const FuriHalAdcChannel7: FuriHalAdcChannel = FuriHalAdcChannel(7);
#[doc = "< Channel 8p or 7n"]
pub const FuriHalAdcChannel8: FuriHalAdcChannel = FuriHalAdcChannel(8);
#[doc = "< Channel 9p or 8n"]
pub const FuriHalAdcChannel9: FuriHalAdcChannel = FuriHalAdcChannel(9);
#[doc = "< Channel 10p or 9n"]
pub const FuriHalAdcChannel10: FuriHalAdcChannel = FuriHalAdcChannel(10);
#[doc = "< Channel 11p or 10n"]
pub const FuriHalAdcChannel11: FuriHalAdcChannel = FuriHalAdcChannel(11);
#[doc = "< Channel 12p or 11n"]
pub const FuriHalAdcChannel12: FuriHalAdcChannel = FuriHalAdcChannel(12);
#[doc = "< Channel 13p or 12n"]
pub const FuriHalAdcChannel13: FuriHalAdcChannel = FuriHalAdcChannel(13);
#[doc = "< Channel 14p or 13n"]
pub const FuriHalAdcChannel14: FuriHalAdcChannel = FuriHalAdcChannel(14);
#[doc = "< Channel 15p or 14n"]
pub const FuriHalAdcChannel15: FuriHalAdcChannel = FuriHalAdcChannel(15);
#[doc = "< Channel 16p or 15n"]
pub const FuriHalAdcChannel16: FuriHalAdcChannel = FuriHalAdcChannel(16);
#[doc = "< Internal channel, see `FuriHalAdcChannelTEMPSENSOR`."]
pub const FuriHalAdcChannel17: FuriHalAdcChannel = FuriHalAdcChannel(17);
#[doc = "< Internal channel, see `FuriHalAdcChannelVBAT`."]
pub const FuriHalAdcChannel18: FuriHalAdcChannel = FuriHalAdcChannel(18);
#[doc = "< Special channel for VREFINT, used for calibration and self test"]
pub const FuriHalAdcChannelVREFINT: FuriHalAdcChannel = FuriHalAdcChannel(19);
#[doc = "< Special channel for on-die temperature sensor, requires at least 5us of sampling time"]
pub const FuriHalAdcChannelTEMPSENSOR: FuriHalAdcChannel = FuriHalAdcChannel(20);
#[doc = "< Special channel for VBAT/3 voltage, requires at least 12us of sampling time"]
pub const FuriHalAdcChannelVBAT: FuriHalAdcChannel = FuriHalAdcChannel(21);
#[doc = "< No channel"]
pub const FuriHalAdcChannelNone: FuriHalAdcChannel = FuriHalAdcChannel(22);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalAdcChannel(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Initialize ADC subsystem"]
    pub fn furi_hal_adc_init();
}
unsafe extern "C" {
    #[doc = "Acquire ADC handle\n\n Enables appropriate power and clocking domains\n\n # Returns\n\nFuriHalAdcHandle pointer"]
    pub fn furi_hal_adc_acquire() -> *mut FuriHalAdcHandle;
}
unsafe extern "C" {
    #[doc = "Release ADC handle\n\n # Arguments\n\n* `handle` - The ADC handle"]
    pub fn furi_hal_adc_release(handle: *mut FuriHalAdcHandle);
}
unsafe extern "C" {
    #[doc = "Configure with default parameters and enable ADC\n\n Parameters used:\n - FuriHalAdcScale2048 - 2.048V VREF Scale. Your signal should be in 0 -\n 2.048V range.\n - FuriHalAdcClockSync64 - Clocked from sysclk bus at 64MHz in synchronous\n mode. Fast, no delay on data bus access.\n - FuriHalAdcOversample64 - Going to acquire and average 64 samples. For\n circuits with slowly or not changing signal. Total time per one read:\n (1/64)*(12.5+247.5)*64 = 260us. The best results you'll get if your signal\n will stay on the same level all this time.\n - FuriHalAdcSamplingtime247_5 - Sampling(transfer from source to internal\n sampling capacitor) time is 247.5 ADC clocks: (1/64)*247.5 = 3.8671875us.\n For relatively high impedance circuits.\n\n Also keep your measurement circuit impedance under 10KOhm or oversampling\n results will be compromised. Verify your signal with oscilloscope(you may\n need fast oscilloscope: 200MHz bandwidth, 125MS/s), ensure that signal is not\n distorted by sampling.\n\n Those parameters were optimized for 0 - 2.048 voltage measurement with ~0.1%\n precision. You can get more, but it will require some magic.\n\n # Arguments\n\n* `handle` - The ADC handle"]
    pub fn furi_hal_adc_configure(handle: *mut FuriHalAdcHandle);
}
unsafe extern "C" {
    #[doc = "Configure with extended parameters and enable ADC\n\n General advice is to start with default parameters, figure out what exactly\n is not working for you and then tune it. Also in some cases changing\n circuit(adding caps, lowering impedance, adding opamp) may be better than changing\n parameters.\n\n In general ADC is a world of magic: make sure that you understand\n how your circuit and ADC works. Then carefully read STM32WB\n series reference manual. Setting incorrect parameters leads to\n very poor results. Also internal channels require special\n settings.\n\n # Arguments\n\n* `handle` - The ADC handle\n * `scale` (direction in) - The ADC voltage scale\n * `clock` (direction in) - The ADC clock\n * `oversample` (direction in) - The ADC oversample mode\n * `sampling_time` (direction in) - The ADC sampling time"]
    pub fn furi_hal_adc_configure_ex(
        handle: *mut FuriHalAdcHandle,
        scale: FuriHalAdcScale,
        clock: FuriHalAdcClock,
        oversample: FuriHalAdcOversample,
        sampling_time: FuriHalAdcSamplingTime,
    );
}
unsafe extern "C" {
    #[doc = "Read single ADC value\n\n # Arguments\n\n* `handle` - The ADC handle\n * `channel` (direction in) - The channel to sample\n\n # Returns\n\nvalue, 12 bits"]
    pub fn furi_hal_adc_read(handle: *mut FuriHalAdcHandle, channel: FuriHalAdcChannel) -> u16;
}
unsafe extern "C" {
    #[doc = "Convert sampled value to voltage\n\n # Arguments\n\n* `handle` - The ADC handle\n * `value` (direction in) - The value acquired with `furi_hal_adc_read`\n\n # Returns\n\nVoltage in mV"]
    pub fn furi_hal_adc_convert_to_voltage(handle: *mut FuriHalAdcHandle, value: u16) -> f32;
}
unsafe extern "C" {
    #[doc = "Convert sampled VREFINT value to voltage\n\n # Arguments\n\n* `handle` - The ADC handle\n * `value` (direction in) - The value acquired with `furi_hal_adc_read` for\n `FuriHalAdcChannelVREFINT` channel\n\n # Returns\n\nVoltage in mV"]
    pub fn furi_hal_adc_convert_vref(handle: *mut FuriHalAdcHandle, value: u16) -> f32;
}
unsafe extern "C" {
    #[doc = "Convert sampled TEMPSENSOR value to temperature\n\n # Arguments\n\n* `handle` - The ADC handle\n * `value` (direction in) - The value acquired with `furi_hal_adc_read` for\n `FuriHalAdcChannelTEMPSENSOR` channel\n\n # Returns\n\ntemperature in degree C"]
    pub fn furi_hal_adc_convert_temp(handle: *mut FuriHalAdcHandle, value: u16) -> f32;
}
unsafe extern "C" {
    #[doc = "Convert sampled VBAT value to voltage\n\n # Arguments\n\n* `handle` - The ADC handle\n * `value` (direction in) - The value acquired with `furi_hal_adc_read` for\n `FuriHalAdcChannelVBAT` channel\n\n # Returns\n\nVoltage in mV"]
    pub fn furi_hal_adc_convert_vbat(handle: *mut FuriHalAdcHandle, value: u16) -> f32;
}
pub const FuriHalBusAHB1_GRP1: FuriHalBus = FuriHalBus(0);
pub const FuriHalBusDMA1: FuriHalBus = FuriHalBus(1);
pub const FuriHalBusDMA2: FuriHalBus = FuriHalBus(2);
pub const FuriHalBusDMAMUX1: FuriHalBus = FuriHalBus(3);
pub const FuriHalBusCRC: FuriHalBus = FuriHalBus(4);
pub const FuriHalBusTSC: FuriHalBus = FuriHalBus(5);
pub const FuriHalBusAHB2_GRP1: FuriHalBus = FuriHalBus(6);
pub const FuriHalBusGPIOA: FuriHalBus = FuriHalBus(7);
pub const FuriHalBusGPIOB: FuriHalBus = FuriHalBus(8);
pub const FuriHalBusGPIOC: FuriHalBus = FuriHalBus(9);
pub const FuriHalBusGPIOD: FuriHalBus = FuriHalBus(10);
pub const FuriHalBusGPIOE: FuriHalBus = FuriHalBus(11);
pub const FuriHalBusGPIOH: FuriHalBus = FuriHalBus(12);
pub const FuriHalBusADC: FuriHalBus = FuriHalBus(13);
pub const FuriHalBusAES1: FuriHalBus = FuriHalBus(14);
pub const FuriHalBusAHB3_GRP1: FuriHalBus = FuriHalBus(15);
pub const FuriHalBusQUADSPI: FuriHalBus = FuriHalBus(16);
pub const FuriHalBusPKA: FuriHalBus = FuriHalBus(17);
pub const FuriHalBusAES2: FuriHalBus = FuriHalBus(18);
pub const FuriHalBusRNG: FuriHalBus = FuriHalBus(19);
pub const FuriHalBusHSEM: FuriHalBus = FuriHalBus(20);
pub const FuriHalBusIPCC: FuriHalBus = FuriHalBus(21);
pub const FuriHalBusFLASH: FuriHalBus = FuriHalBus(22);
pub const FuriHalBusAPB1_GRP1: FuriHalBus = FuriHalBus(23);
pub const FuriHalBusTIM2: FuriHalBus = FuriHalBus(24);
pub const FuriHalBusLCD: FuriHalBus = FuriHalBus(25);
pub const FuriHalBusSPI2: FuriHalBus = FuriHalBus(26);
pub const FuriHalBusI2C1: FuriHalBus = FuriHalBus(27);
pub const FuriHalBusI2C3: FuriHalBus = FuriHalBus(28);
pub const FuriHalBusCRS: FuriHalBus = FuriHalBus(29);
pub const FuriHalBusUSB: FuriHalBus = FuriHalBus(30);
pub const FuriHalBusLPTIM1: FuriHalBus = FuriHalBus(31);
pub const FuriHalBusAPB1_GRP2: FuriHalBus = FuriHalBus(32);
pub const FuriHalBusLPUART1: FuriHalBus = FuriHalBus(33);
pub const FuriHalBusLPTIM2: FuriHalBus = FuriHalBus(34);
pub const FuriHalBusAPB2_GRP1: FuriHalBus = FuriHalBus(35);
pub const FuriHalBusTIM1: FuriHalBus = FuriHalBus(36);
pub const FuriHalBusSPI1: FuriHalBus = FuriHalBus(37);
pub const FuriHalBusUSART1: FuriHalBus = FuriHalBus(38);
pub const FuriHalBusTIM16: FuriHalBus = FuriHalBus(39);
pub const FuriHalBusTIM17: FuriHalBus = FuriHalBus(40);
pub const FuriHalBusSAI1: FuriHalBus = FuriHalBus(41);
pub const FuriHalBusAPB3_GRP1: FuriHalBus = FuriHalBus(42);
pub const FuriHalBusRF: FuriHalBus = FuriHalBus(43);
pub const FuriHalBusMAX: FuriHalBus = FuriHalBus(44);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalBus(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Early initialization"]
    pub fn furi_hal_bus_init_early();
}
unsafe extern "C" {
    #[doc = "Early de-initialization"]
    pub fn furi_hal_bus_deinit_early();
}
unsafe extern "C" {
    #[doc = "Enable a peripheral by turning the clocking on and deasserting the reset.\n # Arguments\n\n* `[in]` - bus Peripheral to be enabled.\n Peripheral must be in disabled state in order to be enabled."]
    pub fn furi_hal_bus_enable(bus: FuriHalBus);
}
unsafe extern "C" {
    #[doc = "Reset a peripheral by sequentially asserting and deasserting the reset.\n # Arguments\n\n* `[in]` - bus Peripheral to be reset.\n Peripheral must be in enabled state in order to be reset."]
    pub fn furi_hal_bus_reset(bus: FuriHalBus);
}
unsafe extern "C" {
    #[doc = "Disable a peripheral by turning the clocking off and asserting the reset.\n # Arguments\n\n* `[in]` - bus Peripheral to be disabled.\n Peripheral must be in enabled state in order to be disabled."]
    pub fn furi_hal_bus_disable(bus: FuriHalBus);
}
unsafe extern "C" {
    #[doc = "Check if peripheral is enabled\n\n FuriHalBusAPB3_GRP1 is a special group of shared peripherals, for\n core1 its clock is always on and the only status we can report is\n peripheral reset status. Check code and Reference Manual for\n details.\n\n # Arguments\n\n* `bus` (direction in) - The peripheral to check\n\n # Returns\n\ntrue if enabled or always enabled, false otherwise"]
    pub fn furi_hal_bus_is_enabled(bus: FuriHalBus) -> bool;
}
#[doc = "< Master key"]
pub const FuriHalCryptoKeyTypeMaster: FuriHalCryptoKeyType = FuriHalCryptoKeyType(0);
#[doc = "< Simple unencrypted key"]
pub const FuriHalCryptoKeyTypeSimple: FuriHalCryptoKeyType = FuriHalCryptoKeyType(1);
#[doc = "< Encrypted with Master key"]
pub const FuriHalCryptoKeyTypeEncrypted: FuriHalCryptoKeyType = FuriHalCryptoKeyType(2);
#[repr(transparent)]
#[doc = "FuriHalCryptoKey Type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalCryptoKeyType(pub core::ffi::c_uchar);
pub const FuriHalCryptoKeySize128: FuriHalCryptoKeySize = FuriHalCryptoKeySize(0);
pub const FuriHalCryptoKeySize256: FuriHalCryptoKeySize = FuriHalCryptoKeySize(1);
#[repr(transparent)]
#[doc = "FuriHalCryptoKey Size in bits"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalCryptoKeySize(pub core::ffi::c_uchar);
#[doc = "FuriHalCryptoKey"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCryptoKey {
    pub type_: FuriHalCryptoKeyType,
    pub size: FuriHalCryptoKeySize,
    pub data: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalCryptoKey"][::core::mem::size_of::<FuriHalCryptoKey>() - 8usize];
    ["Alignment of FuriHalCryptoKey"][::core::mem::align_of::<FuriHalCryptoKey>() - 4usize];
    ["Offset of field: FuriHalCryptoKey::type_"]
        [::core::mem::offset_of!(FuriHalCryptoKey, type_) - 0usize];
    ["Offset of field: FuriHalCryptoKey::size"]
        [::core::mem::offset_of!(FuriHalCryptoKey, size) - 1usize];
    ["Offset of field: FuriHalCryptoKey::data"]
        [::core::mem::offset_of!(FuriHalCryptoKey, data) - 4usize];
};
#[doc = "< operation successful"]
pub const FuriHalCryptoGCMStateOk: FuriHalCryptoGCMState = FuriHalCryptoGCMState(0);
#[doc = "< error during encryption/decryption"]
pub const FuriHalCryptoGCMStateError: FuriHalCryptoGCMState = FuriHalCryptoGCMState(1);
#[doc = "< tags do not match, auth failed"]
pub const FuriHalCryptoGCMStateAuthFailure: FuriHalCryptoGCMState = FuriHalCryptoGCMState(2);
#[repr(transparent)]
#[doc = "FuriHalCryptoGCMState Result of a GCM operation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalCryptoGCMState(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Verify factory provisioned keys\n\n # Arguments\n\n* `keys_nb` - The keys number of\n * `valid_keys_nb` - The valid keys number of\n\n # Returns\n\ntrue if all enclave keys are intact, false otherwise"]
    pub fn furi_hal_crypto_enclave_verify(keys_nb: *mut u8, valid_keys_nb: *mut u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Ensure that requested slot and slots before this slot contains keys.\n\n This function is used to provision FURI_HAL_CRYPTO_ENCLAVE_UNIQUE_KEY_SLOT. Also you\n may want to use it to generate some unique keys in user key slot range.\n\n Because of the sequential nature of the secure enclave this\n method will generate key for all slots from\n FURI_HAL_CRYPTO_ENCLAVE_FACTORY_KEY_SLOT_END to the slot your requested.\n Keys are generated using on-chip RNG.\n\n # Arguments\n\n* `key_slot` (direction in) - The key slot to enclave\n\n # Returns\n\ntrue if key exists or created, false if enclave corrupted"]
    pub fn furi_hal_crypto_enclave_ensure_key(key_slot: u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Store key in crypto enclave\n\n # Arguments\n\n* `key` - FuriHalCryptoKey to be stored\n * `slot` - pointer to int where enclave slot will be stored\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_enclave_store_key(key: *mut FuriHalCryptoKey, slot: *mut u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Init AES engine and load key from crypto enclave\n\n Use only with furi_hal_crypto_enclave_unload_key()\n\n # Arguments\n\n* `slot` - enclave slot\n * `iv` (direction in) - pointer to 16 bytes Initialization Vector data\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_enclave_load_key(slot: u8, iv: *const u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Unload key and deinit AES engine\n\n Use only with furi_hal_crypto_enclave_load_key()\n\n # Arguments\n\n* `slot` - enclave slot\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_enclave_unload_key(slot: u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Init AES engine and load supplied key\n\n Use only with furi_hal_crypto_unload_key()\n\n # Arguments\n\n* `key` (direction in) - pointer to 32 bytes key data\n * `iv` (direction in) - pointer to 16 bytes Initialization Vector data\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_load_key(key: *const u8, iv: *const u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Unload key and de-init AES engine\n\n Use this function only with furi_hal_crypto_load_key()\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_unload_key() -> bool;
}
unsafe extern "C" {
    #[doc = "Encrypt data\n\n # Arguments\n\n* `input` - pointer to input data\n * `output` - pointer to output data\n * `size` - input/output buffer size in bytes\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_encrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Decrypt data\n\n # Arguments\n\n* `input` - pointer to input data\n * `output` - pointer to output data\n * `size` - input/output buffer size in bytes\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_decrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Encrypt the input using AES-CTR\n\n Decryption can be performed by supplying the ciphertext as input. Inits and\n deinits the AES engine internally.\n\n # Arguments\n\n* `key` (direction in) - pointer to 32 bytes key data\n * `iv` (direction in) - pointer to 12 bytes Initialization Vector data\n * `input` (direction in) - pointer to input data\n * `output` (direction out) - pointer to output data\n * `length` - length of the input and output in bytes\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_ctr(
        key: *const u8,
        iv: *const u8,
        input: *const u8,
        output: *mut u8,
        length: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Encrypt/decrypt the input using AES-GCM\n\n When decrypting the tag generated needs to be compared to the tag attached to\n the ciphertext in a constant-time fashion. If the tags are not equal, the\n decryption failed and the plaintext returned needs to be discarded. Inits and\n deinits the AES engine internally.\n\n # Arguments\n\n* `key` (direction in) - pointer to 32 bytes key data\n * `iv` (direction in) - pointer to 12 bytes Initialization Vector data\n * `aad` (direction in) - pointer to additional authentication data\n * `aad_length` - length of the additional authentication data in bytes\n * `input` (direction in) - pointer to input data\n * `output` (direction out) - pointer to output data\n * `length` - length of the input and output in bytes\n * `tag` (direction out) - pointer to 16 bytes space for the tag\n * `decrypt` - true for decryption, false otherwise\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_crypto_gcm(
        key: *const u8,
        iv: *const u8,
        aad: *const u8,
        aad_length: usize,
        input: *const u8,
        output: *mut u8,
        length: usize,
        tag: *mut u8,
        decrypt: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Encrypt the input using AES-GCM and generate a tag\n\n Inits and deinits the AES engine internally.\n\n # Arguments\n\n* `key` (direction in) - pointer to 32 bytes key data\n * `iv` (direction in) - pointer to 12 bytes Initialization Vector data\n * `aad` (direction in) - pointer to additional authentication data\n * `aad_length` - length of the additional authentication data in bytes\n * `input` (direction in) - pointer to input data\n * `output` (direction out) - pointer to output data\n * `length` - length of the input and output in bytes\n * `tag` (direction out) - pointer to 16 bytes space for the tag\n\n # Returns\n\nFuriHalCryptoGCMStateOk on success, FuriHalCryptoGCMStateError on\n failure"]
    pub fn furi_hal_crypto_gcm_encrypt_and_tag(
        key: *const u8,
        iv: *const u8,
        aad: *const u8,
        aad_length: usize,
        input: *const u8,
        output: *mut u8,
        length: usize,
        tag: *mut u8,
    ) -> FuriHalCryptoGCMState;
}
unsafe extern "C" {
    #[doc = "Decrypt the input using AES-GCM and verify the provided tag\n\n Inits and deinits the AES engine internally.\n\n # Arguments\n\n* `key` (direction in) - pointer to 32 bytes key data\n * `iv` (direction in) - pointer to 12 bytes Initialization Vector data\n * `aad` (direction in) - pointer to additional authentication data\n * `aad_length` - length of the additional authentication data in bytes\n * `input` (direction in) - pointer to input data\n * `output` (direction out) - pointer to output data\n * `length` - length of the input and output in bytes\n * `tag` (direction out) - pointer to 16 bytes tag\n\n # Returns\n\nFuriHalCryptoGCMStateOk on success, FuriHalCryptoGCMStateError on\n failure, FuriHalCryptoGCMStateAuthFailure if the tag does not\n match"]
    pub fn furi_hal_crypto_gcm_decrypt_and_verify(
        key: *const u8,
        iv: *const u8,
        aad: *const u8,
        aad_length: usize,
        input: *const u8,
        output: *mut u8,
        length: usize,
        tag: *const u8,
    ) -> FuriHalCryptoGCMState;
}
unsafe extern "C" {
    #[doc = "Enable MCU debug"]
    pub fn furi_hal_debug_enable();
}
unsafe extern "C" {
    #[doc = "Disable MCU debug"]
    pub fn furi_hal_debug_disable();
}
unsafe extern "C" {
    #[doc = "Check if GDB debug session is active"]
    pub fn furi_hal_debug_is_gdb_session_active() -> bool;
}
unsafe extern "C" {
    #[doc = "Early initialization"]
    pub fn furi_hal_dma_init_early();
}
unsafe extern "C" {
    #[doc = "Early de-initialization"]
    pub fn furi_hal_dma_deinit_early();
}
unsafe extern "C" {
    pub fn furi_hal_os_tick();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSdInfo {
    #[doc = "< total capacity in bytes"]
    pub capacity: u64,
    #[doc = "< block size"]
    pub block_size: u32,
    #[doc = "< logical capacity in blocks"]
    pub logical_block_count: u32,
    #[doc = "< logical block size in bytes"]
    pub logical_block_size: u32,
    #[doc = "< manufacturer ID"]
    pub manufacturer_id: u8,
    #[doc = "< OEM ID, 2 characters + null terminator"]
    pub oem_id: [core::ffi::c_char; 3usize],
    #[doc = "< product name, 5 characters + null terminator"]
    pub product_name: [core::ffi::c_char; 6usize],
    #[doc = "< product revision major"]
    pub product_revision_major: u8,
    #[doc = "< product revision minor"]
    pub product_revision_minor: u8,
    #[doc = "< product serial number"]
    pub product_serial_number: u32,
    #[doc = "< manufacturing month"]
    pub manufacturing_month: u8,
    #[doc = "< manufacturing year"]
    pub manufacturing_year: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalSdInfo"][::core::mem::size_of::<FuriHalSdInfo>() - 40usize];
    ["Alignment of FuriHalSdInfo"][::core::mem::align_of::<FuriHalSdInfo>() - 8usize];
    ["Offset of field: FuriHalSdInfo::capacity"]
        [::core::mem::offset_of!(FuriHalSdInfo, capacity) - 0usize];
    ["Offset of field: FuriHalSdInfo::block_size"]
        [::core::mem::offset_of!(FuriHalSdInfo, block_size) - 8usize];
    ["Offset of field: FuriHalSdInfo::logical_block_count"]
        [::core::mem::offset_of!(FuriHalSdInfo, logical_block_count) - 12usize];
    ["Offset of field: FuriHalSdInfo::logical_block_size"]
        [::core::mem::offset_of!(FuriHalSdInfo, logical_block_size) - 16usize];
    ["Offset of field: FuriHalSdInfo::manufacturer_id"]
        [::core::mem::offset_of!(FuriHalSdInfo, manufacturer_id) - 20usize];
    ["Offset of field: FuriHalSdInfo::oem_id"]
        [::core::mem::offset_of!(FuriHalSdInfo, oem_id) - 21usize];
    ["Offset of field: FuriHalSdInfo::product_name"]
        [::core::mem::offset_of!(FuriHalSdInfo, product_name) - 24usize];
    ["Offset of field: FuriHalSdInfo::product_revision_major"]
        [::core::mem::offset_of!(FuriHalSdInfo, product_revision_major) - 30usize];
    ["Offset of field: FuriHalSdInfo::product_revision_minor"]
        [::core::mem::offset_of!(FuriHalSdInfo, product_revision_minor) - 31usize];
    ["Offset of field: FuriHalSdInfo::product_serial_number"]
        [::core::mem::offset_of!(FuriHalSdInfo, product_serial_number) - 32usize];
    ["Offset of field: FuriHalSdInfo::manufacturing_month"]
        [::core::mem::offset_of!(FuriHalSdInfo, manufacturing_month) - 36usize];
    ["Offset of field: FuriHalSdInfo::manufacturing_year"]
        [::core::mem::offset_of!(FuriHalSdInfo, manufacturing_year) - 38usize];
};
unsafe extern "C" {
    #[doc = "Init SD card presence detection"]
    pub fn furi_hal_sd_presence_init();
}
unsafe extern "C" {
    #[doc = "Get SD card status\n # Returns\n\ntrue if SD card is present"]
    pub fn furi_hal_sd_is_present() -> bool;
}
unsafe extern "C" {
    #[doc = "SD card max mount retry count\n # Returns\n\nuint8_t"]
    pub fn furi_hal_sd_max_mount_retry_count() -> u8;
}
unsafe extern "C" {
    #[doc = "Init SD card\n # Arguments\n\n* `power_reset` - reset card power\n # Returns\n\nFuriStatus"]
    pub fn furi_hal_sd_init(power_reset: bool) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Read blocks from SD card\n # Arguments\n\n* `buff` -\n * `sector` -\n * `count` -\n # Returns\n\nFuriStatus"]
    pub fn furi_hal_sd_read_blocks(buff: *mut u32, sector: u32, count: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Write blocks to SD card\n # Arguments\n\n* `buff` -\n * `sector` -\n * `count` -\n # Returns\n\nFuriStatus"]
    pub fn furi_hal_sd_write_blocks(buff: *const u32, sector: u32, count: u32) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get SD card info\n # Arguments\n\n* `info` -\n # Returns\n\nFuriStatus"]
    pub fn furi_hal_sd_info(info: *mut FuriHalSdInfo) -> FuriStatus;
}
unsafe extern "C" {
    #[doc = "Get SD card state\n # Returns\n\nFuriStatus"]
    pub fn furi_hal_sd_get_card_state() -> FuriStatus;
}
#[doc = "I2C_LL_ES_INIT I2C Exported Init structure\n # "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_I2C_InitTypeDef {
    #[doc = "< Specifies the peripheral mode.\nThis parameter can be a value of I2C_LL_EC_PERIPHERAL_MODE.\n\nThis feature can be modified afterwards using unitary function\nLL_I2C_SetMode()."]
    pub PeripheralMode: u32,
    #[doc = "< Specifies the SDA setup, hold time and the SCL high, low period values.\nThis parameter must be set by referring to the STM32CubeMX Tool and\nthe helper macro __LL_I2C_CONVERT_TIMINGS().\n\nThis feature can be modified afterwards using unitary function\nLL_I2C_SetTiming()."]
    pub Timing: u32,
    #[doc = "< Enables or disables analog noise filter.\nThis parameter can be a value of I2C_LL_EC_ANALOGFILTER_SELECTION.\n\nThis feature can be modified afterwards using unitary functions\nLL_I2C_EnableAnalogFilter() or LL_I2C_DisableAnalogFilter()."]
    pub AnalogFilter: u32,
    #[doc = "< Configures the digital noise filter.\nThis parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F.\n\nThis feature can be modified afterwards using unitary function\nLL_I2C_SetDigitalFilter()."]
    pub DigitalFilter: u32,
    #[doc = "< Specifies the device own address 1.\nThis parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF.\n\nThis feature can be modified afterwards using unitary function\nLL_I2C_SetOwnAddress1()."]
    pub OwnAddress1: u32,
    #[doc = "< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive\nmatch code or next received byte.\nThis parameter can be a value of I2C_LL_EC_I2C_ACKNOWLEDGE.\n\nThis feature can be modified afterwards using unitary function\nLL_I2C_AcknowledgeNextData()."]
    pub TypeAcknowledge: u32,
    #[doc = "< Specifies the device own address 1 size (7-bit or 10-bit).\nThis parameter can be a value of I2C_LL_EC_OWNADDRESS1.\n\nThis feature can be modified afterwards using unitary function\nLL_I2C_SetOwnAddress1()."]
    pub OwnAddrSize: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_I2C_InitTypeDef"][::core::mem::size_of::<LL_I2C_InitTypeDef>() - 28usize];
    ["Alignment of LL_I2C_InitTypeDef"][::core::mem::align_of::<LL_I2C_InitTypeDef>() - 4usize];
    ["Offset of field: LL_I2C_InitTypeDef::PeripheralMode"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, PeripheralMode) - 0usize];
    ["Offset of field: LL_I2C_InitTypeDef::Timing"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, Timing) - 4usize];
    ["Offset of field: LL_I2C_InitTypeDef::AnalogFilter"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, AnalogFilter) - 8usize];
    ["Offset of field: LL_I2C_InitTypeDef::DigitalFilter"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, DigitalFilter) - 12usize];
    ["Offset of field: LL_I2C_InitTypeDef::OwnAddress1"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, OwnAddress1) - 16usize];
    ["Offset of field: LL_I2C_InitTypeDef::TypeAcknowledge"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, TypeAcknowledge) - 20usize];
    ["Offset of field: LL_I2C_InitTypeDef::OwnAddrSize"]
        [::core::mem::offset_of!(LL_I2C_InitTypeDef, OwnAddrSize) - 24usize];
};
unsafe extern "C" {
    #[doc = "I2C_LL_EF_Init Initialization and de-initialization functions\n # "]
    pub fn LL_I2C_Init(
        I2Cx: *mut I2C_TypeDef,
        I2C_InitStruct: *const LL_I2C_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "< Bus initialization event, called on system start"]
pub const FuriHalI2cBusEventInit: FuriHalI2cBusEvent = FuriHalI2cBusEvent(0);
#[doc = "< Bus deinitialization event, called on system stop"]
pub const FuriHalI2cBusEventDeinit: FuriHalI2cBusEvent = FuriHalI2cBusEvent(1);
#[doc = "< Bus lock event, called before activation"]
pub const FuriHalI2cBusEventLock: FuriHalI2cBusEvent = FuriHalI2cBusEvent(2);
#[doc = "< Bus unlock event, called after deactivation"]
pub const FuriHalI2cBusEventUnlock: FuriHalI2cBusEvent = FuriHalI2cBusEvent(3);
#[doc = "< Bus activation event, called before handle activation"]
pub const FuriHalI2cBusEventActivate: FuriHalI2cBusEvent = FuriHalI2cBusEvent(4);
#[doc = "< Bus deactivation event, called after handle deactivation"]
pub const FuriHalI2cBusEventDeactivate: FuriHalI2cBusEvent = FuriHalI2cBusEvent(5);
#[repr(transparent)]
#[doc = "FuriHal i2c bus states"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalI2cBusEvent(pub core::ffi::c_uchar);
#[doc = "FuriHal i2c bus event callback"]
pub type FuriHalI2cBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalI2cBus, event: FuriHalI2cBusEvent),
>;
#[doc = "FuriHal i2c bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBus {
    pub i2c: *mut I2C_TypeDef,
    pub current_handle: *mut FuriHalI2cBusHandle,
    pub callback: FuriHalI2cBusEventCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalI2cBus"][::core::mem::size_of::<FuriHalI2cBus>() - 12usize];
    ["Alignment of FuriHalI2cBus"][::core::mem::align_of::<FuriHalI2cBus>() - 4usize];
    ["Offset of field: FuriHalI2cBus::i2c"][::core::mem::offset_of!(FuriHalI2cBus, i2c) - 0usize];
    ["Offset of field: FuriHalI2cBus::current_handle"]
        [::core::mem::offset_of!(FuriHalI2cBus, current_handle) - 4usize];
    ["Offset of field: FuriHalI2cBus::callback"]
        [::core::mem::offset_of!(FuriHalI2cBus, callback) - 8usize];
};
#[doc = "< Handle activate: connect gpio and apply bus config"]
pub const FuriHalI2cBusHandleEventActivate: FuriHalI2cBusHandleEvent = FuriHalI2cBusHandleEvent(0);
#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
pub const FuriHalI2cBusHandleEventDeactivate: FuriHalI2cBusHandleEvent =
    FuriHalI2cBusHandleEvent(1);
#[repr(transparent)]
#[doc = "FuriHal i2c handle states"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalI2cBusHandleEvent(pub core::ffi::c_uchar);
#[doc = "FuriHal i2c handle event callback"]
pub type FuriHalI2cBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalI2cBusHandle, event: FuriHalI2cBusHandleEvent),
>;
#[doc = "FuriHal i2c handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBusHandle {
    pub bus: *mut FuriHalI2cBus,
    pub callback: FuriHalI2cBusHandleEventCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalI2cBusHandle"][::core::mem::size_of::<FuriHalI2cBusHandle>() - 8usize];
    ["Alignment of FuriHalI2cBusHandle"][::core::mem::align_of::<FuriHalI2cBusHandle>() - 4usize];
    ["Offset of field: FuriHalI2cBusHandle::bus"]
        [::core::mem::offset_of!(FuriHalI2cBusHandle, bus) - 0usize];
    ["Offset of field: FuriHalI2cBusHandle::callback"]
        [::core::mem::offset_of!(FuriHalI2cBusHandle, callback) - 4usize];
};
unsafe extern "C" {
    #[doc = "Internal(power) i2c bus, I2C1, under reset when not used"]
    pub static mut furi_hal_i2c_bus_power: FuriHalI2cBus;
}
unsafe extern "C" {
    #[doc = "External i2c bus, I2C3, under reset when not used"]
    pub static mut furi_hal_i2c_bus_external: FuriHalI2cBus;
}
unsafe extern "C" {
    #[doc = "Handle for internal(power) i2c bus\n Bus: furi_hal_i2c_bus_external\n Pins: PA9(SCL) / PA10(SDA), float on release\n Params: 400khz"]
    pub static mut furi_hal_i2c_handle_power: FuriHalI2cBusHandle;
}
unsafe extern "C" {
    #[doc = "Handle for external i2c bus\n Bus: furi_hal_i2c_bus_external\n Pins: PC0(SCL) / PC1(SDA), float on release\n Params: 100khz"]
    pub static mut furi_hal_i2c_handle_external: FuriHalI2cBusHandle;
}
#[doc = "Begin the transaction by sending a START condition followed by the\n address"]
pub const FuriHalI2cBeginStart: FuriHalI2cBegin = FuriHalI2cBegin(0);
#[doc = "Begin the transaction by sending a RESTART condition followed by the\n address\n > **Note:** Must follow a transaction ended with\n FuriHalI2cEndAwaitRestart"]
pub const FuriHalI2cBeginRestart: FuriHalI2cBegin = FuriHalI2cBegin(1);
#[doc = "Continue the previous transaction with new data\n > **Note:** Must follow a transaction ended with FuriHalI2cEndPause and\n be of the same type (RX/TX)"]
pub const FuriHalI2cBeginResume: FuriHalI2cBegin = FuriHalI2cBegin(2);
#[repr(transparent)]
#[doc = "Transaction beginning signal"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalI2cBegin(pub core::ffi::c_uchar);
#[doc = "End the transaction by sending a STOP condition"]
pub const FuriHalI2cEndStop: FuriHalI2cEnd = FuriHalI2cEnd(0);
#[doc = "End the transaction by clock stretching\n > **Note:** Must be followed by a transaction using\n FuriHalI2cBeginRestart"]
pub const FuriHalI2cEndAwaitRestart: FuriHalI2cEnd = FuriHalI2cEnd(1);
#[doc = "Pauses the transaction by clock stretching\n > **Note:** Must be followed by a transaction using FuriHalI2cBeginResume"]
pub const FuriHalI2cEndPause: FuriHalI2cEnd = FuriHalI2cEnd(2);
#[repr(transparent)]
#[doc = "Transaction end signal"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalI2cEnd(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Acquire I2C bus handle\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance"]
    pub fn furi_hal_i2c_acquire(handle: *mut FuriHalI2cBusHandle);
}
unsafe extern "C" {
    #[doc = "Release I2C bus handle\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance acquired in\n `furi_hal_i2c_acquire`"]
    pub fn furi_hal_i2c_release(handle: *mut FuriHalI2cBusHandle);
}
unsafe extern "C" {
    #[doc = "Perform I2C TX transfer\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `address` - I2C slave address\n * `data` - Pointer to data buffer\n * `size` - Size of data buffer\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_tx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *const u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C TX transfer, with additional settings.\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `address` - I2C slave address\n * `ten_bit` - Whether the address is 10 bits wide\n * `data` - Pointer to data buffer\n * `size` - Size of data buffer\n * `begin` - How to begin the transaction\n * `end` - How to end the transaction\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_tx_ext(
        handle: *mut FuriHalI2cBusHandle,
        address: u16,
        ten_bit: bool,
        data: *const u8,
        size: usize,
        begin: FuriHalI2cBegin,
        end: FuriHalI2cEnd,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C RX transfer\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `address` - I2C slave address\n * `data` - Pointer to data buffer\n * `size` - Size of data buffer\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_rx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C RX transfer, with additional settings.\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `address` - I2C slave address\n * `ten_bit` - Whether the address is 10 bits wide\n * `data` - Pointer to data buffer\n * `size` - Size of data buffer\n * `begin` - How to begin the transaction\n * `end` - How to end the transaction\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_rx_ext(
        handle: *mut FuriHalI2cBusHandle,
        address: u16,
        ten_bit: bool,
        data: *mut u8,
        size: usize,
        begin: FuriHalI2cBegin,
        end: FuriHalI2cEnd,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C TX and RX transfers\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `address` - I2C slave address\n * `tx_data` - Pointer to TX data buffer\n * `tx_size` - Size of TX data buffer\n * `rx_data` - Pointer to RX data buffer\n * `rx_size` - Size of RX data buffer\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_trx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        tx_data: *const u8,
        tx_size: usize,
        rx_data: *mut u8,
        rx_size: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Check if I2C device presents on bus\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue if device present and is ready, false otherwise"]
    pub fn furi_hal_i2c_is_device_ready(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C device register read (8-bit)\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `reg_addr` - Register address\n * `data` - Pointer to register value\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u8,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C device register read (16-bit)\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `reg_addr` - Register address\n * `data` - Pointer to register value\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u16,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C device memory read\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `mem_addr` - Memory start address\n * `data` - Pointer to data buffer\n * `len` - Size of data buffer\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *mut u8,
        len: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C device register write (8-bit)\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `reg_addr` - Register address\n * `data` - Register value\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u8,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C device register write (16-bit)\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `reg_addr` - Register address\n * `data` - Register value\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u16,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Perform I2C device memory\n\n # Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n * `i2c_addr` - I2C slave address\n * `mem_addr` - Memory start address\n * `data` - Pointer to data buffer\n * `len` - Size of data buffer\n * `timeout` - Timeout in milliseconds\n\n # Returns\n\ntrue on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *const u8,
        len: usize,
        timeout: u32,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRegionBand {
    pub start: u32,
    pub end: u32,
    pub power_limit: i8,
    pub duty_cycle: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalRegionBand"][::core::mem::size_of::<FuriHalRegionBand>() - 12usize];
    ["Alignment of FuriHalRegionBand"][::core::mem::align_of::<FuriHalRegionBand>() - 4usize];
    ["Offset of field: FuriHalRegionBand::start"]
        [::core::mem::offset_of!(FuriHalRegionBand, start) - 0usize];
    ["Offset of field: FuriHalRegionBand::end"]
        [::core::mem::offset_of!(FuriHalRegionBand, end) - 4usize];
    ["Offset of field: FuriHalRegionBand::power_limit"]
        [::core::mem::offset_of!(FuriHalRegionBand, power_limit) - 8usize];
    ["Offset of field: FuriHalRegionBand::duty_cycle"]
        [::core::mem::offset_of!(FuriHalRegionBand, duty_cycle) - 9usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct FuriHalRegion {
    pub country_code: [core::ffi::c_char; 4usize],
    pub bands_count: u16,
    pub bands: __IncompleteArrayField<FuriHalRegionBand>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalRegion"][::core::mem::size_of::<FuriHalRegion>() - 8usize];
    ["Alignment of FuriHalRegion"][::core::mem::align_of::<FuriHalRegion>() - 4usize];
    ["Offset of field: FuriHalRegion::country_code"]
        [::core::mem::offset_of!(FuriHalRegion, country_code) - 0usize];
    ["Offset of field: FuriHalRegion::bands_count"]
        [::core::mem::offset_of!(FuriHalRegion, bands_count) - 4usize];
    ["Offset of field: FuriHalRegion::bands"]
        [::core::mem::offset_of!(FuriHalRegion, bands) - 8usize];
};
unsafe extern "C" {
    #[doc = "Get Region Data.\n\n Region data may be allocated in Flash or in RAM.\n Keep in mind that we don't do memory management on our side.\n\n # Returns\n\npointer to FuriHalRegion instance (in RAM or Flash, check before freeing on region update)"]
    pub fn furi_hal_region_get() -> *const FuriHalRegion;
}
unsafe extern "C" {
    #[doc = "Set device region data\n\n # Arguments\n\n* `region` - pointer to the FuriHalRegion"]
    pub fn furi_hal_region_set(region: *mut FuriHalRegion);
}
unsafe extern "C" {
    #[doc = "Check if region data provisioned\n\n # Returns\n\ntrue if provisioned, false otherwise"]
    pub fn furi_hal_region_is_provisioned() -> bool;
}
unsafe extern "C" {
    #[doc = "Get region name\n\n 2 letter Region code according to iso 3166 standard\n There are 2 extra values that we use in special cases:\n - \"00\" - developer edition, unlocked\n - \"WW\" - world wide, region provisioned by default\n - \"--\" - no provisioned region\n\n # Returns\n\nPointer to string"]
    pub fn furi_hal_region_get_name() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "heck if transmission is allowed on this frequency for your flipper region\n\n # Arguments\n\n* `frequency` (direction in) - The frequency\n * `value` - frequency in Hz\n\n # Returns\n\ntrue if allowed"]
    pub fn furi_hal_region_is_frequency_allowed(frequency: u32) -> bool;
}
unsafe extern "C" {
    #[doc = "Get band data for frequency\n\n\n\n # Arguments\n\n* `frequency` (direction in) - The frequency\n\n # Returns\n\n{ description_of_the_return_value }"]
    pub fn furi_hal_region_get_band(frequency: u32) -> *const FuriHalRegionBand;
}
pub const InputKeyUp: InputKey = InputKey(0);
pub const InputKeyDown: InputKey = InputKey(1);
pub const InputKeyRight: InputKey = InputKey(2);
pub const InputKeyLeft: InputKey = InputKey(3);
pub const InputKeyOk: InputKey = InputKey(4);
pub const InputKeyBack: InputKey = InputKey(5);
#[doc = "< Special value"]
pub const InputKeyMAX: InputKey = InputKey(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct InputKey(pub core::ffi::c_uchar);
pub const LightRed: Light = Light(1);
pub const LightGreen: Light = Light(2);
pub const LightBlue: Light = Light(4);
pub const LightBacklight: Light = Light(8);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Light(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputPin {
    pub gpio: *const GpioPin,
    pub key: InputKey,
    pub inverted: bool,
    pub name: *const core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InputPin"][::core::mem::size_of::<InputPin>() - 12usize];
    ["Alignment of InputPin"][::core::mem::align_of::<InputPin>() - 4usize];
    ["Offset of field: InputPin::gpio"][::core::mem::offset_of!(InputPin, gpio) - 0usize];
    ["Offset of field: InputPin::key"][::core::mem::offset_of!(InputPin, key) - 4usize];
    ["Offset of field: InputPin::inverted"][::core::mem::offset_of!(InputPin, inverted) - 5usize];
    ["Offset of field: InputPin::name"][::core::mem::offset_of!(InputPin, name) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPinRecord {
    pub pin: *const GpioPin,
    pub name: *const core::ffi::c_char,
    pub channel: FuriHalAdcChannel,
    pub number: u8,
    pub debug: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GpioPinRecord"][::core::mem::size_of::<GpioPinRecord>() - 12usize];
    ["Alignment of GpioPinRecord"][::core::mem::align_of::<GpioPinRecord>() - 4usize];
    ["Offset of field: GpioPinRecord::pin"][::core::mem::offset_of!(GpioPinRecord, pin) - 0usize];
    ["Offset of field: GpioPinRecord::name"][::core::mem::offset_of!(GpioPinRecord, name) - 4usize];
    ["Offset of field: GpioPinRecord::channel"]
        [::core::mem::offset_of!(GpioPinRecord, channel) - 8usize];
    ["Offset of field: GpioPinRecord::number"]
        [::core::mem::offset_of!(GpioPinRecord, number) - 9usize];
    ["Offset of field: GpioPinRecord::debug"]
        [::core::mem::offset_of!(GpioPinRecord, debug) - 10usize];
};
unsafe extern "C" {
    pub static input_pins: [InputPin; 0usize];
}
unsafe extern "C" {
    pub static input_pins_count: usize;
}
unsafe extern "C" {
    pub static gpio_pins: [GpioPinRecord; 0usize];
}
unsafe extern "C" {
    pub static gpio_pins_count: usize;
}
unsafe extern "C" {
    pub static gpio_swdio: GpioPin;
}
unsafe extern "C" {
    pub static gpio_swclk: GpioPin;
}
unsafe extern "C" {
    pub static gpio_vibro: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ibutton: GpioPin;
}
unsafe extern "C" {
    pub static gpio_cc1101_g0: GpioPin;
}
unsafe extern "C" {
    pub static gpio_rf_sw_0: GpioPin;
}
unsafe extern "C" {
    pub static gpio_subghz_cs: GpioPin;
}
unsafe extern "C" {
    pub static gpio_display_cs: GpioPin;
}
unsafe extern "C" {
    pub static gpio_display_rst_n: GpioPin;
}
unsafe extern "C" {
    pub static gpio_display_di: GpioPin;
}
unsafe extern "C" {
    pub static gpio_sdcard_cs: GpioPin;
}
unsafe extern "C" {
    pub static gpio_sdcard_cd: GpioPin;
}
unsafe extern "C" {
    pub static gpio_nfc_cs: GpioPin;
}
unsafe extern "C" {
    pub static gpio_button_up: GpioPin;
}
unsafe extern "C" {
    pub static gpio_button_down: GpioPin;
}
unsafe extern "C" {
    pub static gpio_button_right: GpioPin;
}
unsafe extern "C" {
    pub static gpio_button_left: GpioPin;
}
unsafe extern "C" {
    pub static gpio_button_ok: GpioPin;
}
unsafe extern "C" {
    pub static gpio_button_back: GpioPin;
}
unsafe extern "C" {
    pub static gpio_spi_d_miso: GpioPin;
}
unsafe extern "C" {
    pub static gpio_spi_d_mosi: GpioPin;
}
unsafe extern "C" {
    pub static gpio_spi_d_sck: GpioPin;
}
unsafe extern "C" {
    pub static gpio_spi_r_miso: GpioPin;
}
unsafe extern "C" {
    pub static gpio_spi_r_mosi: GpioPin;
}
unsafe extern "C" {
    pub static gpio_spi_r_sck: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pc0: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pc1: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pc3: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pb2: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pb3: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pa4: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pa6: GpioPin;
}
unsafe extern "C" {
    pub static gpio_ext_pa7: GpioPin;
}
unsafe extern "C" {
    pub static gpio_nfc_irq_rfid_pull: GpioPin;
}
unsafe extern "C" {
    pub static gpio_rfid_carrier_out: GpioPin;
}
unsafe extern "C" {
    pub static gpio_rfid_data_in: GpioPin;
}
unsafe extern "C" {
    pub static gpio_rfid_carrier: GpioPin;
}
unsafe extern "C" {
    pub static gpio_infrared_rx: GpioPin;
}
unsafe extern "C" {
    pub static gpio_infrared_tx: GpioPin;
}
unsafe extern "C" {
    pub static gpio_usart_tx: GpioPin;
}
unsafe extern "C" {
    pub static gpio_usart_rx: GpioPin;
}
unsafe extern "C" {
    pub static gpio_i2c_power_sda: GpioPin;
}
unsafe extern "C" {
    pub static gpio_i2c_power_scl: GpioPin;
}
unsafe extern "C" {
    pub static gpio_speaker: GpioPin;
}
unsafe extern "C" {
    pub static gpio_periph_power: GpioPin;
}
unsafe extern "C" {
    pub static gpio_usb_dm: GpioPin;
}
unsafe extern "C" {
    pub static gpio_usb_dp: GpioPin;
}
unsafe extern "C" {
    #[doc = "Get a corresponding external connector pin number for a gpio\n\n # Arguments\n\n* `gpio` - GpioPin\n\n # Returns\n\npin number or -1 if gpio is not on the external connector"]
    pub fn furi_hal_resources_get_ext_pin_number(gpio: *const GpioPin) -> i32;
}
unsafe extern "C" {
    #[doc = "Finds a pin by its name\n\n # Arguments\n\n* `name` - case-insensitive pin name to look for (e.g. `\"Pc3\"`, `\"pA4\"`)\n\n # Returns\n\na pointer to the corresponding `GpioPinRecord` if such a pin exists,\n `NULL` otherwise."]
    pub fn furi_hal_resources_pin_by_name(name: *const core::ffi::c_char) -> *const GpioPinRecord;
}
unsafe extern "C" {
    #[doc = "Finds a pin by its number\n\n # Arguments\n\n* `name` - pin number to look for (e.g. `7`, `4`)\n\n # Returns\n\na pointer to the corresponding `GpioPinRecord` if such a pin exists,\n `NULL` otherwise."]
    pub fn furi_hal_resources_pin_by_number(number: u8) -> *const GpioPinRecord;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DateTime {
    #[doc = "< Hour in 24H format: 0-23"]
    pub hour: u8,
    #[doc = "< Minute: 0-59"]
    pub minute: u8,
    #[doc = "< Second: 0-59"]
    pub second: u8,
    #[doc = "< Current day: 1-31"]
    pub day: u8,
    #[doc = "< Current month: 1-12"]
    pub month: u8,
    #[doc = "< Current year: 2000-2099"]
    pub year: u16,
    #[doc = "< Current weekday: 1-7"]
    pub weekday: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DateTime"][::core::mem::size_of::<DateTime>() - 10usize];
    ["Alignment of DateTime"][::core::mem::align_of::<DateTime>() - 2usize];
    ["Offset of field: DateTime::hour"][::core::mem::offset_of!(DateTime, hour) - 0usize];
    ["Offset of field: DateTime::minute"][::core::mem::offset_of!(DateTime, minute) - 1usize];
    ["Offset of field: DateTime::second"][::core::mem::offset_of!(DateTime, second) - 2usize];
    ["Offset of field: DateTime::day"][::core::mem::offset_of!(DateTime, day) - 3usize];
    ["Offset of field: DateTime::month"][::core::mem::offset_of!(DateTime, month) - 4usize];
    ["Offset of field: DateTime::year"][::core::mem::offset_of!(DateTime, year) - 6usize];
    ["Offset of field: DateTime::weekday"][::core::mem::offset_of!(DateTime, weekday) - 8usize];
};
unsafe extern "C" {
    #[doc = "Validate Date Time\n\n # Arguments\n\n* `datetime` - The datetime to validate\n\n # Returns\n\n{ description_of_the_return_value }"]
    pub fn datetime_validate_datetime(datetime: *mut DateTime) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert DateTime to UNIX timestamp\n\n Mind timezone when perform conversion\n\n # Arguments\n\n* `datetime` - The datetime (UTC)\n\n # Returns\n\nUNIX Timestamp in seconds from UNIX epoch start"]
    pub fn datetime_datetime_to_timestamp(datetime: *mut DateTime) -> u32;
}
unsafe extern "C" {
    #[doc = "Convert UNIX timestamp to DateTime\n\n Mind timezone when perform conversion\n\n # Arguments\n\n* `timestamp` (direction in) - UNIX Timestamp in seconds from UNIX epoch start\n * `datetime` (direction out) - The datetime (UTC)"]
    pub fn datetime_timestamp_to_datetime(timestamp: u32, datetime: *mut DateTime);
}
unsafe extern "C" {
    #[doc = "Gets the number of days in the year according to the Gregorian calendar.\n\n # Arguments\n\n* `year` - Input year.\n\n # Returns\n\nnumber of days in `year`."]
    pub fn datetime_get_days_per_year(year: u16) -> u16;
}
unsafe extern "C" {
    #[doc = "Check if a year a leap year in the Gregorian calendar.\n\n # Arguments\n\n* `year` - Input year.\n\n # Returns\n\ntrue if `year` is a leap year."]
    pub fn datetime_is_leap_year(year: u16) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the number of days in the month.\n\n # Arguments\n\n* `leap_year` - true to calculate based on leap years\n * `month` - month to check, where 1 = January\n # Returns\n\nthe number of days in the month"]
    pub fn datetime_get_days_per_month(leap_year: bool, month: u8) -> u8;
}
pub const FuriHalRtcFlagDebug: FuriHalRtcFlag = FuriHalRtcFlag(1);
pub const FuriHalRtcFlagStorageFormatInternal: FuriHalRtcFlag = FuriHalRtcFlag(2);
pub const FuriHalRtcFlagLock: FuriHalRtcFlag = FuriHalRtcFlag(4);
pub const FuriHalRtcFlagC2Update: FuriHalRtcFlag = FuriHalRtcFlag(8);
pub const FuriHalRtcFlagHandOrient: FuriHalRtcFlag = FuriHalRtcFlag(16);
pub const FuriHalRtcFlagLegacySleep: FuriHalRtcFlag = FuriHalRtcFlag(32);
pub const FuriHalRtcFlagStealthMode: FuriHalRtcFlag = FuriHalRtcFlag(64);
pub const FuriHalRtcFlagDetailedFilename: FuriHalRtcFlag = FuriHalRtcFlag(128);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcFlag(pub core::ffi::c_uchar);
#[doc = "< Normal boot mode, default value"]
pub const FuriHalRtcBootModeNormal: FuriHalRtcBootMode = FuriHalRtcBootMode(0);
#[doc = "< Boot to DFU (MCU bootloader by ST)"]
pub const FuriHalRtcBootModeDfu: FuriHalRtcBootMode = FuriHalRtcBootMode(1);
#[doc = "< Boot to Update, pre update"]
pub const FuriHalRtcBootModePreUpdate: FuriHalRtcBootMode = FuriHalRtcBootMode(2);
#[doc = "< Boot to Update, main"]
pub const FuriHalRtcBootModeUpdate: FuriHalRtcBootMode = FuriHalRtcBootMode(3);
#[doc = "< Boot to Update, post update"]
pub const FuriHalRtcBootModePostUpdate: FuriHalRtcBootMode = FuriHalRtcBootMode(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcBootMode(pub core::ffi::c_uchar);
#[doc = "< Disable allocation tracking"]
pub const FuriHalRtcHeapTrackModeNone: FuriHalRtcHeapTrackMode = FuriHalRtcHeapTrackMode(0);
#[doc = "< Enable allocation tracking for main application thread"]
pub const FuriHalRtcHeapTrackModeMain: FuriHalRtcHeapTrackMode = FuriHalRtcHeapTrackMode(1);
#[doc = "< Enable allocation tracking for main and children application threads"]
pub const FuriHalRtcHeapTrackModeTree: FuriHalRtcHeapTrackMode = FuriHalRtcHeapTrackMode(2);
#[doc = "< Enable allocation tracking for all threads"]
pub const FuriHalRtcHeapTrackModeAll: FuriHalRtcHeapTrackMode = FuriHalRtcHeapTrackMode(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcHeapTrackMode(pub core::ffi::c_uchar);
#[doc = "< RTC structure header"]
pub const FuriHalRtcRegisterHeader: FuriHalRtcRegister = FuriHalRtcRegister(0);
#[doc = "< Various system bits"]
pub const FuriHalRtcRegisterSystem: FuriHalRtcRegister = FuriHalRtcRegister(1);
#[doc = "< Pointer to Version"]
pub const FuriHalRtcRegisterVersion: FuriHalRtcRegister = FuriHalRtcRegister(2);
#[doc = "< LFS geometry fingerprint"]
pub const FuriHalRtcRegisterLfsFingerprint: FuriHalRtcRegister = FuriHalRtcRegister(3);
#[doc = "< Pointer to last fault message"]
pub const FuriHalRtcRegisterFaultData: FuriHalRtcRegister = FuriHalRtcRegister(4);
#[doc = "< Failed PINs count"]
pub const FuriHalRtcRegisterPinFails: FuriHalRtcRegister = FuriHalRtcRegister(5);
pub const FuriHalRtcRegisterUpdateFolderFSIndex: FuriHalRtcRegister = FuriHalRtcRegister(6);
#[doc = "< Encoded value of the currently set PIN"]
pub const FuriHalRtcRegisterPinValue: FuriHalRtcRegister = FuriHalRtcRegister(7);
#[doc = "< Service value, do not use"]
pub const FuriHalRtcRegisterMAX: FuriHalRtcRegister = FuriHalRtcRegister(8);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcRegister(pub core::ffi::c_uchar);
#[doc = "< Metric measurement units"]
pub const FuriHalRtcLocaleUnitsMetric: FuriHalRtcLocaleUnits = FuriHalRtcLocaleUnits(0);
#[doc = "< Imperial measurement units"]
pub const FuriHalRtcLocaleUnitsImperial: FuriHalRtcLocaleUnits = FuriHalRtcLocaleUnits(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcLocaleUnits(pub core::ffi::c_uchar);
#[doc = "< 24-hour format"]
pub const FuriHalRtcLocaleTimeFormat24h: FuriHalRtcLocaleTimeFormat = FuriHalRtcLocaleTimeFormat(0);
#[doc = "< 12-hour format"]
pub const FuriHalRtcLocaleTimeFormat12h: FuriHalRtcLocaleTimeFormat = FuriHalRtcLocaleTimeFormat(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcLocaleTimeFormat(pub core::ffi::c_uchar);
#[doc = "< Day/Month/Year"]
pub const FuriHalRtcLocaleDateFormatDMY: FuriHalRtcLocaleDateFormat = FuriHalRtcLocaleDateFormat(0);
#[doc = "< Month/Day/Year"]
pub const FuriHalRtcLocaleDateFormatMDY: FuriHalRtcLocaleDateFormat = FuriHalRtcLocaleDateFormat(1);
#[doc = "< Year/Month/Day"]
pub const FuriHalRtcLocaleDateFormatYMD: FuriHalRtcLocaleDateFormat = FuriHalRtcLocaleDateFormat(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcLocaleDateFormat(pub core::ffi::c_uchar);
#[doc = "< Default: USART"]
pub const FuriHalRtcLogDeviceUsart: FuriHalRtcLogDevice = FuriHalRtcLogDevice(0);
#[doc = "< Default: LPUART"]
pub const FuriHalRtcLogDeviceLpuart: FuriHalRtcLogDevice = FuriHalRtcLogDevice(1);
#[doc = "< Reserved for future use"]
pub const FuriHalRtcLogDeviceReserved: FuriHalRtcLogDevice = FuriHalRtcLogDevice(2);
#[doc = "< None, disable serial logging"]
pub const FuriHalRtcLogDeviceNone: FuriHalRtcLogDevice = FuriHalRtcLogDevice(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcLogDevice(pub core::ffi::c_uchar);
#[doc = "< 230400 baud"]
pub const FuriHalRtcLogBaudRate230400: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(0);
#[doc = "< 9600 baud"]
pub const FuriHalRtcLogBaudRate9600: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(1);
#[doc = "< 38400 baud"]
pub const FuriHalRtcLogBaudRate38400: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(2);
#[doc = "< 57600 baud"]
pub const FuriHalRtcLogBaudRate57600: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(3);
#[doc = "< 115200 baud"]
pub const FuriHalRtcLogBaudRate115200: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(4);
#[doc = "< 460800 baud"]
pub const FuriHalRtcLogBaudRate460800: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(5);
#[doc = "< 921600 baud"]
pub const FuriHalRtcLogBaudRate921600: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(6);
#[doc = "< 1843200 baud"]
pub const FuriHalRtcLogBaudRate1843200: FuriHalRtcLogBaudRate = FuriHalRtcLogBaudRate(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalRtcLogBaudRate(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Force sync shadow registers"]
    pub fn furi_hal_rtc_sync_shadow();
}
unsafe extern "C" {
    #[doc = "Reset ALL RTC registers content"]
    pub fn furi_hal_rtc_reset_registers();
}
unsafe extern "C" {
    #[doc = "Get RTC register content\n\n # Arguments\n\n* `reg` (direction in) - The register identifier\n\n # Returns\n\ncontent of the register"]
    pub fn furi_hal_rtc_get_register(reg: FuriHalRtcRegister) -> u32;
}
unsafe extern "C" {
    #[doc = "Set register content\n\n # Arguments\n\n* `reg` (direction in) - The register identifier\n * `value` (direction in) - The value to store into register"]
    pub fn furi_hal_rtc_set_register(reg: FuriHalRtcRegister, value: u32);
}
unsafe extern "C" {
    #[doc = "Set Log Level value\n\n # Arguments\n\n* `level` (direction in) - The level to store"]
    pub fn furi_hal_rtc_set_log_level(level: u8);
}
unsafe extern "C" {
    #[doc = "Get Log Level value\n\n # Returns\n\nThe Log Level value"]
    pub fn furi_hal_rtc_get_log_level() -> u8;
}
unsafe extern "C" {
    #[doc = "Set logging device\n\n # Arguments\n\n* `device` (direction in) - The device"]
    pub fn furi_hal_rtc_set_log_device(device: FuriHalRtcLogDevice);
}
unsafe extern "C" {
    #[doc = "Get logging device\n\n # Returns\n\nThe furi hal rtc log device."]
    pub fn furi_hal_rtc_get_log_device() -> FuriHalRtcLogDevice;
}
unsafe extern "C" {
    #[doc = "Set logging baud rate\n\n # Arguments\n\n* `baud_rate` (direction in) - The baud rate"]
    pub fn furi_hal_rtc_set_log_baud_rate(baud_rate: FuriHalRtcLogBaudRate);
}
unsafe extern "C" {
    #[doc = "Get logging baud rate\n\n # Returns\n\nThe furi hal rtc log baud rate."]
    pub fn furi_hal_rtc_get_log_baud_rate() -> FuriHalRtcLogBaudRate;
}
unsafe extern "C" {
    #[doc = "Set RTC Flag\n\n # Arguments\n\n* `flag` (direction in) - The flag to set"]
    pub fn furi_hal_rtc_set_flag(flag: FuriHalRtcFlag);
}
unsafe extern "C" {
    #[doc = "Reset RTC Flag\n\n # Arguments\n\n* `flag` (direction in) - The flag to reset"]
    pub fn furi_hal_rtc_reset_flag(flag: FuriHalRtcFlag);
}
unsafe extern "C" {
    #[doc = "Check if RTC Flag is set\n\n # Arguments\n\n* `flag` (direction in) - The flag to check\n\n # Returns\n\ntrue if set"]
    pub fn furi_hal_rtc_is_flag_set(flag: FuriHalRtcFlag) -> bool;
}
unsafe extern "C" {
    #[doc = "Set RTC boot mode\n\n # Arguments\n\n* `mode` (direction in) - The mode to set"]
    pub fn furi_hal_rtc_set_boot_mode(mode: FuriHalRtcBootMode);
}
unsafe extern "C" {
    #[doc = "Get RTC boot mode\n\n # Returns\n\nThe RTC boot mode."]
    pub fn furi_hal_rtc_get_boot_mode() -> FuriHalRtcBootMode;
}
unsafe extern "C" {
    #[doc = "Set Heap Track mode\n\n # Arguments\n\n* `mode` (direction in) - The mode to set"]
    pub fn furi_hal_rtc_set_heap_track_mode(mode: FuriHalRtcHeapTrackMode);
}
unsafe extern "C" {
    #[doc = "Get RTC Heap Track mode\n\n # Returns\n\nThe RTC heap track mode."]
    pub fn furi_hal_rtc_get_heap_track_mode() -> FuriHalRtcHeapTrackMode;
}
unsafe extern "C" {
    #[doc = "Set locale units\n\n # Arguments\n\n* `value` (direction in) - The RTC Locale Units"]
    pub fn furi_hal_rtc_set_locale_units(value: FuriHalRtcLocaleUnits);
}
unsafe extern "C" {
    #[doc = "Get RTC Locale Units\n\n # Returns\n\nThe RTC Locale Units."]
    pub fn furi_hal_rtc_get_locale_units() -> FuriHalRtcLocaleUnits;
}
unsafe extern "C" {
    #[doc = "Set RTC Locale Time Format\n\n # Arguments\n\n* `value` (direction in) - The RTC Locale Time Format"]
    pub fn furi_hal_rtc_set_locale_timeformat(value: FuriHalRtcLocaleTimeFormat);
}
unsafe extern "C" {
    #[doc = "Get RTC Locale Time Format\n\n # Returns\n\nThe RTC Locale Time Format."]
    pub fn furi_hal_rtc_get_locale_timeformat() -> FuriHalRtcLocaleTimeFormat;
}
unsafe extern "C" {
    #[doc = "Set RTC Locale Date Format\n\n # Arguments\n\n* `value` (direction in) - The RTC Locale Date Format"]
    pub fn furi_hal_rtc_set_locale_dateformat(value: FuriHalRtcLocaleDateFormat);
}
unsafe extern "C" {
    #[doc = "Get RTC Locale Date Format\n\n # Returns\n\nThe RTC Locale Date Format"]
    pub fn furi_hal_rtc_get_locale_dateformat() -> FuriHalRtcLocaleDateFormat;
}
unsafe extern "C" {
    #[doc = "Set RTC Date Time\n\n # Arguments\n\n* `datetime` - The date time to set"]
    pub fn furi_hal_rtc_set_datetime(datetime: *mut DateTime);
}
unsafe extern "C" {
    #[doc = "Get RTC Date Time\n\n # Arguments\n\n* `datetime` - The datetime"]
    pub fn furi_hal_rtc_get_datetime(datetime: *mut DateTime);
}
#[doc = "Furi HAL RTC alarm callback signature"]
pub type FuriHalRtcAlarmCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Set RTC Fault Data\n\n # Arguments\n\n* `value` (direction in) - The value"]
    pub fn furi_hal_rtc_set_fault_data(value: u32);
}
unsafe extern "C" {
    #[doc = "Get RTC Fault Data\n\n # Returns\n\nRTC Fault Data value"]
    pub fn furi_hal_rtc_get_fault_data() -> u32;
}
unsafe extern "C" {
    #[doc = "Set PIN Fails count\n\n # Arguments\n\n* `value` (direction in) - The PIN Fails count"]
    pub fn furi_hal_rtc_set_pin_fails(value: u32);
}
unsafe extern "C" {
    #[doc = "Get PIN Fails count\n\n # Returns\n\nPIN Fails Count"]
    pub fn furi_hal_rtc_get_pin_fails() -> u32;
}
unsafe extern "C" {
    #[doc = "Get UNIX Timestamp\n\n # Returns\n\nUnix Timestamp in seconds from UNIX epoch start"]
    pub fn furi_hal_rtc_get_timestamp() -> u32;
}
unsafe extern "C" {
    #[doc = "Acquire speaker ownership\n\n You must acquire speaker ownership before use\n\n # Arguments\n\n* `timeout` - Timeout during which speaker ownership must be acquired\n\n # Returns\n\nbool returns true on success"]
    pub fn furi_hal_speaker_acquire(timeout: u32) -> bool;
}
unsafe extern "C" {
    #[doc = "Release speaker ownership\n\n You must release speaker ownership after use"]
    pub fn furi_hal_speaker_release();
}
unsafe extern "C" {
    #[doc = "Check current process speaker ownership\n\n always returns true if called from ISR\n\n # Returns\n\nbool returns true if process owns speaker"]
    pub fn furi_hal_speaker_is_mine() -> bool;
}
unsafe extern "C" {
    #[doc = "Play a note\n\n no ownership check if called from ISR\n\n # Arguments\n\n* `frequency` - The frequency\n * `volume` - The volume"]
    pub fn furi_hal_speaker_start(frequency: f32, volume: f32);
}
unsafe extern "C" {
    #[doc = "Set volume\n\n no ownership check if called from ISR\n\n # Arguments\n\n* `volume` - The volume"]
    pub fn furi_hal_speaker_set_volume(volume: f32);
}
unsafe extern "C" {
    #[doc = "Stop playback\n\n no ownership check if called from ISR"]
    pub fn furi_hal_speaker_stop();
}
unsafe extern "C" {
    #[doc = "Set light value\n\n # Arguments\n\n* `light` - Light\n * `value` - light brightness [0-255]"]
    pub fn furi_hal_light_set(light: Light, value: u8);
}
unsafe extern "C" {
    #[doc = "Start hardware LED blinking mode\n\n # Arguments\n\n* `light` - Light\n * `brightness` - light brightness [0-255]\n * `on_time` - LED on time in ms\n * `period` - LED blink period in ms"]
    pub fn furi_hal_light_blink_start(light: Light, brightness: u8, on_time: u16, period: u16);
}
unsafe extern "C" {
    #[doc = "Stop hardware LED blinking mode"]
    pub fn furi_hal_light_blink_stop();
}
unsafe extern "C" {
    #[doc = "Set color in hardware LED blinking mode\n\n # Arguments\n\n* `light` - Light"]
    pub fn furi_hal_light_blink_set_color(light: Light);
}
unsafe extern "C" {
    #[doc = "Execute sequence\n\n # Arguments\n\n* `sequence` - Sequence to execute"]
    pub fn furi_hal_light_sequence(sequence: *const core::ffi::c_char);
}
#[doc = "Callback type called every time another key-value pair of device information is ready\n\n # Arguments\n\n* `key[in]` - device information type identifier\n * `value[in]` - device information value\n * `last[in]` - whether the passed key-value pair is the last one\n * `context[in]` - to pass to callback"]
pub type PropertyValueCallback = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        last: bool,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyValueContext {
    #[doc = "< key string buffer, must be initialised before use"]
    pub key: *mut FuriString,
    #[doc = "< value string buffer, must be initialised before use"]
    pub value: *mut FuriString,
    #[doc = "< output callback function"]
    pub out: PropertyValueCallback,
    #[doc = "< separator character between key parts"]
    pub sep: core::ffi::c_char,
    #[doc = "< flag to indicate last element"]
    pub last: bool,
    #[doc = "< user-defined context, passed through to out callback"]
    pub context: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PropertyValueContext"][::core::mem::size_of::<PropertyValueContext>() - 20usize];
    ["Alignment of PropertyValueContext"][::core::mem::align_of::<PropertyValueContext>() - 4usize];
    ["Offset of field: PropertyValueContext::key"]
        [::core::mem::offset_of!(PropertyValueContext, key) - 0usize];
    ["Offset of field: PropertyValueContext::value"]
        [::core::mem::offset_of!(PropertyValueContext, value) - 4usize];
    ["Offset of field: PropertyValueContext::out"]
        [::core::mem::offset_of!(PropertyValueContext, out) - 8usize];
    ["Offset of field: PropertyValueContext::sep"]
        [::core::mem::offset_of!(PropertyValueContext, sep) - 12usize];
    ["Offset of field: PropertyValueContext::last"]
        [::core::mem::offset_of!(PropertyValueContext, last) - 13usize];
    ["Offset of field: PropertyValueContext::context"]
        [::core::mem::offset_of!(PropertyValueContext, context) - 16usize];
};
unsafe extern "C" {
    #[doc = "Builds key and value strings and outputs them via a callback function\n\n # Arguments\n\n* `ctx[in]` - local property context\n * `fmt[in]` - value format, set to NULL to bypass formatting\n * `nparts[in]` - number of key parts (separated by character)\n * `...[in]` - list of key parts followed by value"]
    pub fn property_value_out(
        ctx: *mut PropertyValueContext,
        fmt: *const core::ffi::c_char,
        nparts: core::ffi::c_uint,
        ...
    );
}
pub const FuriHalPowerICCharger: FuriHalPowerIC = FuriHalPowerIC(0);
pub const FuriHalPowerICFuelGauge: FuriHalPowerIC = FuriHalPowerIC(1);
#[repr(transparent)]
#[doc = "Power IC type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalPowerIC(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Check if gauge is ok\n\n Verifies that:\n - gauge is alive\n - correct profile loaded\n - self diagnostic status is good\n\n # Returns\n\ntrue if gauge is ok"]
    pub fn furi_hal_power_gauge_is_ok() -> bool;
}
unsafe extern "C" {
    #[doc = "Check if gauge requests system shutdown\n\n # Returns\n\ntrue if system shutdown requested"]
    pub fn furi_hal_power_is_shutdown_requested() -> bool;
}
unsafe extern "C" {
    #[doc = "Enter insomnia mode Prevents device from going to sleep\n Internally increases insomnia level Must be paired with\n furi_hal_power_insomnia_exit"]
    pub fn furi_hal_power_insomnia_enter();
}
unsafe extern "C" {
    #[doc = "Exit insomnia mode Allow device to go to sleep\n Internally decreases insomnia level. Must be paired with\n furi_hal_power_insomnia_enter"]
    pub fn furi_hal_power_insomnia_exit();
}
unsafe extern "C" {
    #[doc = "Check if sleep available\n\n # Returns\n\ntrue if available"]
    pub fn furi_hal_power_sleep_available() -> bool;
}
unsafe extern "C" {
    #[doc = "Go to sleep"]
    pub fn furi_hal_power_sleep();
}
unsafe extern "C" {
    #[doc = "Get predicted remaining battery capacity in percents\n\n # Returns\n\nremaining battery capacity in percents"]
    pub fn furi_hal_power_get_pct() -> u8;
}
unsafe extern "C" {
    #[doc = "Get battery health state in percents\n\n # Returns\n\nhealth in percents"]
    pub fn furi_hal_power_get_bat_health_pct() -> u8;
}
unsafe extern "C" {
    #[doc = "Get charging status\n\n # Returns\n\ntrue if charging"]
    pub fn furi_hal_power_is_charging() -> bool;
}
unsafe extern "C" {
    #[doc = "Get charge complete status\n\n # Returns\n\ntrue if done charging and connected to charger"]
    pub fn furi_hal_power_is_charging_done() -> bool;
}
unsafe extern "C" {
    #[doc = "Switch MCU to SHUTDOWN"]
    pub fn furi_hal_power_shutdown();
}
unsafe extern "C" {
    #[doc = "Poweroff device"]
    pub fn furi_hal_power_off();
}
unsafe extern "C" {
    #[doc = "Reset device"]
    pub fn furi_hal_power_reset();
}
unsafe extern "C" {
    #[doc = "OTG enable"]
    pub fn furi_hal_power_enable_otg() -> bool;
}
unsafe extern "C" {
    #[doc = "OTG disable"]
    pub fn furi_hal_power_disable_otg();
}
unsafe extern "C" {
    #[doc = "Check OTG status fault"]
    pub fn furi_hal_power_check_otg_fault() -> bool;
}
unsafe extern "C" {
    #[doc = "Check OTG status and disable it if falt happened"]
    pub fn furi_hal_power_check_otg_status();
}
unsafe extern "C" {
    #[doc = "Get OTG status\n\n # Returns\n\ntrue if enabled"]
    pub fn furi_hal_power_is_otg_enabled() -> bool;
}
unsafe extern "C" {
    #[doc = "Get battery charge voltage limit in V\n\n # Returns\n\nvoltage in V"]
    pub fn furi_hal_power_get_battery_charge_voltage_limit() -> f32;
}
unsafe extern "C" {
    #[doc = "Set battery charge voltage limit in V\n\n Invalid values will be clamped downward to the nearest valid value.\n\n # Arguments\n\n* `voltage` (direction in) - voltage in V"]
    pub fn furi_hal_power_set_battery_charge_voltage_limit(voltage: f32);
}
unsafe extern "C" {
    #[doc = "Get remaining battery battery capacity in mAh\n\n # Returns\n\ncapacity in mAh"]
    pub fn furi_hal_power_get_battery_remaining_capacity() -> u32;
}
unsafe extern "C" {
    #[doc = "Get full charge battery capacity in mAh\n\n # Returns\n\ncapacity in mAh"]
    pub fn furi_hal_power_get_battery_full_capacity() -> u32;
}
unsafe extern "C" {
    #[doc = "Get battery capacity in mAh from battery profile\n\n # Returns\n\ncapacity in mAh"]
    pub fn furi_hal_power_get_battery_design_capacity() -> u32;
}
unsafe extern "C" {
    #[doc = "Get battery voltage in V\n\n # Arguments\n\n* `ic` (direction in) - FuriHalPowerIc to get measurment\n\n # Returns\n\nvoltage in V"]
    pub fn furi_hal_power_get_battery_voltage(ic: FuriHalPowerIC) -> f32;
}
unsafe extern "C" {
    #[doc = "Get battery current in A\n\n # Arguments\n\n* `ic` (direction in) - FuriHalPowerIc to get measurment\n\n # Returns\n\ncurrent in A"]
    pub fn furi_hal_power_get_battery_current(ic: FuriHalPowerIC) -> f32;
}
unsafe extern "C" {
    #[doc = "Get temperature in C\n\n # Arguments\n\n* `ic` (direction in) - FuriHalPowerIc to get measurment\n\n # Returns\n\ntemperature in C"]
    pub fn furi_hal_power_get_battery_temperature(ic: FuriHalPowerIC) -> f32;
}
unsafe extern "C" {
    #[doc = "Get USB voltage in V\n\n # Returns\n\nvoltage in V"]
    pub fn furi_hal_power_get_usb_voltage() -> f32;
}
unsafe extern "C" {
    #[doc = "Enable 3.3v on external gpio and sd card"]
    pub fn furi_hal_power_enable_external_3_3v();
}
unsafe extern "C" {
    #[doc = "Disable 3.3v on external gpio and sd card"]
    pub fn furi_hal_power_disable_external_3_3v();
}
unsafe extern "C" {
    #[doc = "Enter supress charge mode.\n\n Use this function when your application need clean power supply."]
    pub fn furi_hal_power_suppress_charge_enter();
}
unsafe extern "C" {
    #[doc = "Exit supress charge mode"]
    pub fn furi_hal_power_suppress_charge_exit();
}
unsafe extern "C" {
    #[doc = "Get power information\n\n # Arguments\n\n* `callback` (direction in) - callback to provide with new data\n * `sep` (direction in) - category separator character\n * `context` (direction in) - context to pass to callback"]
    pub fn furi_hal_power_info_get(
        callback: PropertyValueCallback,
        sep: core::ffi::c_char,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get power debug information\n\n # Arguments\n\n* `callback` (direction in) - callback to provide with new data\n * `context` (direction in) - context to pass to callback"]
    pub fn furi_hal_power_debug_get(
        callback: PropertyValueCallback,
        context: *mut core::ffi::c_void,
    );
}
#[doc = "TIM Time Base configuration structure definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_InitTypeDef {
    #[doc = "< Specifies the prescaler value used to divide the TIM clock.\nThis parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_SetPrescaler()."]
    pub Prescaler: u16,
    #[doc = "< Specifies the counter mode.\nThis parameter can be a value of TIM_LL_EC_COUNTERMODE.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_SetCounterMode()."]
    pub CounterMode: u32,
    #[doc = "< Specifies the auto reload value to be loaded into the active\nAuto-Reload Register at the next update event.\nThis parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\nSome timer instances may support 32 bits counters. In that case this parameter must\nbe a number between 0x0000 and 0xFFFFFFFF.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_SetAutoReload()."]
    pub Autoreload: u32,
    #[doc = "< Specifies the clock division.\nThis parameter can be a value of TIM_LL_EC_CLOCKDIVISION.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_SetClockDivision()."]
    pub ClockDivision: u32,
    #[doc = "< Specifies the repetition counter value. Each time the RCR downcounter\nreaches zero, an update event is generated and counting restarts\nfrom the RCR value (N).\nThis means in PWM mode that (N+1) corresponds to:\n- the number of PWM periods in edge-aligned mode\n- the number of half PWM period in center-aligned mode\nGP timers: this parameter must be a number between Min_Data = 0x00 and\nMax_Data = 0xFF.\nAdvanced timers: this parameter must be a number between Min_Data = 0x0000 and\nMax_Data = 0xFFFF.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_SetRepetitionCounter()."]
    pub RepetitionCounter: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_TIM_InitTypeDef"][::core::mem::size_of::<LL_TIM_InitTypeDef>() - 20usize];
    ["Alignment of LL_TIM_InitTypeDef"][::core::mem::align_of::<LL_TIM_InitTypeDef>() - 4usize];
    ["Offset of field: LL_TIM_InitTypeDef::Prescaler"]
        [::core::mem::offset_of!(LL_TIM_InitTypeDef, Prescaler) - 0usize];
    ["Offset of field: LL_TIM_InitTypeDef::CounterMode"]
        [::core::mem::offset_of!(LL_TIM_InitTypeDef, CounterMode) - 4usize];
    ["Offset of field: LL_TIM_InitTypeDef::Autoreload"]
        [::core::mem::offset_of!(LL_TIM_InitTypeDef, Autoreload) - 8usize];
    ["Offset of field: LL_TIM_InitTypeDef::ClockDivision"]
        [::core::mem::offset_of!(LL_TIM_InitTypeDef, ClockDivision) - 12usize];
    ["Offset of field: LL_TIM_InitTypeDef::RepetitionCounter"]
        [::core::mem::offset_of!(LL_TIM_InitTypeDef, RepetitionCounter) - 16usize];
};
#[doc = "TIM Output Compare configuration structure definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_OC_InitTypeDef {
    #[doc = "< Specifies the output mode.\nThis parameter can be a value of TIM_LL_EC_OCMODE.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetMode()."]
    pub OCMode: u32,
    #[doc = "< Specifies the TIM Output Compare state.\nThis parameter can be a value of TIM_LL_EC_OCSTATE.\n\nThis feature can be modified afterwards using unitary functions\nLL_TIM_CC_EnableChannel() or LL_TIM_CC_DisableChannel()."]
    pub OCState: u32,
    #[doc = "< Specifies the TIM complementary Output Compare state.\nThis parameter can be a value of TIM_LL_EC_OCSTATE.\n\nThis feature can be modified afterwards using unitary functions\nLL_TIM_CC_EnableChannel() or LL_TIM_CC_DisableChannel()."]
    pub OCNState: u32,
    #[doc = "< Specifies the Compare value to be loaded into the Capture Compare Register.\nThis parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetCompareCHx (x=1..6)."]
    pub CompareValue: u32,
    #[doc = "< Specifies the output polarity.\nThis parameter can be a value of TIM_LL_EC_OCPOLARITY.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetPolarity()."]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity.\nThis parameter can be a value of TIM_LL_EC_OCPOLARITY.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetPolarity()."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of TIM_LL_EC_OCIDLESTATE.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetIdleState()."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of TIM_LL_EC_OCIDLESTATE.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetIdleState()."]
    pub OCNIdleState: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_TIM_OC_InitTypeDef"][::core::mem::size_of::<LL_TIM_OC_InitTypeDef>() - 32usize];
    ["Alignment of LL_TIM_OC_InitTypeDef"]
        [::core::mem::align_of::<LL_TIM_OC_InitTypeDef>() - 4usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCMode"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCMode) - 0usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCState"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCState) - 4usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCNState"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCNState) - 8usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::CompareValue"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, CompareValue) - 12usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCPolarity"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCPolarity) - 16usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCNPolarity"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCNPolarity) - 20usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCIdleState"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCIdleState) - 24usize];
    ["Offset of field: LL_TIM_OC_InitTypeDef::OCNIdleState"]
        [::core::mem::offset_of!(LL_TIM_OC_InitTypeDef, OCNIdleState) - 28usize];
};
unsafe extern "C" {
    #[doc = "TIM_LL_EF_Init Initialisation and deinitialisation functions\n # "]
    pub fn LL_TIM_DeInit(TIMx: *mut TIM_TypeDef) -> ErrorStatus;
}
unsafe extern "C" {
    pub fn LL_TIM_Init(
        TIMx: *mut TIM_TypeDef,
        TIM_InitStruct: *const LL_TIM_InitTypeDef,
    ) -> ErrorStatus;
}
unsafe extern "C" {
    pub fn LL_TIM_OC_Init(
        TIMx: *mut TIM_TypeDef,
        Channel: u32,
        TIM_OC_InitStruct: *const LL_TIM_OC_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "Timer ISR"]
pub type FuriHalInterruptISR =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub const FuriHalInterruptIdTim1TrgComTim17: FuriHalInterruptId = FuriHalInterruptId(0);
pub const FuriHalInterruptIdTim1Cc: FuriHalInterruptId = FuriHalInterruptId(1);
pub const FuriHalInterruptIdTim1UpTim16: FuriHalInterruptId = FuriHalInterruptId(2);
pub const FuriHalInterruptIdTIM2: FuriHalInterruptId = FuriHalInterruptId(3);
pub const FuriHalInterruptIdDma1Ch1: FuriHalInterruptId = FuriHalInterruptId(4);
pub const FuriHalInterruptIdDma1Ch2: FuriHalInterruptId = FuriHalInterruptId(5);
pub const FuriHalInterruptIdDma1Ch3: FuriHalInterruptId = FuriHalInterruptId(6);
pub const FuriHalInterruptIdDma1Ch4: FuriHalInterruptId = FuriHalInterruptId(7);
pub const FuriHalInterruptIdDma1Ch5: FuriHalInterruptId = FuriHalInterruptId(8);
pub const FuriHalInterruptIdDma1Ch6: FuriHalInterruptId = FuriHalInterruptId(9);
pub const FuriHalInterruptIdDma1Ch7: FuriHalInterruptId = FuriHalInterruptId(10);
pub const FuriHalInterruptIdDma2Ch1: FuriHalInterruptId = FuriHalInterruptId(11);
pub const FuriHalInterruptIdDma2Ch2: FuriHalInterruptId = FuriHalInterruptId(12);
pub const FuriHalInterruptIdDma2Ch3: FuriHalInterruptId = FuriHalInterruptId(13);
pub const FuriHalInterruptIdDma2Ch4: FuriHalInterruptId = FuriHalInterruptId(14);
pub const FuriHalInterruptIdDma2Ch5: FuriHalInterruptId = FuriHalInterruptId(15);
pub const FuriHalInterruptIdDma2Ch6: FuriHalInterruptId = FuriHalInterruptId(16);
pub const FuriHalInterruptIdDma2Ch7: FuriHalInterruptId = FuriHalInterruptId(17);
pub const FuriHalInterruptIdRcc: FuriHalInterruptId = FuriHalInterruptId(18);
pub const FuriHalInterruptIdCOMP: FuriHalInterruptId = FuriHalInterruptId(19);
pub const FuriHalInterruptIdRtcAlarm: FuriHalInterruptId = FuriHalInterruptId(20);
pub const FuriHalInterruptIdHsem: FuriHalInterruptId = FuriHalInterruptId(21);
pub const FuriHalInterruptIdLpTim1: FuriHalInterruptId = FuriHalInterruptId(22);
pub const FuriHalInterruptIdLpTim2: FuriHalInterruptId = FuriHalInterruptId(23);
pub const FuriHalInterruptIdUart1: FuriHalInterruptId = FuriHalInterruptId(24);
pub const FuriHalInterruptIdLpUart1: FuriHalInterruptId = FuriHalInterruptId(25);
pub const FuriHalInterruptIdMax: FuriHalInterruptId = FuriHalInterruptId(26);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalInterruptId(pub core::ffi::c_uchar);
pub const FuriHalInterruptPriorityLowest: FuriHalInterruptPriority = FuriHalInterruptPriority(-3);
pub const FuriHalInterruptPriorityLower: FuriHalInterruptPriority = FuriHalInterruptPriority(-2);
pub const FuriHalInterruptPriorityLow: FuriHalInterruptPriority = FuriHalInterruptPriority(-1);
pub const FuriHalInterruptPriorityNormal: FuriHalInterruptPriority = FuriHalInterruptPriority(0);
pub const FuriHalInterruptPriorityHigh: FuriHalInterruptPriority = FuriHalInterruptPriority(1);
pub const FuriHalInterruptPriorityHigher: FuriHalInterruptPriority = FuriHalInterruptPriority(2);
pub const FuriHalInterruptPriorityHighest: FuriHalInterruptPriority = FuriHalInterruptPriority(3);
pub const FuriHalInterruptPriorityKamiSama: FuriHalInterruptPriority = FuriHalInterruptPriority(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalInterruptPriority(pub core::ffi::c_schar);
unsafe extern "C" {
    #[doc = "Set ISR and enable interrupt with default priority\n\n Interrupt flags are not cleared automatically. You may want to\n ensure that your peripheral status flags are cleared.\n\n # Arguments\n\n* `index` - - interrupt ID\n * `isr` - - your interrupt service routine or use NULL to clear\n * `context` - - isr context"]
    pub fn furi_hal_interrupt_set_isr(
        index: FuriHalInterruptId,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set ISR and enable interrupt with custom priority\n\n Interrupt flags are not cleared automatically. You may want to\n ensure that your peripheral status flags are cleared.\n\n # Arguments\n\n* `index` - - interrupt ID\n * `priority` - - One of FuriHalInterruptPriority\n * `isr` - - your interrupt service routine or use NULL to clear\n * `context` - - isr context"]
    pub fn furi_hal_interrupt_set_isr_ex(
        index: FuriHalInterruptId,
        priority: FuriHalInterruptPriority,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get interrupt name by exception number.\n Exception number can be obtained from IPSR register.\n\n # Arguments\n\n* `exception_number` -\n # Returns\n\nconst char* or NULL if interrupt name is not found"]
    pub fn furi_hal_interrupt_get_name(exception_number: u8) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get total time(in CPU clocks) spent in ISR\n\n # Returns\n\ntotal time in CPU clocks"]
    pub fn furi_hal_interrupt_get_time_in_isr_total() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Version {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Get current running firmware version handle.\n\n You can store it somewhere. But if you want to retrieve data, you have to use\n 'version_*_get()' set of functions. Also, 'version_*_get()' imply to use this\n handle if no handle (NULL_PTR) provided.\n\n # Returns\n\npointer to Version data."]
    pub fn version_get() -> *const Version;
}
unsafe extern "C" {
    #[doc = "Get git commit hash.\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\ngit hash"]
    pub fn version_get_githash(v: *const Version) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get git branch.\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\ngit branch"]
    pub fn version_get_gitbranch(v: *const Version) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get number of commit in git branch.\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\nnumber of commit"]
    pub fn version_get_gitbranchnum(v: *const Version) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get build date.\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\nbuild date"]
    pub fn version_get_builddate(v: *const Version) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get build version. Build version is last tag in git history.\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\nbuild date"]
    pub fn version_get_version(v: *const Version) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get hardware target this firmware was built for\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\nbuild date"]
    pub fn version_get_target(v: *const Version) -> u8;
}
unsafe extern "C" {
    #[doc = "Get flag indicating if this build is \"dirty\" (source code had uncommited changes)\n\n # Arguments\n\n* `v` - pointer to Version data. NULL for currently running\n software.\n\n # Returns\n\nbuild date"]
    pub fn version_get_dirty_flag(v: *const Version) -> bool;
}
unsafe extern "C" {
    #[doc = "Get firmware origin. \"Official\" for mainline firmware, fork name for forks.\n Set by FIRMWARE_ORIGIN fbt argument."]
    pub fn version_get_firmware_origin(v: *const Version) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get git repo origin"]
    pub fn version_get_git_origin(v: *const Version) -> *const core::ffi::c_char;
}
pub const FuriHalVersionOtpVersion0: FuriHalVersionOtpVersion = FuriHalVersionOtpVersion(0);
pub const FuriHalVersionOtpVersion1: FuriHalVersionOtpVersion = FuriHalVersionOtpVersion(1);
pub const FuriHalVersionOtpVersion2: FuriHalVersionOtpVersion = FuriHalVersionOtpVersion(2);
pub const FuriHalVersionOtpVersionEmpty: FuriHalVersionOtpVersion =
    FuriHalVersionOtpVersion(4294967294);
pub const FuriHalVersionOtpVersionUnknown: FuriHalVersionOtpVersion =
    FuriHalVersionOtpVersion(4294967295);
#[repr(transparent)]
#[doc = "OTP Versions enum"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalVersionOtpVersion(pub core::ffi::c_uint);
pub const FuriHalVersionColorUnknown: FuriHalVersionColor = FuriHalVersionColor(0);
pub const FuriHalVersionColorBlack: FuriHalVersionColor = FuriHalVersionColor(1);
pub const FuriHalVersionColorWhite: FuriHalVersionColor = FuriHalVersionColor(2);
pub const FuriHalVersionColorTransparent: FuriHalVersionColor = FuriHalVersionColor(3);
#[repr(transparent)]
#[doc = "Device Colors"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalVersionColor(pub core::ffi::c_uchar);
pub const FuriHalVersionRegionUnknown: FuriHalVersionRegion = FuriHalVersionRegion(0);
pub const FuriHalVersionRegionEuRu: FuriHalVersionRegion = FuriHalVersionRegion(1);
pub const FuriHalVersionRegionUsCaAu: FuriHalVersionRegion = FuriHalVersionRegion(2);
pub const FuriHalVersionRegionJp: FuriHalVersionRegion = FuriHalVersionRegion(3);
pub const FuriHalVersionRegionWorld: FuriHalVersionRegion = FuriHalVersionRegion(4);
#[repr(transparent)]
#[doc = "Device Regions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalVersionRegion(pub core::ffi::c_uchar);
pub const FuriHalVersionDisplayUnknown: FuriHalVersionDisplay = FuriHalVersionDisplay(0);
pub const FuriHalVersionDisplayErc: FuriHalVersionDisplay = FuriHalVersionDisplay(1);
pub const FuriHalVersionDisplayMgg: FuriHalVersionDisplay = FuriHalVersionDisplay(2);
#[repr(transparent)]
#[doc = "Device Display"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalVersionDisplay(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Check target firmware version\n\n # Returns\n\ntrue if target and real matches"]
    pub fn furi_hal_version_do_i_belong_here() -> bool;
}
unsafe extern "C" {
    #[doc = "Get model name\n\n # Returns\n\nmodel name C-string"]
    pub fn furi_hal_version_get_model_name() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get model name\n\n # Returns\n\nmodel code C-string"]
    pub fn furi_hal_version_get_model_code() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get FCC ID\n\n # Returns\n\nFCC id as C-string"]
    pub fn furi_hal_version_get_fcc_id() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get IC id\n\n # Returns\n\nIC id as C-string"]
    pub fn furi_hal_version_get_ic_id() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get MIC id\n\n # Returns\n\nMIC id as C-string"]
    pub fn furi_hal_version_get_mic_id() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get SRRC id\n\n # Returns\n\nSRRC id as C-string"]
    pub fn furi_hal_version_get_srrc_id() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get NCC id\n\n # Returns\n\nNCC id as C-string"]
    pub fn furi_hal_version_get_ncc_id() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get OTP version\n\n # Returns\n\nOTP Version"]
    pub fn furi_hal_version_get_otp_version() -> FuriHalVersionOtpVersion;
}
unsafe extern "C" {
    #[doc = "Get hardware version\n\n # Returns\n\nHardware Version"]
    pub fn furi_hal_version_get_hw_version() -> u8;
}
unsafe extern "C" {
    #[doc = "Get hardware target\n\n # Returns\n\nHardware Target"]
    pub fn furi_hal_version_get_hw_target() -> u8;
}
unsafe extern "C" {
    #[doc = "Get hardware body\n\n # Returns\n\nHardware Body"]
    pub fn furi_hal_version_get_hw_body() -> u8;
}
unsafe extern "C" {
    #[doc = "Get hardware body color\n\n # Returns\n\nHardware Color"]
    pub fn furi_hal_version_get_hw_color() -> FuriHalVersionColor;
}
unsafe extern "C" {
    #[doc = "Get hardware connect\n\n # Returns\n\nHardware Interconnect"]
    pub fn furi_hal_version_get_hw_connect() -> u8;
}
unsafe extern "C" {
    #[doc = "Get hardware region\n\n # Returns\n\nHardware Region"]
    pub fn furi_hal_version_get_hw_region() -> FuriHalVersionRegion;
}
unsafe extern "C" {
    #[doc = "Get hardware region name\n\n # Returns\n\nHardware Region name"]
    pub fn furi_hal_version_get_hw_region_name() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get hardware display id\n\n # Returns\n\nDisplay id"]
    pub fn furi_hal_version_get_hw_display() -> FuriHalVersionDisplay;
}
unsafe extern "C" {
    #[doc = "Get hardware timestamp\n\n # Returns\n\nHardware Manufacture timestamp"]
    pub fn furi_hal_version_get_hw_timestamp() -> u32;
}
unsafe extern "C" {
    #[doc = "Get pointer to target name\n\n # Returns\n\nHardware Name C-string"]
    pub fn furi_hal_version_get_name_ptr() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get pointer to target device name\n\n # Returns\n\nHardware Device Name C-string"]
    pub fn furi_hal_version_get_device_name_ptr() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get pointer to target ble local device name\n\n # Returns\n\nBle Device Name C-string"]
    pub fn furi_hal_version_get_ble_local_device_name_ptr() -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get BLE MAC address\n\n # Returns\n\npointer to BLE MAC address"]
    pub fn furi_hal_version_get_ble_mac() -> *const u8;
}
unsafe extern "C" {
    #[doc = "Get address of version structure of firmware.\n\n # Returns\n\nAddress of firmware version structure."]
    pub fn furi_hal_version_get_firmware_version() -> *const Version;
}
unsafe extern "C" {
    #[doc = "Get platform UID size in bytes\n\n # Returns\n\nUID size in bytes"]
    pub fn furi_hal_version_uid_size() -> usize;
}
unsafe extern "C" {
    #[doc = "Get const pointer to UID\n\n # Returns\n\npointer to UID"]
    pub fn furi_hal_version_uid() -> *const u8;
}
pub const GapEventTypeConnected: GapEventType = GapEventType(0);
pub const GapEventTypeDisconnected: GapEventType = GapEventType(1);
pub const GapEventTypeStartAdvertising: GapEventType = GapEventType(2);
pub const GapEventTypeStopAdvertising: GapEventType = GapEventType(3);
pub const GapEventTypePinCodeShow: GapEventType = GapEventType(4);
pub const GapEventTypePinCodeVerify: GapEventType = GapEventType(5);
pub const GapEventTypeUpdateMTU: GapEventType = GapEventType(6);
pub const GapEventTypeBeaconStart: GapEventType = GapEventType(7);
pub const GapEventTypeBeaconStop: GapEventType = GapEventType(8);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GapEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub union GapEventData {
    pub pin_code: u32,
    pub max_packet_size: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GapEventData"][::core::mem::size_of::<GapEventData>() - 4usize];
    ["Alignment of GapEventData"][::core::mem::align_of::<GapEventData>() - 4usize];
    ["Offset of field: GapEventData::pin_code"]
        [::core::mem::offset_of!(GapEventData, pin_code) - 0usize];
    ["Offset of field: GapEventData::max_packet_size"]
        [::core::mem::offset_of!(GapEventData, max_packet_size) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GapEvent {
    pub type_: GapEventType,
    pub data: GapEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GapEvent"][::core::mem::size_of::<GapEvent>() - 8usize];
    ["Alignment of GapEvent"][::core::mem::align_of::<GapEvent>() - 4usize];
    ["Offset of field: GapEvent::type_"][::core::mem::offset_of!(GapEvent, type_) - 0usize];
    ["Offset of field: GapEvent::data"][::core::mem::offset_of!(GapEvent, data) - 4usize];
};
pub type GapEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: GapEvent, context: *mut core::ffi::c_void) -> bool,
>;
pub const GapPairingNone: GapPairing = GapPairing(0);
pub const GapPairingPinCodeShow: GapPairing = GapPairing(1);
pub const GapPairingPinCodeVerifyYesNo: GapPairing = GapPairing(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GapPairing(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GapConnectionParamsRequest {
    pub conn_int_min: u16,
    pub conn_int_max: u16,
    pub slave_latency: u16,
    pub supervisor_timeout: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GapConnectionParamsRequest"]
        [::core::mem::size_of::<GapConnectionParamsRequest>() - 8usize];
    ["Alignment of GapConnectionParamsRequest"]
        [::core::mem::align_of::<GapConnectionParamsRequest>() - 2usize];
    ["Offset of field: GapConnectionParamsRequest::conn_int_min"]
        [::core::mem::offset_of!(GapConnectionParamsRequest, conn_int_min) - 0usize];
    ["Offset of field: GapConnectionParamsRequest::conn_int_max"]
        [::core::mem::offset_of!(GapConnectionParamsRequest, conn_int_max) - 2usize];
    ["Offset of field: GapConnectionParamsRequest::slave_latency"]
        [::core::mem::offset_of!(GapConnectionParamsRequest, slave_latency) - 4usize];
    ["Offset of field: GapConnectionParamsRequest::supervisor_timeout"]
        [::core::mem::offset_of!(GapConnectionParamsRequest, supervisor_timeout) - 6usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GapConfig {
    pub adv_service_uuid: u16,
    pub appearance_char: u16,
    pub bonding_mode: bool,
    pub pairing_method: GapPairing,
    pub mac_address: [u8; 6usize],
    pub adv_name: [core::ffi::c_char; 18usize],
    pub conn_param: GapConnectionParamsRequest,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GapConfig"][::core::mem::size_of::<GapConfig>() - 38usize];
    ["Alignment of GapConfig"][::core::mem::align_of::<GapConfig>() - 2usize];
    ["Offset of field: GapConfig::adv_service_uuid"]
        [::core::mem::offset_of!(GapConfig, adv_service_uuid) - 0usize];
    ["Offset of field: GapConfig::appearance_char"]
        [::core::mem::offset_of!(GapConfig, appearance_char) - 2usize];
    ["Offset of field: GapConfig::bonding_mode"]
        [::core::mem::offset_of!(GapConfig, bonding_mode) - 4usize];
    ["Offset of field: GapConfig::pairing_method"]
        [::core::mem::offset_of!(GapConfig, pairing_method) - 5usize];
    ["Offset of field: GapConfig::mac_address"]
        [::core::mem::offset_of!(GapConfig, mac_address) - 6usize];
    ["Offset of field: GapConfig::adv_name"]
        [::core::mem::offset_of!(GapConfig, adv_name) - 12usize];
    ["Offset of field: GapConfig::conn_param"]
        [::core::mem::offset_of!(GapConfig, conn_param) - 30usize];
};
pub const GapAdvChannelMap37: GapAdvChannelMap = GapAdvChannelMap(1);
pub const GapAdvChannelMap38: GapAdvChannelMap = GapAdvChannelMap(2);
pub const GapAdvChannelMap39: GapAdvChannelMap = GapAdvChannelMap(4);
pub const GapAdvChannelMapAll: GapAdvChannelMap = GapAdvChannelMap(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GapAdvChannelMap(pub core::ffi::c_uchar);
pub const GapAdvPowerLevel_Neg40dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(0);
pub const GapAdvPowerLevel_Neg20_85dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(1);
pub const GapAdvPowerLevel_Neg19_75dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(2);
pub const GapAdvPowerLevel_Neg18_85dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(3);
pub const GapAdvPowerLevel_Neg17_6dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(4);
pub const GapAdvPowerLevel_Neg16_5dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(5);
pub const GapAdvPowerLevel_Neg15_25dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(6);
pub const GapAdvPowerLevel_Neg14_1dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(7);
pub const GapAdvPowerLevel_Neg13_15dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(8);
pub const GapAdvPowerLevel_Neg12_05dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(9);
pub const GapAdvPowerLevel_Neg10_9dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(10);
pub const GapAdvPowerLevel_Neg9_9dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(11);
pub const GapAdvPowerLevel_Neg8_85dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(12);
pub const GapAdvPowerLevel_Neg7_8dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(13);
pub const GapAdvPowerLevel_Neg6_9dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(14);
pub const GapAdvPowerLevel_Neg5_9dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(15);
pub const GapAdvPowerLevel_Neg4_95dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(16);
pub const GapAdvPowerLevel_Neg4dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(17);
pub const GapAdvPowerLevel_Neg3_15dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(18);
pub const GapAdvPowerLevel_Neg2_45dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(19);
pub const GapAdvPowerLevel_Neg1_8dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(20);
pub const GapAdvPowerLevel_Neg1_3dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(21);
pub const GapAdvPowerLevel_Neg0_85dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(22);
pub const GapAdvPowerLevel_Neg0_5dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(23);
pub const GapAdvPowerLevel_Neg0_15dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(24);
pub const GapAdvPowerLevel_0dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(25);
pub const GapAdvPowerLevel_1dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(26);
pub const GapAdvPowerLevel_2dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(27);
pub const GapAdvPowerLevel_3dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(28);
pub const GapAdvPowerLevel_4dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(29);
pub const GapAdvPowerLevel_5dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(30);
pub const GapAdvPowerLevel_6dBm: GapAdvPowerLevelInd = GapAdvPowerLevelInd(31);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GapAdvPowerLevelInd(pub core::ffi::c_uchar);
pub const GapAddressTypePublic: GapAddressType = GapAddressType(0);
pub const GapAddressTypeRandom: GapAddressType = GapAddressType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GapAddressType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GapExtraBeaconConfig {
    pub min_adv_interval_ms: u16,
    pub max_adv_interval_ms: u16,
    pub adv_channel_map: GapAdvChannelMap,
    pub adv_power_level: GapAdvPowerLevelInd,
    pub address_type: GapAddressType,
    pub address: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GapExtraBeaconConfig"][::core::mem::size_of::<GapExtraBeaconConfig>() - 14usize];
    ["Alignment of GapExtraBeaconConfig"][::core::mem::align_of::<GapExtraBeaconConfig>() - 2usize];
    ["Offset of field: GapExtraBeaconConfig::min_adv_interval_ms"]
        [::core::mem::offset_of!(GapExtraBeaconConfig, min_adv_interval_ms) - 0usize];
    ["Offset of field: GapExtraBeaconConfig::max_adv_interval_ms"]
        [::core::mem::offset_of!(GapExtraBeaconConfig, max_adv_interval_ms) - 2usize];
    ["Offset of field: GapExtraBeaconConfig::adv_channel_map"]
        [::core::mem::offset_of!(GapExtraBeaconConfig, adv_channel_map) - 4usize];
    ["Offset of field: GapExtraBeaconConfig::adv_power_level"]
        [::core::mem::offset_of!(GapExtraBeaconConfig, adv_power_level) - 5usize];
    ["Offset of field: GapExtraBeaconConfig::address_type"]
        [::core::mem::offset_of!(GapExtraBeaconConfig, address_type) - 6usize];
    ["Offset of field: GapExtraBeaconConfig::address"]
        [::core::mem::offset_of!(GapExtraBeaconConfig, address) - 7usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalBleProfileBase {
    pub config: *const FuriHalBleProfileTemplate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalBleProfileBase"][::core::mem::size_of::<FuriHalBleProfileBase>() - 4usize];
    ["Alignment of FuriHalBleProfileBase"]
        [::core::mem::align_of::<FuriHalBleProfileBase>() - 4usize];
    ["Offset of field: FuriHalBleProfileBase::config"]
        [::core::mem::offset_of!(FuriHalBleProfileBase, config) - 0usize];
};
pub type FuriHalBleProfileParams = *mut core::ffi::c_void;
pub type FuriHalBleProfileStart = ::core::option::Option<
    unsafe extern "C" fn(profile_params: FuriHalBleProfileParams) -> *mut FuriHalBleProfileBase,
>;
pub type FuriHalBleProfileStop =
    ::core::option::Option<unsafe extern "C" fn(profile: *mut FuriHalBleProfileBase)>;
pub type FuriHalBleProfileGetGapConfig = ::core::option::Option<
    unsafe extern "C" fn(target_config: *mut GapConfig, profile_params: FuriHalBleProfileParams),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalBleProfileTemplate {
    pub start: FuriHalBleProfileStart,
    pub stop: FuriHalBleProfileStop,
    pub get_gap_config: FuriHalBleProfileGetGapConfig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalBleProfileTemplate"]
        [::core::mem::size_of::<FuriHalBleProfileTemplate>() - 12usize];
    ["Alignment of FuriHalBleProfileTemplate"]
        [::core::mem::align_of::<FuriHalBleProfileTemplate>() - 4usize];
    ["Offset of field: FuriHalBleProfileTemplate::start"]
        [::core::mem::offset_of!(FuriHalBleProfileTemplate, start) - 0usize];
    ["Offset of field: FuriHalBleProfileTemplate::stop"]
        [::core::mem::offset_of!(FuriHalBleProfileTemplate, stop) - 4usize];
    ["Offset of field: FuriHalBleProfileTemplate::get_gap_config"]
        [::core::mem::offset_of!(FuriHalBleProfileTemplate, get_gap_config) - 8usize];
};
pub const BleGlueC2ModeUnknown: BleGlueC2Mode = BleGlueC2Mode(0);
pub const BleGlueC2ModeFUS: BleGlueC2Mode = BleGlueC2Mode(1);
pub const BleGlueC2ModeStack: BleGlueC2Mode = BleGlueC2Mode(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BleGlueC2Mode(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGlueC2Info {
    pub mode: BleGlueC2Mode,
    #[doc = "Wireless Info"]
    pub VersionMajor: u8,
    pub VersionMinor: u8,
    pub VersionSub: u8,
    pub VersionBranch: u8,
    pub VersionReleaseType: u8,
    pub MemorySizeSram2B: u8,
    pub MemorySizeSram2A: u8,
    pub MemorySizeSram1: u8,
    pub MemorySizeFlash: u8,
    pub StackType: u8,
    pub StackTypeString: [core::ffi::c_char; 20usize],
    #[doc = "Fus Info"]
    pub FusVersionMajor: u8,
    pub FusVersionMinor: u8,
    pub FusVersionSub: u8,
    pub FusMemorySizeSram2B: u8,
    pub FusMemorySizeSram2A: u8,
    pub FusMemorySizeFlash: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGlueC2Info"][::core::mem::size_of::<BleGlueC2Info>() - 37usize];
    ["Alignment of BleGlueC2Info"][::core::mem::align_of::<BleGlueC2Info>() - 1usize];
    ["Offset of field: BleGlueC2Info::mode"][::core::mem::offset_of!(BleGlueC2Info, mode) - 0usize];
    ["Offset of field: BleGlueC2Info::VersionMajor"]
        [::core::mem::offset_of!(BleGlueC2Info, VersionMajor) - 1usize];
    ["Offset of field: BleGlueC2Info::VersionMinor"]
        [::core::mem::offset_of!(BleGlueC2Info, VersionMinor) - 2usize];
    ["Offset of field: BleGlueC2Info::VersionSub"]
        [::core::mem::offset_of!(BleGlueC2Info, VersionSub) - 3usize];
    ["Offset of field: BleGlueC2Info::VersionBranch"]
        [::core::mem::offset_of!(BleGlueC2Info, VersionBranch) - 4usize];
    ["Offset of field: BleGlueC2Info::VersionReleaseType"]
        [::core::mem::offset_of!(BleGlueC2Info, VersionReleaseType) - 5usize];
    ["Offset of field: BleGlueC2Info::MemorySizeSram2B"]
        [::core::mem::offset_of!(BleGlueC2Info, MemorySizeSram2B) - 6usize];
    ["Offset of field: BleGlueC2Info::MemorySizeSram2A"]
        [::core::mem::offset_of!(BleGlueC2Info, MemorySizeSram2A) - 7usize];
    ["Offset of field: BleGlueC2Info::MemorySizeSram1"]
        [::core::mem::offset_of!(BleGlueC2Info, MemorySizeSram1) - 8usize];
    ["Offset of field: BleGlueC2Info::MemorySizeFlash"]
        [::core::mem::offset_of!(BleGlueC2Info, MemorySizeFlash) - 9usize];
    ["Offset of field: BleGlueC2Info::StackType"]
        [::core::mem::offset_of!(BleGlueC2Info, StackType) - 10usize];
    ["Offset of field: BleGlueC2Info::StackTypeString"]
        [::core::mem::offset_of!(BleGlueC2Info, StackTypeString) - 11usize];
    ["Offset of field: BleGlueC2Info::FusVersionMajor"]
        [::core::mem::offset_of!(BleGlueC2Info, FusVersionMajor) - 31usize];
    ["Offset of field: BleGlueC2Info::FusVersionMinor"]
        [::core::mem::offset_of!(BleGlueC2Info, FusVersionMinor) - 32usize];
    ["Offset of field: BleGlueC2Info::FusVersionSub"]
        [::core::mem::offset_of!(BleGlueC2Info, FusVersionSub) - 33usize];
    ["Offset of field: BleGlueC2Info::FusMemorySizeSram2B"]
        [::core::mem::offset_of!(BleGlueC2Info, FusMemorySizeSram2B) - 34usize];
    ["Offset of field: BleGlueC2Info::FusMemorySizeSram2A"]
        [::core::mem::offset_of!(BleGlueC2Info, FusMemorySizeSram2A) - 35usize];
    ["Offset of field: BleGlueC2Info::FusMemorySizeFlash"]
        [::core::mem::offset_of!(BleGlueC2Info, FusMemorySizeFlash) - 36usize];
};
pub const BleGlueStatusStartup: BleGlueStatus = BleGlueStatus(0);
pub const BleGlueStatusBroken: BleGlueStatus = BleGlueStatus(1);
pub const BleGlueStatusC2Started: BleGlueStatus = BleGlueStatus(2);
pub const BleGlueStatusRadioStackRunning: BleGlueStatus = BleGlueStatus(3);
pub const BleGlueStatusRadioStackMissing: BleGlueStatus = BleGlueStatus(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BleGlueStatus(pub core::ffi::c_uchar);
pub type BleGlueKeyStorageChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(change_addr_start: *mut u8, size: u16, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Initialize start core2 and initialize transport"]
    pub fn ble_glue_init();
}
unsafe extern "C" {
    #[doc = "Is core2 alive and at least FUS is running\n\n # Returns\n\ntrue if core2 is alive"]
    pub fn ble_glue_is_alive() -> bool;
}
unsafe extern "C" {
    #[doc = "Waits for C2 to reports its mode to callback\n\n # Returns\n\ntrue if it reported before reaching timeout"]
    pub fn ble_glue_wait_for_c2_start(timeout_ms: i32) -> bool;
}
unsafe extern "C" {
    pub fn ble_glue_get_c2_info() -> *const BleGlueC2Info;
}
unsafe extern "C" {
    #[doc = "Is core2 radio stack present and ready\n\n # Returns\n\ntrue if present and ready"]
    pub fn ble_glue_is_radio_stack_ready() -> bool;
}
unsafe extern "C" {
    #[doc = "Set callback for NVM in RAM changes\n\n # Arguments\n\n* `callback` (direction in) - The callback to call on NVM change\n * `context` - The context for callback"]
    pub fn ble_glue_set_key_storage_changed_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn ble_glue_reinit_c2() -> bool;
}
pub const BleGlueCommandResultUnknown: BleGlueCommandResult = BleGlueCommandResult(0);
pub const BleGlueCommandResultOK: BleGlueCommandResult = BleGlueCommandResult(1);
pub const BleGlueCommandResultError: BleGlueCommandResult = BleGlueCommandResult(2);
pub const BleGlueCommandResultRestartPending: BleGlueCommandResult = BleGlueCommandResult(3);
pub const BleGlueCommandResultOperationOngoing: BleGlueCommandResult = BleGlueCommandResult(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BleGlueCommandResult(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Restart MCU to launch radio stack firmware if necessary\n\n # Returns\n\ntrue on radio stack start command"]
    pub fn ble_glue_force_c2_mode(mode: BleGlueC2Mode) -> BleGlueCommandResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGlueHardfaultInfo {
    pub magic: u32,
    pub source_pc: u32,
    pub source_lr: u32,
    pub source_sp: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGlueHardfaultInfo"][::core::mem::size_of::<BleGlueHardfaultInfo>() - 16usize];
    ["Alignment of BleGlueHardfaultInfo"][::core::mem::align_of::<BleGlueHardfaultInfo>() - 4usize];
    ["Offset of field: BleGlueHardfaultInfo::magic"]
        [::core::mem::offset_of!(BleGlueHardfaultInfo, magic) - 0usize];
    ["Offset of field: BleGlueHardfaultInfo::source_pc"]
        [::core::mem::offset_of!(BleGlueHardfaultInfo, source_pc) - 4usize];
    ["Offset of field: BleGlueHardfaultInfo::source_lr"]
        [::core::mem::offset_of!(BleGlueHardfaultInfo, source_lr) - 8usize];
    ["Offset of field: BleGlueHardfaultInfo::source_sp"]
        [::core::mem::offset_of!(BleGlueHardfaultInfo, source_sp) - 12usize];
};
pub const FuriHalBtStackUnknown: FuriHalBtStack = FuriHalBtStack(0);
pub const FuriHalBtStackLight: FuriHalBtStack = FuriHalBtStack(1);
pub const FuriHalBtStackFull: FuriHalBtStack = FuriHalBtStack(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalBtStack(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Lock core2 state transition"]
    pub fn furi_hal_bt_lock_core2();
}
unsafe extern "C" {
    #[doc = "Lock core2 state transition"]
    pub fn furi_hal_bt_unlock_core2();
}
unsafe extern "C" {
    #[doc = "Start radio stack\n\n # Returns\n\ntrue on successfull radio stack start"]
    pub fn furi_hal_bt_start_radio_stack() -> bool;
}
unsafe extern "C" {
    #[doc = "Get radio stack type\n\n # Returns\n\nFuriHalBtStack instance"]
    pub fn furi_hal_bt_get_radio_stack() -> FuriHalBtStack;
}
unsafe extern "C" {
    #[doc = "Check if radio stack supports BLE GAT/GAP\n\n # Returns\n\ntrue if supported"]
    pub fn furi_hal_bt_is_gatt_gap_supported() -> bool;
}
unsafe extern "C" {
    #[doc = "Check if radio stack supports testing\n\n # Returns\n\ntrue if supported"]
    pub fn furi_hal_bt_is_testing_supported() -> bool;
}
unsafe extern "C" {
    #[doc = "Check if particular instance of profile belongs to given type\n\n # Arguments\n\n* `profile` - FuriHalBtProfile instance. If NULL, uses current profile\n * `profile_template` - basic profile template to check against\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_bt_check_profile_type(
        profile: *mut FuriHalBleProfileBase,
        profile_template: *const FuriHalBleProfileTemplate,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Start BLE app\n\n # Arguments\n\n* `profile_template` - FuriHalBleProfileTemplate instance\n * `params` - Parameters to pass to the profile. Can be NULL\n * `event_cb` - GapEventCallback instance\n * `context` - pointer to context\n\n # Returns\n\ninstance of profile, NULL on failure"]
    pub fn furi_hal_bt_start_app(
        profile_template: *const FuriHalBleProfileTemplate,
        params: FuriHalBleProfileParams,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriHalBleProfileBase;
}
unsafe extern "C" {
    #[doc = "Reinitialize core2\n\n Also can be used to prepare core2 for stop modes"]
    pub fn furi_hal_bt_reinit();
}
unsafe extern "C" {
    #[doc = "Change BLE app\n Restarts 2nd core\n\n # Arguments\n\n* `profile_template` - FuriHalBleProfileTemplate instance\n * `profile_params` - Parameters to pass to the profile. Can be NULL\n * `event_cb` - GapEventCallback instance\n * `context` - pointer to context\n\n # Returns\n\ninstance of profile, NULL on failure"]
    pub fn furi_hal_bt_change_app(
        profile_template: *const FuriHalBleProfileTemplate,
        profile_params: FuriHalBleProfileParams,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriHalBleProfileBase;
}
unsafe extern "C" {
    #[doc = "Update battery level\n\n # Arguments\n\n* `battery_level` - battery level"]
    pub fn furi_hal_bt_update_battery_level(battery_level: u8);
}
unsafe extern "C" {
    #[doc = "Update battery power state"]
    pub fn furi_hal_bt_update_power_state(charging: bool);
}
unsafe extern "C" {
    #[doc = "Checks if BLE state is active\n\n # Returns\n\ntrue if device is connected or advertising, false otherwise"]
    pub fn furi_hal_bt_is_active() -> bool;
}
unsafe extern "C" {
    #[doc = "Start advertising"]
    pub fn furi_hal_bt_start_advertising();
}
unsafe extern "C" {
    #[doc = "Stop advertising"]
    pub fn furi_hal_bt_stop_advertising();
}
unsafe extern "C" {
    #[doc = "Get BT/BLE system component state\n\n # Arguments\n\n* `buffer` (direction in) - FuriString* buffer to write to"]
    pub fn furi_hal_bt_dump_state(buffer: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Get BT/BLE system component state\n\n # Returns\n\ntrue if core2 is alive"]
    pub fn furi_hal_bt_is_alive() -> bool;
}
unsafe extern "C" {
    #[doc = "Get key storage buffer address and size\n\n # Arguments\n\n* `key_buff_addr` - pointer to store buffer address\n * `key_buff_size` - pointer to store buffer size"]
    pub fn furi_hal_bt_get_key_storage_buff(key_buff_addr: *mut *mut u8, key_buff_size: *mut u16);
}
unsafe extern "C" {
    #[doc = "Get SRAM2 hardware semaphore\n > **Note:** Must be called before SRAM2 read/write operations"]
    pub fn furi_hal_bt_nvm_sram_sem_acquire();
}
unsafe extern "C" {
    #[doc = "Release SRAM2 hardware semaphore\n > **Note:** Must be called after SRAM2 read/write operations"]
    pub fn furi_hal_bt_nvm_sram_sem_release();
}
unsafe extern "C" {
    #[doc = "Clear key storage\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_bt_clear_white_list() -> bool;
}
unsafe extern "C" {
    #[doc = "Set key storage change callback\n\n # Arguments\n\n* `callback` - BleGlueKeyStorageChangedCallback instance\n * `context` - pointer to context"]
    pub fn furi_hal_bt_set_key_storage_change_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start ble tone tx at given channel and power\n\n # Arguments\n\n* `channel` (direction in) - The channel\n * `power` (direction in) - The power"]
    pub fn furi_hal_bt_start_tone_tx(channel: u8, power: u8);
}
unsafe extern "C" {
    #[doc = "Stop ble tone tx"]
    pub fn furi_hal_bt_stop_tone_tx();
}
unsafe extern "C" {
    #[doc = "Start sending ble packets at a given frequency and datarate\n\n # Arguments\n\n* `channel` (direction in) - The channel\n * `pattern` (direction in) - The pattern\n * `datarate` (direction in) - The datarate"]
    pub fn furi_hal_bt_start_packet_tx(channel: u8, pattern: u8, datarate: u8);
}
unsafe extern "C" {
    #[doc = "Stop sending ble packets\n\n # Returns\n\nsent packet count"]
    pub fn furi_hal_bt_stop_packet_test() -> u16;
}
unsafe extern "C" {
    #[doc = "Start receiving packets\n\n # Arguments\n\n* `channel` (direction in) - RX channel\n * `datarate` (direction in) - Datarate"]
    pub fn furi_hal_bt_start_packet_rx(channel: u8, datarate: u8);
}
unsafe extern "C" {
    #[doc = "Set up the RF to listen to a given RF channel\n\n # Arguments\n\n* `channel` (direction in) - RX channel"]
    pub fn furi_hal_bt_start_rx(channel: u8);
}
unsafe extern "C" {
    #[doc = "Stop RF listenning"]
    pub fn furi_hal_bt_stop_rx();
}
unsafe extern "C" {
    #[doc = "Get RSSI\n\n # Returns\n\nRSSI in dBm"]
    pub fn furi_hal_bt_get_rssi() -> f32;
}
unsafe extern "C" {
    #[doc = "Get number of transmitted packets\n\n # Returns\n\npacket count"]
    pub fn furi_hal_bt_get_transmitted_packets() -> u32;
}
unsafe extern "C" {
    #[doc = "Check & switch C2 to given mode\n\n # Arguments\n\n* `mode` (direction in) - mode to switch into"]
    pub fn furi_hal_bt_ensure_c2_mode(mode: BleGlueC2Mode) -> bool;
}
unsafe extern "C" {
    #[doc = "Set extra beacon data. Can be called in any state\n\n # Arguments\n\n* `data` (direction in) - data to set\n * `len` (direction in) - data length. Must be <= EXTRA_BEACON_MAX_DATA_SIZE\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_bt_extra_beacon_set_data(data: *const u8, len: u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Get last configured extra beacon data\n\n # Arguments\n\n* `data` - data buffer to write to. Must be at least EXTRA_BEACON_MAX_DATA_SIZE bytes long\n\n # Returns\n\nvalid data length"]
    pub fn furi_hal_bt_extra_beacon_get_data(data: *mut u8) -> u8;
}
unsafe extern "C" {
    #[doc = "Configure extra beacon.\n\n # Arguments\n\n* `config` (direction in) - extra beacon config: interval, power, address, etc.\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_bt_extra_beacon_set_config(config: *const GapExtraBeaconConfig) -> bool;
}
unsafe extern "C" {
    #[doc = "Start extra beacon.\n Beacon must configured with furi_hal_bt_extra_beacon_set_config()\n and in stopped state before calling this function.\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_bt_extra_beacon_start() -> bool;
}
unsafe extern "C" {
    #[doc = "Stop extra beacon\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_bt_extra_beacon_stop() -> bool;
}
unsafe extern "C" {
    #[doc = "Check if extra beacon is active.\n\n # Returns\n\nextra beacon state"]
    pub fn furi_hal_bt_extra_beacon_is_active() -> bool;
}
unsafe extern "C" {
    #[doc = "Get last configured extra beacon config\n\n # Returns\n\nextra beacon config. NULL if beacon had never been configured."]
    pub fn furi_hal_bt_extra_beacon_get_config() -> *const GapExtraBeaconConfig;
}
#[doc = "SPI Init structures definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_SPI_InitTypeDef {
    #[doc = "< Specifies the SPI unidirectional or bidirectional data mode.\nThis parameter can be a value of SPI_LL_EC_TRANSFER_MODE.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies the SPI mode (Master/Slave).\nThis parameter can be a value of SPI_LL_EC_MODE.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetMode()."]
    pub Mode: u32,
    #[doc = "< Specifies the SPI data width.\nThis parameter can be a value of SPI_LL_EC_DATAWIDTH.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the serial clock steady state.\nThis parameter can be a value of SPI_LL_EC_POLARITY.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetClockPolarity()."]
    pub ClockPolarity: u32,
    #[doc = "< Specifies the clock active edge for the bit capture.\nThis parameter can be a value of SPI_LL_EC_PHASE.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetClockPhase()."]
    pub ClockPhase: u32,
    #[doc = "< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit.\nThis parameter can be a value of SPI_LL_EC_NSS_MODE.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetNSSMode()."]
    pub NSS: u32,
    #[doc = "< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock.\nThis parameter can be a value of SPI_LL_EC_BAUDRATEPRESCALER.\n> **Note:** The communication clock is derived from the master clock. The slave clock does not need to be set.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetBaudRatePrescaler()."]
    pub BaudRate: u32,
    #[doc = "< Specifies whether data transfers start from MSB or LSB bit.\nThis parameter can be a value of SPI_LL_EC_BIT_ORDER.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetTransferBitOrder()."]
    pub BitOrder: u32,
    #[doc = "< Specifies if the CRC calculation is enabled or not.\nThis parameter can be a value of SPI_LL_EC_CRC_CALCULATION.\n\nThis feature can be modified afterwards using unitary functions LL_SPI_EnableCRC() and LL_SPI_DisableCRC()."]
    pub CRCCalculation: u32,
    #[doc = "< Specifies the polynomial used for the CRC calculation.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF.\n\nThis feature can be modified afterwards using unitary function LL_SPI_SetCRCPolynomial()."]
    pub CRCPoly: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_SPI_InitTypeDef"][::core::mem::size_of::<LL_SPI_InitTypeDef>() - 40usize];
    ["Alignment of LL_SPI_InitTypeDef"][::core::mem::align_of::<LL_SPI_InitTypeDef>() - 4usize];
    ["Offset of field: LL_SPI_InitTypeDef::TransferDirection"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, TransferDirection) - 0usize];
    ["Offset of field: LL_SPI_InitTypeDef::Mode"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, Mode) - 4usize];
    ["Offset of field: LL_SPI_InitTypeDef::DataWidth"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, DataWidth) - 8usize];
    ["Offset of field: LL_SPI_InitTypeDef::ClockPolarity"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, ClockPolarity) - 12usize];
    ["Offset of field: LL_SPI_InitTypeDef::ClockPhase"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, ClockPhase) - 16usize];
    ["Offset of field: LL_SPI_InitTypeDef::NSS"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, NSS) - 20usize];
    ["Offset of field: LL_SPI_InitTypeDef::BaudRate"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, BaudRate) - 24usize];
    ["Offset of field: LL_SPI_InitTypeDef::BitOrder"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, BitOrder) - 28usize];
    ["Offset of field: LL_SPI_InitTypeDef::CRCCalculation"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, CRCCalculation) - 32usize];
    ["Offset of field: LL_SPI_InitTypeDef::CRCPoly"]
        [::core::mem::offset_of!(LL_SPI_InitTypeDef, CRCPoly) - 36usize];
};
unsafe extern "C" {
    pub fn LL_SPI_Init(
        SPIx: *mut SPI_TypeDef,
        SPI_InitStruct: *mut LL_SPI_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "< Bus initialization event, called on system start"]
pub const FuriHalSpiBusEventInit: FuriHalSpiBusEvent = FuriHalSpiBusEvent(0);
#[doc = "< Bus deinitialization event, called on system stop"]
pub const FuriHalSpiBusEventDeinit: FuriHalSpiBusEvent = FuriHalSpiBusEvent(1);
#[doc = "< Bus lock event, called before activation"]
pub const FuriHalSpiBusEventLock: FuriHalSpiBusEvent = FuriHalSpiBusEvent(2);
#[doc = "< Bus unlock event, called after deactivation"]
pub const FuriHalSpiBusEventUnlock: FuriHalSpiBusEvent = FuriHalSpiBusEvent(3);
#[doc = "< Bus activation event, called before handle activation"]
pub const FuriHalSpiBusEventActivate: FuriHalSpiBusEvent = FuriHalSpiBusEvent(4);
#[doc = "< Bus deactivation event, called after handle deactivation"]
pub const FuriHalSpiBusEventDeactivate: FuriHalSpiBusEvent = FuriHalSpiBusEvent(5);
#[repr(transparent)]
#[doc = "FuriHal spi bus states"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSpiBusEvent(pub core::ffi::c_uchar);
#[doc = "FuriHal spi bus event callback"]
pub type FuriHalSpiBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalSpiBus, event: FuriHalSpiBusEvent),
>;
#[doc = "FuriHal spi bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBus {
    pub spi: *mut SPI_TypeDef,
    pub callback: FuriHalSpiBusEventCallback,
    pub current_handle: *mut FuriHalSpiBusHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalSpiBus"][::core::mem::size_of::<FuriHalSpiBus>() - 12usize];
    ["Alignment of FuriHalSpiBus"][::core::mem::align_of::<FuriHalSpiBus>() - 4usize];
    ["Offset of field: FuriHalSpiBus::spi"][::core::mem::offset_of!(FuriHalSpiBus, spi) - 0usize];
    ["Offset of field: FuriHalSpiBus::callback"]
        [::core::mem::offset_of!(FuriHalSpiBus, callback) - 4usize];
    ["Offset of field: FuriHalSpiBus::current_handle"]
        [::core::mem::offset_of!(FuriHalSpiBus, current_handle) - 8usize];
};
#[doc = "< Handle init, called on system start, initialize gpio for idle state"]
pub const FuriHalSpiBusHandleEventInit: FuriHalSpiBusHandleEvent = FuriHalSpiBusHandleEvent(0);
#[doc = "< Handle deinit, called on system stop, deinitialize gpio for default state"]
pub const FuriHalSpiBusHandleEventDeinit: FuriHalSpiBusHandleEvent = FuriHalSpiBusHandleEvent(1);
#[doc = "< Handle activate: connect gpio and apply bus config"]
pub const FuriHalSpiBusHandleEventActivate: FuriHalSpiBusHandleEvent = FuriHalSpiBusHandleEvent(2);
#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
pub const FuriHalSpiBusHandleEventDeactivate: FuriHalSpiBusHandleEvent =
    FuriHalSpiBusHandleEvent(3);
#[repr(transparent)]
#[doc = "FuriHal spi handle states"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSpiBusHandleEvent(pub core::ffi::c_uchar);
#[doc = "FuriHal spi handle event callback"]
pub type FuriHalSpiBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalSpiBusHandle, event: FuriHalSpiBusHandleEvent),
>;
#[doc = "FuriHal spi handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBusHandle {
    pub bus: *mut FuriHalSpiBus,
    pub callback: FuriHalSpiBusHandleEventCallback,
    pub miso: *const GpioPin,
    pub mosi: *const GpioPin,
    pub sck: *const GpioPin,
    pub cs: *const GpioPin,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalSpiBusHandle"][::core::mem::size_of::<FuriHalSpiBusHandle>() - 24usize];
    ["Alignment of FuriHalSpiBusHandle"][::core::mem::align_of::<FuriHalSpiBusHandle>() - 4usize];
    ["Offset of field: FuriHalSpiBusHandle::bus"]
        [::core::mem::offset_of!(FuriHalSpiBusHandle, bus) - 0usize];
    ["Offset of field: FuriHalSpiBusHandle::callback"]
        [::core::mem::offset_of!(FuriHalSpiBusHandle, callback) - 4usize];
    ["Offset of field: FuriHalSpiBusHandle::miso"]
        [::core::mem::offset_of!(FuriHalSpiBusHandle, miso) - 8usize];
    ["Offset of field: FuriHalSpiBusHandle::mosi"]
        [::core::mem::offset_of!(FuriHalSpiBusHandle, mosi) - 12usize];
    ["Offset of field: FuriHalSpiBusHandle::sck"]
        [::core::mem::offset_of!(FuriHalSpiBusHandle, sck) - 16usize];
    ["Offset of field: FuriHalSpiBusHandle::cs"]
        [::core::mem::offset_of!(FuriHalSpiBusHandle, cs) - 20usize];
};
unsafe extern "C" {
    #[doc = "Preset for ST25R916"]
    pub static furi_hal_spi_preset_2edge_low_8m: LL_SPI_InitTypeDef;
}
unsafe extern "C" {
    #[doc = "Preset for CC1101"]
    pub static furi_hal_spi_preset_1edge_low_8m: LL_SPI_InitTypeDef;
}
unsafe extern "C" {
    #[doc = "Preset for ST7567 (Display)"]
    pub static furi_hal_spi_preset_1edge_low_4m: LL_SPI_InitTypeDef;
}
unsafe extern "C" {
    #[doc = "Preset for SdCard in fast mode"]
    pub static furi_hal_spi_preset_1edge_low_16m: LL_SPI_InitTypeDef;
}
unsafe extern "C" {
    #[doc = "Preset for SdCard in slow mode"]
    pub static furi_hal_spi_preset_1edge_low_2m: LL_SPI_InitTypeDef;
}
unsafe extern "C" {
    #[doc = "Furi Hal Spi Bus R (Radio: CC1101, Nfc, External)"]
    pub static mut furi_hal_spi_bus_r: FuriHalSpiBus;
}
unsafe extern "C" {
    #[doc = "Furi Hal Spi Bus D (Display, SdCard)"]
    pub static mut furi_hal_spi_bus_d: FuriHalSpiBus;
}
unsafe extern "C" {
    #[doc = "CC1101 on `furi_hal_spi_bus_r`"]
    pub static mut furi_hal_spi_bus_handle_subghz: FuriHalSpiBusHandle;
}
unsafe extern "C" {
    #[doc = "ST25R3916 on `furi_hal_spi_bus_r`"]
    pub static mut furi_hal_spi_bus_handle_nfc: FuriHalSpiBusHandle;
}
unsafe extern "C" {
    #[doc = "External on `furi_hal_spi_bus_r`\n Preset: `furi_hal_spi_preset_1edge_low_2m`\n\n miso: pa6\n mosi: pa7\n sck: pb3\n cs: pa4 (software controlled)\n\n not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize\n Bus pins are floating on inactive state, CS high after initialization\n"]
    pub static mut furi_hal_spi_bus_handle_external: FuriHalSpiBusHandle;
}
unsafe extern "C" {
    #[doc = "ST7567(Display) on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_display: FuriHalSpiBusHandle;
}
unsafe extern "C" {
    #[doc = "SdCard in fast mode on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_sd_fast: FuriHalSpiBusHandle;
}
unsafe extern "C" {
    #[doc = "SdCard in slow mode on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_sd_slow: FuriHalSpiBusHandle;
}
unsafe extern "C" {
    #[doc = "Initialize SPI Bus\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBus instance"]
    pub fn furi_hal_spi_bus_init(bus: *mut FuriHalSpiBus);
}
unsafe extern "C" {
    #[doc = "Deinitialize SPI Bus\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBus instance"]
    pub fn furi_hal_spi_bus_deinit(bus: *mut FuriHalSpiBus);
}
unsafe extern "C" {
    #[doc = "Initialize SPI Bus Handle\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_bus_handle_init(handle: *mut FuriHalSpiBusHandle);
}
unsafe extern "C" {
    #[doc = "Deinitialize SPI Bus Handle\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_bus_handle_deinit(handle: *mut FuriHalSpiBusHandle);
}
unsafe extern "C" {
    #[doc = "Acquire SPI bus\n\n blocking, calls `furi_crash` on programming error, CS transition is up to handler event routine\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_acquire(handle: *mut FuriHalSpiBusHandle);
}
unsafe extern "C" {
    #[doc = "Release SPI bus\n\n calls `furi_crash` on programming error, CS transition is up to handler event routine\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_release(handle: *mut FuriHalSpiBusHandle);
}
unsafe extern "C" {
    #[doc = "SPI Receive\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n * `buffer` - receive buffer\n * `size` - transaction size (buffer size)\n * `timeout` - operation timeout in ms\n\n # Returns\n\ntrue on sucess"]
    pub fn furi_hal_spi_bus_rx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "SPI Transmit\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n * `buffer` - transmit buffer\n * `size` - transaction size (buffer size)\n * `timeout` - operation timeout in ms\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_spi_bus_tx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *const u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "SPI Transmit and Receive\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n * `tx_buffer` - pointer to tx buffer\n * `rx_buffer` - pointer to rx buffer\n * `size` - transaction size (buffer size)\n * `timeout` - operation timeout in ms\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_spi_bus_trx(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *const u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "SPI Transmit and Receive with DMA\n\n # Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n * `tx_buffer` - pointer to tx buffer\n * `rx_buffer` - pointer to rx buffer\n * `size` - transaction size (buffer size)\n * `timeout_ms` - operation timeout in ms\n\n # Returns\n\ntrue on success"]
    pub fn furi_hal_spi_bus_trx_dma(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *mut u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout_ms: u32,
    ) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FuriHalFlashRawOptionByteData {
    pub bytes: [u8; 128usize],
    pub obs: [FuriHalFlashRawOptionByteData__bindgen_ty_1; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FuriHalFlashRawOptionByteData__bindgen_ty_1 {
    pub values: FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1,
    pub dword: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1 {
    pub base: u32,
    pub complementary_value: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1"][::core::mem::size_of::<
        FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1"][::core::mem::align_of::<
        FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1,
    >() - 4usize];
    ["Offset of field: FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1::base"][::core::mem::offset_of!(
        FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1,
        base
    )
        - 0usize];
    [
        "Offset of field: FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1::complementary_value",
    ][::core::mem::offset_of!(
        FuriHalFlashRawOptionByteData__bindgen_ty_1__bindgen_ty_1,
        complementary_value
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalFlashRawOptionByteData__bindgen_ty_1"]
        [::core::mem::size_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1>() - 8usize];
    ["Alignment of FuriHalFlashRawOptionByteData__bindgen_ty_1"]
        [::core::mem::align_of::<FuriHalFlashRawOptionByteData__bindgen_ty_1>() - 8usize];
    ["Offset of field: FuriHalFlashRawOptionByteData__bindgen_ty_1::values"]
        [::core::mem::offset_of!(FuriHalFlashRawOptionByteData__bindgen_ty_1, values) - 0usize];
    ["Offset of field: FuriHalFlashRawOptionByteData__bindgen_ty_1::dword"]
        [::core::mem::offset_of!(FuriHalFlashRawOptionByteData__bindgen_ty_1, dword) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalFlashRawOptionByteData"]
        [::core::mem::size_of::<FuriHalFlashRawOptionByteData>() - 128usize];
    ["Alignment of FuriHalFlashRawOptionByteData"]
        [::core::mem::align_of::<FuriHalFlashRawOptionByteData>() - 8usize];
    ["Offset of field: FuriHalFlashRawOptionByteData::bytes"]
        [::core::mem::offset_of!(FuriHalFlashRawOptionByteData, bytes) - 0usize];
    ["Offset of field: FuriHalFlashRawOptionByteData::obs"]
        [::core::mem::offset_of!(FuriHalFlashRawOptionByteData, obs) - 0usize];
};
unsafe extern "C" {
    #[doc = "Turn on/off vibro\n\n # Arguments\n\n* `value` (direction in) - new state"]
    pub fn furi_hal_vibro_on(value: bool);
}
#[doc = "<Function has an error, STALLPID will be issued."]
pub const usbd_fail: _usbd_respond = _usbd_respond(0);
#[doc = "<Function completes request accepted ZLP or data will be send."]
pub const usbd_ack: _usbd_respond = _usbd_respond(1);
#[doc = "<Function is busy. NAK handshake."]
pub const usbd_nak: _usbd_respond = _usbd_respond(2);
#[repr(transparent)]
#[doc = "Reporting status results."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _usbd_respond(pub core::ffi::c_uchar);
#[doc = "Reporting status results."]
pub use self::_usbd_respond as usbd_respond;
#[doc = "Represents a USB device data."]
pub type usbd_device = _usbd_device;
#[doc = "Represents generic USB control request."]
#[repr(C)]
#[derive(Debug)]
pub struct usbd_ctlreq {
    #[doc = "<This bitmapped field identifies the characteristics of\n the specific request."]
    pub bmRequestType: u8,
    #[doc = "<This field specifies the particular request."]
    pub bRequest: u8,
    #[doc = "<It is used to pass a parameter to the device, specific to\n the request."]
    pub wValue: u16,
    #[doc = "<It is used to pass a parameter to the device, specific to\n the request."]
    pub wIndex: u16,
    #[doc = "<This field specifies the length of the data transferred\n during the second phase of the control transfer."]
    pub wLength: u16,
    #[doc = "<Data payload."]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of usbd_ctlreq"][::core::mem::size_of::<usbd_ctlreq>() - 8usize];
    ["Alignment of usbd_ctlreq"][::core::mem::align_of::<usbd_ctlreq>() - 2usize];
    ["Offset of field: usbd_ctlreq::bmRequestType"]
        [::core::mem::offset_of!(usbd_ctlreq, bmRequestType) - 0usize];
    ["Offset of field: usbd_ctlreq::bRequest"]
        [::core::mem::offset_of!(usbd_ctlreq, bRequest) - 1usize];
    ["Offset of field: usbd_ctlreq::wValue"][::core::mem::offset_of!(usbd_ctlreq, wValue) - 2usize];
    ["Offset of field: usbd_ctlreq::wIndex"][::core::mem::offset_of!(usbd_ctlreq, wIndex) - 4usize];
    ["Offset of field: usbd_ctlreq::wLength"]
        [::core::mem::offset_of!(usbd_ctlreq, wLength) - 6usize];
    ["Offset of field: usbd_ctlreq::data"][::core::mem::offset_of!(usbd_ctlreq, data) - 8usize];
};
#[doc = "USB device status data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_status {
    #[doc = "<Pointer to data buffer used for control requests."]
    pub data_buf: *mut core::ffi::c_void,
    #[doc = "<Pointer to current data for control request."]
    pub data_ptr: *mut core::ffi::c_void,
    #[doc = "<Count remained data for control request."]
    pub data_count: u16,
    #[doc = "<Size of the data buffer for control requests."]
    pub data_maxsize: u16,
    #[doc = "<Size of the control endpoint."]
    pub ep0size: u8,
    #[doc = "<Current device configuration number."]
    pub device_cfg: u8,
    #[doc = "<Current usbd_machine_state."]
    pub device_state: u8,
    #[doc = "<Current usbd_ctl_state."]
    pub control_state: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of usbd_status"][::core::mem::size_of::<usbd_status>() - 16usize];
    ["Alignment of usbd_status"][::core::mem::align_of::<usbd_status>() - 4usize];
    ["Offset of field: usbd_status::data_buf"]
        [::core::mem::offset_of!(usbd_status, data_buf) - 0usize];
    ["Offset of field: usbd_status::data_ptr"]
        [::core::mem::offset_of!(usbd_status, data_ptr) - 4usize];
    ["Offset of field: usbd_status::data_count"]
        [::core::mem::offset_of!(usbd_status, data_count) - 8usize];
    ["Offset of field: usbd_status::data_maxsize"]
        [::core::mem::offset_of!(usbd_status, data_maxsize) - 10usize];
    ["Offset of field: usbd_status::ep0size"]
        [::core::mem::offset_of!(usbd_status, ep0size) - 12usize];
    ["Offset of field: usbd_status::device_cfg"]
        [::core::mem::offset_of!(usbd_status, device_cfg) - 13usize];
    ["Offset of field: usbd_status::device_state"]
        [::core::mem::offset_of!(usbd_status, device_state) - 14usize];
    ["Offset of field: usbd_status::control_state"]
        [::core::mem::offset_of!(usbd_status, control_state) - 15usize];
};
#[doc = "Generic USB device event callback for events and endpoints processing\n # Arguments\n\n* `dev` (direction in) - pointer to USB device\n * `event` - USB_EVENTS \"USB event\"\n * `ep` - active endpoint number\n > **Note:** endpoints with same indexes i.e. 0x01 and 0x81 shares same callback."]
pub type usbd_evt_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, event: u8, ep: u8)>;
#[doc = "USB control transfer completed callback function.\n # Arguments\n\n* `dev` (direction in) - pointer to USB device\n * `req` (direction in) - pointer to usb request structure\n > **Note:** usbd_device->complete_callback will be set to NULL after this callback completion."]
pub type usbd_rqc_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, req: *mut usbd_ctlreq)>;
#[doc = "USB control callback function.\n \n\nUses for the control request processing.\n Some requests will be handled by core if callback don't process it (returns FALSE).\n If request was not processed STALL PID will be issued.\n - GET_CONFIGURATION\n - SET_CONFIGURATION (passes to usbd_cfg_callback)\n - GET_DESCRIPTOR (passes to usbd_dsc_callback)\n - GET_STATUS\n - SET_FEATURE, CLEAR_FEATURE (endpoints only)\n - SET_ADDRESS\n # Arguments\n\n* `dev` (direction in) - points to USB device\n * `req` (direction in) - points to usb control request\n * `*callback` (direction out) - USB control transfer completion callback, default is NULL (no callback)\n # Returns\n\nusbd_respond status."]
pub type usbd_ctl_callback = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut usbd_device,
        req: *mut usbd_ctlreq,
        callback: *mut usbd_rqc_callback,
    ) -> usbd_respond,
>;
#[doc = "USB get descriptor callback function\n \n\nCalled when GET_DESCRIPTOR request issued\n # Arguments\n\n* `req` (direction in) - pointer to usb control request structure\n * `address` (direction in, out) - pointer to the descriptor in memory. Points to req->data by default. You\n can use this buffer.\n * `dsize` (direction in, out) - descriptor size. maximum buffer size by default.\n # Returns\n\nusbd_ack if you passed the correct descriptor, usbd_fail otherwise."]
pub type usbd_dsc_callback = ::core::option::Option<
    unsafe extern "C" fn(
        req: *mut usbd_ctlreq,
        address: *mut *mut core::ffi::c_void,
        dsize: *mut u16,
    ) -> usbd_respond,
>;
#[doc = "USB set configuration callback function\n \n\ncalled when SET_CONFIGURATION request issued\n # Arguments\n\n* `dev` (direction in) - pointer to USB device\n * `cfg` (direction in) - configuration number.\n > **Note:** if config is 0 device endpoints should be de-configured\n # Returns\n\nTRUE if success"]
pub type usbd_cfg_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, cfg: u8) -> usbd_respond>;
#[doc = "USBD_HW\n # /\n/**Get USB device status and capabilities.\n # Returns\n\nHardware status and capabilities USBD_HW_CAPS"]
pub type usbd_hw_getinfo = ::core::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = "Enables or disables USB hardware\n # Arguments\n\n* `enable` - Enables USB when TRUE disables otherwise."]
pub type usbd_hw_enable = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = "Connects or disconnects USB hardware to/from usb host\n # Arguments\n\n* `connect` - Connects USB to host if TRUE, disconnects otherwise\n # Returns\n\nlanes connection status."]
pub type usbd_hw_connect = ::core::option::Option<unsafe extern "C" fn(connect: bool) -> u8>;
#[doc = "Sets USB hardware address\n # Arguments\n\n* `address` - USB address"]
pub type usbd_hw_setaddr = ::core::option::Option<unsafe extern "C" fn(address: u8)>;
#[doc = "Configures endpoint\n # Arguments\n\n* `ep` - endpoint address. Use USB_EPDIR_ macros to set endpoint direction\n * `eptype` - endpoint type. Use USB_EPTYPE_* macros.\n * `epsize` - endpoint size in bytes\n # Returns\n\nTRUE if success"]
pub type usbd_hw_ep_config =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, eptype: u8, epsize: u16) -> bool>;
#[doc = "De-configures, cleans and disables endpoint\n # Arguments\n\n* `ep` - endpoint index\n > **Note:** if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82)\n both will be deconfigured."]
pub type usbd_hw_ep_deconfig = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = "Reads data from OUT or control endpoint\n # Arguments\n\n* `ep` - endpoint index, should belong to OUT or CONTROL endpoint.\n * `buf` - pointer to read buffer\n * `blen` - size of the read buffer in bytes\n # Returns\n\nsize of the actually received data, -1 on error.\n > **Note:** if data does not fit buffer it will be truncated"]
pub type usbd_hw_ep_read = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = "Writes data to IN or control endpoint\n # Arguments\n\n* `ep` - endpoint index, hould belong to IN or CONTROL endpoint\n * `buf` - pointer to data buffer\n * `blen` - size of data will be written\n # Returns\n\nnumber of written bytes"]
pub type usbd_hw_ep_write = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *const core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = "Stalls and unstalls endpoint\n # Arguments\n\n* `ep` - endpoint address\n * `stall` - endpoint will be stalled if TRUE and unstalled otherwise.\n > **Note:** Has no effect on inactive endpoints."]
pub type usbd_hw_ep_setstall = ::core::option::Option<unsafe extern "C" fn(ep: u8, stall: bool)>;
#[doc = "Checks endpoint for stalled state\n # Arguments\n\n* `ep` - endpoint address\n # Returns\n\nTRUE if endpoint is stalled"]
pub type usbd_hw_ep_isstalled = ::core::option::Option<unsafe extern "C" fn(ep: u8) -> bool>;
#[doc = "Polls USB hardware for the events\n # Arguments\n\n* `dev` (direction in) - pointer to usb device structure\n * `callback` - callback to event processing subroutine"]
pub type usbd_hw_poll = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut usbd_device, callback: usbd_evt_callback),
>;
#[doc = "Gets frame number from usb hardware."]
pub type usbd_hw_get_frameno = ::core::option::Option<unsafe extern "C" fn() -> u16>;
#[doc = "Makes a string descriptor contains unique serial number from hardware ID's\n # Arguments\n\n* `buffer` (direction in) - pointer to buffer for the descriptor\n # Returns\n\nof the descriptor in bytes"]
pub type usbd_hw_get_serialno =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut core::ffi::c_void) -> u16>;
#[doc = "Represents a hardware USB driver call table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_driver {
    #[doc = "<usbd_hw_getinfo"]
    pub getinfo: usbd_hw_getinfo,
    #[doc = "<usbd_hw_enable"]
    pub enable: usbd_hw_enable,
    #[doc = "<usbd_hw_connect"]
    pub connect: usbd_hw_connect,
    #[doc = "<usbd_hw_setaddr"]
    pub setaddr: usbd_hw_setaddr,
    #[doc = "<usbd_hw_ep_config"]
    pub ep_config: usbd_hw_ep_config,
    #[doc = "<usbd_hw_ep_deconfig"]
    pub ep_deconfig: usbd_hw_ep_deconfig,
    #[doc = "<usbd_hw_ep_read"]
    pub ep_read: usbd_hw_ep_read,
    #[doc = "<usbd_hw_ep_write"]
    pub ep_write: usbd_hw_ep_write,
    #[doc = "<usbd_hw_ep_setstall"]
    pub ep_setstall: usbd_hw_ep_setstall,
    #[doc = "<usbd_hw_ep_isstalled"]
    pub ep_isstalled: usbd_hw_ep_isstalled,
    #[doc = "<usbd_hw_poll"]
    pub poll: usbd_hw_poll,
    #[doc = "<usbd_hw_get_frameno"]
    pub frame_no: usbd_hw_get_frameno,
    #[doc = "<usbd_hw_get_serialno"]
    pub get_serialno_desc: usbd_hw_get_serialno,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of usbd_driver"][::core::mem::size_of::<usbd_driver>() - 52usize];
    ["Alignment of usbd_driver"][::core::mem::align_of::<usbd_driver>() - 4usize];
    ["Offset of field: usbd_driver::getinfo"]
        [::core::mem::offset_of!(usbd_driver, getinfo) - 0usize];
    ["Offset of field: usbd_driver::enable"][::core::mem::offset_of!(usbd_driver, enable) - 4usize];
    ["Offset of field: usbd_driver::connect"]
        [::core::mem::offset_of!(usbd_driver, connect) - 8usize];
    ["Offset of field: usbd_driver::setaddr"]
        [::core::mem::offset_of!(usbd_driver, setaddr) - 12usize];
    ["Offset of field: usbd_driver::ep_config"]
        [::core::mem::offset_of!(usbd_driver, ep_config) - 16usize];
    ["Offset of field: usbd_driver::ep_deconfig"]
        [::core::mem::offset_of!(usbd_driver, ep_deconfig) - 20usize];
    ["Offset of field: usbd_driver::ep_read"]
        [::core::mem::offset_of!(usbd_driver, ep_read) - 24usize];
    ["Offset of field: usbd_driver::ep_write"]
        [::core::mem::offset_of!(usbd_driver, ep_write) - 28usize];
    ["Offset of field: usbd_driver::ep_setstall"]
        [::core::mem::offset_of!(usbd_driver, ep_setstall) - 32usize];
    ["Offset of field: usbd_driver::ep_isstalled"]
        [::core::mem::offset_of!(usbd_driver, ep_isstalled) - 36usize];
    ["Offset of field: usbd_driver::poll"][::core::mem::offset_of!(usbd_driver, poll) - 40usize];
    ["Offset of field: usbd_driver::frame_no"]
        [::core::mem::offset_of!(usbd_driver, frame_no) - 44usize];
    ["Offset of field: usbd_driver::get_serialno_desc"]
        [::core::mem::offset_of!(usbd_driver, get_serialno_desc) - 48usize];
};
#[doc = "Represents a USB device data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usbd_device {
    #[doc = "<usbd_driver"]
    pub driver: *const usbd_driver,
    #[doc = "<usbd_ctl_callback"]
    pub control_callback: usbd_ctl_callback,
    #[doc = "<usbd_rqc_callback"]
    pub complete_callback: usbd_rqc_callback,
    #[doc = "<usbd_cfg_callback"]
    pub config_callback: usbd_cfg_callback,
    #[doc = "<usbd_dsc_callback"]
    pub descriptor_callback: usbd_dsc_callback,
    #[doc = "<array of the event callbacks."]
    pub events: [usbd_evt_callback; 8usize],
    #[doc = "<array of the endpoint callbacks."]
    pub endpoint: [usbd_evt_callback; 8usize],
    #[doc = "<usbd_status"]
    pub status: usbd_status,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _usbd_device"][::core::mem::size_of::<_usbd_device>() - 100usize];
    ["Alignment of _usbd_device"][::core::mem::align_of::<_usbd_device>() - 4usize];
    ["Offset of field: _usbd_device::driver"]
        [::core::mem::offset_of!(_usbd_device, driver) - 0usize];
    ["Offset of field: _usbd_device::control_callback"]
        [::core::mem::offset_of!(_usbd_device, control_callback) - 4usize];
    ["Offset of field: _usbd_device::complete_callback"]
        [::core::mem::offset_of!(_usbd_device, complete_callback) - 8usize];
    ["Offset of field: _usbd_device::config_callback"]
        [::core::mem::offset_of!(_usbd_device, config_callback) - 12usize];
    ["Offset of field: _usbd_device::descriptor_callback"]
        [::core::mem::offset_of!(_usbd_device, descriptor_callback) - 16usize];
    ["Offset of field: _usbd_device::events"]
        [::core::mem::offset_of!(_usbd_device, events) - 20usize];
    ["Offset of field: _usbd_device::endpoint"]
        [::core::mem::offset_of!(_usbd_device, endpoint) - 52usize];
    ["Offset of field: _usbd_device::status"]
        [::core::mem::offset_of!(_usbd_device, status) - 84usize];
};
#[doc = "Represents a USB device descriptor\n \n\nA device descriptor describes general information about a USB device. It includes\n information that applies globally to the device and all of the devices configurations. A USB\n device has only one device descriptor. A high-speed capable device that has different device\n information for full-speed and high-speed must also have a usb_qualifier_descriptor."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_device_descriptor {
    #[doc = "<Size of the descriptor, in bytes."]
    pub bLength: u8,
    #[doc = "<USB_DTYPE_DEVICE Device descriptor."]
    pub bDescriptorType: u8,
    #[doc = "<BCD of the supported USB specification."]
    pub bcdUSB: u16,
    #[doc = "<USB device class."]
    pub bDeviceClass: u8,
    #[doc = "<USB device subclass."]
    pub bDeviceSubClass: u8,
    #[doc = "<USB device protocol."]
    pub bDeviceProtocol: u8,
    #[doc = "<Size of the control endpoint's bank in bytes."]
    pub bMaxPacketSize0: u8,
    #[doc = "<Vendor ID for the USB product."]
    pub idVendor: u16,
    #[doc = "<Unique product ID for the USB product."]
    pub idProduct: u16,
    #[doc = "<Product release (version) number."]
    pub bcdDevice: u16,
    #[doc = "<String index for the manufacturer's name."]
    pub iManufacturer: u8,
    #[doc = "<String index for the product name/details."]
    pub iProduct: u8,
    #[doc = "<String index for the product serial number."]
    pub iSerialNumber: u8,
    #[doc = "<Total number of configurations supported by the device."]
    pub bNumConfigurations: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of usb_device_descriptor"][::core::mem::size_of::<usb_device_descriptor>() - 18usize];
    ["Alignment of usb_device_descriptor"]
        [::core::mem::align_of::<usb_device_descriptor>() - 1usize];
    ["Offset of field: usb_device_descriptor::bLength"]
        [::core::mem::offset_of!(usb_device_descriptor, bLength) - 0usize];
    ["Offset of field: usb_device_descriptor::bDescriptorType"]
        [::core::mem::offset_of!(usb_device_descriptor, bDescriptorType) - 1usize];
    ["Offset of field: usb_device_descriptor::bcdUSB"]
        [::core::mem::offset_of!(usb_device_descriptor, bcdUSB) - 2usize];
    ["Offset of field: usb_device_descriptor::bDeviceClass"]
        [::core::mem::offset_of!(usb_device_descriptor, bDeviceClass) - 4usize];
    ["Offset of field: usb_device_descriptor::bDeviceSubClass"]
        [::core::mem::offset_of!(usb_device_descriptor, bDeviceSubClass) - 5usize];
    ["Offset of field: usb_device_descriptor::bDeviceProtocol"]
        [::core::mem::offset_of!(usb_device_descriptor, bDeviceProtocol) - 6usize];
    ["Offset of field: usb_device_descriptor::bMaxPacketSize0"]
        [::core::mem::offset_of!(usb_device_descriptor, bMaxPacketSize0) - 7usize];
    ["Offset of field: usb_device_descriptor::idVendor"]
        [::core::mem::offset_of!(usb_device_descriptor, idVendor) - 8usize];
    ["Offset of field: usb_device_descriptor::idProduct"]
        [::core::mem::offset_of!(usb_device_descriptor, idProduct) - 10usize];
    ["Offset of field: usb_device_descriptor::bcdDevice"]
        [::core::mem::offset_of!(usb_device_descriptor, bcdDevice) - 12usize];
    ["Offset of field: usb_device_descriptor::iManufacturer"]
        [::core::mem::offset_of!(usb_device_descriptor, iManufacturer) - 14usize];
    ["Offset of field: usb_device_descriptor::iProduct"]
        [::core::mem::offset_of!(usb_device_descriptor, iProduct) - 15usize];
    ["Offset of field: usb_device_descriptor::iSerialNumber"]
        [::core::mem::offset_of!(usb_device_descriptor, iSerialNumber) - 16usize];
    ["Offset of field: usb_device_descriptor::bNumConfigurations"]
        [::core::mem::offset_of!(usb_device_descriptor, bNumConfigurations) - 17usize];
};
unsafe extern "C" {
    pub static usbd_devfs: usbd_driver;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalUsbInterface {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut usbd_device,
            intf: *mut FuriHalUsbInterface,
            ctx: *mut core::ffi::c_void,
        ),
    >,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub wakeup: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub dev_descr: *mut usb_device_descriptor,
    pub str_manuf_descr: *mut core::ffi::c_void,
    pub str_prod_descr: *mut core::ffi::c_void,
    pub str_serial_descr: *mut core::ffi::c_void,
    pub cfg_descr: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalUsbInterface"][::core::mem::size_of::<FuriHalUsbInterface>() - 36usize];
    ["Alignment of FuriHalUsbInterface"][::core::mem::align_of::<FuriHalUsbInterface>() - 4usize];
    ["Offset of field: FuriHalUsbInterface::init"]
        [::core::mem::offset_of!(FuriHalUsbInterface, init) - 0usize];
    ["Offset of field: FuriHalUsbInterface::deinit"]
        [::core::mem::offset_of!(FuriHalUsbInterface, deinit) - 4usize];
    ["Offset of field: FuriHalUsbInterface::wakeup"]
        [::core::mem::offset_of!(FuriHalUsbInterface, wakeup) - 8usize];
    ["Offset of field: FuriHalUsbInterface::suspend"]
        [::core::mem::offset_of!(FuriHalUsbInterface, suspend) - 12usize];
    ["Offset of field: FuriHalUsbInterface::dev_descr"]
        [::core::mem::offset_of!(FuriHalUsbInterface, dev_descr) - 16usize];
    ["Offset of field: FuriHalUsbInterface::str_manuf_descr"]
        [::core::mem::offset_of!(FuriHalUsbInterface, str_manuf_descr) - 20usize];
    ["Offset of field: FuriHalUsbInterface::str_prod_descr"]
        [::core::mem::offset_of!(FuriHalUsbInterface, str_prod_descr) - 24usize];
    ["Offset of field: FuriHalUsbInterface::str_serial_descr"]
        [::core::mem::offset_of!(FuriHalUsbInterface, str_serial_descr) - 28usize];
    ["Offset of field: FuriHalUsbInterface::cfg_descr"]
        [::core::mem::offset_of!(FuriHalUsbInterface, cfg_descr) - 32usize];
};
unsafe extern "C" {
    #[doc = "USB device interface modes"]
    pub static mut usb_cdc_single: FuriHalUsbInterface;
}
unsafe extern "C" {
    pub static mut usb_cdc_dual: FuriHalUsbInterface;
}
unsafe extern "C" {
    pub static mut usb_hid: FuriHalUsbInterface;
}
unsafe extern "C" {
    pub static mut usb_hid_u2f: FuriHalUsbInterface;
}
unsafe extern "C" {
    pub static mut usb_ccid: FuriHalUsbInterface;
}
pub const FuriHalUsbStateEventReset: FuriHalUsbStateEvent = FuriHalUsbStateEvent(0);
pub const FuriHalUsbStateEventWakeup: FuriHalUsbStateEvent = FuriHalUsbStateEvent(1);
pub const FuriHalUsbStateEventSuspend: FuriHalUsbStateEvent = FuriHalUsbStateEvent(2);
pub const FuriHalUsbStateEventDescriptorRequest: FuriHalUsbStateEvent = FuriHalUsbStateEvent(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalUsbStateEvent(pub core::ffi::c_uchar);
pub type FuriHalUsbStateCallback = ::core::option::Option<
    unsafe extern "C" fn(state: FuriHalUsbStateEvent, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Set USB device configuration\n\n # Arguments\n\n* `mode` - new USB device mode\n * `ctx` - context passed to device mode init function\n # Returns\n\ntrue - mode switch started, false - mode switch is locked"]
    pub fn furi_hal_usb_set_config(
        new_if: *mut FuriHalUsbInterface,
        ctx: *mut core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get USB device configuration\n\n # Returns\n\ncurrent USB device mode"]
    pub fn furi_hal_usb_get_config() -> *mut FuriHalUsbInterface;
}
unsafe extern "C" {
    #[doc = "Lock USB device mode switch"]
    pub fn furi_hal_usb_lock();
}
unsafe extern "C" {
    #[doc = "Unlock USB device mode switch"]
    pub fn furi_hal_usb_unlock();
}
unsafe extern "C" {
    #[doc = "Check if USB device mode switch locked\n\n # Returns\n\nlock state"]
    pub fn furi_hal_usb_is_locked() -> bool;
}
unsafe extern "C" {
    #[doc = "Disable USB device"]
    pub fn furi_hal_usb_disable();
}
unsafe extern "C" {
    #[doc = "Enable USB device"]
    pub fn furi_hal_usb_enable();
}
unsafe extern "C" {
    #[doc = "Restart USB device"]
    pub fn furi_hal_usb_reinit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalUsbHidConfig {
    pub vid: u32,
    pub pid: u32,
    pub manuf: [core::ffi::c_char; 32usize],
    pub product: [core::ffi::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalUsbHidConfig"][::core::mem::size_of::<FuriHalUsbHidConfig>() - 72usize];
    ["Alignment of FuriHalUsbHidConfig"][::core::mem::align_of::<FuriHalUsbHidConfig>() - 4usize];
    ["Offset of field: FuriHalUsbHidConfig::vid"]
        [::core::mem::offset_of!(FuriHalUsbHidConfig, vid) - 0usize];
    ["Offset of field: FuriHalUsbHidConfig::pid"]
        [::core::mem::offset_of!(FuriHalUsbHidConfig, pid) - 4usize];
    ["Offset of field: FuriHalUsbHidConfig::manuf"]
        [::core::mem::offset_of!(FuriHalUsbHidConfig, manuf) - 8usize];
    ["Offset of field: FuriHalUsbHidConfig::product"]
        [::core::mem::offset_of!(FuriHalUsbHidConfig, product) - 40usize];
};
pub type HidStateCallback =
    ::core::option::Option<unsafe extern "C" fn(state: bool, context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Get USB HID connection state\n\n # Returns\n\ntrue / false"]
    pub fn furi_hal_hid_is_connected() -> bool;
}
unsafe extern "C" {
    #[doc = "Get USB HID keyboard leds state\n\n # Returns\n\nleds state"]
    pub fn furi_hal_hid_get_led_state() -> u8;
}
unsafe extern "C" {
    #[doc = "Set USB HID connect/disconnect callback\n\n # Arguments\n\n* `cb` - callback\n * `ctx` - callback context"]
    pub fn furi_hal_hid_set_state_callback(cb: HidStateCallback, ctx: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set the following key to pressed state and send HID report\n\n # Arguments\n\n* `button` - key code"]
    pub fn furi_hal_hid_kb_press(button: u16) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the following key to released state and send HID report\n\n # Arguments\n\n* `button` - key code"]
    pub fn furi_hal_hid_kb_release(button: u16) -> bool;
}
unsafe extern "C" {
    #[doc = "Clear all pressed keys and send HID report\n"]
    pub fn furi_hal_hid_kb_release_all() -> bool;
}
unsafe extern "C" {
    #[doc = "Set mouse movement and send HID report\n\n # Arguments\n\n* `dx` - x coordinate delta\n * `dy` - y coordinate delta"]
    pub fn furi_hal_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
unsafe extern "C" {
    #[doc = "Set mouse button to pressed state and send HID report\n\n # Arguments\n\n* `button` - key code"]
    pub fn furi_hal_hid_mouse_press(button: u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Set mouse button to released state and send HID report\n\n # Arguments\n\n* `button` - key code"]
    pub fn furi_hal_hid_mouse_release(button: u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Set mouse wheel position and send HID report\n\n # Arguments\n\n* `delta` - number of scroll steps"]
    pub fn furi_hal_hid_mouse_scroll(delta: i8) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the following consumer key to pressed state and send HID report\n\n # Arguments\n\n* `button` - key code"]
    pub fn furi_hal_hid_consumer_key_press(button: u16) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the following consumer key to released state and send HID report\n\n # Arguments\n\n* `button` - key code"]
    pub fn furi_hal_hid_consumer_key_release(button: u16) -> bool;
}
unsafe extern "C" {
    #[doc = "Clear all pressed consumer keys and send HID report\n"]
    pub fn furi_hal_hid_consumer_key_release_all() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalUsbCcidConfig {
    pub vid: u16,
    pub pid: u16,
    pub manuf: [core::ffi::c_char; 32usize],
    pub product: [core::ffi::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FuriHalUsbCcidConfig"][::core::mem::size_of::<FuriHalUsbCcidConfig>() - 68usize];
    ["Alignment of FuriHalUsbCcidConfig"][::core::mem::align_of::<FuriHalUsbCcidConfig>() - 2usize];
    ["Offset of field: FuriHalUsbCcidConfig::vid"]
        [::core::mem::offset_of!(FuriHalUsbCcidConfig, vid) - 0usize];
    ["Offset of field: FuriHalUsbCcidConfig::pid"]
        [::core::mem::offset_of!(FuriHalUsbCcidConfig, pid) - 2usize];
    ["Offset of field: FuriHalUsbCcidConfig::manuf"]
        [::core::mem::offset_of!(FuriHalUsbCcidConfig, manuf) - 4usize];
    ["Offset of field: FuriHalUsbCcidConfig::product"]
        [::core::mem::offset_of!(FuriHalUsbCcidConfig, product) - 36usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CcidCallbacks {
    pub icc_power_on_callback: ::core::option::Option<
        unsafe extern "C" fn(
            dataBlock: *mut u8,
            dataBlockLen: *mut u32,
            context: *mut core::ffi::c_void,
        ),
    >,
    pub xfr_datablock_callback: ::core::option::Option<
        unsafe extern "C" fn(
            pcToReaderDataBlock: *const u8,
            pcToReaderDataBlockLen: u32,
            readerToPcDataBlock: *mut u8,
            readerToPcDataBlockLen: *mut u32,
            context: *mut core::ffi::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CcidCallbacks"][::core::mem::size_of::<CcidCallbacks>() - 8usize];
    ["Alignment of CcidCallbacks"][::core::mem::align_of::<CcidCallbacks>() - 4usize];
    ["Offset of field: CcidCallbacks::icc_power_on_callback"]
        [::core::mem::offset_of!(CcidCallbacks, icc_power_on_callback) - 0usize];
    ["Offset of field: CcidCallbacks::xfr_datablock_callback"]
        [::core::mem::offset_of!(CcidCallbacks, xfr_datablock_callback) - 4usize];
};
unsafe extern "C" {
    #[doc = "Set CCID callbacks\n\n # Arguments\n\n* `cb` - CcidCallbacks instance\n * `context` - The context for callbacks"]
    pub fn furi_hal_usb_ccid_set_callbacks(cb: *mut CcidCallbacks, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Insert Smart Card"]
    pub fn furi_hal_usb_ccid_insert_smartcard();
}
unsafe extern "C" {
    #[doc = "Remove Smart Card"]
    pub fn furi_hal_usb_ccid_remove_smartcard();
}
pub const FuriHalSerialIdUsart: FuriHalSerialId = FuriHalSerialId(0);
pub const FuriHalSerialIdLpuart: FuriHalSerialId = FuriHalSerialId(1);
pub const FuriHalSerialIdMax: FuriHalSerialId = FuriHalSerialId(2);
#[repr(transparent)]
#[doc = "UART channels"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSerialId(pub core::ffi::c_uchar);
pub const FuriHalSerialDirectionTx: FuriHalSerialDirection = FuriHalSerialDirection(0);
pub const FuriHalSerialDirectionRx: FuriHalSerialDirection = FuriHalSerialDirection(1);
pub const FuriHalSerialDirectionMax: FuriHalSerialDirection = FuriHalSerialDirection(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSerialDirection(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSerialHandle {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Initialize Serial Control"]
    pub fn furi_hal_serial_control_init();
}
unsafe extern "C" {
    #[doc = "De-Initialize Serial Control"]
    pub fn furi_hal_serial_control_deinit();
}
unsafe extern "C" {
    #[doc = "Acquire Serial Interface Handler\n\n # Arguments\n\n* `serial_id` (direction in) - The serial transceiver identifier\n\n # Returns\n\nThe Serial Interface Handle or null if interfaces is in use"]
    pub fn furi_hal_serial_control_acquire(serial_id: FuriHalSerialId) -> *mut FuriHalSerialHandle;
}
unsafe extern "C" {
    #[doc = "Release Serial Interface Handler\n\n # Arguments\n\n* `handle` - The handle"]
    pub fn furi_hal_serial_control_release(handle: *mut FuriHalSerialHandle);
}
unsafe extern "C" {
    #[doc = "Acquire Serial Interface Handler\n\n # Arguments\n\n* `serial_id` (direction in) - The serial transceiver identifier\n\n # Returns\n\ntrue if handle is acquired by someone"]
    pub fn furi_hal_serial_control_is_busy(serial_id: FuriHalSerialId) -> bool;
}
unsafe extern "C" {
    #[doc = "Acquire Serial Interface Handler\n\n # Arguments\n\n* `serial_id` (direction in) - The serial transceiver identifier. Use FuriHalSerialIdMax to disable logging.\n * `baud_rate` (direction in) - The baud rate\n\n # Returns\n\nThe Serial Interface Handle or null if interfaces is in use"]
    pub fn furi_hal_serial_control_set_logging_config(serial_id: FuriHalSerialId, baud_rate: u32);
}
#[doc = "Expansion module detection callback type.\n\n # Arguments\n\n* `context` (direction in, out) - Pointer to the user-defined context object."]
pub type FuriHalSerialControlExpansionCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Enable expansion module detection for a given serial interface.\n\n Passing NULL as the callback parameter disables external module detection.\n\n # Arguments\n\n* `serial_id` (direction in) - Identifier of the serial interface to be used.\n * `callback` (direction in) - Pointer to the callback function to be called upon module detection.\n * `context` (direction in, out) - Pointer to the user-defined context object. Will be passed to the callback function."]
    pub fn furi_hal_serial_control_set_expansion_callback(
        serial_id: FuriHalSerialId,
        callback: FuriHalSerialControlExpansionCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Initialize Serial\n\n Configures GPIO, configures and enables transceiver.\n\n # Arguments\n\n* `handle` - Serial handle\n * `baud` - baud rate"]
    pub fn furi_hal_serial_init(handle: *mut FuriHalSerialHandle, baud: u32);
}
unsafe extern "C" {
    #[doc = "De-initialize Serial\n\n Configures GPIO to analog, clears callback and callback context, disables\n hardware\n\n # Arguments\n\n* `handle` - Serial handle"]
    pub fn furi_hal_serial_deinit(handle: *mut FuriHalSerialHandle);
}
unsafe extern "C" {
    #[doc = "Suspend operation\n\n Suspend hardware, settings and callbacks are preserved\n\n # Arguments\n\n* `handle` - Serial handle"]
    pub fn furi_hal_serial_suspend(handle: *mut FuriHalSerialHandle);
}
unsafe extern "C" {
    #[doc = "Resume operation\n\n Resumes hardware from suspended state\n\n # Arguments\n\n* `handle` - Serial handle"]
    pub fn furi_hal_serial_resume(handle: *mut FuriHalSerialHandle);
}
unsafe extern "C" {
    #[doc = "Determine whether a certain baud rate is supported\n\n # Arguments\n\n* `handle` - Serial handle\n * `baud` - baud rate to be checked\n # Returns\n\ntrue if baud rate is supported, false otherwise."]
    pub fn furi_hal_serial_is_baud_rate_supported(
        handle: *mut FuriHalSerialHandle,
        baud: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Changes baud rate\n\n # Arguments\n\n* `handle` - Serial handle\n * `baud` - baud rate"]
    pub fn furi_hal_serial_set_br(handle: *mut FuriHalSerialHandle, baud: u32);
}
unsafe extern "C" {
    #[doc = "Transmits data in semi-blocking mode\n\n Fills transmission pipe with data, returns as soon as all bytes from buffer\n are in the pipe.\n\n Real transmission will be completed later. Use\n `furi_hal_serial_tx_wait_complete` to wait for completion if you need it.\n\n # Arguments\n\n* `handle` - Serial handle\n * `buffer` - data\n * `buffer_size` - data size (in bytes)"]
    pub fn furi_hal_serial_tx(
        handle: *mut FuriHalSerialHandle,
        buffer: *const u8,
        buffer_size: usize,
    );
}
unsafe extern "C" {
    #[doc = "Wait until transmission is completed\n\n Ensures that all data has been sent.\n\n # Arguments\n\n* `handle` - Serial handle"]
    pub fn furi_hal_serial_tx_wait_complete(handle: *mut FuriHalSerialHandle);
}
#[doc = "< Data: new data available"]
pub const FuriHalSerialRxEventData: FuriHalSerialRxEvent = FuriHalSerialRxEvent(1);
#[doc = "< Idle: bus idle detected"]
pub const FuriHalSerialRxEventIdle: FuriHalSerialRxEvent = FuriHalSerialRxEvent(2);
#[doc = "< Framing Error: incorrect frame detected"]
pub const FuriHalSerialRxEventFrameError: FuriHalSerialRxEvent = FuriHalSerialRxEvent(4);
#[doc = "< Noise Error: noise on the line detected"]
pub const FuriHalSerialRxEventNoiseError: FuriHalSerialRxEvent = FuriHalSerialRxEvent(8);
#[doc = "< Overrun Error: no space for received data"]
pub const FuriHalSerialRxEventOverrunError: FuriHalSerialRxEvent = FuriHalSerialRxEvent(16);
#[repr(transparent)]
#[doc = "Serial RX events"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSerialRxEvent(pub core::ffi::c_uchar);
#[doc = "Receive callback\n\n Callback will be called in interrupt context, ensure thread\n safety on your side.\n # Arguments\n\n* `handle` - Serial handle\n * `event` - FuriHalSerialRxEvent\n * `context` - Callback context provided earlier"]
pub type FuriHalSerialAsyncRxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut FuriHalSerialHandle,
        event: FuriHalSerialRxEvent,
        context: *mut core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = "Start and sets Serial Receive callback\n\n Callback will be called in interrupt context, ensure thread\n safety on your side\n\n # Arguments\n\n* `handle` - Serial handle\n * `callback` - callback pointer\n * `context` - callback context\n * `report_errors` (direction in) - report RX error"]
    pub fn furi_hal_serial_async_rx_start(
        handle: *mut FuriHalSerialHandle,
        callback: FuriHalSerialAsyncRxCallback,
        context: *mut core::ffi::c_void,
        report_errors: bool,
    );
}
unsafe extern "C" {
    #[doc = "Stop Serial Receive\n\n # Arguments\n\n* `handle` - Serial handle"]
    pub fn furi_hal_serial_async_rx_stop(handle: *mut FuriHalSerialHandle);
}
unsafe extern "C" {
    #[doc = "Check if there is data available for reading\n\n This function must be called only from the callback\n FuriHalSerialAsyncRxCallback\n\n # Arguments\n\n* `handle` - Serial handle\n # Returns\n\ntrue if data is available for reading, false otherwise"]
    pub fn furi_hal_serial_async_rx_available(handle: *mut FuriHalSerialHandle) -> bool;
}
unsafe extern "C" {
    #[doc = "Get data Serial receive\n\n This function must be called only from the callback\n FuriHalSerialAsyncRxCallback\n\n # Arguments\n\n* `handle` - Serial handle\n\n # Returns\n\ndata"]
    pub fn furi_hal_serial_async_rx(handle: *mut FuriHalSerialHandle) -> u8;
}
#[doc = "Receive DMA callback\n\n DMA Callback will be called in interrupt context, ensure thread\n safety on your side.\n\n # Arguments\n\n* `handle` - Serial handle\n * `event` - FuriHalSerialDmaRxEvent\n * `data_len` - Received data\n * `context` - Callback context provided earlier"]
pub type FuriHalSerialDmaRxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut FuriHalSerialHandle,
        event: FuriHalSerialRxEvent,
        data_len: usize,
        context: *mut core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = "Enable an input/output directon\n\n Takes over the respective pin by reconfiguring it to\n the appropriate alternative function.\n\n # Arguments\n\n* `handle` - Serial handle\n * `direction` - Direction to enable"]
    pub fn furi_hal_serial_enable_direction(
        handle: *mut FuriHalSerialHandle,
        direction: FuriHalSerialDirection,
    );
}
unsafe extern "C" {
    #[doc = "Disable an input/output directon\n\n Releases the respective pin by reconfiguring it to\n initial state, making possible its use for other purposes.\n\n # Arguments\n\n* `handle` - Serial handle\n * `direction` - Direction to disable"]
    pub fn furi_hal_serial_disable_direction(
        handle: *mut FuriHalSerialHandle,
        direction: FuriHalSerialDirection,
    );
}
unsafe extern "C" {
    #[doc = "Get the GPIO pin associated with a serial\n\n # Arguments\n\n* `handle` - Serial handle\n * `direction` - Direction to query\n # Returns\n\npointer to the respective pin instance"]
    pub fn furi_hal_serial_get_gpio_pin(
        handle: *mut FuriHalSerialHandle,
        direction: FuriHalSerialDirection,
    ) -> *const GpioPin;
}
unsafe extern "C" {
    #[doc = "Start and sets Serial event callback receive DMA\n\n # Arguments\n\n* `handle` - Serial handle\n * `callback` - callback pointer\n * `context` - callback context\n * `report_errors` (direction in) - report RX error"]
    pub fn furi_hal_serial_dma_rx_start(
        handle: *mut FuriHalSerialHandle,
        callback: FuriHalSerialDmaRxCallback,
        context: *mut core::ffi::c_void,
        report_errors: bool,
    );
}
unsafe extern "C" {
    #[doc = "Stop Serial receive DMA\n\n # Arguments\n\n* `handle` - Serial handle"]
    pub fn furi_hal_serial_dma_rx_stop(handle: *mut FuriHalSerialHandle);
}
unsafe extern "C" {
    #[doc = "Get data Serial receive DMA\n\n This function must be called only from the callback\n FuriHalSerialDmaRxCallback\n\n # Arguments\n\n* `handle` - Serial handle\n * `data` - pointer to data buffer\n * `len` - get data size (in bytes)\n\n # Returns\n\nsize actual data receive (in bytes)"]
    pub fn furi_hal_serial_dma_rx(
        handle: *mut FuriHalSerialHandle,
        data: *mut u8,
        len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn furi_hal_info_get_api_version(major: *mut u16, minor: *mut u16);
}
unsafe extern "C" {
    #[doc = "Get device information\n\n # Arguments\n\n* `callback` (direction in) - callback to provide with new data\n * `sep` (direction in) - category separator character\n * `context` (direction in) - context to pass to callback"]
    pub fn furi_hal_info_get(
        callback: PropertyValueCallback,
        sep: core::ffi::c_char,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Initialize random subsystem"]
    pub fn furi_hal_random_init();
}
unsafe extern "C" {
    #[doc = "Get random value\n furi_hal_random_get() gives up to FURI_HAL_RANDOM_MAX\n rand() and random() give up to RAND_MAX\n\n # Returns\n\n32 bit random value (up to FURI_HAL_RANDOM_MAX)"]
    pub fn furi_hal_random_get() -> u32;
}
unsafe extern "C" {
    #[doc = "Fill buffer with random data\n\n # Arguments\n\n* `buf` - buffer pointer\n * `data` - buffer len"]
    pub fn furi_hal_random_fill_buf(buf: *mut u8, len: u32);
}
#[doc = "< default configuration"]
pub const FuriHalSubGhzPresetIDLE: FuriHalSubGhzPreset = FuriHalSubGhzPreset(0);
#[doc = "< OOK, bandwidth 270kHz, asynchronous"]
pub const FuriHalSubGhzPresetOok270Async: FuriHalSubGhzPreset = FuriHalSubGhzPreset(1);
#[doc = "< OOK, bandwidth 650kHz, asynchronous"]
pub const FuriHalSubGhzPresetOok650Async: FuriHalSubGhzPreset = FuriHalSubGhzPreset(2);
#[doc = "< FM, deviation 2.380371 kHz, asynchronous"]
pub const FuriHalSubGhzPreset2FSKDev238Async: FuriHalSubGhzPreset = FuriHalSubGhzPreset(3);
#[doc = "< FM, deviation 47.60742 kHz, asynchronous"]
pub const FuriHalSubGhzPreset2FSKDev476Async: FuriHalSubGhzPreset = FuriHalSubGhzPreset(4);
#[doc = "< MSK, deviation 47.60742 kHz, 99.97Kb/s, asynchronous"]
pub const FuriHalSubGhzPresetMSK99_97KbAsync: FuriHalSubGhzPreset = FuriHalSubGhzPreset(5);
#[doc = "< GFSK, deviation 19.042969 kHz, 9.996Kb/s, asynchronous"]
pub const FuriHalSubGhzPresetGFSK9_99KbAsync: FuriHalSubGhzPreset = FuriHalSubGhzPreset(6);
pub const FuriHalSubGhzPresetCustom: FuriHalSubGhzPreset = FuriHalSubGhzPreset(7);
#[repr(transparent)]
#[doc = "Radio Presets"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSubGhzPreset(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LevelDuration {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LevelDuration"][::core::mem::size_of::<LevelDuration>() - 4usize];
    ["Alignment of LevelDuration"][::core::mem::align_of::<LevelDuration>() - 4usize];
};
impl LevelDuration {
    #[inline]
    pub fn duration(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_duration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn duration_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_duration_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn level_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_level_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(duration: u32, level: u8) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let duration: u32 = unsafe { ::core::mem::transmute(duration) };
            duration as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let level: u8 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Isolate Radio from antenna"]
pub const FuriHalSubGhzPathIsolate: FuriHalSubGhzPath = FuriHalSubGhzPath(0);
#[doc = "< Center Frequency: 433MHz. Path 1: SW1RF1-SW2RF2, LCLCL"]
pub const FuriHalSubGhzPath433: FuriHalSubGhzPath = FuriHalSubGhzPath(1);
#[doc = "< Center Frequency: 315MHz. Path 2: SW1RF2-SW2RF1, LCLCLCL"]
pub const FuriHalSubGhzPath315: FuriHalSubGhzPath = FuriHalSubGhzPath(2);
#[doc = "< Center Frequency: 868MHz. Path 3: SW1RF3-SW2RF3, LCLC"]
pub const FuriHalSubGhzPath868: FuriHalSubGhzPath = FuriHalSubGhzPath(3);
#[repr(transparent)]
#[doc = "Switchable Radio Paths"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalSubGhzPath(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn furi_hal_subghz_set_async_mirror_pin(pin: *const GpioPin);
}
unsafe extern "C" {
    #[doc = "Get data GPIO\n\n # Returns\n\npointer to the gpio pin structure"]
    pub fn furi_hal_subghz_get_data_gpio() -> *const GpioPin;
}
unsafe extern "C" {
    #[doc = "Send device to sleep mode"]
    pub fn furi_hal_subghz_sleep();
}
unsafe extern "C" {
    #[doc = "Load custom registers from preset\n\n # Arguments\n\n* `preset_data` - registers to load"]
    pub fn furi_hal_subghz_load_custom_preset(preset_data: *const u8);
}
unsafe extern "C" {
    #[doc = "Load registers\n\n # Arguments\n\n* `data` - Registers data"]
    pub fn furi_hal_subghz_load_registers(data: *const u8);
}
unsafe extern "C" {
    #[doc = "Load PATABLE\n\n # Arguments\n\n* `data` - 8 uint8_t values"]
    pub fn furi_hal_subghz_load_patable(data: *const u8);
}
unsafe extern "C" {
    #[doc = "Write packet to FIFO\n\n # Arguments\n\n* `data` - bytes array\n * `size` - size"]
    pub fn furi_hal_subghz_write_packet(data: *const u8, size: u8);
}
unsafe extern "C" {
    #[doc = "Check if receive pipe is not empty\n\n # Returns\n\ntrue if not empty"]
    pub fn furi_hal_subghz_rx_pipe_not_empty() -> bool;
}
unsafe extern "C" {
    #[doc = "Check if received data crc is valid\n\n # Returns\n\ntrue if valid"]
    pub fn furi_hal_subghz_is_rx_data_crc_valid() -> bool;
}
unsafe extern "C" {
    #[doc = "Read packet from FIFO\n\n # Arguments\n\n* `data` - pointer\n * `size` - size"]
    pub fn furi_hal_subghz_read_packet(data: *mut u8, size: *mut u8);
}
unsafe extern "C" {
    #[doc = "Flush rx FIFO buffer"]
    pub fn furi_hal_subghz_flush_rx();
}
unsafe extern "C" {
    #[doc = "Flush tx FIFO buffer"]
    pub fn furi_hal_subghz_flush_tx();
}
unsafe extern "C" {
    #[doc = "Shutdown Issue SPWD command\n registers content will be lost"]
    pub fn furi_hal_subghz_shutdown();
}
unsafe extern "C" {
    #[doc = "Reset Issue reset command\n registers content will be lost"]
    pub fn furi_hal_subghz_reset();
}
unsafe extern "C" {
    #[doc = "Switch to Idle"]
    pub fn furi_hal_subghz_idle();
}
unsafe extern "C" {
    #[doc = "Switch to Receive"]
    pub fn furi_hal_subghz_rx();
}
unsafe extern "C" {
    #[doc = "Switch to Transmit\n\n # Returns\n\ntrue if the transfer is allowed by belonging to the region"]
    pub fn furi_hal_subghz_tx() -> bool;
}
unsafe extern "C" {
    #[doc = "Get RSSI value in dBm\n\n # Returns\n\nRSSI value"]
    pub fn furi_hal_subghz_get_rssi() -> f32;
}
unsafe extern "C" {
    #[doc = "Get LQI\n\n # Returns\n\nLQI value"]
    pub fn furi_hal_subghz_get_lqi() -> u8;
}
unsafe extern "C" {
    #[doc = "Check if frequency is in valid range\n\n # Arguments\n\n* `value` - frequency in Hz\n\n # Returns\n\ntrue if frequency is valid, otherwise false"]
    pub fn furi_hal_subghz_is_frequency_valid(value: u32) -> bool;
}
unsafe extern "C" {
    #[doc = "Set frequency and path This function automatically selects antenna matching\n network\n\n # Arguments\n\n* `value` - frequency in Hz\n\n # Returns\n\nreal frequency in Hz"]
    pub fn furi_hal_subghz_set_frequency_and_path(value: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Set frequency\n\n # Arguments\n\n* `value` - frequency in Hz\n\n # Returns\n\nreal frequency in Hz"]
    pub fn furi_hal_subghz_set_frequency(value: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Set path\n\n # Arguments\n\n* `path` - path to use"]
    pub fn furi_hal_subghz_set_path(path: FuriHalSubGhzPath);
}
#[doc = "Signal Timings Capture callback"]
pub type FuriHalSubGhzCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Enable signal timings capture Initializes GPIO and TIM2 for timings capture\n\n # Arguments\n\n* `callback` - FuriHalSubGhzCaptureCallback\n * `context` - callback context"]
    pub fn furi_hal_subghz_start_async_rx(
        callback: FuriHalSubGhzCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Disable signal timings capture Resets GPIO and TIM2"]
    pub fn furi_hal_subghz_stop_async_rx();
}
#[doc = "Async TX callback type\n # Arguments\n\n* `context` - callback context\n # Returns\n\nLevelDuration"]
pub type FuriHalSubGhzAsyncTxCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
unsafe extern "C" {
    #[doc = "Start async TX Initializes GPIO, TIM2 and DMA1 for signal output\n\n # Arguments\n\n* `callback` - FuriHalSubGhzAsyncTxCallback\n * `context` - callback context\n\n # Returns\n\ntrue if the transfer is allowed by belonging to the region"]
    pub fn furi_hal_subghz_start_async_tx(
        callback: FuriHalSubGhzAsyncTxCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Wait for async transmission to complete\n\n # Returns\n\ntrue if TX complete"]
    pub fn furi_hal_subghz_is_async_tx_complete() -> bool;
}
unsafe extern "C" {
    #[doc = "Stop async transmission and cleanup resources Resets GPIO, TIM2, and DMA1"]
    pub fn furi_hal_subghz_stop_async_tx();
}
pub type FuriHalIbuttonEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Start emulation timer\n # Arguments\n\n* `period` - timer period\n * `callback` - timer callback\n * `context` - callback context"]
    pub fn furi_hal_ibutton_emulate_start(
        period: u32,
        callback: FuriHalIbuttonEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Update emulation timer period\n # Arguments\n\n* `period` - new timer period"]
    pub fn furi_hal_ibutton_emulate_set_next(period: u32);
}
unsafe extern "C" {
    #[doc = "Stop emulation timer"]
    pub fn furi_hal_ibutton_emulate_stop();
}
unsafe extern "C" {
    #[doc = "Set the pin to normal mode (open collector), and sets it to float"]
    pub fn furi_hal_ibutton_pin_configure();
}
unsafe extern "C" {
    #[doc = "Sets the pin to analog mode, and sets it to float"]
    pub fn furi_hal_ibutton_pin_reset();
}
unsafe extern "C" {
    #[doc = "iButton write pin\n # Arguments\n\n* `state` - true / false"]
    pub fn furi_hal_ibutton_pin_write(state: bool);
}
unsafe extern "C" {
    #[doc = "Config rfid pins to reset state"]
    pub fn furi_hal_rfid_pins_reset();
}
unsafe extern "C" {
    #[doc = "Release rfid pull pin"]
    pub fn furi_hal_rfid_pin_pull_release();
}
unsafe extern "C" {
    #[doc = "Pulldown rfid pull pin"]
    pub fn furi_hal_rfid_pin_pull_pulldown();
}
unsafe extern "C" {
    #[doc = "Start read timer\n # Arguments\n\n* `freq` - timer frequency\n * `duty_cycle` - timer duty cycle, 0.0-1.0"]
    pub fn furi_hal_rfid_tim_read_start(freq: f32, duty_cycle: f32);
}
unsafe extern "C" {
    #[doc = "Pause read timer, to be able to continue later"]
    pub fn furi_hal_rfid_tim_read_pause();
}
unsafe extern "C" {
    #[doc = "Continue read timer"]
    pub fn furi_hal_rfid_tim_read_continue();
}
unsafe extern "C" {
    #[doc = "Stop read timer"]
    pub fn furi_hal_rfid_tim_read_stop();
}
pub type FuriHalRfidReadCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_start(
        callback: FuriHalRfidReadCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_stop();
}
pub type FuriHalRfidDMACallback =
    ::core::option::Option<unsafe extern "C" fn(half: bool, context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_start(
        duration: *mut u32,
        pulse: *mut u32,
        length: usize,
        callback: FuriHalRfidDMACallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_stop();
}
unsafe extern "C" {
    #[doc = "Set read timer period\n\n # Arguments\n\n* `period` - overall duration"]
    pub fn furi_hal_rfid_set_read_period(period: u32);
}
unsafe extern "C" {
    #[doc = "Set read timer pulse\n\n # Arguments\n\n* `pulse` - duration of high level"]
    pub fn furi_hal_rfid_set_read_pulse(pulse: u32);
}
unsafe extern "C" {
    #[doc = "Start/Enable comparator"]
    pub fn furi_hal_rfid_comp_start();
}
unsafe extern "C" {
    #[doc = "Stop/Disable comparator"]
    pub fn furi_hal_rfid_comp_stop();
}
pub type FuriHalRfidCompCallback =
    ::core::option::Option<unsafe extern "C" fn(level: bool, context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Set comparator callback"]
    pub fn furi_hal_rfid_comp_set_callback(
        callback: FuriHalRfidCompCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start/Enable Field Presence detect"]
    pub fn furi_hal_rfid_field_detect_start();
}
unsafe extern "C" {
    #[doc = "Stop/Disable Field Presence detect"]
    pub fn furi_hal_rfid_field_detect_stop();
}
unsafe extern "C" {
    #[doc = "Check Field Presence\n\n # Arguments\n\n* `frequency` (direction out) - pointer to frequency value to be set if filed detected\n\n # Returns\n\ntrue if field is present, false if not"]
    pub fn furi_hal_rfid_field_is_present(frequency: *mut u32) -> bool;
}
#[doc = "< Oscillator has been started."]
pub const FuriHalNfcEventOscOn: FuriHalNfcEvent = FuriHalNfcEvent(1);
#[doc = "< External field (carrier) has been detected."]
pub const FuriHalNfcEventFieldOn: FuriHalNfcEvent = FuriHalNfcEvent(2);
#[doc = "< External field (carrier) has been lost."]
pub const FuriHalNfcEventFieldOff: FuriHalNfcEvent = FuriHalNfcEvent(4);
#[doc = "< Reader has issued a wake-up command."]
pub const FuriHalNfcEventListenerActive: FuriHalNfcEvent = FuriHalNfcEvent(8);
#[doc = "< Transmission has started."]
pub const FuriHalNfcEventTxStart: FuriHalNfcEvent = FuriHalNfcEvent(16);
#[doc = "< Transmission has ended."]
pub const FuriHalNfcEventTxEnd: FuriHalNfcEvent = FuriHalNfcEvent(32);
#[doc = "< Reception has started."]
pub const FuriHalNfcEventRxStart: FuriHalNfcEvent = FuriHalNfcEvent(64);
#[doc = "< Reception has ended."]
pub const FuriHalNfcEventRxEnd: FuriHalNfcEvent = FuriHalNfcEvent(128);
#[doc = "< A collision has occurred."]
pub const FuriHalNfcEventCollision: FuriHalNfcEvent = FuriHalNfcEvent(256);
#[doc = "< Frame wait timer has expired."]
pub const FuriHalNfcEventTimerFwtExpired: FuriHalNfcEvent = FuriHalNfcEvent(512);
#[doc = "< Transmission block timer has expired."]
pub const FuriHalNfcEventTimerBlockTxExpired: FuriHalNfcEvent = FuriHalNfcEvent(1024);
pub const FuriHalNfcEventTimeout: FuriHalNfcEvent = FuriHalNfcEvent(2048);
pub const FuriHalNfcEventAbortRequest: FuriHalNfcEvent = FuriHalNfcEvent(4096);
#[repr(transparent)]
#[doc = "Enumeration of possible NFC HAL events."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalNfcEvent(pub core::ffi::c_ushort);
#[doc = "< No error has occurred."]
pub const FuriHalNfcErrorNone: FuriHalNfcError = FuriHalNfcError(0);
#[doc = "< The communication bus is busy."]
pub const FuriHalNfcErrorBusy: FuriHalNfcError = FuriHalNfcError(1);
#[doc = "< NFC hardware did not respond or responded unexpectedly."]
pub const FuriHalNfcErrorCommunication: FuriHalNfcError = FuriHalNfcError(2);
#[doc = "< Oscillator failed to start."]
pub const FuriHalNfcErrorOscillator: FuriHalNfcError = FuriHalNfcError(3);
#[doc = "< NFC hardware did not respond in time."]
pub const FuriHalNfcErrorCommunicationTimeout: FuriHalNfcError = FuriHalNfcError(4);
#[doc = "< Receive buffer was too small for the received data."]
pub const FuriHalNfcErrorBufferOverflow: FuriHalNfcError = FuriHalNfcError(5);
#[doc = "< Not enough data was received to parse a valid frame."]
pub const FuriHalNfcErrorIncompleteFrame: FuriHalNfcError = FuriHalNfcError(6);
#[doc = "< Cannot parse a frame due to unexpected/invalid data."]
pub const FuriHalNfcErrorDataFormat: FuriHalNfcError = FuriHalNfcError(7);
#[repr(transparent)]
#[doc = "Enumeration of possible NFC HAL errors."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalNfcError(pub core::ffi::c_uchar);
#[doc = "< Configure NFC HAL to operate as a poller."]
pub const FuriHalNfcModePoller: FuriHalNfcMode = FuriHalNfcMode(0);
#[doc = "< Configure NFC HAL to operate as a listener."]
pub const FuriHalNfcModeListener: FuriHalNfcMode = FuriHalNfcMode(1);
#[doc = "< Special value equal to the operating modes count. Internal use."]
pub const FuriHalNfcModeNum: FuriHalNfcMode = FuriHalNfcMode(2);
#[repr(transparent)]
#[doc = "Enumeration of possible NFC HAL operating modes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalNfcMode(pub core::ffi::c_uchar);
#[doc = "< Configure NFC HAL to use the ISO14443 (type A) technology."]
pub const FuriHalNfcTechIso14443a: FuriHalNfcTech = FuriHalNfcTech(0);
#[doc = "< Configure NFC HAL to use the ISO14443 (type B) technology."]
pub const FuriHalNfcTechIso14443b: FuriHalNfcTech = FuriHalNfcTech(1);
#[doc = "< Configure NFC HAL to use the ISO15693 technology."]
pub const FuriHalNfcTechIso15693: FuriHalNfcTech = FuriHalNfcTech(2);
#[doc = "< Configure NFC HAL to use the FeliCa technology."]
pub const FuriHalNfcTechFelica: FuriHalNfcTech = FuriHalNfcTech(3);
#[doc = "< Special value equal to the supported technologies count. Internal use."]
pub const FuriHalNfcTechNum: FuriHalNfcTech = FuriHalNfcTech(4);
#[doc = "< Special value indicating the unconfigured state. Internal use."]
pub const FuriHalNfcTechInvalid: FuriHalNfcTech = FuriHalNfcTech(5);
#[repr(transparent)]
#[doc = "Enumeration of supported NFC technologies."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalNfcTech(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Initialise the NFC HAL and associated hardware.\n\n This function is called automatically during the firmware initialisation,\n so there is no need to call it explicitly.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_init() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Check whether the NFC HAL was properly initialised and is ready.\n\n # Returns\n\nFuriHalNfcErrorNone if ready, any other error code if not ready."]
    pub fn furi_hal_nfc_is_hal_ready() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Exclusively take over the NFC HAL and associated hardware.\n\n This function needs to be called whenever an interaction with the NFC HAL\n is to take place (usually once upon the application start).\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_acquire() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Release the exclusive lock and make the NFC HAL available for others.\n\n This function needs to be called when the user code is done working\n with the NFC HAL (usually once upon application exit). It must be called\n from the same thread that has called furi_hal_nfc_acquire().\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_release() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Configure the NFC hardware to enter the low-power mode.\n\n This function must be called each time when the user code is done working\n with the NFC HAL for the time being (e.g. waiting on user input).\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_low_power_mode_start() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Configure the NFC hardware to exit the low-power mode.\n\n This function must be called each time when the user code begins working\n with the NFC HAL, as the default state is low-power mode.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_low_power_mode_stop() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Configure the NFC HAL to work in a particular mode.\n\n Not all technologies implement the listener operating mode.\n\n # Arguments\n\n* `mode` (direction in) - required operating mode.\n * `tech` (direction in) - required technology configuration.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_set_mode(mode: FuriHalNfcMode, tech: FuriHalNfcTech) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Reset the NFC HAL to its default (unconfigured) state.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_reset_mode() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Enable field (carrier) detection by the NFC hardware.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_field_detect_start() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Disable field (carrier) detection by the NFC hardware.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_field_detect_stop() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Check if the reader field (carrier) was detected by the NFC hardware.\n\n # Returns\n\ntrue if the field was detected, false otherwise."]
    pub fn furi_hal_nfc_field_is_present() -> bool;
}
unsafe extern "C" {
    #[doc = "Enable field (carrier) generation by the NFC hardware.\n\n No carrier modulation will occur unless a transmission is explicitly started.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_poller_field_on() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Wait for an NFC HAL event in poller mode.\n\n # Arguments\n\n* `timeout_ms` (direction in) - time to wait (timeout) in milliseconds.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_poller_wait_event(timeout_ms: u32) -> FuriHalNfcEvent;
}
unsafe extern "C" {
    #[doc = "Wait for an NFC HAL event in listener mode.\n # Arguments\n\n* `timeout_ms` (direction in) - time to wait (timeout) in milliseconds.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_listener_wait_event(timeout_ms: u32) -> FuriHalNfcEvent;
}
unsafe extern "C" {
    #[doc = "Transmit data in poller mode.\n\n # Arguments\n\n* `tx_data` (direction in) - pointer to a byte array containing the data to be transmitted.\n * `tx_bits` (direction in) - transmit data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_poller_tx(tx_data: *const u8, tx_bits: usize) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Receive data in poller mode.\n\n The receive buffer must be big enough to accomodate all of the expected data.\n\n # Arguments\n\n* `rx_data` (direction out) - pointer to a byte array to be filled with received data.\n * `rx_data_size` (direction in) - maximum received data size, in bytes.\n * `rx_bits` (direction out) - pointer to the variable to hold received data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_poller_rx(
        rx_data: *mut u8,
        rx_data_size: usize,
        rx_bits: *mut usize,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Transmit data in listener mode.\n\n # Arguments\n\n* `tx_data` (direction in) - pointer to a byte array containing the data to be transmitted.\n * `tx_bits` (direction in) - transmit data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_listener_tx(tx_data: *const u8, tx_bits: usize) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Receive data in listener mode.\n\n The receive buffer must be big enough to accomodate all of the expected data.\n\n # Arguments\n\n* `rx_data` (direction out) - pointer to a byte array to be filled with received data.\n * `rx_data_size` (direction in) - maximum received data size, in bytes.\n * `rx_bits` (direction out) - pointer to the variable to hold received data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_listener_rx(
        rx_data: *mut u8,
        rx_data_size: usize,
        rx_bits: *mut usize,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Go to sleep in listener mode.\n\n Puts the passive target logic into Sleep (Halt) state.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_listener_sleep() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Go to idle in listener mode.\n\n Puts the passive target logic into Sense (Idle) state.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_listener_idle() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Enable reception in listener mode.\n\n Starts hardware receivers and receive decoders.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_listener_enable_rx() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Reset communication.\n\n Resets the communication state and stops all activities: transmission, reception, etc.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_trx_reset() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Enable generation of NFC HAL events.\n\n This function must be called from the same thread from which\n the the furi_hal_nfc_*_wait_event() calls will be made.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_event_start() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Disable generation of NFC HAL events.\n\n Unlike furi_hal_nfc_event_start(), this function may be called from any thread.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_event_stop() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Manually emit the FuriHalNfcEventAbortRequest event.\n\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_abort() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Start frame wait timeout timer.\n\n # Arguments\n\n* `time_fc` (direction in) - time to wait, in carrier cycles."]
    pub fn furi_hal_nfc_timer_fwt_start(time_fc: u32);
}
unsafe extern "C" {
    #[doc = "Stop frame wait timeout timer."]
    pub fn furi_hal_nfc_timer_fwt_stop();
}
unsafe extern "C" {
    #[doc = "Start block transmit (frame delay) timer.\n\n # Arguments\n\n* `time_fc` (direction in) - time to wait, in carrier cycles."]
    pub fn furi_hal_nfc_timer_block_tx_start(time_fc: u32);
}
unsafe extern "C" {
    #[doc = "Start block transmit (frame delay) timer.\n\n # Arguments\n\n* `time_us` (direction in) - time to wait, in microseconds."]
    pub fn furi_hal_nfc_timer_block_tx_start_us(time_us: u32);
}
unsafe extern "C" {
    #[doc = "Stop block transmit (frame delay) timer."]
    pub fn furi_hal_nfc_timer_block_tx_stop();
}
unsafe extern "C" {
    #[doc = "Check whether block transmit (frame delay) timer is running.\n\n # Returns\n\ntrue if timer is running, false otherwise."]
    pub fn furi_hal_nfc_timer_block_tx_is_running() -> bool;
}
pub const FuriHalNfcaShortFrameAllReq: FuriHalNfcaShortFrame = FuriHalNfcaShortFrame(0);
pub const FuriHalNfcaShortFrameSensReq: FuriHalNfcaShortFrame = FuriHalNfcaShortFrame(1);
#[repr(transparent)]
#[doc = "Enumeration of ISO14443 (Type A) short frame types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalNfcaShortFrame(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Transmit ISO14443 (Type A) short frame in poller mode.\n\n # Arguments\n\n* `frame` (direction in) - short frame type to be transmitted.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_iso14443a_poller_trx_short_frame(
        frame: FuriHalNfcaShortFrame,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Transmit ISO14443 (Type A) SDD frame in poller mode.\n\n # Arguments\n\n* `tx_data` (direction in) - pointer to a byte array containing the data to be transmitted.\n * `tx_bits` (direction in) - transmit data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_iso14443a_tx_sdd_frame(
        tx_data: *const u8,
        tx_bits: usize,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Receive ISO14443 (Type A) SDD frame in poller mode.\n\n The receive buffer must be big enough to accomodate all of the expected data.\n\n # Arguments\n\n* `rx_data` (direction in) - pointer to a byte array to be filled with received data.\n * `rx_data_size` (direction in) - maximum received data size, in bytes.\n * `rx_bits` (direction in) - pointer to the variable to hold received data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_iso14443a_rx_sdd_frame(
        rx_data: *mut u8,
        rx_data_size: usize,
        rx_bits: *mut usize,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Transmit ISO14443 (Type A) frame with custom parity bits in poller mode.\n\n Same as furi_hal_nfc_poller_tx(), but uses the parity bits provided\n by the user code instead of calculating them automatically.\n\n # Arguments\n\n* `tx_data` (direction in) - pointer to a byte array containing the data to be transmitted.\n * `tx_bits` (direction in) - transmit data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_iso14443a_poller_tx_custom_parity(
        tx_data: *const u8,
        tx_bits: usize,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Set ISO14443 (Type A) collision resolution parameters in listener mode.\n\n Configures the NFC hardware for automatic collision resolution.\n\n # Arguments\n\n* `uid` (direction in) - pointer to a byte array containing the UID.\n * `uid_len` (direction in) - UID length in bytes (must be supported by the protocol).\n * `atqa` (direction in) - ATQA byte value.\n * `sak` (direction in) - SAK byte value.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_iso14443a_listener_set_col_res_data(
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Transmit ISO14443 (Type A) frame with custom parity bits in listener mode.\n\n # Arguments\n\n* `tx_data` (direction in) - pointer to a byte array containing the data to be transmitted.\n * `tx_parity` (direction in) - pointer to a (bit-packed) byte array containing the parity to be transmitted.\n * `tx_bits` (direction in) - transmit data size, in bits.\n # Returns\n\nFuriHalNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_iso14443a_listener_tx_custom_parity(
        tx_data: *const u8,
        tx_parity: *const u8,
        tx_bits: usize,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Send ISO15693 SOF in listener mode\n\n # Returns\n\nFuriHalNfcError"]
    pub fn furi_hal_nfc_iso15693_listener_tx_sof() -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Set FeliCa collision resolution parameters in listener mode.\n\n Configures the NFC hardware for automatic collision resolution.\n\n # Arguments\n\n* `idm` (direction in) - pointer to a byte array containing the IDm.\n * `idm_len` (direction in) - IDm length in bytes.\n * `pmm` (direction in) - pointer to a byte array containing the PMm.\n * `pmm_len` (direction in) - PMm length in bytes.\n * `sys_code` (direction in) - System code from SYS_C block\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn furi_hal_nfc_felica_listener_set_sensf_res_data(
        idm: *const u8,
        idm_len: u8,
        pmm: *const u8,
        pmm_len: u8,
        sys_code: u16,
    ) -> FuriHalNfcError;
}
unsafe extern "C" {
    #[doc = "Jump to the void*\n\n Allow your code to transfer control to another firmware.\n\n This code doesn't reset system before jump. Call it only from\n main thread, no kernel should be running. Ensure that no\n peripheral blocks active and no interrupts are pending.\n\n # Arguments\n\n* `address` - The System Vector address(start of your new firmware)"]
    pub fn furi_hal_switch(address: *mut core::ffi::c_void);
}
pub type Elf32_Half = u16;
pub type Elf64_Half = u16;
pub type Elf32_Word = u32;
pub type Elf32_Sword = i32;
pub type Elf64_Word = u32;
pub type Elf64_Sword = i32;
pub type Elf32_Xword = u64;
pub type Elf32_Sxword = i64;
pub type Elf64_Xword = u64;
pub type Elf64_Sxword = i64;
pub type Elf32_Addr = u32;
pub type Elf64_Addr = u64;
pub type Elf32_Off = u32;
pub type Elf64_Off = u64;
pub type Elf32_Section = u16;
pub type Elf64_Section = u16;
pub type Elf32_Versym = Elf32_Half;
pub type Elf64_Versym = Elf64_Half;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Ehdr {
    pub e_ident: [core::ffi::c_uchar; 16usize],
    pub e_type: Elf32_Half,
    pub e_machine: Elf32_Half,
    pub e_version: Elf32_Word,
    pub e_entry: Elf32_Addr,
    pub e_phoff: Elf32_Off,
    pub e_shoff: Elf32_Off,
    pub e_flags: Elf32_Word,
    pub e_ehsize: Elf32_Half,
    pub e_phentsize: Elf32_Half,
    pub e_phnum: Elf32_Half,
    pub e_shentsize: Elf32_Half,
    pub e_shnum: Elf32_Half,
    pub e_shstrndx: Elf32_Half,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Ehdr"][::core::mem::size_of::<Elf32_Ehdr>() - 52usize];
    ["Alignment of Elf32_Ehdr"][::core::mem::align_of::<Elf32_Ehdr>() - 4usize];
    ["Offset of field: Elf32_Ehdr::e_ident"][::core::mem::offset_of!(Elf32_Ehdr, e_ident) - 0usize];
    ["Offset of field: Elf32_Ehdr::e_type"][::core::mem::offset_of!(Elf32_Ehdr, e_type) - 16usize];
    ["Offset of field: Elf32_Ehdr::e_machine"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_machine) - 18usize];
    ["Offset of field: Elf32_Ehdr::e_version"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_version) - 20usize];
    ["Offset of field: Elf32_Ehdr::e_entry"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_entry) - 24usize];
    ["Offset of field: Elf32_Ehdr::e_phoff"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_phoff) - 28usize];
    ["Offset of field: Elf32_Ehdr::e_shoff"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_shoff) - 32usize];
    ["Offset of field: Elf32_Ehdr::e_flags"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_flags) - 36usize];
    ["Offset of field: Elf32_Ehdr::e_ehsize"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_ehsize) - 40usize];
    ["Offset of field: Elf32_Ehdr::e_phentsize"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_phentsize) - 42usize];
    ["Offset of field: Elf32_Ehdr::e_phnum"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_phnum) - 44usize];
    ["Offset of field: Elf32_Ehdr::e_shentsize"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_shentsize) - 46usize];
    ["Offset of field: Elf32_Ehdr::e_shnum"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_shnum) - 48usize];
    ["Offset of field: Elf32_Ehdr::e_shstrndx"]
        [::core::mem::offset_of!(Elf32_Ehdr, e_shstrndx) - 50usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Ehdr {
    pub e_ident: [core::ffi::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Ehdr"][::core::mem::size_of::<Elf64_Ehdr>() - 64usize];
    ["Alignment of Elf64_Ehdr"][::core::mem::align_of::<Elf64_Ehdr>() - 8usize];
    ["Offset of field: Elf64_Ehdr::e_ident"][::core::mem::offset_of!(Elf64_Ehdr, e_ident) - 0usize];
    ["Offset of field: Elf64_Ehdr::e_type"][::core::mem::offset_of!(Elf64_Ehdr, e_type) - 16usize];
    ["Offset of field: Elf64_Ehdr::e_machine"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_machine) - 18usize];
    ["Offset of field: Elf64_Ehdr::e_version"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_version) - 20usize];
    ["Offset of field: Elf64_Ehdr::e_entry"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_entry) - 24usize];
    ["Offset of field: Elf64_Ehdr::e_phoff"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_phoff) - 32usize];
    ["Offset of field: Elf64_Ehdr::e_shoff"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_shoff) - 40usize];
    ["Offset of field: Elf64_Ehdr::e_flags"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_flags) - 48usize];
    ["Offset of field: Elf64_Ehdr::e_ehsize"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_ehsize) - 52usize];
    ["Offset of field: Elf64_Ehdr::e_phentsize"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_phentsize) - 54usize];
    ["Offset of field: Elf64_Ehdr::e_phnum"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_phnum) - 56usize];
    ["Offset of field: Elf64_Ehdr::e_shentsize"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_shentsize) - 58usize];
    ["Offset of field: Elf64_Ehdr::e_shnum"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_shnum) - 60usize];
    ["Offset of field: Elf64_Ehdr::e_shstrndx"]
        [::core::mem::offset_of!(Elf64_Ehdr, e_shstrndx) - 62usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Shdr {
    pub sh_name: Elf32_Word,
    pub sh_type: Elf32_Word,
    pub sh_flags: Elf32_Word,
    pub sh_addr: Elf32_Addr,
    pub sh_offset: Elf32_Off,
    pub sh_size: Elf32_Word,
    pub sh_link: Elf32_Word,
    pub sh_info: Elf32_Word,
    pub sh_addralign: Elf32_Word,
    pub sh_entsize: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Shdr"][::core::mem::size_of::<Elf32_Shdr>() - 40usize];
    ["Alignment of Elf32_Shdr"][::core::mem::align_of::<Elf32_Shdr>() - 4usize];
    ["Offset of field: Elf32_Shdr::sh_name"][::core::mem::offset_of!(Elf32_Shdr, sh_name) - 0usize];
    ["Offset of field: Elf32_Shdr::sh_type"][::core::mem::offset_of!(Elf32_Shdr, sh_type) - 4usize];
    ["Offset of field: Elf32_Shdr::sh_flags"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_flags) - 8usize];
    ["Offset of field: Elf32_Shdr::sh_addr"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_addr) - 12usize];
    ["Offset of field: Elf32_Shdr::sh_offset"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_offset) - 16usize];
    ["Offset of field: Elf32_Shdr::sh_size"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_size) - 20usize];
    ["Offset of field: Elf32_Shdr::sh_link"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_link) - 24usize];
    ["Offset of field: Elf32_Shdr::sh_info"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_info) - 28usize];
    ["Offset of field: Elf32_Shdr::sh_addralign"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_addralign) - 32usize];
    ["Offset of field: Elf32_Shdr::sh_entsize"]
        [::core::mem::offset_of!(Elf32_Shdr, sh_entsize) - 36usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Shdr"][::core::mem::size_of::<Elf64_Shdr>() - 64usize];
    ["Alignment of Elf64_Shdr"][::core::mem::align_of::<Elf64_Shdr>() - 8usize];
    ["Offset of field: Elf64_Shdr::sh_name"][::core::mem::offset_of!(Elf64_Shdr, sh_name) - 0usize];
    ["Offset of field: Elf64_Shdr::sh_type"][::core::mem::offset_of!(Elf64_Shdr, sh_type) - 4usize];
    ["Offset of field: Elf64_Shdr::sh_flags"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_flags) - 8usize];
    ["Offset of field: Elf64_Shdr::sh_addr"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_addr) - 16usize];
    ["Offset of field: Elf64_Shdr::sh_offset"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_offset) - 24usize];
    ["Offset of field: Elf64_Shdr::sh_size"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_size) - 32usize];
    ["Offset of field: Elf64_Shdr::sh_link"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_link) - 40usize];
    ["Offset of field: Elf64_Shdr::sh_info"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_info) - 44usize];
    ["Offset of field: Elf64_Shdr::sh_addralign"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_addralign) - 48usize];
    ["Offset of field: Elf64_Shdr::sh_entsize"]
        [::core::mem::offset_of!(Elf64_Shdr, sh_entsize) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Chdr {
    pub ch_type: Elf32_Word,
    pub ch_size: Elf32_Word,
    pub ch_addralign: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Chdr"][::core::mem::size_of::<Elf32_Chdr>() - 12usize];
    ["Alignment of Elf32_Chdr"][::core::mem::align_of::<Elf32_Chdr>() - 4usize];
    ["Offset of field: Elf32_Chdr::ch_type"][::core::mem::offset_of!(Elf32_Chdr, ch_type) - 0usize];
    ["Offset of field: Elf32_Chdr::ch_size"][::core::mem::offset_of!(Elf32_Chdr, ch_size) - 4usize];
    ["Offset of field: Elf32_Chdr::ch_addralign"]
        [::core::mem::offset_of!(Elf32_Chdr, ch_addralign) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Chdr {
    pub ch_type: Elf64_Word,
    pub ch_reserved: Elf64_Word,
    pub ch_size: Elf64_Xword,
    pub ch_addralign: Elf64_Xword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Chdr"][::core::mem::size_of::<Elf64_Chdr>() - 24usize];
    ["Alignment of Elf64_Chdr"][::core::mem::align_of::<Elf64_Chdr>() - 8usize];
    ["Offset of field: Elf64_Chdr::ch_type"][::core::mem::offset_of!(Elf64_Chdr, ch_type) - 0usize];
    ["Offset of field: Elf64_Chdr::ch_reserved"]
        [::core::mem::offset_of!(Elf64_Chdr, ch_reserved) - 4usize];
    ["Offset of field: Elf64_Chdr::ch_size"][::core::mem::offset_of!(Elf64_Chdr, ch_size) - 8usize];
    ["Offset of field: Elf64_Chdr::ch_addralign"]
        [::core::mem::offset_of!(Elf64_Chdr, ch_addralign) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Sym {
    pub st_name: Elf32_Word,
    pub st_value: Elf32_Addr,
    pub st_size: Elf32_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf32_Section,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Sym"][::core::mem::size_of::<Elf32_Sym>() - 16usize];
    ["Alignment of Elf32_Sym"][::core::mem::align_of::<Elf32_Sym>() - 4usize];
    ["Offset of field: Elf32_Sym::st_name"][::core::mem::offset_of!(Elf32_Sym, st_name) - 0usize];
    ["Offset of field: Elf32_Sym::st_value"][::core::mem::offset_of!(Elf32_Sym, st_value) - 4usize];
    ["Offset of field: Elf32_Sym::st_size"][::core::mem::offset_of!(Elf32_Sym, st_size) - 8usize];
    ["Offset of field: Elf32_Sym::st_info"][::core::mem::offset_of!(Elf32_Sym, st_info) - 12usize];
    ["Offset of field: Elf32_Sym::st_other"]
        [::core::mem::offset_of!(Elf32_Sym, st_other) - 13usize];
    ["Offset of field: Elf32_Sym::st_shndx"]
        [::core::mem::offset_of!(Elf32_Sym, st_shndx) - 14usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Sym {
    pub st_name: Elf64_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf64_Section,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Sym"][::core::mem::size_of::<Elf64_Sym>() - 24usize];
    ["Alignment of Elf64_Sym"][::core::mem::align_of::<Elf64_Sym>() - 8usize];
    ["Offset of field: Elf64_Sym::st_name"][::core::mem::offset_of!(Elf64_Sym, st_name) - 0usize];
    ["Offset of field: Elf64_Sym::st_info"][::core::mem::offset_of!(Elf64_Sym, st_info) - 4usize];
    ["Offset of field: Elf64_Sym::st_other"][::core::mem::offset_of!(Elf64_Sym, st_other) - 5usize];
    ["Offset of field: Elf64_Sym::st_shndx"][::core::mem::offset_of!(Elf64_Sym, st_shndx) - 6usize];
    ["Offset of field: Elf64_Sym::st_value"][::core::mem::offset_of!(Elf64_Sym, st_value) - 8usize];
    ["Offset of field: Elf64_Sym::st_size"][::core::mem::offset_of!(Elf64_Sym, st_size) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Syminfo {
    pub si_boundto: Elf32_Half,
    pub si_flags: Elf32_Half,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Syminfo"][::core::mem::size_of::<Elf32_Syminfo>() - 4usize];
    ["Alignment of Elf32_Syminfo"][::core::mem::align_of::<Elf32_Syminfo>() - 2usize];
    ["Offset of field: Elf32_Syminfo::si_boundto"]
        [::core::mem::offset_of!(Elf32_Syminfo, si_boundto) - 0usize];
    ["Offset of field: Elf32_Syminfo::si_flags"]
        [::core::mem::offset_of!(Elf32_Syminfo, si_flags) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Syminfo {
    pub si_boundto: Elf64_Half,
    pub si_flags: Elf64_Half,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Syminfo"][::core::mem::size_of::<Elf64_Syminfo>() - 4usize];
    ["Alignment of Elf64_Syminfo"][::core::mem::align_of::<Elf64_Syminfo>() - 2usize];
    ["Offset of field: Elf64_Syminfo::si_boundto"]
        [::core::mem::offset_of!(Elf64_Syminfo, si_boundto) - 0usize];
    ["Offset of field: Elf64_Syminfo::si_flags"]
        [::core::mem::offset_of!(Elf64_Syminfo, si_flags) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Rel {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Rel"][::core::mem::size_of::<Elf32_Rel>() - 8usize];
    ["Alignment of Elf32_Rel"][::core::mem::align_of::<Elf32_Rel>() - 4usize];
    ["Offset of field: Elf32_Rel::r_offset"][::core::mem::offset_of!(Elf32_Rel, r_offset) - 0usize];
    ["Offset of field: Elf32_Rel::r_info"][::core::mem::offset_of!(Elf32_Rel, r_info) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Rel {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Rel"][::core::mem::size_of::<Elf64_Rel>() - 16usize];
    ["Alignment of Elf64_Rel"][::core::mem::align_of::<Elf64_Rel>() - 8usize];
    ["Offset of field: Elf64_Rel::r_offset"][::core::mem::offset_of!(Elf64_Rel, r_offset) - 0usize];
    ["Offset of field: Elf64_Rel::r_info"][::core::mem::offset_of!(Elf64_Rel, r_info) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Rela {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
    pub r_addend: Elf32_Sword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Rela"][::core::mem::size_of::<Elf32_Rela>() - 12usize];
    ["Alignment of Elf32_Rela"][::core::mem::align_of::<Elf32_Rela>() - 4usize];
    ["Offset of field: Elf32_Rela::r_offset"]
        [::core::mem::offset_of!(Elf32_Rela, r_offset) - 0usize];
    ["Offset of field: Elf32_Rela::r_info"][::core::mem::offset_of!(Elf32_Rela, r_info) - 4usize];
    ["Offset of field: Elf32_Rela::r_addend"]
        [::core::mem::offset_of!(Elf32_Rela, r_addend) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Rela {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
    pub r_addend: Elf64_Sxword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Rela"][::core::mem::size_of::<Elf64_Rela>() - 24usize];
    ["Alignment of Elf64_Rela"][::core::mem::align_of::<Elf64_Rela>() - 8usize];
    ["Offset of field: Elf64_Rela::r_offset"]
        [::core::mem::offset_of!(Elf64_Rela, r_offset) - 0usize];
    ["Offset of field: Elf64_Rela::r_info"][::core::mem::offset_of!(Elf64_Rela, r_info) - 8usize];
    ["Offset of field: Elf64_Rela::r_addend"]
        [::core::mem::offset_of!(Elf64_Rela, r_addend) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Phdr {
    pub p_type: Elf32_Word,
    pub p_offset: Elf32_Off,
    pub p_vaddr: Elf32_Addr,
    pub p_paddr: Elf32_Addr,
    pub p_filesz: Elf32_Word,
    pub p_memsz: Elf32_Word,
    pub p_flags: Elf32_Word,
    pub p_align: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Phdr"][::core::mem::size_of::<Elf32_Phdr>() - 32usize];
    ["Alignment of Elf32_Phdr"][::core::mem::align_of::<Elf32_Phdr>() - 4usize];
    ["Offset of field: Elf32_Phdr::p_type"][::core::mem::offset_of!(Elf32_Phdr, p_type) - 0usize];
    ["Offset of field: Elf32_Phdr::p_offset"]
        [::core::mem::offset_of!(Elf32_Phdr, p_offset) - 4usize];
    ["Offset of field: Elf32_Phdr::p_vaddr"][::core::mem::offset_of!(Elf32_Phdr, p_vaddr) - 8usize];
    ["Offset of field: Elf32_Phdr::p_paddr"]
        [::core::mem::offset_of!(Elf32_Phdr, p_paddr) - 12usize];
    ["Offset of field: Elf32_Phdr::p_filesz"]
        [::core::mem::offset_of!(Elf32_Phdr, p_filesz) - 16usize];
    ["Offset of field: Elf32_Phdr::p_memsz"]
        [::core::mem::offset_of!(Elf32_Phdr, p_memsz) - 20usize];
    ["Offset of field: Elf32_Phdr::p_flags"]
        [::core::mem::offset_of!(Elf32_Phdr, p_flags) - 24usize];
    ["Offset of field: Elf32_Phdr::p_align"]
        [::core::mem::offset_of!(Elf32_Phdr, p_align) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Phdr {
    pub p_type: Elf64_Word,
    pub p_flags: Elf64_Word,
    pub p_offset: Elf64_Off,
    pub p_vaddr: Elf64_Addr,
    pub p_paddr: Elf64_Addr,
    pub p_filesz: Elf64_Xword,
    pub p_memsz: Elf64_Xword,
    pub p_align: Elf64_Xword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Phdr"][::core::mem::size_of::<Elf64_Phdr>() - 56usize];
    ["Alignment of Elf64_Phdr"][::core::mem::align_of::<Elf64_Phdr>() - 8usize];
    ["Offset of field: Elf64_Phdr::p_type"][::core::mem::offset_of!(Elf64_Phdr, p_type) - 0usize];
    ["Offset of field: Elf64_Phdr::p_flags"][::core::mem::offset_of!(Elf64_Phdr, p_flags) - 4usize];
    ["Offset of field: Elf64_Phdr::p_offset"]
        [::core::mem::offset_of!(Elf64_Phdr, p_offset) - 8usize];
    ["Offset of field: Elf64_Phdr::p_vaddr"]
        [::core::mem::offset_of!(Elf64_Phdr, p_vaddr) - 16usize];
    ["Offset of field: Elf64_Phdr::p_paddr"]
        [::core::mem::offset_of!(Elf64_Phdr, p_paddr) - 24usize];
    ["Offset of field: Elf64_Phdr::p_filesz"]
        [::core::mem::offset_of!(Elf64_Phdr, p_filesz) - 32usize];
    ["Offset of field: Elf64_Phdr::p_memsz"]
        [::core::mem::offset_of!(Elf64_Phdr, p_memsz) - 40usize];
    ["Offset of field: Elf64_Phdr::p_align"]
        [::core::mem::offset_of!(Elf64_Phdr, p_align) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf32_Dyn {
    pub d_tag: Elf32_Sword,
    pub d_un: Elf32_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf32_Dyn__bindgen_ty_1 {
    pub d_val: Elf32_Word,
    pub d_ptr: Elf32_Addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Dyn__bindgen_ty_1"][::core::mem::size_of::<Elf32_Dyn__bindgen_ty_1>() - 4usize];
    ["Alignment of Elf32_Dyn__bindgen_ty_1"]
        [::core::mem::align_of::<Elf32_Dyn__bindgen_ty_1>() - 4usize];
    ["Offset of field: Elf32_Dyn__bindgen_ty_1::d_val"]
        [::core::mem::offset_of!(Elf32_Dyn__bindgen_ty_1, d_val) - 0usize];
    ["Offset of field: Elf32_Dyn__bindgen_ty_1::d_ptr"]
        [::core::mem::offset_of!(Elf32_Dyn__bindgen_ty_1, d_ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Dyn"][::core::mem::size_of::<Elf32_Dyn>() - 8usize];
    ["Alignment of Elf32_Dyn"][::core::mem::align_of::<Elf32_Dyn>() - 4usize];
    ["Offset of field: Elf32_Dyn::d_tag"][::core::mem::offset_of!(Elf32_Dyn, d_tag) - 0usize];
    ["Offset of field: Elf32_Dyn::d_un"][::core::mem::offset_of!(Elf32_Dyn, d_un) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf64_Dyn {
    pub d_tag: Elf64_Sxword,
    pub d_un: Elf64_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf64_Dyn__bindgen_ty_1 {
    pub d_val: Elf64_Xword,
    pub d_ptr: Elf64_Addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Dyn__bindgen_ty_1"][::core::mem::size_of::<Elf64_Dyn__bindgen_ty_1>() - 8usize];
    ["Alignment of Elf64_Dyn__bindgen_ty_1"]
        [::core::mem::align_of::<Elf64_Dyn__bindgen_ty_1>() - 8usize];
    ["Offset of field: Elf64_Dyn__bindgen_ty_1::d_val"]
        [::core::mem::offset_of!(Elf64_Dyn__bindgen_ty_1, d_val) - 0usize];
    ["Offset of field: Elf64_Dyn__bindgen_ty_1::d_ptr"]
        [::core::mem::offset_of!(Elf64_Dyn__bindgen_ty_1, d_ptr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Dyn"][::core::mem::size_of::<Elf64_Dyn>() - 16usize];
    ["Alignment of Elf64_Dyn"][::core::mem::align_of::<Elf64_Dyn>() - 8usize];
    ["Offset of field: Elf64_Dyn::d_tag"][::core::mem::offset_of!(Elf64_Dyn, d_tag) - 0usize];
    ["Offset of field: Elf64_Dyn::d_un"][::core::mem::offset_of!(Elf64_Dyn, d_un) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Verdef {
    pub vd_version: Elf32_Half,
    pub vd_flags: Elf32_Half,
    pub vd_ndx: Elf32_Half,
    pub vd_cnt: Elf32_Half,
    pub vd_hash: Elf32_Word,
    pub vd_aux: Elf32_Word,
    pub vd_next: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Verdef"][::core::mem::size_of::<Elf32_Verdef>() - 20usize];
    ["Alignment of Elf32_Verdef"][::core::mem::align_of::<Elf32_Verdef>() - 4usize];
    ["Offset of field: Elf32_Verdef::vd_version"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_version) - 0usize];
    ["Offset of field: Elf32_Verdef::vd_flags"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_flags) - 2usize];
    ["Offset of field: Elf32_Verdef::vd_ndx"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_ndx) - 4usize];
    ["Offset of field: Elf32_Verdef::vd_cnt"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_cnt) - 6usize];
    ["Offset of field: Elf32_Verdef::vd_hash"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_hash) - 8usize];
    ["Offset of field: Elf32_Verdef::vd_aux"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_aux) - 12usize];
    ["Offset of field: Elf32_Verdef::vd_next"]
        [::core::mem::offset_of!(Elf32_Verdef, vd_next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Verdef {
    pub vd_version: Elf64_Half,
    pub vd_flags: Elf64_Half,
    pub vd_ndx: Elf64_Half,
    pub vd_cnt: Elf64_Half,
    pub vd_hash: Elf64_Word,
    pub vd_aux: Elf64_Word,
    pub vd_next: Elf64_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Verdef"][::core::mem::size_of::<Elf64_Verdef>() - 20usize];
    ["Alignment of Elf64_Verdef"][::core::mem::align_of::<Elf64_Verdef>() - 4usize];
    ["Offset of field: Elf64_Verdef::vd_version"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_version) - 0usize];
    ["Offset of field: Elf64_Verdef::vd_flags"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_flags) - 2usize];
    ["Offset of field: Elf64_Verdef::vd_ndx"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_ndx) - 4usize];
    ["Offset of field: Elf64_Verdef::vd_cnt"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_cnt) - 6usize];
    ["Offset of field: Elf64_Verdef::vd_hash"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_hash) - 8usize];
    ["Offset of field: Elf64_Verdef::vd_aux"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_aux) - 12usize];
    ["Offset of field: Elf64_Verdef::vd_next"]
        [::core::mem::offset_of!(Elf64_Verdef, vd_next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Verdaux {
    pub vda_name: Elf32_Word,
    pub vda_next: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Verdaux"][::core::mem::size_of::<Elf32_Verdaux>() - 8usize];
    ["Alignment of Elf32_Verdaux"][::core::mem::align_of::<Elf32_Verdaux>() - 4usize];
    ["Offset of field: Elf32_Verdaux::vda_name"]
        [::core::mem::offset_of!(Elf32_Verdaux, vda_name) - 0usize];
    ["Offset of field: Elf32_Verdaux::vda_next"]
        [::core::mem::offset_of!(Elf32_Verdaux, vda_next) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Verdaux {
    pub vda_name: Elf64_Word,
    pub vda_next: Elf64_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Verdaux"][::core::mem::size_of::<Elf64_Verdaux>() - 8usize];
    ["Alignment of Elf64_Verdaux"][::core::mem::align_of::<Elf64_Verdaux>() - 4usize];
    ["Offset of field: Elf64_Verdaux::vda_name"]
        [::core::mem::offset_of!(Elf64_Verdaux, vda_name) - 0usize];
    ["Offset of field: Elf64_Verdaux::vda_next"]
        [::core::mem::offset_of!(Elf64_Verdaux, vda_next) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Verneed {
    pub vn_version: Elf32_Half,
    pub vn_cnt: Elf32_Half,
    pub vn_file: Elf32_Word,
    pub vn_aux: Elf32_Word,
    pub vn_next: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Verneed"][::core::mem::size_of::<Elf32_Verneed>() - 16usize];
    ["Alignment of Elf32_Verneed"][::core::mem::align_of::<Elf32_Verneed>() - 4usize];
    ["Offset of field: Elf32_Verneed::vn_version"]
        [::core::mem::offset_of!(Elf32_Verneed, vn_version) - 0usize];
    ["Offset of field: Elf32_Verneed::vn_cnt"]
        [::core::mem::offset_of!(Elf32_Verneed, vn_cnt) - 2usize];
    ["Offset of field: Elf32_Verneed::vn_file"]
        [::core::mem::offset_of!(Elf32_Verneed, vn_file) - 4usize];
    ["Offset of field: Elf32_Verneed::vn_aux"]
        [::core::mem::offset_of!(Elf32_Verneed, vn_aux) - 8usize];
    ["Offset of field: Elf32_Verneed::vn_next"]
        [::core::mem::offset_of!(Elf32_Verneed, vn_next) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Verneed {
    pub vn_version: Elf64_Half,
    pub vn_cnt: Elf64_Half,
    pub vn_file: Elf64_Word,
    pub vn_aux: Elf64_Word,
    pub vn_next: Elf64_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Verneed"][::core::mem::size_of::<Elf64_Verneed>() - 16usize];
    ["Alignment of Elf64_Verneed"][::core::mem::align_of::<Elf64_Verneed>() - 4usize];
    ["Offset of field: Elf64_Verneed::vn_version"]
        [::core::mem::offset_of!(Elf64_Verneed, vn_version) - 0usize];
    ["Offset of field: Elf64_Verneed::vn_cnt"]
        [::core::mem::offset_of!(Elf64_Verneed, vn_cnt) - 2usize];
    ["Offset of field: Elf64_Verneed::vn_file"]
        [::core::mem::offset_of!(Elf64_Verneed, vn_file) - 4usize];
    ["Offset of field: Elf64_Verneed::vn_aux"]
        [::core::mem::offset_of!(Elf64_Verneed, vn_aux) - 8usize];
    ["Offset of field: Elf64_Verneed::vn_next"]
        [::core::mem::offset_of!(Elf64_Verneed, vn_next) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Vernaux {
    pub vna_hash: Elf32_Word,
    pub vna_flags: Elf32_Half,
    pub vna_other: Elf32_Half,
    pub vna_name: Elf32_Word,
    pub vna_next: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Vernaux"][::core::mem::size_of::<Elf32_Vernaux>() - 16usize];
    ["Alignment of Elf32_Vernaux"][::core::mem::align_of::<Elf32_Vernaux>() - 4usize];
    ["Offset of field: Elf32_Vernaux::vna_hash"]
        [::core::mem::offset_of!(Elf32_Vernaux, vna_hash) - 0usize];
    ["Offset of field: Elf32_Vernaux::vna_flags"]
        [::core::mem::offset_of!(Elf32_Vernaux, vna_flags) - 4usize];
    ["Offset of field: Elf32_Vernaux::vna_other"]
        [::core::mem::offset_of!(Elf32_Vernaux, vna_other) - 6usize];
    ["Offset of field: Elf32_Vernaux::vna_name"]
        [::core::mem::offset_of!(Elf32_Vernaux, vna_name) - 8usize];
    ["Offset of field: Elf32_Vernaux::vna_next"]
        [::core::mem::offset_of!(Elf32_Vernaux, vna_next) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Vernaux {
    pub vna_hash: Elf64_Word,
    pub vna_flags: Elf64_Half,
    pub vna_other: Elf64_Half,
    pub vna_name: Elf64_Word,
    pub vna_next: Elf64_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Vernaux"][::core::mem::size_of::<Elf64_Vernaux>() - 16usize];
    ["Alignment of Elf64_Vernaux"][::core::mem::align_of::<Elf64_Vernaux>() - 4usize];
    ["Offset of field: Elf64_Vernaux::vna_hash"]
        [::core::mem::offset_of!(Elf64_Vernaux, vna_hash) - 0usize];
    ["Offset of field: Elf64_Vernaux::vna_flags"]
        [::core::mem::offset_of!(Elf64_Vernaux, vna_flags) - 4usize];
    ["Offset of field: Elf64_Vernaux::vna_other"]
        [::core::mem::offset_of!(Elf64_Vernaux, vna_other) - 6usize];
    ["Offset of field: Elf64_Vernaux::vna_name"]
        [::core::mem::offset_of!(Elf64_Vernaux, vna_name) - 8usize];
    ["Offset of field: Elf64_Vernaux::vna_next"]
        [::core::mem::offset_of!(Elf64_Vernaux, vna_next) - 12usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf32_auxv_t {
    pub a_type: u32,
    pub a_un: Elf32_auxv_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf32_auxv_t__bindgen_ty_1 {
    pub a_val: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_auxv_t__bindgen_ty_1"]
        [::core::mem::size_of::<Elf32_auxv_t__bindgen_ty_1>() - 4usize];
    ["Alignment of Elf32_auxv_t__bindgen_ty_1"]
        [::core::mem::align_of::<Elf32_auxv_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: Elf32_auxv_t__bindgen_ty_1::a_val"]
        [::core::mem::offset_of!(Elf32_auxv_t__bindgen_ty_1, a_val) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_auxv_t"][::core::mem::size_of::<Elf32_auxv_t>() - 8usize];
    ["Alignment of Elf32_auxv_t"][::core::mem::align_of::<Elf32_auxv_t>() - 4usize];
    ["Offset of field: Elf32_auxv_t::a_type"]
        [::core::mem::offset_of!(Elf32_auxv_t, a_type) - 0usize];
    ["Offset of field: Elf32_auxv_t::a_un"][::core::mem::offset_of!(Elf32_auxv_t, a_un) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf64_auxv_t {
    pub a_type: u64,
    pub a_un: Elf64_auxv_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf64_auxv_t__bindgen_ty_1 {
    pub a_val: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_auxv_t__bindgen_ty_1"]
        [::core::mem::size_of::<Elf64_auxv_t__bindgen_ty_1>() - 8usize];
    ["Alignment of Elf64_auxv_t__bindgen_ty_1"]
        [::core::mem::align_of::<Elf64_auxv_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: Elf64_auxv_t__bindgen_ty_1::a_val"]
        [::core::mem::offset_of!(Elf64_auxv_t__bindgen_ty_1, a_val) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_auxv_t"][::core::mem::size_of::<Elf64_auxv_t>() - 16usize];
    ["Alignment of Elf64_auxv_t"][::core::mem::align_of::<Elf64_auxv_t>() - 8usize];
    ["Offset of field: Elf64_auxv_t::a_type"]
        [::core::mem::offset_of!(Elf64_auxv_t, a_type) - 0usize];
    ["Offset of field: Elf64_auxv_t::a_un"][::core::mem::offset_of!(Elf64_auxv_t, a_un) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Nhdr {
    pub n_namesz: Elf32_Word,
    pub n_descsz: Elf32_Word,
    pub n_type: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Nhdr"][::core::mem::size_of::<Elf32_Nhdr>() - 12usize];
    ["Alignment of Elf32_Nhdr"][::core::mem::align_of::<Elf32_Nhdr>() - 4usize];
    ["Offset of field: Elf32_Nhdr::n_namesz"]
        [::core::mem::offset_of!(Elf32_Nhdr, n_namesz) - 0usize];
    ["Offset of field: Elf32_Nhdr::n_descsz"]
        [::core::mem::offset_of!(Elf32_Nhdr, n_descsz) - 4usize];
    ["Offset of field: Elf32_Nhdr::n_type"][::core::mem::offset_of!(Elf32_Nhdr, n_type) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Nhdr {
    pub n_namesz: Elf64_Word,
    pub n_descsz: Elf64_Word,
    pub n_type: Elf64_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Nhdr"][::core::mem::size_of::<Elf64_Nhdr>() - 12usize];
    ["Alignment of Elf64_Nhdr"][::core::mem::align_of::<Elf64_Nhdr>() - 4usize];
    ["Offset of field: Elf64_Nhdr::n_namesz"]
        [::core::mem::offset_of!(Elf64_Nhdr, n_namesz) - 0usize];
    ["Offset of field: Elf64_Nhdr::n_descsz"]
        [::core::mem::offset_of!(Elf64_Nhdr, n_descsz) - 4usize];
    ["Offset of field: Elf64_Nhdr::n_type"][::core::mem::offset_of!(Elf64_Nhdr, n_type) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Move {
    pub m_value: Elf32_Xword,
    pub m_info: Elf32_Word,
    pub m_poffset: Elf32_Word,
    pub m_repeat: Elf32_Half,
    pub m_stride: Elf32_Half,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Move"][::core::mem::size_of::<Elf32_Move>() - 24usize];
    ["Alignment of Elf32_Move"][::core::mem::align_of::<Elf32_Move>() - 8usize];
    ["Offset of field: Elf32_Move::m_value"][::core::mem::offset_of!(Elf32_Move, m_value) - 0usize];
    ["Offset of field: Elf32_Move::m_info"][::core::mem::offset_of!(Elf32_Move, m_info) - 8usize];
    ["Offset of field: Elf32_Move::m_poffset"]
        [::core::mem::offset_of!(Elf32_Move, m_poffset) - 12usize];
    ["Offset of field: Elf32_Move::m_repeat"]
        [::core::mem::offset_of!(Elf32_Move, m_repeat) - 16usize];
    ["Offset of field: Elf32_Move::m_stride"]
        [::core::mem::offset_of!(Elf32_Move, m_stride) - 18usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Move {
    pub m_value: Elf64_Xword,
    pub m_info: Elf64_Xword,
    pub m_poffset: Elf64_Xword,
    pub m_repeat: Elf64_Half,
    pub m_stride: Elf64_Half,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Move"][::core::mem::size_of::<Elf64_Move>() - 32usize];
    ["Alignment of Elf64_Move"][::core::mem::align_of::<Elf64_Move>() - 8usize];
    ["Offset of field: Elf64_Move::m_value"][::core::mem::offset_of!(Elf64_Move, m_value) - 0usize];
    ["Offset of field: Elf64_Move::m_info"][::core::mem::offset_of!(Elf64_Move, m_info) - 8usize];
    ["Offset of field: Elf64_Move::m_poffset"]
        [::core::mem::offset_of!(Elf64_Move, m_poffset) - 16usize];
    ["Offset of field: Elf64_Move::m_repeat"]
        [::core::mem::offset_of!(Elf64_Move, m_repeat) - 24usize];
    ["Offset of field: Elf64_Move::m_stride"]
        [::core::mem::offset_of!(Elf64_Move, m_stride) - 26usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf32_gptab {
    pub gt_header: Elf32_gptab__bindgen_ty_1,
    pub gt_entry: Elf32_gptab__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_gptab__bindgen_ty_1 {
    pub gt_current_g_value: Elf32_Word,
    pub gt_unused: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_gptab__bindgen_ty_1"]
        [::core::mem::size_of::<Elf32_gptab__bindgen_ty_1>() - 8usize];
    ["Alignment of Elf32_gptab__bindgen_ty_1"]
        [::core::mem::align_of::<Elf32_gptab__bindgen_ty_1>() - 4usize];
    ["Offset of field: Elf32_gptab__bindgen_ty_1::gt_current_g_value"]
        [::core::mem::offset_of!(Elf32_gptab__bindgen_ty_1, gt_current_g_value) - 0usize];
    ["Offset of field: Elf32_gptab__bindgen_ty_1::gt_unused"]
        [::core::mem::offset_of!(Elf32_gptab__bindgen_ty_1, gt_unused) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_gptab__bindgen_ty_2 {
    pub gt_g_value: Elf32_Word,
    pub gt_bytes: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_gptab__bindgen_ty_2"]
        [::core::mem::size_of::<Elf32_gptab__bindgen_ty_2>() - 8usize];
    ["Alignment of Elf32_gptab__bindgen_ty_2"]
        [::core::mem::align_of::<Elf32_gptab__bindgen_ty_2>() - 4usize];
    ["Offset of field: Elf32_gptab__bindgen_ty_2::gt_g_value"]
        [::core::mem::offset_of!(Elf32_gptab__bindgen_ty_2, gt_g_value) - 0usize];
    ["Offset of field: Elf32_gptab__bindgen_ty_2::gt_bytes"]
        [::core::mem::offset_of!(Elf32_gptab__bindgen_ty_2, gt_bytes) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_gptab"][::core::mem::size_of::<Elf32_gptab>() - 8usize];
    ["Alignment of Elf32_gptab"][::core::mem::align_of::<Elf32_gptab>() - 4usize];
    ["Offset of field: Elf32_gptab::gt_header"]
        [::core::mem::offset_of!(Elf32_gptab, gt_header) - 0usize];
    ["Offset of field: Elf32_gptab::gt_entry"]
        [::core::mem::offset_of!(Elf32_gptab, gt_entry) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_RegInfo {
    pub ri_gprmask: Elf32_Word,
    pub ri_cprmask: [Elf32_Word; 4usize],
    pub ri_gp_value: Elf32_Sword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_RegInfo"][::core::mem::size_of::<Elf32_RegInfo>() - 24usize];
    ["Alignment of Elf32_RegInfo"][::core::mem::align_of::<Elf32_RegInfo>() - 4usize];
    ["Offset of field: Elf32_RegInfo::ri_gprmask"]
        [::core::mem::offset_of!(Elf32_RegInfo, ri_gprmask) - 0usize];
    ["Offset of field: Elf32_RegInfo::ri_cprmask"]
        [::core::mem::offset_of!(Elf32_RegInfo, ri_cprmask) - 4usize];
    ["Offset of field: Elf32_RegInfo::ri_gp_value"]
        [::core::mem::offset_of!(Elf32_RegInfo, ri_gp_value) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf_Options {
    pub kind: core::ffi::c_uchar,
    pub size: core::ffi::c_uchar,
    pub section: Elf32_Section,
    pub info: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf_Options"][::core::mem::size_of::<Elf_Options>() - 8usize];
    ["Alignment of Elf_Options"][::core::mem::align_of::<Elf_Options>() - 4usize];
    ["Offset of field: Elf_Options::kind"][::core::mem::offset_of!(Elf_Options, kind) - 0usize];
    ["Offset of field: Elf_Options::size"][::core::mem::offset_of!(Elf_Options, size) - 1usize];
    ["Offset of field: Elf_Options::section"]
        [::core::mem::offset_of!(Elf_Options, section) - 2usize];
    ["Offset of field: Elf_Options::info"][::core::mem::offset_of!(Elf_Options, info) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf_Options_Hw {
    pub hwp_flags1: Elf32_Word,
    pub hwp_flags2: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf_Options_Hw"][::core::mem::size_of::<Elf_Options_Hw>() - 8usize];
    ["Alignment of Elf_Options_Hw"][::core::mem::align_of::<Elf_Options_Hw>() - 4usize];
    ["Offset of field: Elf_Options_Hw::hwp_flags1"]
        [::core::mem::offset_of!(Elf_Options_Hw, hwp_flags1) - 0usize];
    ["Offset of field: Elf_Options_Hw::hwp_flags2"]
        [::core::mem::offset_of!(Elf_Options_Hw, hwp_flags2) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf32_Lib {
    pub l_name: Elf32_Word,
    pub l_time_stamp: Elf32_Word,
    pub l_checksum: Elf32_Word,
    pub l_version: Elf32_Word,
    pub l_flags: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf32_Lib"][::core::mem::size_of::<Elf32_Lib>() - 20usize];
    ["Alignment of Elf32_Lib"][::core::mem::align_of::<Elf32_Lib>() - 4usize];
    ["Offset of field: Elf32_Lib::l_name"][::core::mem::offset_of!(Elf32_Lib, l_name) - 0usize];
    ["Offset of field: Elf32_Lib::l_time_stamp"]
        [::core::mem::offset_of!(Elf32_Lib, l_time_stamp) - 4usize];
    ["Offset of field: Elf32_Lib::l_checksum"]
        [::core::mem::offset_of!(Elf32_Lib, l_checksum) - 8usize];
    ["Offset of field: Elf32_Lib::l_version"]
        [::core::mem::offset_of!(Elf32_Lib, l_version) - 12usize];
    ["Offset of field: Elf32_Lib::l_flags"][::core::mem::offset_of!(Elf32_Lib, l_flags) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf64_Lib {
    pub l_name: Elf64_Word,
    pub l_time_stamp: Elf64_Word,
    pub l_checksum: Elf64_Word,
    pub l_version: Elf64_Word,
    pub l_flags: Elf64_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf64_Lib"][::core::mem::size_of::<Elf64_Lib>() - 20usize];
    ["Alignment of Elf64_Lib"][::core::mem::align_of::<Elf64_Lib>() - 4usize];
    ["Offset of field: Elf64_Lib::l_name"][::core::mem::offset_of!(Elf64_Lib, l_name) - 0usize];
    ["Offset of field: Elf64_Lib::l_time_stamp"]
        [::core::mem::offset_of!(Elf64_Lib, l_time_stamp) - 4usize];
    ["Offset of field: Elf64_Lib::l_checksum"]
        [::core::mem::offset_of!(Elf64_Lib, l_checksum) - 8usize];
    ["Offset of field: Elf64_Lib::l_version"]
        [::core::mem::offset_of!(Elf64_Lib, l_version) - 12usize];
    ["Offset of field: Elf64_Lib::l_flags"][::core::mem::offset_of!(Elf64_Lib, l_flags) - 16usize];
};
pub type Elf32_Conflict = Elf32_Addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Elf_MIPS_ABIFlags_v0 {
    pub version: Elf32_Half,
    pub isa_level: core::ffi::c_uchar,
    pub isa_rev: core::ffi::c_uchar,
    pub gpr_size: core::ffi::c_uchar,
    pub cpr1_size: core::ffi::c_uchar,
    pub cpr2_size: core::ffi::c_uchar,
    pub fp_abi: core::ffi::c_uchar,
    pub isa_ext: Elf32_Word,
    pub ases: Elf32_Word,
    pub flags1: Elf32_Word,
    pub flags2: Elf32_Word,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Elf_MIPS_ABIFlags_v0"][::core::mem::size_of::<Elf_MIPS_ABIFlags_v0>() - 24usize];
    ["Alignment of Elf_MIPS_ABIFlags_v0"][::core::mem::align_of::<Elf_MIPS_ABIFlags_v0>() - 4usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::version"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, version) - 0usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::isa_level"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, isa_level) - 2usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::isa_rev"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, isa_rev) - 3usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::gpr_size"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, gpr_size) - 4usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::cpr1_size"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, cpr1_size) - 5usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::cpr2_size"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, cpr2_size) - 6usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::fp_abi"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, fp_abi) - 7usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::isa_ext"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, isa_ext) - 8usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::ases"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, ases) - 12usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::flags1"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, flags1) - 16usize];
    ["Offset of field: Elf_MIPS_ABIFlags_v0::flags2"]
        [::core::mem::offset_of!(Elf_MIPS_ABIFlags_v0, flags2) - 20usize];
};
#[doc = "Interface for ELF loader to resolve symbols"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ElfApiInterface {
    pub api_version_major: u16,
    pub api_version_minor: u16,
    pub resolver_callback: ::core::option::Option<
        unsafe extern "C" fn(
            interface: *const ElfApiInterface,
            hash: u32,
            address: *mut Elf32_Addr,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ElfApiInterface"][::core::mem::size_of::<ElfApiInterface>() - 8usize];
    ["Alignment of ElfApiInterface"][::core::mem::align_of::<ElfApiInterface>() - 4usize];
    ["Offset of field: ElfApiInterface::api_version_major"]
        [::core::mem::offset_of!(ElfApiInterface, api_version_major) - 0usize];
    ["Offset of field: ElfApiInterface::api_version_minor"]
        [::core::mem::offset_of!(ElfApiInterface, api_version_minor) - 2usize];
    ["Offset of field: ElfApiInterface::resolver_callback"]
        [::core::mem::offset_of!(ElfApiInterface, resolver_callback) - 4usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestBase {
    pub manifest_magic: u32,
    pub manifest_version: u32,
    pub api_version: FlipperApplicationManifestBase__bindgen_ty_1,
    pub hardware_target_id: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FlipperApplicationManifestBase__bindgen_ty_1 {
    pub __bindgen_anon_1: FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    pub version: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1 {
    pub minor: u16,
    pub major: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1"][::core::mem::size_of::<
        FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    >() - 4usize];
    ["Alignment of FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>()
            - 1usize];
    ["Offset of field: FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1::minor"][::core::mem::offset_of!(
        FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
        minor
    )
        - 0usize];
    ["Offset of field: FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1::major"][::core::mem::offset_of!(
        FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
        major
    )
        - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperApplicationManifestBase__bindgen_ty_1"]
        [::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1>() - 4usize];
    ["Alignment of FlipperApplicationManifestBase__bindgen_ty_1"]
        [::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1>() - 1usize];
    ["Offset of field: FlipperApplicationManifestBase__bindgen_ty_1::version"]
        [::core::mem::offset_of!(FlipperApplicationManifestBase__bindgen_ty_1, version) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperApplicationManifestBase"]
        [::core::mem::size_of::<FlipperApplicationManifestBase>() - 14usize];
    ["Alignment of FlipperApplicationManifestBase"]
        [::core::mem::align_of::<FlipperApplicationManifestBase>() - 1usize];
    ["Offset of field: FlipperApplicationManifestBase::manifest_magic"]
        [::core::mem::offset_of!(FlipperApplicationManifestBase, manifest_magic) - 0usize];
    ["Offset of field: FlipperApplicationManifestBase::manifest_version"]
        [::core::mem::offset_of!(FlipperApplicationManifestBase, manifest_version) - 4usize];
    ["Offset of field: FlipperApplicationManifestBase::api_version"]
        [::core::mem::offset_of!(FlipperApplicationManifestBase, api_version) - 8usize];
    ["Offset of field: FlipperApplicationManifestBase::hardware_target_id"]
        [::core::mem::offset_of!(FlipperApplicationManifestBase, hardware_target_id) - 12usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestV1 {
    pub base: FlipperApplicationManifestBase,
    pub stack_size: u16,
    pub app_version: u32,
    pub name: [core::ffi::c_char; 32usize],
    pub has_icon: core::ffi::c_char,
    pub icon: [core::ffi::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperApplicationManifestV1"]
        [::core::mem::size_of::<FlipperApplicationManifestV1>() - 85usize];
    ["Alignment of FlipperApplicationManifestV1"]
        [::core::mem::align_of::<FlipperApplicationManifestV1>() - 1usize];
    ["Offset of field: FlipperApplicationManifestV1::base"]
        [::core::mem::offset_of!(FlipperApplicationManifestV1, base) - 0usize];
    ["Offset of field: FlipperApplicationManifestV1::stack_size"]
        [::core::mem::offset_of!(FlipperApplicationManifestV1, stack_size) - 14usize];
    ["Offset of field: FlipperApplicationManifestV1::app_version"]
        [::core::mem::offset_of!(FlipperApplicationManifestV1, app_version) - 16usize];
    ["Offset of field: FlipperApplicationManifestV1::name"]
        [::core::mem::offset_of!(FlipperApplicationManifestV1, name) - 20usize];
    ["Offset of field: FlipperApplicationManifestV1::has_icon"]
        [::core::mem::offset_of!(FlipperApplicationManifestV1, has_icon) - 52usize];
    ["Offset of field: FlipperApplicationManifestV1::icon"]
        [::core::mem::offset_of!(FlipperApplicationManifestV1, icon) - 53usize];
};
pub type FlipperApplicationManifest = FlipperApplicationManifestV1;
unsafe extern "C" {
    #[doc = "Check if manifest is valid\n\n # Arguments\n\n* `manifest` -\n # Returns\n\nbool"]
    pub fn flipper_application_manifest_is_valid(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Check if API Version declared in manifest is older than firmware ELF API interface\n\n # Arguments\n\n* `manifest` - The manifest\n * `api_interface` - The api interface\n\n # Returns\n\nbool"]
    pub fn flipper_application_manifest_is_too_old(
        manifest: *const FlipperApplicationManifest,
        api_interface: *const ElfApiInterface,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Check if API Version declared in manifest is newer than firmware ELF API interface\n\n # Arguments\n\n* `manifest` - The manifest\n * `api_interface` - The api interface\n\n # Returns\n\nbool"]
    pub fn flipper_application_manifest_is_too_new(
        manifest: *const FlipperApplicationManifest,
        api_interface: *const ElfApiInterface,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Check if application is compatible with current hardware\n\n # Arguments\n\n* `manifest` -\n # Returns\n\nbool"]
    pub fn flipper_application_manifest_is_target_compatible(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
#[doc = "< Read access"]
pub const FSAM_READ: FS_AccessMode = FS_AccessMode(1);
#[doc = "< Write access"]
pub const FSAM_WRITE: FS_AccessMode = FS_AccessMode(2);
#[doc = "< Read and write access"]
pub const FSAM_READ_WRITE: FS_AccessMode = FS_AccessMode(3);
#[repr(transparent)]
#[doc = "Access mode flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FS_AccessMode(pub core::ffi::c_uchar);
#[doc = "< Open file, fail if file doesn't exist"]
pub const FSOM_OPEN_EXISTING: FS_OpenMode = FS_OpenMode(1);
#[doc = "< Open file. Create new file if not exist"]
pub const FSOM_OPEN_ALWAYS: FS_OpenMode = FS_OpenMode(2);
#[doc = "< Open file. Create new file if not exist. Set R/W pointer to EOF"]
pub const FSOM_OPEN_APPEND: FS_OpenMode = FS_OpenMode(4);
#[doc = "< Creates a new file. Fails if the file is exist"]
pub const FSOM_CREATE_NEW: FS_OpenMode = FS_OpenMode(8);
#[doc = "< Creates a new file. If file exist, truncate to zero size"]
pub const FSOM_CREATE_ALWAYS: FS_OpenMode = FS_OpenMode(16);
#[repr(transparent)]
#[doc = "Open mode flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FS_OpenMode(pub core::ffi::c_uchar);
#[doc = "< No error"]
pub const FSE_OK: FS_Error = FS_Error(0);
#[doc = "< FS not ready"]
pub const FSE_NOT_READY: FS_Error = FS_Error(1);
#[doc = "< File/Dir already exist"]
pub const FSE_EXIST: FS_Error = FS_Error(2);
#[doc = "< File/Dir does not exist"]
pub const FSE_NOT_EXIST: FS_Error = FS_Error(3);
#[doc = "< Invalid API parameter"]
pub const FSE_INVALID_PARAMETER: FS_Error = FS_Error(4);
#[doc = "< Access denied"]
pub const FSE_DENIED: FS_Error = FS_Error(5);
#[doc = "< Invalid name/path"]
pub const FSE_INVALID_NAME: FS_Error = FS_Error(6);
#[doc = "< Internal error"]
pub const FSE_INTERNAL: FS_Error = FS_Error(7);
#[doc = "< Function not implemented"]
pub const FSE_NOT_IMPLEMENTED: FS_Error = FS_Error(8);
#[doc = "< File/Dir already opened"]
pub const FSE_ALREADY_OPEN: FS_Error = FS_Error(9);
#[repr(transparent)]
#[doc = "API errors enumeration"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FS_Error(pub core::ffi::c_uchar);
#[doc = "< Directory"]
pub const FSF_DIRECTORY: FS_Flags = FS_Flags(1);
#[repr(transparent)]
#[doc = "FileInfo flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FS_Flags(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    _unused: [u8; 0],
}
#[doc = "Structure that hold file info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileInfo {
    #[doc = "< flags from FS_Flags enum"]
    pub flags: u8,
    #[doc = "< file size"]
    pub size: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FileInfo"][::core::mem::size_of::<FileInfo>() - 16usize];
    ["Alignment of FileInfo"][::core::mem::align_of::<FileInfo>() - 8usize];
    ["Offset of field: FileInfo::flags"][::core::mem::offset_of!(FileInfo, flags) - 0usize];
    ["Offset of field: FileInfo::size"][::core::mem::offset_of!(FileInfo, size) - 8usize];
};
unsafe extern "C" {
    #[doc = "Gets the error text from FS_Error\n # Arguments\n\n* `error_id` - error id\n # Returns\n\nconst char* error text"]
    pub fn filesystem_api_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Checks if file info is directory\n # Arguments\n\n* `file_info` - file info pointer\n # Returns\n\nbool is directory"]
    pub fn file_info_is_dir(file_info: *const FileInfo) -> bool;
}
pub const FST_UNKNOWN: SDFsType = SDFsType(0);
pub const FST_FAT12: SDFsType = SDFsType(1);
pub const FST_FAT16: SDFsType = SDFsType(2);
pub const FST_FAT32: SDFsType = SDFsType(3);
pub const FST_EXFAT: SDFsType = SDFsType(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SDFsType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDInfo {
    pub fs_type: SDFsType,
    pub kb_total: u32,
    pub kb_free: u32,
    pub cluster_size: u16,
    pub sector_size: u16,
    pub label: [core::ffi::c_char; 34usize],
    pub manufacturer_id: u8,
    pub oem_id: [core::ffi::c_char; 3usize],
    pub product_name: [core::ffi::c_char; 6usize],
    pub product_revision_major: u8,
    pub product_revision_minor: u8,
    pub product_serial_number: u32,
    pub manufacturing_month: u8,
    pub manufacturing_year: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SDInfo"][::core::mem::size_of::<SDInfo>() - 72usize];
    ["Alignment of SDInfo"][::core::mem::align_of::<SDInfo>() - 4usize];
    ["Offset of field: SDInfo::fs_type"][::core::mem::offset_of!(SDInfo, fs_type) - 0usize];
    ["Offset of field: SDInfo::kb_total"][::core::mem::offset_of!(SDInfo, kb_total) - 4usize];
    ["Offset of field: SDInfo::kb_free"][::core::mem::offset_of!(SDInfo, kb_free) - 8usize];
    ["Offset of field: SDInfo::cluster_size"]
        [::core::mem::offset_of!(SDInfo, cluster_size) - 12usize];
    ["Offset of field: SDInfo::sector_size"]
        [::core::mem::offset_of!(SDInfo, sector_size) - 14usize];
    ["Offset of field: SDInfo::label"][::core::mem::offset_of!(SDInfo, label) - 16usize];
    ["Offset of field: SDInfo::manufacturer_id"]
        [::core::mem::offset_of!(SDInfo, manufacturer_id) - 50usize];
    ["Offset of field: SDInfo::oem_id"][::core::mem::offset_of!(SDInfo, oem_id) - 51usize];
    ["Offset of field: SDInfo::product_name"]
        [::core::mem::offset_of!(SDInfo, product_name) - 54usize];
    ["Offset of field: SDInfo::product_revision_major"]
        [::core::mem::offset_of!(SDInfo, product_revision_major) - 60usize];
    ["Offset of field: SDInfo::product_revision_minor"]
        [::core::mem::offset_of!(SDInfo, product_revision_minor) - 61usize];
    ["Offset of field: SDInfo::product_serial_number"]
        [::core::mem::offset_of!(SDInfo, product_serial_number) - 64usize];
    ["Offset of field: SDInfo::manufacturing_month"]
        [::core::mem::offset_of!(SDInfo, manufacturing_month) - 68usize];
    ["Offset of field: SDInfo::manufacturing_year"]
        [::core::mem::offset_of!(SDInfo, manufacturing_year) - 70usize];
};
unsafe extern "C" {
    pub fn sd_api_get_fs_type_text(fs_type: SDFsType) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Storage {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate and initialize a file instance.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n # Returns\n\npointer to the created instance."]
    pub fn storage_file_alloc(storage: *mut Storage) -> *mut File;
}
unsafe extern "C" {
    #[doc = "Free the file instance.\n\n If the file was open, calling this function will close it automatically.\n # Arguments\n\n* `file` - pointer to the file instance to be freed."]
    pub fn storage_file_free(file: *mut File);
}
#[doc = "< SD card was mounted."]
pub const StorageEventTypeCardMount: StorageEventType = StorageEventType(0);
#[doc = "< SD card was unmounted."]
pub const StorageEventTypeCardUnmount: StorageEventType = StorageEventType(1);
#[doc = "< An error occurred during mounting of an SD card."]
pub const StorageEventTypeCardMountError: StorageEventType = StorageEventType(2);
#[doc = "< A file was closed."]
pub const StorageEventTypeFileClose: StorageEventType = StorageEventType(3);
#[doc = "< A directory was closed."]
pub const StorageEventTypeDirClose: StorageEventType = StorageEventType(4);
#[repr(transparent)]
#[doc = "Enumeration of events emitted by the storage through the PubSub system."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StorageEventType(pub core::ffi::c_uchar);
#[doc = "Storage event (passed to the PubSub callback)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StorageEvent {
    #[doc = "< Type of the event."]
    pub type_: StorageEventType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of StorageEvent"][::core::mem::size_of::<StorageEvent>() - 1usize];
    ["Alignment of StorageEvent"][::core::mem::align_of::<StorageEvent>() - 1usize];
    ["Offset of field: StorageEvent::type_"][::core::mem::offset_of!(StorageEvent, type_) - 0usize];
};
unsafe extern "C" {
    #[doc = "Get the storage pubsub instance.\n\n Storage will send StorageEvent messages.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n # Returns\n\npointer to the pubsub instance."]
    pub fn storage_get_pubsub(storage: *mut Storage) -> *mut FuriPubSub;
}
unsafe extern "C" {
    #[doc = "Open an existing file or create a new one.\n\n The calling code MUST call storage_file_close() even if the open operation had failed.\n\n # Arguments\n\n* `file` - pointer to the file instance to be opened.\n * `path` - pointer to a zero-terminated string containing the path to the file to be opened.\n * `access_mode` - access mode from FS_AccessMode.\n * `open_mode` - open mode from FS_OpenMode\n # Returns\n\ntrue if the file was successfully opened, false otherwise."]
    pub fn storage_file_open(
        file: *mut File,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Close the file.\n\n # Arguments\n\n* `file` - pointer to the file instance to be closed.\n # Returns\n\ntrue if the file was successfully closed, false otherwise."]
    pub fn storage_file_close(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether the file is open.\n\n # Arguments\n\n* `file` - pointer to the file instance in question.\n # Returns\n\ntrue if the file is open, false otherwise."]
    pub fn storage_file_is_open(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether a file instance represents a directory.\n\n # Arguments\n\n* `file` - pointer to the file instance in question.\n # Returns\n\ntrue if the file instance represents a directory, false otherwise."]
    pub fn storage_file_is_dir(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Read bytes from a file into a buffer.\n\n # Arguments\n\n* `file` - pointer to the file instance to read from.\n * `buff` - pointer to the buffer to be filled with read data.\n * `bytes_to_read` - number of bytes to read. Must be less than or equal to the size of the buffer.\n # Returns\n\nactual number of bytes read (may be fewer than requested)."]
    pub fn storage_file_read(
        file: *mut File,
        buff: *mut core::ffi::c_void,
        bytes_to_read: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Write bytes from a buffer to a file.\n\n # Arguments\n\n* `file` - pointer to the file instance to write into.\n * `buff` - pointer to the buffer containing the data to be written.\n * `bytes_to_write` - number of bytes to write. Must be less than or equal to the size of the buffer.\n # Returns\n\nactual number of bytes written (may be fewer than requested)."]
    pub fn storage_file_write(
        file: *mut File,
        buff: *const core::ffi::c_void,
        bytes_to_write: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Change the current access position in a file.\n\n # Arguments\n\n* `file` - pointer to the file instance in question.\n * `offset` - access position offset (meaning depends on from_start parameter).\n * `from_start` - if true, set the access position relative to the file start, otherwise relative to the current position.\n # Returns\n\nsuccess flag"]
    pub fn storage_file_seek(file: *mut File, offset: u32, from_start: bool) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the current access position.\n\n # Arguments\n\n* `file` - pointer to the file instance in question.\n # Returns\n\ncurrent access position."]
    pub fn storage_file_tell(file: *mut File) -> u64;
}
unsafe extern "C" {
    #[doc = "Truncate the file size to the current access position.\n\n # Arguments\n\n* `file` - pointer to the file instance to be truncated.\n # Returns\n\ntrue if the file was successfully truncated, false otherwise."]
    pub fn storage_file_truncate(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the file size.\n\n # Arguments\n\n* `file` - pointer to the file instance in question.\n # Returns\n\nsize of the file, in bytes."]
    pub fn storage_file_size(file: *mut File) -> u64;
}
unsafe extern "C" {
    #[doc = "Synchronise the file cache with the actual storage.\n\n # Arguments\n\n* `file` - pointer to the file instance in question.\n # Returns\n\ntrue if the file was successfully synchronised, false otherwise."]
    pub fn storage_file_sync(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether the current access position is at the end of the file.\n\n # Arguments\n\n* `file` - pointer to a file instance in question.\n # Returns\n\nbool true if the current access position is at the end of the file, false otherwise."]
    pub fn storage_file_eof(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether a file exists.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path to the file in question.\n # Returns\n\ntrue if the file exists, false otherwise."]
    pub fn storage_file_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Copy data from a source file to the destination file.\n\n Both files must be opened prior to calling this function.\n\n The requested amount of bytes will be copied from the current access position\n in the source file to the current access position in the destination file.\n\n # Arguments\n\n* `source` - pointer to a source file instance.\n * `destination` - pointer to a destination file instance.\n * `size` - data size to be copied, in bytes.\n # Returns\n\ntrue if the data was successfully copied, false otherwise."]
    pub fn storage_file_copy_to_file(
        source: *mut File,
        destination: *mut File,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open a directory.\n\n Opening a directory is necessary to be able to read its contents with storage_dir_read().\n\n The calling code MUST call storage_dir_close() even if the open operation had failed.\n\n # Arguments\n\n* `file` - pointer to a file instance representing the directory in question.\n * `path` - pointer to a zero-terminated string containing the path of the directory in question.\n # Returns\n\ntrue if the directory was successfully opened, false otherwise."]
    pub fn storage_dir_open(file: *mut File, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Close the directory.\n\n # Arguments\n\n* `file` - pointer to a file instance representing the directory in question.\n # Returns\n\ntrue if the directory was successfully closed, false otherwise."]
    pub fn storage_dir_close(file: *mut File) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the next item in the directory.\n\n If the next object does not exist, this function returns false as well\n and sets the file error id to FSE_NOT_EXIST.\n\n # Arguments\n\n* `file` - pointer to a file instance representing the directory in question.\n * `fileinfo` - pointer to the FileInfo structure to contain the info (may be NULL).\n * `name` - pointer to the buffer to contain the name (may be NULL).\n * `name_length` - maximum capacity of the name buffer, in bytes.\n # Returns\n\ntrue if the next item was successfully read, false otherwise."]
    pub fn storage_dir_read(
        file: *mut File,
        fileinfo: *mut FileInfo,
        name: *mut core::ffi::c_char,
        name_length: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether a directory exists.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path of the directory in question.\n # Returns\n\ntrue if the directory exists, false otherwise."]
    pub fn storage_dir_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the last access time in UNIX format.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path of the item in question.\n * `timestamp` - pointer to a value to contain the timestamp.\n # Returns\n\nFSE_OK if the timestamp has been successfully received, any other error code on failure."]
    pub fn storage_common_timestamp(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        timestamp: *mut u32,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Get information about a file or a directory.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path of the item in question.\n * `fileinfo` - pointer to the FileInfo structure to contain the info (may be NULL).\n # Returns\n\nFSE_OK if the info has been successfully received, any other error code on failure."]
    pub fn storage_common_stat(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Remove a file or a directory.\n\n The directory must be empty.\n The file or the directory must NOT be open.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path of the item to be removed.\n # Returns\n\nFSE_OK if the file or directory has been successfully removed, any other error code on failure."]
    pub fn storage_common_remove(storage: *mut Storage, path: *const core::ffi::c_char)
    -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Rename a file or a directory.\n\n The file or the directory must NOT be open.\n Will overwrite the destination file if it already exists.\n\n Renaming a regular file to itself does nothing and always succeeds.\n Renaming a directory to itself or to a subdirectory of itself always fails.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `old_path` - pointer to a zero-terminated string containing the source path.\n * `new_path` - pointer to a zero-terminated string containing the destination path.\n # Returns\n\nFSE_OK if the file or directory has been successfully renamed, any other error code on failure."]
    pub fn storage_common_rename(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Copy the file to a new location.\n\n The file must NOT be open at the time of calling this function.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `old_path` - pointer to a zero-terminated string containing the source path.\n * `new_path` - pointer to a zero-terminated string containing the destination path.\n # Returns\n\nFSE_OK if the file has been successfully copied, any other error code on failure."]
    pub fn storage_common_copy(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Copy the contents of one directory into another and rename all conflicting files.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `old_path` - pointer to a zero-terminated string containing the source path.\n * `new_path` - pointer to a zero-terminated string containing the destination path.\n # Returns\n\nFSE_OK if the directories have been successfully merged, any other error code on failure."]
    pub fn storage_common_merge(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Create a directory.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the directory path.\n # Returns\n\nFSE_OK if the directory has been successfully created, any other error code on failure."]
    pub fn storage_common_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Get the general information about the storage.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `fs_path` - pointer to a zero-terminated string containing the path to the storage question.\n * `total_space` - pointer to the value to contain the total capacity, in bytes.\n * `free_space` - pointer to the value to contain the available space, in bytes.\n # Returns\n\nFSE_OK if the information has been successfully received, any other error code on failure."]
    pub fn storage_common_fs_info(
        storage: *mut Storage,
        fs_path: *const core::ffi::c_char,
        total_space: *mut u64,
        free_space: *mut u64,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Parse aliases in a path and replace them with the real path.\n\n Necessary special directories will be created automatically if they did not exist.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path in question."]
    pub fn storage_common_resolve_path_and_ensure_app_directory(
        storage: *mut Storage,
        path: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Move the contents of source folder to destination one and rename all conflicting files.\n\n Source folder will be deleted if the migration was successful.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `source` - pointer to a zero-terminated string containing the source path.\n * `dest` - pointer to a zero-terminated string containing the destination path.\n # Returns\n\nFSE_OK if the migration was successfully completed, any other error code on failure."]
    pub fn storage_common_migrate(
        storage: *mut Storage,
        source: *const core::ffi::c_char,
        dest: *const core::ffi::c_char,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Check whether a file or a directory exists.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the path in question.\n # Returns\n\ntrue if a file or a directory exists, false otherwise."]
    pub fn storage_common_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether two paths are equivalent.\n\n This function will resolve aliases and apply filesystem-specific\n rules to determine whether the two given paths are equivalent.\n\n Examples:\n - /int/text and /ext/test -> false (Different storages),\n - /int/Test and /int/test -> false (Case-sensitive storage),\n - /ext/Test and /ext/test -> true (Case-insensitive storage).\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path1` - pointer to a zero-terminated string containing the first path.\n * `path2` - pointer to a zero-terminated string containing the second path.\n # Returns\n\ntrue if paths are equivalent, false otherwise."]
    pub fn storage_common_equivalent_path(
        storage: *mut Storage,
        path1: *const core::ffi::c_char,
        path2: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether a path is a subpath of another path.\n\n This function respects storage-defined equivalence rules\n (see `storage_common_equivalent_path`).\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `parent` - pointer to a zero-terminated string containing the parent path.\n * `child` - pointer to a zero-terminated string containing the child path.\n # Returns\n\ntrue if `child` is a subpath of `parent`, or if `child` is equivalent\n to `parent`; false otherwise."]
    pub fn storage_common_is_subdir(
        storage: *mut Storage,
        parent: *const core::ffi::c_char,
        child: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the textual description of a numeric error identifier.\n\n # Arguments\n\n* `error_id` - numeric identifier of the error in question.\n # Returns\n\npointer to a statically allocated zero-terminated string containing the respective error text."]
    pub fn storage_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get the numeric error identifier from a file instance.\n\n It is not possible to get the error identifier after the file has been closed.\n\n # Arguments\n\n* `file` - pointer to the file instance in question (must NOT be NULL).\n # Returns\n\nnumeric identifier of the last error associated with the file instance."]
    pub fn storage_file_get_error(file: *mut File) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Get the textual description of a the last error associated with a file instance.\n\n It is not possible to get the error text after the file has been closed.\n\n # Arguments\n\n* `file` - pointer to the file instance in question (must NOT be NULL).\n # Returns\n\npointer to a statically allocated zero-terminated string containing the respective error text."]
    pub fn storage_file_get_error_desc(file: *mut File) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Format the SD Card.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n # Returns\n\nFSE_OK if the card was successfully formatted, any other error code on failure."]
    pub fn storage_sd_format(storage: *mut Storage) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Unmount the SD card.\n\n These return values have special meaning:\n - FSE_NOT_READY if the SD card is not mounted.\n - FSE_DENIED if there are open files on the SD card.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n # Returns\n\nFSE_OK if the card was successfully formatted, any other error code on failure."]
    pub fn storage_sd_unmount(storage: *mut Storage) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Mount the SD card.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n # Returns\n\nFSE_OK if the card was successfully mounted, any other error code on failure."]
    pub fn storage_sd_mount(storage: *mut Storage) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Get SD card information.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `info` - pointer to the info object to contain the requested information.\n # Returns\n\nFSE_OK if the info was successfully received, any other error code on failure."]
    pub fn storage_sd_info(storage: *mut Storage, info: *mut SDInfo) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Get SD card status.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n # Returns\n\nstorage status in the form of a numeric error identifier."]
    pub fn storage_sd_status(storage: *mut Storage) -> FS_Error;
}
#[doc = "Internal Storage Backup/Restore"]
pub type StorageNameConverter = ::core::option::Option<unsafe extern "C" fn(arg1: *mut FuriString)>;
unsafe extern "C" {
    #[doc = "Back up the internal storage contents to a *.tar archive.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `dstname` - pointer to a zero-terminated string containing the archive file path.\n # Returns\n\nFSE_OK if the storage was successfully backed up, any other error code on failure."]
    pub fn storage_int_backup(storage: *mut Storage, dstname: *const core::ffi::c_char)
    -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Restore the internal storage contents from a *.tar archive.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `dstname` - pointer to a zero-terminated string containing the archive file path.\n * `converter` - pointer to a filename conversion function (may be NULL).\n # Returns\n\nFSE_OK if the storage was successfully restored, any other error code on failure."]
    pub fn storage_int_restore(
        storage: *mut Storage,
        dstname: *const core::ffi::c_char,
        converter: StorageNameConverter,
    ) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Remove a file or a directory.\n\n The following conditions must be met:\n - the directory must be empty.\n - the file or the directory must NOT be open.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the item path.\n # Returns\n\ntrue on success or if the item does not exist, false otherwise."]
    pub fn storage_simply_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Recursively remove a file or a directory.\n\n Unlike storage_simply_remove(), the directory does not need to be empty.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the item path.\n # Returns\n\ntrue on success or if the item does not exist, false otherwise."]
    pub fn storage_simply_remove_recursive(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Create a directory.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `path` - pointer to a zero-terminated string containing the directory path.\n # Returns\n\ntrue on success or if directory does already exist, false otherwise."]
    pub fn storage_simply_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the next free filename in a directory.\n\n Usage example:\n ```c\n FuriString* file_name = furi_string_alloc();\n Storage* storage = furi_record_open(RECORD_STORAGE);\n\n storage_get_next_filename(storage,\n \"/ext/test\",\n \"cookies\",\n \".yum\",\n 20);\n\n furi_record_close(RECORD_STORAGE);\n\n use_file_name(file_name);\n\n furi_string_free(file_name);\n ```\n Possible file_name values after calling storage_get_next_filename():\n \"cookies\", \"cookies1\", \"cookies2\", ... etc depending on whether any of\n these files have already existed in the directory.\n\n > **Note:** If the resulting next file name length is greater than set by the max_len\n parameter, the original filename will be returned instead.\n\n # Arguments\n\n* `storage` - pointer to a storage API instance.\n * `dirname` - pointer to a zero-terminated string containing the directory path.\n * `filename` - pointer to a zero-terminated string containing the file name.\n * `fileextension` - pointer to a zero-terminated string containing the file extension.\n * `nextfilename` - pointer to a dynamic string containing the resulting file name.\n * `max_len` - maximum length of the new name."]
    pub fn storage_get_next_filename(
        storage: *mut Storage,
        dirname: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        fileextension: *const core::ffi::c_char,
        nextfilename: *mut FuriString,
        max_len: u8,
    );
}
pub const FlipperApplicationPreloadStatusSuccess: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(0);
pub const FlipperApplicationPreloadStatusInvalidFile: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(1);
pub const FlipperApplicationPreloadStatusNotEnoughMemory: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(2);
pub const FlipperApplicationPreloadStatusInvalidManifest: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(3);
pub const FlipperApplicationPreloadStatusApiTooOld: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(4);
pub const FlipperApplicationPreloadStatusApiTooNew: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(5);
pub const FlipperApplicationPreloadStatusTargetMismatch: FlipperApplicationPreloadStatus =
    FlipperApplicationPreloadStatus(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FlipperApplicationPreloadStatus(pub core::ffi::c_uchar);
pub const FlipperApplicationLoadStatusSuccess: FlipperApplicationLoadStatus =
    FlipperApplicationLoadStatus(0);
pub const FlipperApplicationLoadStatusUnspecifiedError: FlipperApplicationLoadStatus =
    FlipperApplicationLoadStatus(1);
pub const FlipperApplicationLoadStatusMissingImports: FlipperApplicationLoadStatus =
    FlipperApplicationLoadStatus(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FlipperApplicationLoadStatus(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Get text description of preload status\n # Arguments\n\n* `status` - Status code\n # Returns\n\nString pointer to description"]
    pub fn flipper_application_preload_status_to_string(
        status: FlipperApplicationPreloadStatus,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get text description of load status\n # Arguments\n\n* `status` - Status code\n # Returns\n\nString pointer to description"]
    pub fn flipper_application_load_status_to_string(
        status: FlipperApplicationLoadStatus,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplication {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplicationMemoryMapEntry {
    pub name: *const core::ffi::c_char,
    pub address: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperApplicationMemoryMapEntry"]
        [::core::mem::size_of::<FlipperApplicationMemoryMapEntry>() - 8usize];
    ["Alignment of FlipperApplicationMemoryMapEntry"]
        [::core::mem::align_of::<FlipperApplicationMemoryMapEntry>() - 4usize];
    ["Offset of field: FlipperApplicationMemoryMapEntry::name"]
        [::core::mem::offset_of!(FlipperApplicationMemoryMapEntry, name) - 0usize];
    ["Offset of field: FlipperApplicationMemoryMapEntry::address"]
        [::core::mem::offset_of!(FlipperApplicationMemoryMapEntry, address) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplicationState {
    pub mmap_entry_count: u32,
    pub mmap_entries: *mut FlipperApplicationMemoryMapEntry,
    pub debug_link_size: u32,
    pub debug_link: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperApplicationState"]
        [::core::mem::size_of::<FlipperApplicationState>() - 16usize];
    ["Alignment of FlipperApplicationState"]
        [::core::mem::align_of::<FlipperApplicationState>() - 4usize];
    ["Offset of field: FlipperApplicationState::mmap_entry_count"]
        [::core::mem::offset_of!(FlipperApplicationState, mmap_entry_count) - 0usize];
    ["Offset of field: FlipperApplicationState::mmap_entries"]
        [::core::mem::offset_of!(FlipperApplicationState, mmap_entries) - 4usize];
    ["Offset of field: FlipperApplicationState::debug_link_size"]
        [::core::mem::offset_of!(FlipperApplicationState, debug_link_size) - 8usize];
    ["Offset of field: FlipperApplicationState::debug_link"]
        [::core::mem::offset_of!(FlipperApplicationState, debug_link) - 12usize];
};
unsafe extern "C" {
    #[doc = "Initialize FlipperApplication object\n # Arguments\n\n* `storage` - Storage instance\n * `api_interface` - ELF API interface to use for pre-loading and symbol resolving\n # Returns\n\nApplication instance"]
    pub fn flipper_application_alloc(
        storage: *mut Storage,
        api_interface: *const ElfApiInterface,
    ) -> *mut FlipperApplication;
}
unsafe extern "C" {
    #[doc = "Destroy FlipperApplication object\n # Arguments\n\n* `app` - Application pointer"]
    pub fn flipper_application_free(app: *mut FlipperApplication);
}
unsafe extern "C" {
    #[doc = "Validate elf file and load application metadata\n\n # Arguments\n\n* `app` - Application pointer\n * `path` (direction in) - The path to fap file\n\n # Returns\n\nPreload result code"]
    pub fn flipper_application_preload(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
unsafe extern "C" {
    #[doc = "Validate elf file and load application manifest\n\n # Arguments\n\n* `app` - Application pointer\n * `path` (direction in) - The path to fap file\n\n # Returns\n\nPreload result code"]
    pub fn flipper_application_preload_manifest(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
unsafe extern "C" {
    #[doc = "Get pointer to application manifest for preloaded application\n # Arguments\n\n* `app` - Application pointer\n # Returns\n\nPointer to application manifest"]
    pub fn flipper_application_get_manifest(
        app: *mut FlipperApplication,
    ) -> *const FlipperApplicationManifest;
}
unsafe extern "C" {
    #[doc = "Load sections and process relocations for already pre-loaded application\n # Arguments\n\n* `app` - Application pointer\n # Returns\n\nLoad result code"]
    pub fn flipper_application_map_to_memory(
        app: *mut FlipperApplication,
    ) -> FlipperApplicationLoadStatus;
}
unsafe extern "C" {
    #[doc = "Allocate application thread at entry point address, using app name and\n stack size from metadata. Returned thread isn't started yet.\n Can be only called once for application instance.\n # Arguments\n\n* `app` - Applicaiton pointer\n * `args` - Args to pass to app's entry point\n # Returns\n\nCreated thread"]
    pub fn flipper_application_alloc_thread(
        app: *mut FlipperApplication,
        args: *const core::ffi::c_char,
    ) -> *mut FuriThread;
}
unsafe extern "C" {
    #[doc = "Check if application is a plugin (not a runnable standalone app)\n # Arguments\n\n* `app` - Application pointer\n # Returns\n\ntrue if application is a plugin, false otherwise"]
    pub fn flipper_application_is_plugin(app: *mut FlipperApplication) -> bool;
}
#[doc = "Entry point prototype for standalone applications"]
pub type FlipperApplicationEntryPoint =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> i32>;
#[doc = "An object that describes a plugin - must be returned by plugin's entry point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperAppPluginDescriptor {
    pub appid: *const core::ffi::c_char,
    pub ep_api_version: u32,
    pub entry_point: *const core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperAppPluginDescriptor"]
        [::core::mem::size_of::<FlipperAppPluginDescriptor>() - 12usize];
    ["Alignment of FlipperAppPluginDescriptor"]
        [::core::mem::align_of::<FlipperAppPluginDescriptor>() - 4usize];
    ["Offset of field: FlipperAppPluginDescriptor::appid"]
        [::core::mem::offset_of!(FlipperAppPluginDescriptor, appid) - 0usize];
    ["Offset of field: FlipperAppPluginDescriptor::ep_api_version"]
        [::core::mem::offset_of!(FlipperAppPluginDescriptor, ep_api_version) - 4usize];
    ["Offset of field: FlipperAppPluginDescriptor::entry_point"]
        [::core::mem::offset_of!(FlipperAppPluginDescriptor, entry_point) - 8usize];
};
#[doc = "Entry point prototype for plugins"]
pub type FlipperApplicationPluginEntryPoint =
    ::core::option::Option<unsafe extern "C" fn() -> *const FlipperAppPluginDescriptor>;
unsafe extern "C" {
    #[doc = "Get plugin descriptor for preloaded plugin\n # Arguments\n\n* `app` - Application pointer\n # Returns\n\nPointer to plugin descriptor"]
    pub fn flipper_application_plugin_get_descriptor(
        app: *mut FlipperApplication,
    ) -> *const FlipperAppPluginDescriptor;
}
unsafe extern "C" {
    #[doc = "Load name and icon from FAP file.\n\n # Arguments\n\n* `path` - Path to FAP file.\n * `storage` - Storage instance.\n * `icon_ptr` - Icon pointer.\n * `item_name` - Application name.\n # Returns\n\ntrue if icon and name were loaded successfully."]
    pub fn flipper_application_load_name_and_icon(
        path: *mut FuriString,
        storage: *mut Storage,
        icon_ptr: *mut *mut u8,
        item_name: *mut FuriString,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDeviceRegistry {
    _unused: [u8; 0],
}
pub type SubGhzBegin = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzEnd = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzIsConnect = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzReset = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzSleep = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzIdle = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzLoadPreset =
    ::core::option::Option<unsafe extern "C" fn(preset: FuriHalSubGhzPreset, preset_data: *mut u8)>;
pub type SubGhzSetFrequency = ::core::option::Option<unsafe extern "C" fn(frequency: u32) -> u32>;
pub type SubGhzIsFrequencyValid =
    ::core::option::Option<unsafe extern "C" fn(frequency: u32) -> bool>;
pub type SubGhzSetAsyncMirrorPin =
    ::core::option::Option<unsafe extern "C" fn(gpio: *const GpioPin)>;
pub type SubGhzGetDataGpio = ::core::option::Option<unsafe extern "C" fn() -> *const GpioPin>;
pub type SubGhzSetTx = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzFlushTx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzStartAsyncTx = ::core::option::Option<
    unsafe extern "C" fn(callback: *mut core::ffi::c_void, context: *mut core::ffi::c_void) -> bool,
>;
pub type SubGhzIsAsyncCompleteTx = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzStopAsyncTx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzSetRx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzFlushRx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzStartAsyncRx = ::core::option::Option<
    unsafe extern "C" fn(callback: *mut core::ffi::c_void, context: *mut core::ffi::c_void),
>;
pub type SubGhzStopAsyncRx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzGetRSSI = ::core::option::Option<unsafe extern "C" fn() -> f32>;
pub type SubGhzGetLQI = ::core::option::Option<unsafe extern "C" fn() -> u8>;
pub type SubGhzRxPipeNotEmpty = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzRxIsDataCrcValid = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzReadPacket =
    ::core::option::Option<unsafe extern "C" fn(data: *mut u8, size: *mut u8)>;
pub type SubGhzWritePacket =
    ::core::option::Option<unsafe extern "C" fn(data: *const u8, size: u8)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDeviceInterconnect {
    pub begin: SubGhzBegin,
    pub end: SubGhzEnd,
    pub is_connect: SubGhzIsConnect,
    pub reset: SubGhzReset,
    pub sleep: SubGhzSleep,
    pub idle: SubGhzIdle,
    pub load_preset: SubGhzLoadPreset,
    pub set_frequency: SubGhzSetFrequency,
    pub is_frequency_valid: SubGhzIsFrequencyValid,
    pub set_async_mirror_pin: SubGhzSetAsyncMirrorPin,
    pub get_data_gpio: SubGhzGetDataGpio,
    pub set_tx: SubGhzSetTx,
    pub flush_tx: SubGhzFlushTx,
    pub start_async_tx: SubGhzStartAsyncTx,
    pub is_async_complete_tx: SubGhzIsAsyncCompleteTx,
    pub stop_async_tx: SubGhzStopAsyncTx,
    pub set_rx: SubGhzSetRx,
    pub flush_rx: SubGhzFlushRx,
    pub start_async_rx: SubGhzStartAsyncRx,
    pub stop_async_rx: SubGhzStopAsyncRx,
    pub get_rssi: SubGhzGetRSSI,
    pub get_lqi: SubGhzGetLQI,
    pub rx_pipe_not_empty: SubGhzRxPipeNotEmpty,
    pub is_rx_data_crc_valid: SubGhzRxIsDataCrcValid,
    pub read_packet: SubGhzReadPacket,
    pub write_packet: SubGhzWritePacket,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzDeviceInterconnect"]
        [::core::mem::size_of::<SubGhzDeviceInterconnect>() - 104usize];
    ["Alignment of SubGhzDeviceInterconnect"]
        [::core::mem::align_of::<SubGhzDeviceInterconnect>() - 4usize];
    ["Offset of field: SubGhzDeviceInterconnect::begin"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, begin) - 0usize];
    ["Offset of field: SubGhzDeviceInterconnect::end"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, end) - 4usize];
    ["Offset of field: SubGhzDeviceInterconnect::is_connect"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, is_connect) - 8usize];
    ["Offset of field: SubGhzDeviceInterconnect::reset"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, reset) - 12usize];
    ["Offset of field: SubGhzDeviceInterconnect::sleep"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, sleep) - 16usize];
    ["Offset of field: SubGhzDeviceInterconnect::idle"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, idle) - 20usize];
    ["Offset of field: SubGhzDeviceInterconnect::load_preset"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, load_preset) - 24usize];
    ["Offset of field: SubGhzDeviceInterconnect::set_frequency"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, set_frequency) - 28usize];
    ["Offset of field: SubGhzDeviceInterconnect::is_frequency_valid"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, is_frequency_valid) - 32usize];
    ["Offset of field: SubGhzDeviceInterconnect::set_async_mirror_pin"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, set_async_mirror_pin) - 36usize];
    ["Offset of field: SubGhzDeviceInterconnect::get_data_gpio"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, get_data_gpio) - 40usize];
    ["Offset of field: SubGhzDeviceInterconnect::set_tx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, set_tx) - 44usize];
    ["Offset of field: SubGhzDeviceInterconnect::flush_tx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, flush_tx) - 48usize];
    ["Offset of field: SubGhzDeviceInterconnect::start_async_tx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, start_async_tx) - 52usize];
    ["Offset of field: SubGhzDeviceInterconnect::is_async_complete_tx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, is_async_complete_tx) - 56usize];
    ["Offset of field: SubGhzDeviceInterconnect::stop_async_tx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, stop_async_tx) - 60usize];
    ["Offset of field: SubGhzDeviceInterconnect::set_rx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, set_rx) - 64usize];
    ["Offset of field: SubGhzDeviceInterconnect::flush_rx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, flush_rx) - 68usize];
    ["Offset of field: SubGhzDeviceInterconnect::start_async_rx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, start_async_rx) - 72usize];
    ["Offset of field: SubGhzDeviceInterconnect::stop_async_rx"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, stop_async_rx) - 76usize];
    ["Offset of field: SubGhzDeviceInterconnect::get_rssi"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, get_rssi) - 80usize];
    ["Offset of field: SubGhzDeviceInterconnect::get_lqi"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, get_lqi) - 84usize];
    ["Offset of field: SubGhzDeviceInterconnect::rx_pipe_not_empty"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, rx_pipe_not_empty) - 88usize];
    ["Offset of field: SubGhzDeviceInterconnect::is_rx_data_crc_valid"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, is_rx_data_crc_valid) - 92usize];
    ["Offset of field: SubGhzDeviceInterconnect::read_packet"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, read_packet) - 96usize];
    ["Offset of field: SubGhzDeviceInterconnect::write_packet"]
        [::core::mem::offset_of!(SubGhzDeviceInterconnect, write_packet) - 100usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDevice {
    pub name: *const core::ffi::c_char,
    pub interconnect: *const SubGhzDeviceInterconnect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzDevice"][::core::mem::size_of::<SubGhzDevice>() - 8usize];
    ["Alignment of SubGhzDevice"][::core::mem::align_of::<SubGhzDevice>() - 4usize];
    ["Offset of field: SubGhzDevice::name"][::core::mem::offset_of!(SubGhzDevice, name) - 0usize];
    ["Offset of field: SubGhzDevice::interconnect"]
        [::core::mem::offset_of!(SubGhzDevice, interconnect) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDeviceCC1101Ext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bt {
    _unused: [u8; 0],
}
pub const BtStatusUnavailable: BtStatus = BtStatus(0);
pub const BtStatusOff: BtStatus = BtStatus(1);
pub const BtStatusAdvertising: BtStatus = BtStatus(2);
pub const BtStatusConnected: BtStatus = BtStatus(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BtStatus(pub core::ffi::c_uchar);
pub type BtStatusChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(status: BtStatus, context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Change BLE Profile\n > **Note:** Call of this function leads to 2nd core restart\n\n # Arguments\n\n* `bt` - Bt instance\n * `profile_template` - Profile template to change to\n * `params` - Profile parameters. Can be NULL\n\n # Returns\n\ntrue on success"]
    pub fn bt_profile_start(
        bt: *mut Bt,
        profile_template: *const FuriHalBleProfileTemplate,
        params: FuriHalBleProfileParams,
    ) -> *mut FuriHalBleProfileBase;
}
unsafe extern "C" {
    #[doc = "Stop current BLE Profile and restore default profile\n > **Note:** Call of this function leads to 2nd core restart\n\n # Arguments\n\n* `bt` - Bt instance\n\n # Returns\n\ntrue on success"]
    pub fn bt_profile_restore_default(bt: *mut Bt) -> bool;
}
unsafe extern "C" {
    #[doc = "Disconnect from Central\n\n # Arguments\n\n* `bt` - Bt instance"]
    pub fn bt_disconnect(bt: *mut Bt);
}
unsafe extern "C" {
    #[doc = "Set callback for Bluetooth status change notification\n\n # Arguments\n\n* `bt` - Bt instance\n * `callback` - BtStatusChangedCallback instance\n * `context` - pointer to context"]
    pub fn bt_set_status_changed_callback(
        bt: *mut Bt,
        callback: BtStatusChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Forget bonded devices\n > **Note:** Leads to wipe ble key storage and deleting bt.keys\n\n # Arguments\n\n* `bt` - Bt instance"]
    pub fn bt_forget_bonded_devices(bt: *mut Bt);
}
unsafe extern "C" {
    #[doc = "Set keys storage file path\n\n # Arguments\n\n* `bt` - Bt instance\n * `keys_storage_path` - Path to file with saved keys"]
    pub fn bt_keys_storage_set_storage_path(
        bt: *mut Bt,
        keys_storage_path: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Set default keys storage file path\n\n # Arguments\n\n* `bt` - Bt instance"]
    pub fn bt_keys_storage_set_default_path(bt: *mut Bt);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BtKeysStorage {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bt_keys_storage_alloc(keys_storage_path: *const core::ffi::c_char)
    -> *mut BtKeysStorage;
}
unsafe extern "C" {
    pub fn bt_keys_storage_free(instance: *mut BtKeysStorage);
}
unsafe extern "C" {
    pub fn bt_keys_storage_set_file_path(
        instance: *mut BtKeysStorage,
        path: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    pub fn bt_keys_storage_set_ram_params(instance: *mut BtKeysStorage, buff: *mut u8, size: u16);
}
unsafe extern "C" {
    pub fn bt_keys_storage_is_changed(instance: *mut BtKeysStorage) -> bool;
}
unsafe extern "C" {
    pub fn bt_keys_storage_load(instance: *mut BtKeysStorage) -> bool;
}
unsafe extern "C" {
    pub fn bt_keys_storage_update(
        instance: *mut BtKeysStorage,
        start_addr: *mut u8,
        size: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn bt_keys_storage_delete(instance: *mut BtKeysStorage) -> bool;
}
pub const CliSymbolAsciiSOH: CliSymbols = CliSymbols(1);
pub const CliSymbolAsciiETX: CliSymbols = CliSymbols(3);
pub const CliSymbolAsciiEOT: CliSymbols = CliSymbols(4);
pub const CliSymbolAsciiBell: CliSymbols = CliSymbols(7);
pub const CliSymbolAsciiBackspace: CliSymbols = CliSymbols(8);
pub const CliSymbolAsciiTab: CliSymbols = CliSymbols(9);
pub const CliSymbolAsciiLF: CliSymbols = CliSymbols(10);
pub const CliSymbolAsciiCR: CliSymbols = CliSymbols(13);
pub const CliSymbolAsciiEsc: CliSymbols = CliSymbols(27);
pub const CliSymbolAsciiUS: CliSymbols = CliSymbols(31);
pub const CliSymbolAsciiSpace: CliSymbols = CliSymbols(32);
pub const CliSymbolAsciiDel: CliSymbols = CliSymbols(127);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CliSymbols(pub core::ffi::c_uchar);
#[doc = "< Default, loader lock is used"]
pub const CliCommandFlagDefault: CliCommandFlag = CliCommandFlag(0);
pub const CliCommandFlagParallelSafe: CliCommandFlag = CliCommandFlag(1);
#[doc = "< Safe to run with insomnia mode on"]
pub const CliCommandFlagInsomniaSafe: CliCommandFlag = CliCommandFlag(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CliCommandFlag(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cli {
    _unused: [u8; 0],
}
#[doc = "Cli callback function pointer. Implement this interface and use\n add_cli_command\n # Arguments\n\n* `args` - string with what was passed after command\n * `context` - pointer to whatever you gave us on cli_add_command"]
pub type CliCallback = ::core::option::Option<
    unsafe extern "C" fn(cli: *mut Cli, args: *mut FuriString, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Add cli command Registers you command callback\n\n # Arguments\n\n* `cli` - pointer to cli instance\n * `name` - command name\n * `flags` - CliCommandFlag\n * `callback` - callback function\n * `context` - pointer to whatever we need to pass to callback"]
    pub fn cli_add_command(
        cli: *mut Cli,
        name: *const core::ffi::c_char,
        flags: CliCommandFlag,
        callback: CliCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Print unified cmd usage tip\n\n # Arguments\n\n* `cmd` - cmd name\n * `usage` - usage tip\n * `arg` - arg passed by user"]
    pub fn cli_print_usage(
        cmd: *const core::ffi::c_char,
        usage: *const core::ffi::c_char,
        arg: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Delete cli command\n\n # Arguments\n\n* `cli` - pointer to cli instance\n * `name` - command name"]
    pub fn cli_delete_command(cli: *mut Cli, name: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Read from terminal\n\n # Arguments\n\n* `cli` - Cli instance\n * `buffer` - pointer to buffer\n * `size` - size of buffer in bytes\n\n # Returns\n\nbytes read"]
    pub fn cli_read(cli: *mut Cli, buffer: *mut u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Non-blocking read from terminal\n\n # Arguments\n\n* `cli` - Cli instance\n * `buffer` - pointer to buffer\n * `size` - size of buffer in bytes\n * `timeout` - timeout value in ms\n\n # Returns\n\nbytes read"]
    pub fn cli_read_timeout(cli: *mut Cli, buffer: *mut u8, size: usize, timeout: u32) -> usize;
}
unsafe extern "C" {
    #[doc = "Non-blocking check for interrupt command received\n\n # Arguments\n\n* `cli` - Cli instance\n\n # Returns\n\ntrue if received"]
    pub fn cli_cmd_interrupt_received(cli: *mut Cli) -> bool;
}
unsafe extern "C" {
    #[doc = "Write to terminal Do it only from inside of cli call.\n\n # Arguments\n\n* `cli` - Cli instance\n * `buffer` - pointer to buffer\n * `size` - size of buffer in bytes"]
    pub fn cli_write(cli: *mut Cli, buffer: *const u8, size: usize);
}
unsafe extern "C" {
    #[doc = "Read character\n\n # Arguments\n\n* `cli` - Cli instance\n\n # Returns\n\nchar"]
    pub fn cli_getc(cli: *mut Cli) -> core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "New line Send new ine sequence"]
    pub fn cli_nl(cli: *mut Cli);
}
unsafe extern "C" {
    pub fn cli_session_open(cli: *mut Cli, session: *mut core::ffi::c_void);
}
unsafe extern "C" {
    pub fn cli_session_close(cli: *mut Cli);
}
unsafe extern "C" {
    pub fn cli_is_connected(cli: *mut Cli) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CliSession {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static mut cli_vcp: CliSession;
}
unsafe extern "C" {
    #[doc = "Get icon width\n\n # Arguments\n\n* `instance` (direction in) - pointer to Icon data\n\n # Returns\n\nwidth in pixels"]
    pub fn icon_get_width(instance: *const Icon) -> u16;
}
unsafe extern "C" {
    #[doc = "Get icon height\n\n # Arguments\n\n* `instance` (direction in) - pointer to Icon data\n\n # Returns\n\nheight in pixels"]
    pub fn icon_get_height(instance: *const Icon) -> u16;
}
unsafe extern "C" {
    #[doc = "Get Icon XBM bitmap data for the first frame\n\n # Arguments\n\n* `instance` (direction in) - pointer to Icon data\n\n # Returns\n\npointer to compressed XBM bitmap data"]
    pub fn icon_get_data(instance: *const Icon) -> *const u8;
}
unsafe extern "C" {
    #[doc = "Get Icon frame count\n\n # Arguments\n\n* `instance` (direction in) - pointer to Icon data\n\n # Returns\n\nframe count"]
    pub fn icon_get_frame_count(instance: *const Icon) -> u32;
}
unsafe extern "C" {
    #[doc = "Get Icon XBM bitmap data for a particular frame\n\n # Arguments\n\n* `instance` (direction in) - pointer to Icon data\n * `frame` (direction in) - frame index\n\n # Returns\n\npointer to compressed XBM bitmap data"]
    pub fn icon_get_frame_data(instance: *const Icon, frame: u32) -> *const u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IconAnimation {
    _unused: [u8; 0],
}
#[doc = "Icon Animation Callback. Used for update notification"]
pub type IconAnimationCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut IconAnimation, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Allocate icon animation instance with const icon data.\n\n always returns Icon or stops system if not enough memory\n\n # Arguments\n\n* `icon` (direction in) - pointer to Icon data\n\n # Returns\n\nIconAnimation instance"]
    pub fn icon_animation_alloc(icon: *const Icon) -> *mut IconAnimation;
}
unsafe extern "C" {
    #[doc = "Release icon animation instance\n\n # Arguments\n\n* `instance` - IconAnimation instance"]
    pub fn icon_animation_free(instance: *mut IconAnimation);
}
unsafe extern "C" {
    #[doc = "Set IconAnimation update callback\n\n Normally you do not need to use this function, use view_tie_icon_animation\n instead.\n\n # Arguments\n\n* `instance` - IconAnimation instance\n * `callback` (direction in) - IconAnimationCallback\n * `context` - callback context"]
    pub fn icon_animation_set_update_callback(
        instance: *mut IconAnimation,
        callback: IconAnimationCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get icon animation width\n\n # Arguments\n\n* `instance` - IconAnimation instance\n\n # Returns\n\nwidth in pixels"]
    pub fn icon_animation_get_width(instance: *const IconAnimation) -> u8;
}
unsafe extern "C" {
    #[doc = "Get icon animation height\n\n # Arguments\n\n* `instance` - IconAnimation instance\n\n # Returns\n\nheight in pixels"]
    pub fn icon_animation_get_height(instance: *const IconAnimation) -> u8;
}
unsafe extern "C" {
    #[doc = "Start icon animation\n\n # Arguments\n\n* `instance` - IconAnimation instance"]
    pub fn icon_animation_start(instance: *mut IconAnimation);
}
unsafe extern "C" {
    #[doc = "Stop icon animation\n\n # Arguments\n\n* `instance` - IconAnimation instance"]
    pub fn icon_animation_stop(instance: *mut IconAnimation);
}
unsafe extern "C" {
    #[doc = "Returns true if current frame is a last one\n\n # Arguments\n\n* `instance` - IconAnimation instance\n\n # Returns\n\ntrue if last frame"]
    pub fn icon_animation_is_last_frame(instance: *const IconAnimation) -> bool;
}
pub const ColorWhite: Color = Color(0);
pub const ColorBlack: Color = Color(1);
pub const ColorXOR: Color = Color(2);
#[repr(transparent)]
#[doc = "Color enumeration"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Color(pub core::ffi::c_uchar);
pub const FontPrimary: Font = Font(0);
pub const FontSecondary: Font = Font(1);
pub const FontKeyboard: Font = Font(2);
pub const FontBigNumbers: Font = Font(3);
pub const FontTotalNumber: Font = Font(4);
#[repr(transparent)]
#[doc = "Fonts enumeration"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Font(pub core::ffi::c_uchar);
pub const AlignLeft: Align = Align(0);
pub const AlignRight: Align = Align(1);
pub const AlignTop: Align = Align(2);
pub const AlignBottom: Align = Align(3);
pub const AlignCenter: Align = Align(4);
#[repr(transparent)]
#[doc = "Alignment enumeration"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Align(pub core::ffi::c_uchar);
pub const CanvasOrientationHorizontal: CanvasOrientation = CanvasOrientation(0);
pub const CanvasOrientationHorizontalFlip: CanvasOrientation = CanvasOrientation(1);
pub const CanvasOrientationVertical: CanvasOrientation = CanvasOrientation(2);
pub const CanvasOrientationVerticalFlip: CanvasOrientation = CanvasOrientation(3);
#[repr(transparent)]
#[doc = "Canvas Orientation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CanvasOrientation(pub core::ffi::c_uchar);
pub const CanvasDirectionLeftToRight: CanvasDirection = CanvasDirection(0);
pub const CanvasDirectionTopToBottom: CanvasDirection = CanvasDirection(1);
pub const CanvasDirectionRightToLeft: CanvasDirection = CanvasDirection(2);
pub const CanvasDirectionBottomToTop: CanvasDirection = CanvasDirection(3);
#[repr(transparent)]
#[doc = "Font Direction"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CanvasDirection(pub core::ffi::c_uchar);
#[doc = "Font parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CanvasFontParameters {
    pub leading_default: u8,
    pub leading_min: u8,
    pub height: u8,
    pub descender: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CanvasFontParameters"][::core::mem::size_of::<CanvasFontParameters>() - 4usize];
    ["Alignment of CanvasFontParameters"][::core::mem::align_of::<CanvasFontParameters>() - 1usize];
    ["Offset of field: CanvasFontParameters::leading_default"]
        [::core::mem::offset_of!(CanvasFontParameters, leading_default) - 0usize];
    ["Offset of field: CanvasFontParameters::leading_min"]
        [::core::mem::offset_of!(CanvasFontParameters, leading_min) - 1usize];
    ["Offset of field: CanvasFontParameters::height"]
        [::core::mem::offset_of!(CanvasFontParameters, height) - 2usize];
    ["Offset of field: CanvasFontParameters::descender"]
        [::core::mem::offset_of!(CanvasFontParameters, descender) - 3usize];
};
pub const IconFlipNone: IconFlip = IconFlip(0);
pub const IconFlipHorizontal: IconFlip = IconFlip(1);
pub const IconFlipVertical: IconFlip = IconFlip(2);
pub const IconFlipBoth: IconFlip = IconFlip(3);
#[repr(transparent)]
#[doc = "Icon flip"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IconFlip(pub core::ffi::c_uchar);
pub const IconRotation0: IconRotation = IconRotation(0);
pub const IconRotation90: IconRotation = IconRotation(1);
pub const IconRotation180: IconRotation = IconRotation(2);
pub const IconRotation270: IconRotation = IconRotation(3);
#[repr(transparent)]
#[doc = "Icon rotation"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct IconRotation(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Canvas {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Reset canvas drawing tools configuration\n\n # Arguments\n\n* `canvas` - Canvas instance"]
    pub fn canvas_reset(canvas: *mut Canvas);
}
unsafe extern "C" {
    #[doc = "Commit canvas. Send buffer to display\n\n # Arguments\n\n* `canvas` - Canvas instance"]
    pub fn canvas_commit(canvas: *mut Canvas);
}
unsafe extern "C" {
    #[doc = "Get Canvas width\n\n # Arguments\n\n* `canvas` - Canvas instance\n\n # Returns\n\nwidth in pixels."]
    pub fn canvas_width(canvas: *const Canvas) -> usize;
}
unsafe extern "C" {
    #[doc = "Get Canvas height\n\n # Arguments\n\n* `canvas` - Canvas instance\n\n # Returns\n\nheight in pixels."]
    pub fn canvas_height(canvas: *const Canvas) -> usize;
}
unsafe extern "C" {
    #[doc = "Get current font height\n\n # Arguments\n\n* `canvas` - Canvas instance\n\n # Returns\n\nheight in pixels."]
    pub fn canvas_current_font_height(canvas: *const Canvas) -> usize;
}
unsafe extern "C" {
    #[doc = "Get font parameters\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `font` - Font\n\n # Returns\n\npointer to CanvasFontParameters structure"]
    pub fn canvas_get_font_params(canvas: *const Canvas, font: Font)
    -> *const CanvasFontParameters;
}
unsafe extern "C" {
    #[doc = "Clear canvas\n\n # Arguments\n\n* `canvas` - Canvas instance"]
    pub fn canvas_clear(canvas: *mut Canvas);
}
unsafe extern "C" {
    #[doc = "Set drawing color\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `color` - Color"]
    pub fn canvas_set_color(canvas: *mut Canvas, color: Color);
}
unsafe extern "C" {
    #[doc = "Set font swap Argument String Rotation Description\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `dir` - Direction font"]
    pub fn canvas_set_font_direction(canvas: *mut Canvas, dir: CanvasDirection);
}
unsafe extern "C" {
    #[doc = "Invert drawing color\n\n # Arguments\n\n* `canvas` - Canvas instance"]
    pub fn canvas_invert_color(canvas: *mut Canvas);
}
unsafe extern "C" {
    #[doc = "Set drawing font\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `font` - Font"]
    pub fn canvas_set_font(canvas: *mut Canvas, font: Font);
}
unsafe extern "C" {
    #[doc = "Set custom drawing font\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `font` - Pointer to u8g2 const uint8_t* font array"]
    pub fn canvas_set_custom_u8g2_font(canvas: *mut Canvas, font: *const u8);
}
unsafe extern "C" {
    #[doc = "Draw string at position of baseline defined by x, y.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - anchor point x coordinate\n * `y` - anchor point y coordinate\n * `str` - C-string"]
    pub fn canvas_draw_str(canvas: *mut Canvas, x: i32, y: i32, str_: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Draw aligned string defined by x, y.\n\n Align calculated from position of baseline, string width and ascent (height\n of the glyphs above the baseline)\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - anchor point x coordinate\n * `y` - anchor point y coordinate\n * `horizontal` - horizontal alignment\n * `vertical` - vertical alignment\n * `str` - C-string"]
    pub fn canvas_draw_str_aligned(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        horizontal: Align,
        vertical: Align,
        str_: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Get string width\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `str` - C-string\n\n # Returns\n\nwidth in pixels."]
    pub fn canvas_string_width(canvas: *mut Canvas, str_: *const core::ffi::c_char) -> u16;
}
unsafe extern "C" {
    #[doc = "Get glyph width\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `symbol` (direction in) - character\n\n # Returns\n\nwidth in pixels"]
    pub fn canvas_glyph_width(canvas: *mut Canvas, symbol: u16) -> usize;
}
unsafe extern "C" {
    #[doc = "Draw bitmap picture at position defined by x,y.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - width of bitmap\n * `height` - height of bitmap\n * `compressed_bitmap_data` - compressed bitmap data"]
    pub fn canvas_draw_bitmap(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
        compressed_bitmap_data: *const u8,
    );
}
unsafe extern "C" {
    #[doc = "Draw icon at position defined by x,y with rotation and flip.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `icon` - Icon instance\n * `rotation` - IconRotation"]
    pub fn canvas_draw_icon_ex(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        icon: *const Icon,
        rotation: IconRotation,
    );
}
unsafe extern "C" {
    #[doc = "Draw animation at position defined by x,y.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `icon_animation` - IconAnimation instance"]
    pub fn canvas_draw_icon_animation(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        icon_animation: *mut IconAnimation,
    );
}
unsafe extern "C" {
    #[doc = "Draw icon at position defined by x,y.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `icon` - Icon instance"]
    pub fn canvas_draw_icon(canvas: *mut Canvas, x: i32, y: i32, icon: *const Icon);
}
unsafe extern "C" {
    #[doc = "Draw XBM bitmap\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` (direction in) - bitmap width\n * `height` (direction in) - bitmap height\n * `bitmap` - pointer to XBM bitmap data"]
    pub fn canvas_draw_xbm(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
        bitmap: *const u8,
    );
}
unsafe extern "C" {
    #[doc = "Draw rotated XBM bitmap\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` (direction in) - bitmap width\n * `height` (direction in) - bitmap height\n * `rotation` (direction in) - bitmap rotation\n * `bitmap_data` - pointer to XBM bitmap data"]
    pub fn canvas_draw_xbm_ex(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
        rotation: IconRotation,
        bitmap_data: *const u8,
    );
}
unsafe extern "C" {
    #[doc = "Draw dot at x,y\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate"]
    pub fn canvas_draw_dot(canvas: *mut Canvas, x: i32, y: i32);
}
unsafe extern "C" {
    #[doc = "Draw box of width, height at x,y\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - box width\n * `height` - box height"]
    pub fn canvas_draw_box(canvas: *mut Canvas, x: i32, y: i32, width: usize, height: usize);
}
unsafe extern "C" {
    #[doc = "Draw frame of width, height at x,y\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - frame width\n * `height` - frame height"]
    pub fn canvas_draw_frame(canvas: *mut Canvas, x: i32, y: i32, width: usize, height: usize);
}
unsafe extern "C" {
    #[doc = "Draw line from x1,y1 to x2,y2\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x1` - x1 coordinate\n * `y1` - y1 coordinate\n * `x2` - x2 coordinate\n * `y2` - y2 coordinate"]
    pub fn canvas_draw_line(canvas: *mut Canvas, x1: i32, y1: i32, x2: i32, y2: i32);
}
unsafe extern "C" {
    #[doc = "Draw circle at x,y with radius r\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `radius` - radius"]
    pub fn canvas_draw_circle(canvas: *mut Canvas, x: i32, y: i32, radius: usize);
}
unsafe extern "C" {
    #[doc = "Draw disc at x,y with radius r\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `radius` - radius"]
    pub fn canvas_draw_disc(canvas: *mut Canvas, x: i32, y: i32, radius: usize);
}
unsafe extern "C" {
    #[doc = "Draw triangle with given base and height lengths and their intersection\n coordinate\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate of base and height intersection\n * `y` - y coordinate of base and height intersection\n * `base` - length of triangle side\n * `height` - length of triangle height\n * `dir` - CanvasDirection triangle orientation"]
    pub fn canvas_draw_triangle(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        base: usize,
        height: usize,
        dir: CanvasDirection,
    );
}
unsafe extern "C" {
    #[doc = "Draw glyph\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `ch` - character"]
    pub fn canvas_draw_glyph(canvas: *mut Canvas, x: i32, y: i32, ch: u16);
}
unsafe extern "C" {
    #[doc = "Set transparency mode\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `alpha` - transparency mode"]
    pub fn canvas_set_bitmap_mode(canvas: *mut Canvas, alpha: bool);
}
unsafe extern "C" {
    #[doc = "Draw rounded-corner frame of width, height at x,y, with round value radius\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - frame width\n * `height` - frame height\n * `radius` - frame corner radius"]
    pub fn canvas_draw_rframe(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
        radius: usize,
    );
}
unsafe extern "C" {
    #[doc = "Draw rounded-corner box of width, height at x,y, with round value raduis\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - box width\n * `height` - box height\n * `radius` - box corner radius"]
    pub fn canvas_draw_rbox(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
        radius: usize,
    );
}
#[doc = "< Press event, emitted after debounce"]
pub const InputTypePress: InputType = InputType(0);
#[doc = "< Release event, emitted after debounce"]
pub const InputTypeRelease: InputType = InputType(1);
#[doc = "< Short event, emitted after InputTypeRelease done within INPUT_LONG_PRESS interval"]
pub const InputTypeShort: InputType = InputType(2);
#[doc = "< Long event, emitted after INPUT_LONG_PRESS_COUNTS interval, asynchronous to InputTypeRelease"]
pub const InputTypeLong: InputType = InputType(3);
#[doc = "< Repeat event, emitted with INPUT_LONG_PRESS_COUNTS period after InputTypeLong event"]
pub const InputTypeRepeat: InputType = InputType(4);
#[doc = "< Special value for exceptional"]
pub const InputTypeMAX: InputType = InputType(5);
#[repr(transparent)]
#[doc = "Input Types\n Some of them are physical events and some logical"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct InputType(pub core::ffi::c_uchar);
#[doc = "Input Event, dispatches with FuriPubSub"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InputEvent {
    pub __bindgen_anon_1: InputEvent__bindgen_ty_1,
    pub key: InputKey,
    pub type_: InputType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union InputEvent__bindgen_ty_1 {
    pub sequence: u32,
    pub __bindgen_anon_1: InputEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputEvent__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InputEvent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<InputEvent__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of InputEvent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<InputEvent__bindgen_ty_1__bindgen_ty_1>() - 4usize];
};
impl InputEvent__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sequence_source(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_sequence_source(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sequence_source_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_sequence_source_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sequence_counter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_sequence_counter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sequence_counter_raw(this: *const Self) -> u32 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sequence_counter_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sequence_source: u8,
        sequence_counter: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sequence_source: u8 = unsafe { ::core::mem::transmute(sequence_source) };
            sequence_source as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let sequence_counter: u32 = unsafe { ::core::mem::transmute(sequence_counter) };
            sequence_counter as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InputEvent__bindgen_ty_1"]
        [::core::mem::size_of::<InputEvent__bindgen_ty_1>() - 4usize];
    ["Alignment of InputEvent__bindgen_ty_1"]
        [::core::mem::align_of::<InputEvent__bindgen_ty_1>() - 4usize];
    ["Offset of field: InputEvent__bindgen_ty_1::sequence"]
        [::core::mem::offset_of!(InputEvent__bindgen_ty_1, sequence) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InputEvent"][::core::mem::size_of::<InputEvent>() - 8usize];
    ["Alignment of InputEvent"][::core::mem::align_of::<InputEvent>() - 4usize];
    ["Offset of field: InputEvent::key"][::core::mem::offset_of!(InputEvent, key) - 4usize];
    ["Offset of field: InputEvent::type_"][::core::mem::offset_of!(InputEvent, type_) - 5usize];
};
unsafe extern "C" {
    #[doc = "Get human readable input key name\n # Arguments\n\n* `key` - - InputKey\n # Returns\n\nstring"]
    pub fn input_get_key_name(key: InputKey) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get human readable input type name\n # Arguments\n\n* `type` - - InputType\n # Returns\n\nstring"]
    pub fn input_get_type_name(type_: InputType) -> *const core::ffi::c_char;
}
pub const ViewOrientationHorizontal: ViewOrientation = ViewOrientation(0);
pub const ViewOrientationHorizontalFlip: ViewOrientation = ViewOrientation(1);
pub const ViewOrientationVertical: ViewOrientation = ViewOrientation(2);
pub const ViewOrientationVerticalFlip: ViewOrientation = ViewOrientation(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ViewOrientation(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct View {
    _unused: [u8; 0],
}
#[doc = "View Draw callback\n # Arguments\n\n* `canvas` - pointer to canvas\n * `model` - pointer to model\n called from GUI thread"]
pub type ViewDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, model: *mut core::ffi::c_void),
>;
#[doc = "View Input callback\n # Arguments\n\n* `event` - pointer to input event data\n * `context` - pointer to context\n # Returns\n\ntrue if event handled, false if event ignored\n called from GUI thread"]
pub type ViewInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = "View Custom callback\n # Arguments\n\n* `event` - number of custom event\n * `context` - pointer to context\n # Returns\n\ntrue if event handled, false if event ignored"]
pub type ViewCustomCallback = ::core::option::Option<
    unsafe extern "C" fn(event: u32, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = "View navigation callback\n # Arguments\n\n* `context` - pointer to context\n # Returns\n\nnext view id\n called from GUI thread"]
pub type ViewNavigationCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> u32>;
#[doc = "View callback\n # Arguments\n\n* `context` - pointer to context\n called from GUI thread"]
pub type ViewCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "View Update Callback Called upon model change, need to be propagated to GUI\n throw ViewPort update\n # Arguments\n\n* `view` - pointer to view\n * `context` - pointer to context\n called from GUI thread"]
pub type ViewUpdateCallback =
    ::core::option::Option<unsafe extern "C" fn(view: *mut View, context: *mut core::ffi::c_void)>;
#[doc = "Model is not allocated"]
pub const ViewModelTypeNone: ViewModelType = ViewModelType(0);
#[doc = "Model consist of atomic types and/or partial update is not critical for rendering.\n Lock free."]
pub const ViewModelTypeLockFree: ViewModelType = ViewModelType(1);
#[doc = "Model access is guarded with mutex.\n Locking gui thread."]
pub const ViewModelTypeLocking: ViewModelType = ViewModelType(2);
#[repr(transparent)]
#[doc = "View model types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ViewModelType(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Allocate and init View\n # Returns\n\nView instance"]
    pub fn view_alloc() -> *mut View;
}
unsafe extern "C" {
    #[doc = "Free View\n\n # Arguments\n\n* `view` - instance"]
    pub fn view_free(view: *mut View);
}
unsafe extern "C" {
    #[doc = "Tie IconAnimation with View\n\n # Arguments\n\n* `view` - View instance\n * `icon_animation` - IconAnimation instance"]
    pub fn view_tie_icon_animation(view: *mut View, icon_animation: *mut IconAnimation);
}
unsafe extern "C" {
    #[doc = "Set View Draw callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - draw callback"]
    pub fn view_set_draw_callback(view: *mut View, callback: ViewDrawCallback);
}
unsafe extern "C" {
    #[doc = "Set View Input callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - input callback"]
    pub fn view_set_input_callback(view: *mut View, callback: ViewInputCallback);
}
unsafe extern "C" {
    #[doc = "Set View Custom callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - input callback"]
    pub fn view_set_custom_callback(view: *mut View, callback: ViewCustomCallback);
}
unsafe extern "C" {
    #[doc = "Set Navigation Previous callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - input callback"]
    pub fn view_set_previous_callback(view: *mut View, callback: ViewNavigationCallback);
}
unsafe extern "C" {
    #[doc = "Set Enter callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - callback"]
    pub fn view_set_enter_callback(view: *mut View, callback: ViewCallback);
}
unsafe extern "C" {
    #[doc = "Set Exit callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - callback"]
    pub fn view_set_exit_callback(view: *mut View, callback: ViewCallback);
}
unsafe extern "C" {
    #[doc = "Set Update callback\n\n # Arguments\n\n* `view` - View instance\n * `callback` - callback"]
    pub fn view_set_update_callback(view: *mut View, callback: ViewUpdateCallback);
}
unsafe extern "C" {
    #[doc = "Set View Draw callback\n\n # Arguments\n\n* `view` - View instance\n * `context` - context for callbacks"]
    pub fn view_set_update_callback_context(view: *mut View, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set View Draw callback\n\n # Arguments\n\n* `view` - View instance\n * `context` - context for callbacks"]
    pub fn view_set_context(view: *mut View, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set View Orientation\n\n # Arguments\n\n* `view` - View instance\n * `orientation` - either vertical or horizontal"]
    pub fn view_set_orientation(view: *mut View, orientation: ViewOrientation);
}
unsafe extern "C" {
    #[doc = "Allocate view model.\n\n # Arguments\n\n* `view` - View instance\n * `type` - View Model Type\n * `size` - size"]
    pub fn view_allocate_model(view: *mut View, type_: ViewModelType, size: usize);
}
unsafe extern "C" {
    #[doc = "Free view model data memory.\n\n # Arguments\n\n* `view` - View instance"]
    pub fn view_free_model(view: *mut View);
}
unsafe extern "C" {
    #[doc = "Get view model data\n\n # Arguments\n\n* `view` - View instance\n\n # Returns\n\npointer to model data\n Don't forget to commit model changes"]
    pub fn view_get_model(view: *mut View) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Commit view model\n\n # Arguments\n\n* `view` - View instance\n * `update` - true if you want to emit view update, false otherwise"]
    pub fn view_commit_model(view: *mut View, update: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileBrowser {
    _unused: [u8; 0],
}
pub type FileBrowserCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type FileBrowserLoadItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        path: *mut FuriString,
        context: *mut core::ffi::c_void,
        icon: *mut *mut u8,
        item_name: *mut FuriString,
    ) -> bool,
>;
unsafe extern "C" {
    pub fn file_browser_alloc(result_path: *mut FuriString) -> *mut FileBrowser;
}
unsafe extern "C" {
    pub fn file_browser_free(browser: *mut FileBrowser);
}
unsafe extern "C" {
    pub fn file_browser_get_view(browser: *mut FileBrowser) -> *mut View;
}
unsafe extern "C" {
    pub fn file_browser_configure(
        browser: *mut FileBrowser,
        extension: *const core::ffi::c_char,
        base_path: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
        file_icon: *const Icon,
        hide_ext: bool,
    );
}
unsafe extern "C" {
    pub fn file_browser_start(browser: *mut FileBrowser, path: *mut FuriString);
}
unsafe extern "C" {
    pub fn file_browser_stop(browser: *mut FileBrowser);
}
unsafe extern "C" {
    pub fn file_browser_set_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn file_browser_set_item_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserLoadItemCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsApp {
    _unused: [u8; 0],
}
#[doc = "File browser dialog extra options.\n This can be default-initialized using {dialog_file_browser_set_basic_options}.\n # Arguments\n\n* `extension` - file extension to be offered for selection\n * `base_path` - root folder path for navigation with back key\n * `skip_assets` - true - do not show assets folders\n * `hide_dot_files` - true - hide dot files\n * `icon` - file icon pointer, NULL for default icon\n * `hide_ext` - true - hide extensions for files\n * `item_loader_callback` - callback function for providing custom icon & entry name\n * `hide_ext` - callback context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsFileBrowserOptions {
    pub extension: *const core::ffi::c_char,
    pub base_path: *const core::ffi::c_char,
    pub skip_assets: bool,
    pub hide_dot_files: bool,
    pub icon: *const Icon,
    pub hide_ext: bool,
    pub item_loader_callback: FileBrowserLoadItemCallback,
    pub item_loader_context: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DialogsFileBrowserOptions"]
        [::core::mem::size_of::<DialogsFileBrowserOptions>() - 28usize];
    ["Alignment of DialogsFileBrowserOptions"]
        [::core::mem::align_of::<DialogsFileBrowserOptions>() - 4usize];
    ["Offset of field: DialogsFileBrowserOptions::extension"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, extension) - 0usize];
    ["Offset of field: DialogsFileBrowserOptions::base_path"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, base_path) - 4usize];
    ["Offset of field: DialogsFileBrowserOptions::skip_assets"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, skip_assets) - 8usize];
    ["Offset of field: DialogsFileBrowserOptions::hide_dot_files"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, hide_dot_files) - 9usize];
    ["Offset of field: DialogsFileBrowserOptions::icon"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, icon) - 12usize];
    ["Offset of field: DialogsFileBrowserOptions::hide_ext"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, hide_ext) - 16usize];
    ["Offset of field: DialogsFileBrowserOptions::item_loader_callback"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, item_loader_callback) - 20usize];
    ["Offset of field: DialogsFileBrowserOptions::item_loader_context"]
        [::core::mem::offset_of!(DialogsFileBrowserOptions, item_loader_context) - 24usize];
};
unsafe extern "C" {
    #[doc = "Initialize file browser dialog options and set default values.\n This is guaranteed to initialize all fields\n so it is safe to pass pointer to uninitialized {options}\n and assume that the data behind it becomes fully initialized after the call.\n # Arguments\n\n* `options` - pointer to options structure\n * `extension` - file extension to filter\n * `icon` - file icon pointer, NULL for default icon"]
    pub fn dialog_file_browser_set_basic_options(
        options: *mut DialogsFileBrowserOptions,
        extension: *const core::ffi::c_char,
        icon: *const Icon,
    );
}
unsafe extern "C" {
    #[doc = "Shows and processes the file browser dialog\n # Arguments\n\n* `context` - api pointer\n * `result_path` - selected file path string pointer\n * `path` - preselected file path string pointer\n * `options` - file browser dialog extra options, may be null\n # Returns\n\nbool whether a file was selected"]
    pub fn dialog_file_browser_show(
        context: *mut DialogsApp,
        result_path: *mut FuriString,
        path: *mut FuriString,
        options: *const DialogsFileBrowserOptions,
    ) -> bool;
}
pub const DialogMessageButtonBack: DialogMessageButton = DialogMessageButton(0);
pub const DialogMessageButtonLeft: DialogMessageButton = DialogMessageButton(1);
pub const DialogMessageButtonCenter: DialogMessageButton = DialogMessageButton(2);
pub const DialogMessageButtonRight: DialogMessageButton = DialogMessageButton(3);
#[repr(transparent)]
#[doc = "Message result type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DialogMessageButton(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogMessage {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate and fill message\n # Returns\n\nDialogMessage*"]
    pub fn dialog_message_alloc() -> *mut DialogMessage;
}
unsafe extern "C" {
    #[doc = "Free message struct\n # Arguments\n\n* `message` - message pointer"]
    pub fn dialog_message_free(message: *mut DialogMessage);
}
unsafe extern "C" {
    #[doc = "Set message text\n # Arguments\n\n* `message` - message pointer\n * `text` - text, can be NULL if you don't want to display the text\n * `x` - x position\n * `y` - y position\n * `horizontal` - horizontal alignment\n * `vertical` - vertical alignment"]
    pub fn dialog_message_set_text(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Set message header\n # Arguments\n\n* `message` - message pointer\n * `text` - text, can be NULL if you don't want to display the header\n * `x` - x position\n * `y` - y position\n * `horizontal` - horizontal alignment\n * `vertical` - vertical alignment"]
    pub fn dialog_message_set_header(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Set message icon\n # Arguments\n\n* `message` - message pointer\n * `icon` - icon pointer, can be NULL if you don't want to display the icon\n * `x` - x position\n * `y` - y position"]
    pub fn dialog_message_set_icon(message: *mut DialogMessage, icon: *const Icon, x: u8, y: u8);
}
unsafe extern "C" {
    #[doc = "Set message buttons text, button text can be NULL if you don't want to display and process some buttons\n # Arguments\n\n* `message` - message pointer\n * `left` - left button text, can be NULL if you don't want to display the left button\n * `center` - center button text, can be NULL if you don't want to display the center button\n * `right` - right button text, can be NULL if you don't want to display the right button"]
    pub fn dialog_message_set_buttons(
        message: *mut DialogMessage,
        left: *const core::ffi::c_char,
        center: *const core::ffi::c_char,
        right: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Show message from filled struct\n # Arguments\n\n* `context` - api pointer\n * `message` - message struct pointer to be shown\n # Returns\n\nDialogMessageButton type"]
    pub fn dialog_message_show(
        context: *mut DialogsApp,
        message: *const DialogMessage,
    ) -> DialogMessageButton;
}
unsafe extern "C" {
    #[doc = "Show SD error message (with question sign)\n # Arguments\n\n* `context` -\n * `error_text` -"]
    pub fn dialog_message_show_storage_error(
        context: *mut DialogsApp,
        error_text: *const core::ffi::c_char,
    );
}
pub const DolphinAppSubGhz: DolphinApp = DolphinApp(0);
pub const DolphinAppRfid: DolphinApp = DolphinApp(1);
pub const DolphinAppNfc: DolphinApp = DolphinApp(2);
pub const DolphinAppIr: DolphinApp = DolphinApp(3);
pub const DolphinAppIbutton: DolphinApp = DolphinApp(4);
pub const DolphinAppBadusb: DolphinApp = DolphinApp(5);
pub const DolphinAppPlugin: DolphinApp = DolphinApp(6);
pub const DolphinAppMAX: DolphinApp = DolphinApp(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DolphinApp(pub core::ffi::c_uchar);
pub const DolphinDeedSubGhzReceiverInfo: DolphinDeed = DolphinDeed(0);
pub const DolphinDeedSubGhzSave: DolphinDeed = DolphinDeed(1);
pub const DolphinDeedSubGhzRawRec: DolphinDeed = DolphinDeed(2);
pub const DolphinDeedSubGhzAddManually: DolphinDeed = DolphinDeed(3);
pub const DolphinDeedSubGhzSend: DolphinDeed = DolphinDeed(4);
pub const DolphinDeedSubGhzFrequencyAnalyzer: DolphinDeed = DolphinDeed(5);
pub const DolphinDeedRfidRead: DolphinDeed = DolphinDeed(6);
pub const DolphinDeedRfidReadSuccess: DolphinDeed = DolphinDeed(7);
pub const DolphinDeedRfidSave: DolphinDeed = DolphinDeed(8);
pub const DolphinDeedRfidEmulate: DolphinDeed = DolphinDeed(9);
pub const DolphinDeedRfidAdd: DolphinDeed = DolphinDeed(10);
pub const DolphinDeedNfcRead: DolphinDeed = DolphinDeed(11);
pub const DolphinDeedNfcReadSuccess: DolphinDeed = DolphinDeed(12);
pub const DolphinDeedNfcSave: DolphinDeed = DolphinDeed(13);
pub const DolphinDeedNfcDetectReader: DolphinDeed = DolphinDeed(14);
pub const DolphinDeedNfcEmulate: DolphinDeed = DolphinDeed(15);
pub const DolphinDeedNfcMfcAdd: DolphinDeed = DolphinDeed(16);
pub const DolphinDeedNfcAddSave: DolphinDeed = DolphinDeed(17);
pub const DolphinDeedNfcAddEmulate: DolphinDeed = DolphinDeed(18);
pub const DolphinDeedIrSend: DolphinDeed = DolphinDeed(19);
pub const DolphinDeedIrLearnSuccess: DolphinDeed = DolphinDeed(20);
pub const DolphinDeedIrSave: DolphinDeed = DolphinDeed(21);
pub const DolphinDeedIbuttonRead: DolphinDeed = DolphinDeed(22);
pub const DolphinDeedIbuttonReadSuccess: DolphinDeed = DolphinDeed(23);
pub const DolphinDeedIbuttonSave: DolphinDeed = DolphinDeed(24);
pub const DolphinDeedIbuttonEmulate: DolphinDeed = DolphinDeed(25);
pub const DolphinDeedIbuttonAdd: DolphinDeed = DolphinDeed(26);
pub const DolphinDeedBadUsbPlayScript: DolphinDeed = DolphinDeed(27);
pub const DolphinDeedU2fAuthorized: DolphinDeed = DolphinDeed(28);
pub const DolphinDeedGpioUartBridge: DolphinDeed = DolphinDeed(29);
pub const DolphinDeedPluginStart: DolphinDeed = DolphinDeed(30);
pub const DolphinDeedPluginGameStart: DolphinDeed = DolphinDeed(31);
pub const DolphinDeedPluginGameWin: DolphinDeed = DolphinDeed(32);
pub const DolphinDeedMAX: DolphinDeed = DolphinDeed(33);
pub const DolphinDeedTestLeft: DolphinDeed = DolphinDeed(34);
pub const DolphinDeedTestRight: DolphinDeed = DolphinDeed(35);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DolphinDeed(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinDeedWeight {
    pub icounter: u8,
    pub app: DolphinApp,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DolphinDeedWeight"][::core::mem::size_of::<DolphinDeedWeight>() - 2usize];
    ["Alignment of DolphinDeedWeight"][::core::mem::align_of::<DolphinDeedWeight>() - 1usize];
    ["Offset of field: DolphinDeedWeight::icounter"]
        [::core::mem::offset_of!(DolphinDeedWeight, icounter) - 0usize];
    ["Offset of field: DolphinDeedWeight::app"]
        [::core::mem::offset_of!(DolphinDeedWeight, app) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinDeedLimits {
    pub app: DolphinApp,
    pub icounter_limit: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DolphinDeedLimits"][::core::mem::size_of::<DolphinDeedLimits>() - 2usize];
    ["Alignment of DolphinDeedLimits"][::core::mem::align_of::<DolphinDeedLimits>() - 1usize];
    ["Offset of field: DolphinDeedLimits::app"]
        [::core::mem::offset_of!(DolphinDeedLimits, app) - 0usize];
    ["Offset of field: DolphinDeedLimits::icounter_limit"]
        [::core::mem::offset_of!(DolphinDeedLimits, icounter_limit) - 1usize];
};
unsafe extern "C" {
    pub fn dolphin_deed_get_app(deed: DolphinDeed) -> DolphinApp;
}
unsafe extern "C" {
    pub fn dolphin_deed_get_app_limit(app: DolphinApp) -> u8;
}
unsafe extern "C" {
    pub fn dolphin_deed_get_weight(deed: DolphinDeed) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dolphin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinStats {
    pub icounter: u32,
    pub butthurt: u32,
    pub timestamp: u64,
    pub level: u8,
    pub level_up_is_pending: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DolphinStats"][::core::mem::size_of::<DolphinStats>() - 24usize];
    ["Alignment of DolphinStats"][::core::mem::align_of::<DolphinStats>() - 8usize];
    ["Offset of field: DolphinStats::icounter"]
        [::core::mem::offset_of!(DolphinStats, icounter) - 0usize];
    ["Offset of field: DolphinStats::butthurt"]
        [::core::mem::offset_of!(DolphinStats, butthurt) - 4usize];
    ["Offset of field: DolphinStats::timestamp"]
        [::core::mem::offset_of!(DolphinStats, timestamp) - 8usize];
    ["Offset of field: DolphinStats::level"]
        [::core::mem::offset_of!(DolphinStats, level) - 16usize];
    ["Offset of field: DolphinStats::level_up_is_pending"]
        [::core::mem::offset_of!(DolphinStats, level_up_is_pending) - 17usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinSettings {
    pub happy_mode: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DolphinSettings"][::core::mem::size_of::<DolphinSettings>() - 1usize];
    ["Alignment of DolphinSettings"][::core::mem::align_of::<DolphinSettings>() - 1usize];
    ["Offset of field: DolphinSettings::happy_mode"]
        [::core::mem::offset_of!(DolphinSettings, happy_mode) - 0usize];
};
pub const DolphinPubsubEventUpdate: DolphinPubsubEvent = DolphinPubsubEvent(0);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DolphinPubsubEvent(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Deed complete notification. Call it on deed completion.\n See dolphin_deed.h for available deeds. In futures it will become part of assets.\n Thread safe, async"]
    pub fn dolphin_deed(deed: DolphinDeed);
}
unsafe extern "C" {
    pub fn dolphin_get_settings(dolphin: *mut Dolphin, settings: *mut DolphinSettings);
}
unsafe extern "C" {
    pub fn dolphin_set_settings(dolphin: *mut Dolphin, settings: *mut DolphinSettings);
}
unsafe extern "C" {
    #[doc = "Retrieve dolphin stats\n Thread safe, blocking"]
    pub fn dolphin_stats(dolphin: *mut Dolphin) -> DolphinStats;
}
unsafe extern "C" {
    #[doc = "Flush dolphin queue and save state\n Thread safe, blocking"]
    pub fn dolphin_flush(dolphin: *mut Dolphin);
}
unsafe extern "C" {
    pub fn dolphin_upgrade_level(dolphin: *mut Dolphin);
}
unsafe extern "C" {
    pub fn dolphin_get_pubsub(dolphin: *mut Dolphin) -> *mut FuriPubSub;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Expansion {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Enable support for expansion modules.\n\n Calling this function will load user settings and enable\n expansion module support on the serial port specified in said settings.\n\n If expansion module support was disabled in settings, this function\n does nothing.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the Expansion instance."]
    pub fn expansion_enable(instance: *mut Expansion);
}
unsafe extern "C" {
    #[doc = "Disable support for expansion modules.\n\n Calling this function will cease all communications with the\n expansion module (if any), release the serial handle and\n reset the respective pins to the default state.\n\n > **Note:** Applications requiring serial port access MUST call\n this function BEFORE calling furi_hal_serial_control_acquire().\n Similarly, an expansion_enable() call MUST be made right AFTER\n a call to furi_hal_serial_control_release() to ensure that\n the user settings are properly restored.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the Expansion instance."]
    pub fn expansion_disable(instance: *mut Expansion);
}
unsafe extern "C" {
    #[doc = "Enable support for expansion modules on designated serial port.\n\n Only one serial port can be used to communicate with an expansion\n module at a time.\n\n Calling this function when expansion module support is already enabled\n will first disable the previous setting, then enable the current one.\n\n This function does not respect user settings for expansion modules,\n so calling it might leave the system in inconsistent state. Avoid using it\n unless absolutely necessary.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the Expansion instance.\n * `serial_id` (direction in) - numerical identifier of the serial."]
    pub fn expansion_set_listen_serial(instance: *mut Expansion, serial_id: FuriHalSerialId);
}
unsafe extern "C" {
    #[doc = "Draw progress bar.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - progress bar position on X axis\n * `y` - progress bar position on Y axis\n * `width` - progress bar width\n * `progress` - progress (0.0 - 1.0)"]
    pub fn elements_progress_bar(canvas: *mut Canvas, x: i32, y: i32, width: usize, progress: f32);
}
unsafe extern "C" {
    #[doc = "Draw progress bar with text.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - progress bar position on X axis\n * `y` - progress bar position on Y axis\n * `width` - progress bar width\n * `progress` - progress (0.0 - 1.0)\n * `text` - text to draw"]
    pub fn elements_progress_bar_with_text(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        progress: f32,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Draw scrollbar on canvas at specific position.\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - scrollbar position on X axis\n * `y` - scrollbar position on Y axis\n * `height` - scrollbar height\n * `pos` - current element\n * `total` - total elements"]
    pub fn elements_scrollbar_pos(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        height: usize,
        pos: usize,
        total: usize,
    );
}
unsafe extern "C" {
    #[doc = "Draw scrollbar on canvas.\n > **Note:** width 3px, height equal to canvas height\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `pos` - current element of total elements\n * `total` - total elements"]
    pub fn elements_scrollbar(canvas: *mut Canvas, pos: usize, total: usize);
}
unsafe extern "C" {
    #[doc = "Draw rounded frame\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x,` - y top left corner coordinates\n * `width,` - height frame width and height"]
    pub fn elements_frame(canvas: *mut Canvas, x: i32, y: i32, width: usize, height: usize);
}
unsafe extern "C" {
    #[doc = "Draw button in left corner\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `str` - button text"]
    pub fn elements_button_left(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Draw button in right corner\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `str` - button text"]
    pub fn elements_button_right(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "This function draws a button in the top left corner of the canvas with icon and string.\n\n The design and layout of the button is defined within this function.\n\n # Arguments\n\n* `canvas` (direction in) - This is a pointer to the `Canvas` structure where the button will be drawn.\n * `str` (direction in) - This is a pointer to the character string that will be drawn within the button.\n"]
    pub fn elements_button_up(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "This function draws a button in the top right corner of the canvas with icon and string.\n\n The design and layout of the button is defined within this function.\n\n # Arguments\n\n* `canvas` (direction in) - This is a pointer to the `Canvas` structure where the button will be drawn.\n * `str` (direction in) - This is a pointer to the character string that will be drawn within the button.\n"]
    pub fn elements_button_down(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Draw button in center\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `str` - button text"]
    pub fn elements_button_center(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Draw aligned multiline text\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x,` - y coordinates based on align param\n * `horizontal,` - vertical alignment of multiline text\n * `text` - string (possible multiline)"]
    pub fn elements_multiline_text_aligned(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Draw multiline text\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - top left corner coordinates\n * `y` - top left corner coordinates\n * `text` - string (possible multiline)"]
    pub fn elements_multiline_text(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Draw framed multiline text\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - top left corner coordinates\n * `y` - top left corner coordinates\n * `text` - string (possible multiline)"]
    pub fn elements_multiline_text_framed(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Draw slightly rounded frame\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - top left corner coordinates\n * `y` - top left corner coordinates\n * `width` - width of frame\n * `height` - height of frame"]
    pub fn elements_slightly_rounded_frame(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
    );
}
unsafe extern "C" {
    #[doc = "Draw slightly rounded box\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - top left corner coordinates\n * `y` - top left corner coordinates\n * `width` - height of box\n * `height` - height of box"]
    pub fn elements_slightly_rounded_box(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
    );
}
unsafe extern "C" {
    #[doc = "Draw bold rounded frame\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - top left corner coordinates\n * `y` - top left corner coordinates\n * `width` - width of frame\n * `height` - height of frame"]
    pub fn elements_bold_rounded_frame(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
    );
}
unsafe extern "C" {
    #[doc = "Draw bubble frame for text\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - left x coordinates\n * `y` - top y coordinate\n * `width` - bubble width\n * `height` - bubble height"]
    pub fn elements_bubble(canvas: *mut Canvas, x: i32, y: i32, width: usize, height: usize);
}
unsafe extern "C" {
    #[doc = "Draw bubble frame for text with corner\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - left x coordinates\n * `y` - top y coordinate\n * `text` - text to display\n * `horizontal` - horizontal aligning\n * `vertical` - aligning"]
    pub fn elements_bubble_str(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        text: *const core::ffi::c_char,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Trim string buffer to fit width in pixels\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `string` - string to trim\n * `width` - max width"]
    pub fn elements_string_fit_width(canvas: *mut Canvas, string: *mut FuriString, width: usize);
}
unsafe extern "C" {
    #[doc = "Draw scrollable text line\n\n # Arguments\n\n* `canvas` - The canvas\n * `x` (direction in) - X coordinate\n * `y` (direction in) - Y coordinate\n * `width` (direction in) - The width\n * `string` - The string\n * `scroll` (direction in) - The scroll counter: 0 - no scroll, any other number - scroll. Just count up, everything else will be calculated on the inside.\n * `ellipsis` (direction in) - The ellipsis flag: true to add ellipse"]
    pub fn elements_scrollable_text_line(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        string: *mut FuriString,
        scroll: usize,
        ellipsis: bool,
    );
}
unsafe extern "C" {
    #[doc = "Draw text box element\n\n # Arguments\n\n* `canvas` - Canvas instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - width to fit text\n * `height` - height to fit text\n * `horizontal` - Align instance\n * `vertical` - Align instance\n * `text` (direction in) - Formatted text. The following formats are available:\n \"text- bold font is used\n \"text- monospaced font is used\n \"text- white text on black background\n * `strip_to_dots` - Strip text to ... if does not fit to width"]
    pub fn elements_text_box(
        canvas: *mut Canvas,
        x: i32,
        y: i32,
        width: usize,
        height: usize,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewPort {
    _unused: [u8; 0],
}
pub const ViewPortOrientationHorizontal: ViewPortOrientation = ViewPortOrientation(0);
pub const ViewPortOrientationHorizontalFlip: ViewPortOrientation = ViewPortOrientation(1);
pub const ViewPortOrientationVertical: ViewPortOrientation = ViewPortOrientation(2);
pub const ViewPortOrientationVerticalFlip: ViewPortOrientation = ViewPortOrientation(3);
#[doc = "< Special value, don't use it"]
pub const ViewPortOrientationMAX: ViewPortOrientation = ViewPortOrientation(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ViewPortOrientation(pub core::ffi::c_uchar);
#[doc = "ViewPort Draw callback\n called from GUI thread"]
pub type ViewPortDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, context: *mut core::ffi::c_void),
>;
#[doc = "ViewPort Input callback\n called from GUI thread"]
pub type ViewPortInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "ViewPort allocator\n\n always returns view_port or stops system if not enough memory.\n\n # Returns\n\nViewPort instance"]
    pub fn view_port_alloc() -> *mut ViewPort;
}
unsafe extern "C" {
    #[doc = "ViewPort deallocator\n\n Ensure that view_port was unregistered in GUI system before use.\n\n # Arguments\n\n* `view_port` - ViewPort instance"]
    pub fn view_port_free(view_port: *mut ViewPort);
}
unsafe extern "C" {
    #[doc = "Set view_port width.\n\n Will be used to limit canvas drawing area and autolayout feature.\n\n # Arguments\n\n* `view_port` - ViewPort instance\n * `width` - wanted width, 0 - auto."]
    pub fn view_port_set_width(view_port: *mut ViewPort, width: u8);
}
unsafe extern "C" {
    pub fn view_port_get_width(view_port: *const ViewPort) -> u8;
}
unsafe extern "C" {
    #[doc = "Set view_port height.\n\n Will be used to limit canvas drawing area and autolayout feature.\n\n # Arguments\n\n* `view_port` - ViewPort instance\n * `height` - wanted height, 0 - auto."]
    pub fn view_port_set_height(view_port: *mut ViewPort, height: u8);
}
unsafe extern "C" {
    pub fn view_port_get_height(view_port: *const ViewPort) -> u8;
}
unsafe extern "C" {
    #[doc = "Enable or disable view_port rendering.\n\n # Arguments\n\n* `view_port` - ViewPort instance\n * `enabled` - Indicates if enabled\n automatically dispatches update event"]
    pub fn view_port_enabled_set(view_port: *mut ViewPort, enabled: bool);
}
unsafe extern "C" {
    pub fn view_port_is_enabled(view_port: *const ViewPort) -> bool;
}
unsafe extern "C" {
    #[doc = "ViewPort event callbacks\n\n # Arguments\n\n* `view_port` - ViewPort instance\n * `callback` - appropriate callback function\n * `context` - context to pass to callback"]
    pub fn view_port_draw_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortDrawCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn view_port_input_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortInputCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Emit update signal to GUI system.\n\n Rendering will happen later after GUI system process signal.\n\n # Arguments\n\n* `view_port` - ViewPort instance"]
    pub fn view_port_update(view_port: *mut ViewPort);
}
unsafe extern "C" {
    #[doc = "Set ViewPort orientation.\n\n # Arguments\n\n* `view_port` - ViewPort instance\n * `orientation` - display orientation, horizontal or vertical."]
    pub fn view_port_set_orientation(view_port: *mut ViewPort, orientation: ViewPortOrientation);
}
unsafe extern "C" {
    pub fn view_port_get_orientation(view_port: *const ViewPort) -> ViewPortOrientation;
}
#[doc = "< Desktop layer for internal use. Like fullscreen but with status bar"]
pub const GuiLayerDesktop: GuiLayer = GuiLayer(0);
#[doc = "< Window layer, status bar is shown"]
pub const GuiLayerWindow: GuiLayer = GuiLayer(1);
#[doc = "< Status bar left-side layer, auto-layout"]
pub const GuiLayerStatusBarLeft: GuiLayer = GuiLayer(2);
#[doc = "< Status bar right-side layer, auto-layout"]
pub const GuiLayerStatusBarRight: GuiLayer = GuiLayer(3);
#[doc = "< Fullscreen layer, no status bar"]
pub const GuiLayerFullscreen: GuiLayer = GuiLayer(4);
#[doc = "< Don't use or move, special value"]
pub const GuiLayerMAX: GuiLayer = GuiLayer(5);
#[repr(transparent)]
#[doc = "Gui layers"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GuiLayer(pub core::ffi::c_uchar);
#[doc = "Gui Canvas Commit Callback"]
pub type GuiCanvasCommitCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut u8,
        size: usize,
        orientation: CanvasOrientation,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gui {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Add view_port to view_port tree\n\n > thread safe\n\n # Arguments\n\n* `gui` - Gui instance\n * `view_port` - ViewPort instance\n * `layer` (direction in) - GuiLayer where to place view_port"]
    pub fn gui_add_view_port(gui: *mut Gui, view_port: *mut ViewPort, layer: GuiLayer);
}
unsafe extern "C" {
    #[doc = "Remove view_port from rendering tree\n\n > thread safe\n\n # Arguments\n\n* `gui` - Gui instance\n * `view_port` - ViewPort instance"]
    pub fn gui_remove_view_port(gui: *mut Gui, view_port: *mut ViewPort);
}
unsafe extern "C" {
    #[doc = "Send ViewPort to the front\n\n Places selected ViewPort to the top of the drawing stack\n\n # Arguments\n\n* `gui` - Gui instance\n * `view_port` - ViewPort instance"]
    pub fn gui_view_port_send_to_front(gui: *mut Gui, view_port: *mut ViewPort);
}
unsafe extern "C" {
    #[doc = "Add gui canvas commit callback\n\n This callback will be called upon Canvas commit Callback dispatched from GUI\n thread and is time critical\n\n # Arguments\n\n* `gui` - Gui instance\n * `callback` - GuiCanvasCommitCallback\n * `context` - GuiCanvasCommitCallback context"]
    pub fn gui_add_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Remove gui canvas commit callback\n\n # Arguments\n\n* `gui` - Gui instance\n * `callback` - GuiCanvasCommitCallback\n * `context` - GuiCanvasCommitCallback context"]
    pub fn gui_remove_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get gui canvas frame buffer size\n *\n # Arguments\n\n* `gui` - Gui instance\n # Returns\n\nsize_t size of frame buffer in bytes"]
    pub fn gui_get_framebuffer_size(gui: *const Gui) -> usize;
}
unsafe extern "C" {
    #[doc = "Set lockdown mode\n\n When lockdown mode is enabled, only GuiLayerDesktop is shown.\n This feature prevents services from showing sensitive information when flipper is locked.\n\n # Arguments\n\n* `gui` - Gui instance\n * `lockdown` - bool, true if enabled"]
    pub fn gui_set_lockdown(gui: *mut Gui, lockdown: bool);
}
unsafe extern "C" {
    #[doc = "Acquire Direct Draw lock and get Canvas instance\n\n This method return Canvas instance for use in monopoly mode. Direct draw lock\n disables input and draw call dispatch functions in GUI service. No other\n applications or services will be able to draw until gui_direct_draw_release\n call.\n\n # Arguments\n\n* `gui` - The graphical user interface\n\n # Returns\n\nCanvas instance"]
    pub fn gui_direct_draw_acquire(gui: *mut Gui) -> *mut Canvas;
}
unsafe extern "C" {
    #[doc = "Release Direct Draw Lock\n\n Release Direct Draw Lock, enables Input and Draw call processing. Canvas\n acquired in gui_direct_draw_acquire will become invalid after this call.\n\n # Arguments\n\n* `gui` - Gui instance"]
    pub fn gui_direct_draw_release(gui: *mut Gui);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Icon {
    pub width: u16,
    pub height: u16,
    pub frame_count: u8,
    pub frame_rate: u8,
    pub frames: *const *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Icon"][::core::mem::size_of::<Icon>() - 12usize];
    ["Alignment of Icon"][::core::mem::align_of::<Icon>() - 4usize];
    ["Offset of field: Icon::width"][::core::mem::offset_of!(Icon, width) - 0usize];
    ["Offset of field: Icon::height"][::core::mem::offset_of!(Icon, height) - 2usize];
    ["Offset of field: Icon::frame_count"][::core::mem::offset_of!(Icon, frame_count) - 4usize];
    ["Offset of field: Icon::frame_rate"][::core::mem::offset_of!(Icon, frame_rate) - 5usize];
    ["Offset of field: Icon::frames"][::core::mem::offset_of!(Icon, frames) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenuItem {
    _unused: [u8; 0],
}
#[doc = "Callback for any button menu actions"]
pub type ButtonMenuItemCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, index: i32, type_: InputType),
>;
pub const ButtonMenuItemTypeCommon: ButtonMenuItemType = ButtonMenuItemType(0);
pub const ButtonMenuItemTypeControl: ButtonMenuItemType = ButtonMenuItemType(1);
#[repr(transparent)]
#[doc = "Type of button. Difference in drawing buttons."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ButtonMenuItemType(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Get button menu view\n\n # Arguments\n\n* `button_menu` - ButtonMenu instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn button_menu_get_view(button_menu: *mut ButtonMenu) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Clean button menu\n\n # Arguments\n\n* `button_menu` - ButtonMenu instance"]
    pub fn button_menu_reset(button_menu: *mut ButtonMenu);
}
unsafe extern "C" {
    #[doc = "Add item to button menu instance\n\n # Arguments\n\n* `button_menu` - ButtonMenu instance\n * `label` - text inside new button\n * `index` - value to distinct between buttons inside\n ButtonMenuItemCallback\n * `callback` - The callback\n * `type` - type of button to create. Differ by button\n drawing. Control buttons have no frames, and\n have more squared borders.\n * `callback_context` - The callback context\n\n # Returns\n\npointer to just-created item"]
    pub fn button_menu_add_item(
        button_menu: *mut ButtonMenu,
        label: *const core::ffi::c_char,
        index: i32,
        callback: ButtonMenuItemCallback,
        type_: ButtonMenuItemType,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut ButtonMenuItem;
}
unsafe extern "C" {
    #[doc = "Allocate and initialize new instance of ButtonMenu model\n\n # Returns\n\njust-created ButtonMenu model"]
    pub fn button_menu_alloc() -> *mut ButtonMenu;
}
unsafe extern "C" {
    #[doc = "Free ButtonMenu element\n\n # Arguments\n\n* `button_menu` - ButtonMenu instance"]
    pub fn button_menu_free(button_menu: *mut ButtonMenu);
}
unsafe extern "C" {
    #[doc = "Set ButtonMenu header on top of canvas\n\n # Arguments\n\n* `button_menu` - ButtonMenu instance\n * `header` - header on the top of button menu"]
    pub fn button_menu_set_header(button_menu: *mut ButtonMenu, header: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set selected item\n\n # Arguments\n\n* `button_menu` - ButtonMenu instance\n * `index` - index of ButtonMenu to be selected"]
    pub fn button_menu_set_selected_item(button_menu: *mut ButtonMenu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonPanel {
    _unused: [u8; 0],
}
#[doc = "Callback type to call for handling selecting button_panel items"]
pub type ButtonItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
unsafe extern "C" {
    #[doc = "Allocate new button_panel module.\n\n # Returns\n\nButtonPanel instance"]
    pub fn button_panel_alloc() -> *mut ButtonPanel;
}
unsafe extern "C" {
    #[doc = "Free button_panel module.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance"]
    pub fn button_panel_free(button_panel: *mut ButtonPanel);
}
unsafe extern "C" {
    #[doc = "Free items from button_panel module. Preallocated matrix stays unchanged.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance"]
    pub fn button_panel_reset(button_panel: *mut ButtonPanel);
}
unsafe extern "C" {
    #[doc = "Reserve space for adding items.\n\n One does not simply use button_panel_add_item() without this function. It\n should be allocated space for it first.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance\n * `reserve_x` - number of columns in button_panel\n * `reserve_y` - number of rows in button_panel"]
    pub fn button_panel_reserve(button_panel: *mut ButtonPanel, reserve_x: usize, reserve_y: usize);
}
unsafe extern "C" {
    #[doc = "Add item to button_panel module.\n\n Have to set element in bounds of allocated size by X and by Y.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance\n * `index` - value to pass to callback\n * `matrix_place_x` - coordinates by x-axis on virtual grid, it\n is only used for navigation\n * `matrix_place_y` - coordinates by y-axis on virtual grid, it\n is only used for naviagation\n * `x` - x-coordinate to draw icon on\n * `y` - y-coordinate to draw icon on\n * `icon_name` - name of the icon to draw\n * `icon_name_selected` - name of the icon to draw when current\n element is selected\n * `callback` - function to call when specific element is\n selected (pressed Ok on selected item)\n * `callback_context` - context to pass to callback"]
    pub fn button_panel_add_item(
        button_panel: *mut ButtonPanel,
        index: u32,
        matrix_place_x: u16,
        matrix_place_y: u16,
        x: u16,
        y: u16,
        icon_name: *const Icon,
        icon_name_selected: *const Icon,
        callback: ButtonItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get button_panel view.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance\n\n # Returns\n\nacquired view"]
    pub fn button_panel_get_view(button_panel: *mut ButtonPanel) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Add label to button_panel module.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance\n * `x` - x-coordinate to place label\n * `y` - y-coordinate to place label\n * `font` - font to write label with\n * `label_str` - string label to write"]
    pub fn button_panel_add_label(
        button_panel: *mut ButtonPanel,
        x: u16,
        y: u16,
        font: Font,
        label_str: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Add a non-button icon to button_panel module.\n\n # Arguments\n\n* `button_panel` - ButtonPanel instance\n * `x` - x-coordinate to place icon\n * `y` - y-coordinate to place icon\n * `icon_name` - name of the icon to draw"]
    pub fn button_panel_add_icon(
        button_panel: *mut ButtonPanel,
        x: u16,
        y: u16,
        icon_name: *const Icon,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteInput {
    _unused: [u8; 0],
}
#[doc = "callback that is executed on save button press"]
pub type ByteInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "callback that is executed when byte buffer is changed"]
pub type ByteChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Allocate and initialize byte input. This byte input is used to enter bytes.\n\n # Returns\n\nByteInput instance pointer"]
    pub fn byte_input_alloc() -> *mut ByteInput;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free byte input\n\n # Arguments\n\n* `byte_input` - Byte input instance"]
    pub fn byte_input_free(byte_input: *mut ByteInput);
}
unsafe extern "C" {
    #[doc = "Get byte input view\n\n # Arguments\n\n* `byte_input` - byte input instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn byte_input_get_view(byte_input: *mut ByteInput) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Set byte input result callback\n\n # Arguments\n\n* `byte_input` - byte input instance\n * `input_callback` - input callback fn\n * `changed_callback` - changed callback fn\n * `callback_context` - callback context\n * `bytes` - buffer to use\n * `bytes_count` - buffer length"]
    pub fn byte_input_set_result_callback(
        byte_input: *mut ByteInput,
        input_callback: ByteInputCallback,
        changed_callback: ByteChangedCallback,
        callback_context: *mut core::ffi::c_void,
        bytes: *mut u8,
        bytes_count: u8,
    );
}
unsafe extern "C" {
    #[doc = "Set byte input header text\n\n # Arguments\n\n* `byte_input` - byte input instance\n * `text` - text to be shown"]
    pub fn byte_input_set_header_text(byte_input: *mut ByteInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogEx {
    _unused: [u8; 0],
}
pub const DialogExResultLeft: DialogExResult = DialogExResult(0);
pub const DialogExResultCenter: DialogExResult = DialogExResult(1);
pub const DialogExResultRight: DialogExResult = DialogExResult(2);
pub const DialogExPressLeft: DialogExResult = DialogExResult(3);
pub const DialogExPressCenter: DialogExResult = DialogExResult(4);
pub const DialogExPressRight: DialogExResult = DialogExResult(5);
pub const DialogExReleaseLeft: DialogExResult = DialogExResult(6);
pub const DialogExReleaseCenter: DialogExResult = DialogExResult(7);
pub const DialogExReleaseRight: DialogExResult = DialogExResult(8);
#[repr(transparent)]
#[doc = "DialogEx result"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DialogExResult(pub core::ffi::c_uchar);
#[doc = "DialogEx result callback type\n comes from GUI thread"]
pub type DialogExResultCallback = ::core::option::Option<
    unsafe extern "C" fn(result: DialogExResult, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Allocate and initialize dialog\n\n This dialog used to ask simple questions\n\n # Returns\n\nDialogEx instance"]
    pub fn dialog_ex_alloc() -> *mut DialogEx;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free dialog\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance"]
    pub fn dialog_ex_free(dialog_ex: *mut DialogEx);
}
unsafe extern "C" {
    #[doc = "Get dialog view\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn dialog_ex_get_view(dialog_ex: *mut DialogEx) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Set dialog result callback\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `callback` - result callback function"]
    pub fn dialog_ex_set_result_callback(
        dialog_ex: *mut DialogEx,
        callback: DialogExResultCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set dialog context\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `context` - context pointer, will be passed to result callback"]
    pub fn dialog_ex_set_context(dialog_ex: *mut DialogEx, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set dialog header text\n\n If text is null, dialog header will not be rendered\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `text` - text to be shown, can be multiline\n * `x` - x position\n * `y` - y position\n * `horizontal` - horizontal text alignment\n * `vertical` - vertical text alignment"]
    pub fn dialog_ex_set_header(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Set dialog text\n\n If text is null, dialog text will not be rendered\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `text` - text to be shown, can be multiline\n * `x` - x position\n * `y` - y position\n * `horizontal` - horizontal text alignment\n * `vertical` - vertical text alignment"]
    pub fn dialog_ex_set_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Set dialog icon\n\n If x or y is negative, dialog icon will not be rendered\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `x` - x position\n * `y` - y position\n * `icon` - The icon"]
    pub fn dialog_ex_set_icon(dialog_ex: *mut DialogEx, x: u8, y: u8, icon: *const Icon);
}
unsafe extern "C" {
    #[doc = "Set left button text\n\n If text is null, left button will not be rendered and processed\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `text` - text to be shown"]
    pub fn dialog_ex_set_left_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set center button text\n\n If text is null, center button will not be rendered and processed\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `text` - text to be shown"]
    pub fn dialog_ex_set_center_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Set right button text\n\n If text is null, right button will not be rendered and processed\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance\n * `text` - text to be shown"]
    pub fn dialog_ex_set_right_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Clean dialog\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance"]
    pub fn dialog_ex_reset(dialog_ex: *mut DialogEx);
}
unsafe extern "C" {
    #[doc = "Enable press/release events\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance"]
    pub fn dialog_ex_enable_extended_events(dialog_ex: *mut DialogEx);
}
unsafe extern "C" {
    #[doc = "Disable press/release events\n\n # Arguments\n\n* `dialog_ex` - DialogEx instance"]
    pub fn dialog_ex_disable_extended_events(dialog_ex: *mut DialogEx);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmptyScreen {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate and initialize empty screen\n\n This empty screen used to ask simple questions like Yes/\n\n # Returns\n\nEmptyScreen instance"]
    pub fn empty_screen_alloc() -> *mut EmptyScreen;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free empty screen\n\n # Arguments\n\n* `empty_screen` - Empty screen instance"]
    pub fn empty_screen_free(empty_screen: *mut EmptyScreen);
}
unsafe extern "C" {
    #[doc = "Get empty screen view\n\n # Arguments\n\n* `empty_screen` - Empty screen instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn empty_screen_get_view(empty_screen: *mut EmptyScreen) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrowserWorker {
    _unused: [u8; 0],
}
pub type BrowserWorkerFolderOpenCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_cnt: u32,
        file_idx: i32,
        is_root: bool,
    ),
>;
pub type BrowserWorkerListLoadCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, list_load_offset: u32),
>;
pub type BrowserWorkerListItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_path: *mut FuriString,
        is_folder: bool,
        is_last: bool,
    ),
>;
pub type BrowserWorkerLongLoadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    pub fn file_browser_worker_alloc(
        path: *mut FuriString,
        base_path: *const core::ffi::c_char,
        ext_filter: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
    ) -> *mut BrowserWorker;
}
unsafe extern "C" {
    pub fn file_browser_worker_free(browser: *mut BrowserWorker);
}
unsafe extern "C" {
    pub fn file_browser_worker_set_callback_context(
        browser: *mut BrowserWorker,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_set_folder_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerFolderOpenCallback,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_set_list_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListLoadCallback,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_set_item_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListItemCallback,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_set_long_load_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerLongLoadCallback,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_set_config(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        ext_filter: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_folder_enter(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        item_idx: i32,
    );
}
unsafe extern "C" {
    pub fn file_browser_worker_is_in_start_folder(browser: *mut BrowserWorker) -> bool;
}
unsafe extern "C" {
    pub fn file_browser_worker_folder_exit(browser: *mut BrowserWorker);
}
unsafe extern "C" {
    pub fn file_browser_worker_folder_refresh(browser: *mut BrowserWorker, item_idx: i32);
}
unsafe extern "C" {
    pub fn file_browser_worker_load(browser: *mut BrowserWorker, offset: u32, count: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loading {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate and initialize\n\n This View used to show system is doing some processing\n\n # Returns\n\nLoading View instance"]
    pub fn loading_alloc() -> *mut Loading;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free Loading View\n\n # Arguments\n\n* `instance` - Loading instance"]
    pub fn loading_free(instance: *mut Loading);
}
unsafe extern "C" {
    #[doc = "Get Loading view\n\n # Arguments\n\n* `instance` - Loading instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn loading_get_view(instance: *mut Loading) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Menu {
    _unused: [u8; 0],
}
#[doc = "Menu Item Callback"]
pub type MenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
unsafe extern "C" {
    #[doc = "Menu allocation and initialization\n\n # Returns\n\nMenu instance"]
    pub fn menu_alloc() -> *mut Menu;
}
unsafe extern "C" {
    #[doc = "Free menu\n\n # Arguments\n\n* `menu` - Menu instance"]
    pub fn menu_free(menu: *mut Menu);
}
unsafe extern "C" {
    #[doc = "Get Menu view\n\n # Arguments\n\n* `menu` - Menu instance\n\n # Returns\n\nView instance"]
    pub fn menu_get_view(menu: *mut Menu) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Add item to menu\n\n # Arguments\n\n* `menu` - Menu instance\n * `label` - menu item string label\n * `icon` - IconAnimation instance\n * `index` - menu item index\n * `callback` - MenuItemCallback instance\n * `context` - pointer to context"]
    pub fn menu_add_item(
        menu: *mut Menu,
        label: *const core::ffi::c_char,
        icon: *const Icon,
        index: u32,
        callback: MenuItemCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Clean menu\n > **Note:** this function does not free menu instance\n\n # Arguments\n\n* `menu` - Menu instance"]
    pub fn menu_reset(menu: *mut Menu);
}
unsafe extern "C" {
    #[doc = "Set current menu item\n\n # Arguments\n\n* `menu` - Menu instance\n * `index` - The index"]
    pub fn menu_set_selected_item(menu: *mut Menu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumberInput {
    _unused: [u8; 0],
}
#[doc = "Callback to be called on save button press"]
pub type NumberInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, number: i32)>;
unsafe extern "C" {
    #[doc = "Allocate and initialize Number input.\n\n This Number input is used to enter Numbers (Integers).\n\n # Returns\n\nNumberInput instance pointer"]
    pub fn number_input_alloc() -> *mut NumberInput;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free byte input\n\n # Arguments\n\n* `number_input` - Number input instance"]
    pub fn number_input_free(number_input: *mut NumberInput);
}
unsafe extern "C" {
    #[doc = "Get byte input view\n\n # Arguments\n\n* `number_input` - byte input instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn number_input_get_view(number_input: *mut NumberInput) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Set byte input result callback\n\n # Arguments\n\n* `number_input` - byte input instance\n * `input_callback` - input callback fn\n * `callback_context` - callback context\n * `current_number` (direction in) - The current number\n * `min_value` - Min number value\n * `max_value` - Max number value"]
    pub fn number_input_set_result_callback(
        number_input: *mut NumberInput,
        input_callback: NumberInputCallback,
        callback_context: *mut core::ffi::c_void,
        current_number: i32,
        min_value: i32,
        max_value: i32,
    );
}
unsafe extern "C" {
    #[doc = "Set byte input header text\n\n # Arguments\n\n* `number_input` - byte input instance\n * `text` - text to be shown"]
    pub fn number_input_set_header_text(
        number_input: *mut NumberInput,
        text: *const core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Popup {
    _unused: [u8; 0],
}
#[doc = "Popup result callback type\n comes from GUI thread"]
pub type PopupCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Allocate and initialize popup\n\n This popup used to ask simple questions like Yes/\n\n # Returns\n\nPopup instance"]
    pub fn popup_alloc() -> *mut Popup;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free popup\n\n # Arguments\n\n* `popup` - Popup instance"]
    pub fn popup_free(popup: *mut Popup);
}
unsafe extern "C" {
    #[doc = "Get popup view\n\n # Arguments\n\n* `popup` - Popup instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn popup_get_view(popup: *mut Popup) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Set popup header text\n\n # Arguments\n\n* `popup` - Popup instance\n * `callback` - PopupCallback"]
    pub fn popup_set_callback(popup: *mut Popup, callback: PopupCallback);
}
unsafe extern "C" {
    #[doc = "Set popup context\n\n # Arguments\n\n* `popup` - Popup instance\n * `context` - context pointer, will be passed to result callback"]
    pub fn popup_set_context(popup: *mut Popup, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set popup header text\n\n If text is null, popup header will not be rendered\n\n # Arguments\n\n* `popup` - Popup instance\n * `text` - text to be shown, can be multiline\n * `x` - x position\n * `y` - y position\n * `horizontal` - horizontal alignment\n * `vertical` - vertical alignment"]
    pub fn popup_set_header(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Set popup text\n\n If text is null, popup text will not be rendered\n\n # Arguments\n\n* `popup` - Popup instance\n * `text` - text to be shown, can be multiline\n * `x` - x position\n * `y` - y position\n * `horizontal` - horizontal alignment\n * `vertical` - vertical alignment"]
    pub fn popup_set_text(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
unsafe extern "C" {
    #[doc = "Set popup icon\n\n If icon position is negative, popup icon will not be rendered\n\n # Arguments\n\n* `popup` - Popup instance\n * `x` - x position\n * `y` - y position\n * `icon` - pointer to Icon data"]
    pub fn popup_set_icon(popup: *mut Popup, x: u8, y: u8, icon: *const Icon);
}
unsafe extern "C" {
    #[doc = "Set popup timeout\n\n # Arguments\n\n* `popup` - Popup instance\n * `timeout_in_ms` - popup timeout value in milliseconds"]
    pub fn popup_set_timeout(popup: *mut Popup, timeout_in_ms: u32);
}
unsafe extern "C" {
    #[doc = "Enable popup timeout\n\n # Arguments\n\n* `popup` - Popup instance"]
    pub fn popup_enable_timeout(popup: *mut Popup);
}
unsafe extern "C" {
    #[doc = "Disable popup timeout\n\n # Arguments\n\n* `popup` - Popup instance"]
    pub fn popup_disable_timeout(popup: *mut Popup);
}
unsafe extern "C" {
    #[doc = "Reset popup instance state\n\n # Arguments\n\n* `popup` - Popup instance"]
    pub fn popup_reset(popup: *mut Popup);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Submenu {
    _unused: [u8; 0],
}
pub type SubmenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
unsafe extern "C" {
    #[doc = "Allocate and initialize submenu\n\n This submenu is used to select one option\n\n # Returns\n\nSubmenu instance"]
    pub fn submenu_alloc() -> *mut Submenu;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free submenu\n\n # Arguments\n\n* `submenu` - Submenu instance"]
    pub fn submenu_free(submenu: *mut Submenu);
}
unsafe extern "C" {
    #[doc = "Get submenu view\n\n # Arguments\n\n* `submenu` - Submenu instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn submenu_get_view(submenu: *mut Submenu) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Add item to submenu\n\n # Arguments\n\n* `submenu` - Submenu instance\n * `label` - menu item label\n * `index` - menu item index, used for callback, may be\n the same with other items\n * `callback` - menu item callback\n * `callback_context` - menu item callback context"]
    pub fn submenu_add_item(
        submenu: *mut Submenu,
        label: *const core::ffi::c_char,
        index: u32,
        callback: SubmenuItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Change label of an existing item\n\n # Arguments\n\n* `submenu` - Submenu instance\n * `index` - The index of the item\n * `label` - The new label"]
    pub fn submenu_change_item_label(
        submenu: *mut Submenu,
        index: u32,
        label: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Remove all items from submenu\n\n # Arguments\n\n* `submenu` - Submenu instance"]
    pub fn submenu_reset(submenu: *mut Submenu);
}
unsafe extern "C" {
    #[doc = "Get submenu selected item index\n\n # Arguments\n\n* `submenu` - Submenu instance\n\n # Returns\n\nIndex of the selected item"]
    pub fn submenu_get_selected_item(submenu: *mut Submenu) -> u32;
}
unsafe extern "C" {
    #[doc = "Set submenu selected item by index\n\n # Arguments\n\n* `submenu` - Submenu instance\n * `index` - The index of the selected item"]
    pub fn submenu_set_selected_item(submenu: *mut Submenu, index: u32);
}
unsafe extern "C" {
    #[doc = "Set optional header for submenu\n\n # Arguments\n\n* `submenu` - Submenu instance\n * `header` - header to set"]
    pub fn submenu_set_header(submenu: *mut Submenu, header: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextBox {
    _unused: [u8; 0],
}
pub const TextBoxFontText: TextBoxFont = TextBoxFont(0);
pub const TextBoxFontHex: TextBoxFont = TextBoxFont(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextBoxFont(pub core::ffi::c_uchar);
pub const TextBoxFocusStart: TextBoxFocus = TextBoxFocus(0);
pub const TextBoxFocusEnd: TextBoxFocus = TextBoxFocus(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextBoxFocus(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Allocate and initialize text_box\n\n # Returns\n\nTextBox instance"]
    pub fn text_box_alloc() -> *mut TextBox;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free text_box\n\n # Arguments\n\n* `text_box` - text_box instance"]
    pub fn text_box_free(text_box: *mut TextBox);
}
unsafe extern "C" {
    #[doc = "Get text_box view\n\n # Arguments\n\n* `text_box` - TextBox instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn text_box_get_view(text_box: *mut TextBox) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Clean text_box\n\n # Arguments\n\n* `text_box` - TextBox instance"]
    pub fn text_box_reset(text_box: *mut TextBox);
}
unsafe extern "C" {
    #[doc = "Set text for text_box\n\n # Arguments\n\n* `text_box` - TextBox instance\n * `text` - text to set"]
    pub fn text_box_set_text(text_box: *mut TextBox, text: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Set TextBox font\n\n # Arguments\n\n* `text_box` - TextBox instance\n * `font` - TextBoxFont instance"]
    pub fn text_box_set_font(text_box: *mut TextBox, font: TextBoxFont);
}
unsafe extern "C" {
    #[doc = "Set TextBox focus\n > **Note:** Use to display from start or from end\n\n # Arguments\n\n* `text_box` - TextBox instance\n * `focus` - TextBoxFocus instance"]
    pub fn text_box_set_focus(text_box: *mut TextBox, focus: TextBoxFocus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidatorIsFile {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn validator_is_file_alloc_init(
        app_path_folder: *const core::ffi::c_char,
        app_extension: *const core::ffi::c_char,
        current_name: *const core::ffi::c_char,
    ) -> *mut ValidatorIsFile;
}
unsafe extern "C" {
    pub fn validator_is_file_free(instance: *mut ValidatorIsFile);
}
unsafe extern "C" {
    pub fn validator_is_file_callback(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextInput {
    _unused: [u8; 0],
}
pub type TextInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type TextInputValidatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = "Allocate and initialize text input\n\n This text input is used to enter string\n\n # Returns\n\nTextInput instance"]
    pub fn text_input_alloc() -> *mut TextInput;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free text input\n\n # Arguments\n\n* `text_input` - TextInput instance"]
    pub fn text_input_free(text_input: *mut TextInput);
}
unsafe extern "C" {
    #[doc = "Clean text input view Note: this function does not free memory\n\n # Arguments\n\n* `text_input` - Text input instance"]
    pub fn text_input_reset(text_input: *mut TextInput);
}
unsafe extern "C" {
    #[doc = "Get text input view\n\n # Arguments\n\n* `text_input` - TextInput instance\n\n # Returns\n\nView instance that can be used for embedding"]
    pub fn text_input_get_view(text_input: *mut TextInput) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Set text input result callback\n\n # Arguments\n\n* `text_input` - TextInput instance\n * `callback` - callback fn\n * `callback_context` - callback context\n * `text_buffer` - pointer to YOUR text buffer, that we going\n to modify\n * `text_buffer_size` - YOUR text buffer size in bytes. Max string\n length will be text_buffer_size-1.\n * `clear_default_text` - clear text from text_buffer on first OK\n event"]
    pub fn text_input_set_result_callback(
        text_input: *mut TextInput,
        callback: TextInputCallback,
        callback_context: *mut core::ffi::c_void,
        text_buffer: *mut core::ffi::c_char,
        text_buffer_size: usize,
        clear_default_text: bool,
    );
}
unsafe extern "C" {
    #[doc = "Sets the minimum length of a TextInput\n # Arguments\n\n* `[in]` - text_input TextInput\n * `[in]` - minimum_length Minimum input length"]
    pub fn text_input_set_minimum_length(text_input: *mut TextInput, minimum_length: usize);
}
unsafe extern "C" {
    pub fn text_input_set_validator(
        text_input: *mut TextInput,
        callback: TextInputValidatorCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn text_input_get_validator_callback(
        text_input: *mut TextInput,
    ) -> TextInputValidatorCallback;
}
unsafe extern "C" {
    pub fn text_input_get_validator_callback_context(
        text_input: *mut TextInput,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Set text input header text\n\n # Arguments\n\n* `text_input` - TextInput instance\n * `text` - text to be shown"]
    pub fn text_input_set_header_text(text_input: *mut TextInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItemList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItem {
    _unused: [u8; 0],
}
pub type VariableItemChangeCallback =
    ::core::option::Option<unsafe extern "C" fn(item: *mut VariableItem)>;
pub type VariableItemListEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
unsafe extern "C" {
    #[doc = "Allocate and initialize VariableItemList\n\n # Returns\n\nVariableItemList*"]
    pub fn variable_item_list_alloc() -> *mut VariableItemList;
}
unsafe extern "C" {
    #[doc = "Deinitialize and free VariableItemList\n\n # Arguments\n\n* `variable_item_list` - VariableItemList instance"]
    pub fn variable_item_list_free(variable_item_list: *mut VariableItemList);
}
unsafe extern "C" {
    #[doc = "Clear all elements from list\n\n # Arguments\n\n* `variable_item_list` - VariableItemList instance"]
    pub fn variable_item_list_reset(variable_item_list: *mut VariableItemList);
}
unsafe extern "C" {
    #[doc = "Get VariableItemList View instance\n\n # Arguments\n\n* `variable_item_list` - VariableItemList instance\n\n # Returns\n\nView instance"]
    pub fn variable_item_list_get_view(variable_item_list: *mut VariableItemList) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Add item to VariableItemList\n\n # Arguments\n\n* `variable_item_list` - VariableItemList instance\n * `label` - item name\n * `values_count` - item values count\n * `change_callback` - called on value change in gui\n * `context` - item context\n\n # Returns\n\nVariableItem* item instance"]
    pub fn variable_item_list_add(
        variable_item_list: *mut VariableItemList,
        label: *const core::ffi::c_char,
        values_count: u8,
        change_callback: VariableItemChangeCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut VariableItem;
}
unsafe extern "C" {
    #[doc = "Set enter callback\n\n # Arguments\n\n* `variable_item_list` - VariableItemList instance\n * `callback` - VariableItemListEnterCallback instance\n * `context` - pointer to context"]
    pub fn variable_item_list_set_enter_callback(
        variable_item_list: *mut VariableItemList,
        callback: VariableItemListEnterCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn variable_item_list_set_selected_item(
        variable_item_list: *mut VariableItemList,
        index: u8,
    );
}
unsafe extern "C" {
    pub fn variable_item_list_get_selected_item_index(
        variable_item_list: *mut VariableItemList,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Set item current selected index\n\n # Arguments\n\n* `item` - VariableItem* instance\n * `current_value_index` - The current value index"]
    pub fn variable_item_set_current_value_index(item: *mut VariableItem, current_value_index: u8);
}
unsafe extern "C" {
    #[doc = "Set number of values for item\n\n # Arguments\n\n* `item` - VariableItem* instance\n * `values_count` - The new values count"]
    pub fn variable_item_set_values_count(item: *mut VariableItem, values_count: u8);
}
unsafe extern "C" {
    #[doc = "Set item current selected text\n\n # Arguments\n\n* `item` - VariableItem* instance\n * `current_value_text` - The current value text"]
    pub fn variable_item_set_current_value_text(
        item: *mut VariableItem,
        current_value_text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Get item current selected index\n\n # Arguments\n\n* `item` - VariableItem* instance\n\n # Returns\n\nuint8_t current selected index"]
    pub fn variable_item_get_current_value_index(item: *mut VariableItem) -> u8;
}
unsafe extern "C" {
    #[doc = "Get item context\n\n # Arguments\n\n* `item` - VariableItem* instance\n\n # Returns\n\nvoid* item context"]
    pub fn variable_item_get_context(item: *mut VariableItem) -> *mut core::ffi::c_void;
}
pub const GuiButtonTypeLeft: GuiButtonType = GuiButtonType(0);
pub const GuiButtonTypeCenter: GuiButtonType = GuiButtonType(1);
pub const GuiButtonTypeRight: GuiButtonType = GuiButtonType(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GuiButtonType(pub core::ffi::c_uchar);
pub type ButtonCallback = ::core::option::Option<
    unsafe extern "C" fn(result: GuiButtonType, type_: InputType, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Widget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WidgetElement {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate Widget that holds Widget Elements\n\n # Returns\n\nWidget instance"]
    pub fn widget_alloc() -> *mut Widget;
}
unsafe extern "C" {
    #[doc = "Free Widget\n > **Note:** this function free allocated Widget Elements\n\n # Arguments\n\n* `widget` - Widget instance"]
    pub fn widget_free(widget: *mut Widget);
}
unsafe extern "C" {
    #[doc = "Reset Widget\n\n # Arguments\n\n* `widget` - Widget instance"]
    pub fn widget_reset(widget: *mut Widget);
}
unsafe extern "C" {
    #[doc = "Get Widget view\n\n # Arguments\n\n* `widget` - Widget instance\n\n # Returns\n\nView instance"]
    pub fn widget_get_view(widget: *mut Widget) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Add Multi String Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `horizontal` - Align instance\n * `vertical` - Align instance\n * `font` - Font instance\n * `text` (direction in) - The text"]
    pub fn widget_add_string_multiline_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Add String Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `horizontal` - Align instance\n * `vertical` - Align instance\n * `font` - Font instance\n * `text` (direction in) - The text"]
    pub fn widget_add_string_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Add Text Box Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - width to fit text\n * `height` - height to fit text\n * `horizontal` - Align instance\n * `vertical` - Align instance\n * `text` (direction in) - Formatted text. The following formats are available:\n \"text- bold font is used\n \"text- monospaced font is used\n \"text- white text on black background\n * `strip_to_dots` - Strip text to ... if does not fit to width"]
    pub fn widget_add_text_box_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
unsafe extern "C" {
    #[doc = "Add Text Scroll Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `x` - x coordinate\n * `y` - y coordinate\n * `width` - width to fit text\n * `height` - height to fit text\n * `text` (direction in) - Formatted text. Default format: align left, Secondary font.\n The following formats are available:\n \"text\" - sets bold font before until next 'symbol\n \"text- sets monospaced font before until next 'symbol\n \"text\" - sets center horizontal align until the next 'symbol\n \"text\" - sets right horizontal align until the next 'symbol"]
    pub fn widget_add_text_scroll_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Add Button Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `button_type` - GuiButtonType instance\n * `text` - text on allocated button\n * `callback` - ButtonCallback instance\n * `context` - pointer to context"]
    pub fn widget_add_button_element(
        widget: *mut Widget,
        button_type: GuiButtonType,
        text: *const core::ffi::c_char,
        callback: ButtonCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Add Icon Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `x` - top left x coordinate\n * `y` - top left y coordinate\n * `icon` - Icon instance"]
    pub fn widget_add_icon_element(widget: *mut Widget, x: u8, y: u8, icon: *const Icon);
}
unsafe extern "C" {
    #[doc = "Add Frame Element\n\n # Arguments\n\n* `widget` - Widget instance\n * `x` - top left x coordinate\n * `y` - top left y coordinate\n * `width` - frame width\n * `height` - frame height\n * `radius` - frame radius"]
    pub fn widget_add_frame_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        radius: u8,
    );
}
pub const SceneManagerEventTypeCustom: SceneManagerEventType = SceneManagerEventType(0);
pub const SceneManagerEventTypeBack: SceneManagerEventType = SceneManagerEventType(1);
pub const SceneManagerEventTypeTick: SceneManagerEventType = SceneManagerEventType(2);
#[repr(transparent)]
#[doc = "Scene Manager events type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SceneManagerEventType(pub core::ffi::c_uchar);
#[doc = "Scene Manager event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerEvent {
    pub type_: SceneManagerEventType,
    pub event: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SceneManagerEvent"][::core::mem::size_of::<SceneManagerEvent>() - 8usize];
    ["Alignment of SceneManagerEvent"][::core::mem::align_of::<SceneManagerEvent>() - 4usize];
    ["Offset of field: SceneManagerEvent::type_"]
        [::core::mem::offset_of!(SceneManagerEvent, type_) - 0usize];
    ["Offset of field: SceneManagerEvent::event"]
        [::core::mem::offset_of!(SceneManagerEvent, event) - 4usize];
};
#[doc = "Prototype for Scene on_enter handler"]
pub type AppSceneOnEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Prototype for Scene on_event handler"]
pub type AppSceneOnEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: SceneManagerEvent) -> bool,
>;
#[doc = "Prototype for Scene on_exit handler"]
pub type AppSceneOnExitCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Scene Manager configuration structure\n Contains array of Scene handlers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerHandlers {
    pub on_enter_handlers: *const AppSceneOnEnterCallback,
    pub on_event_handlers: *const AppSceneOnEventCallback,
    pub on_exit_handlers: *const AppSceneOnExitCallback,
    pub scene_num: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SceneManagerHandlers"][::core::mem::size_of::<SceneManagerHandlers>() - 16usize];
    ["Alignment of SceneManagerHandlers"][::core::mem::align_of::<SceneManagerHandlers>() - 4usize];
    ["Offset of field: SceneManagerHandlers::on_enter_handlers"]
        [::core::mem::offset_of!(SceneManagerHandlers, on_enter_handlers) - 0usize];
    ["Offset of field: SceneManagerHandlers::on_event_handlers"]
        [::core::mem::offset_of!(SceneManagerHandlers, on_event_handlers) - 4usize];
    ["Offset of field: SceneManagerHandlers::on_exit_handlers"]
        [::core::mem::offset_of!(SceneManagerHandlers, on_exit_handlers) - 8usize];
    ["Offset of field: SceneManagerHandlers::scene_num"]
        [::core::mem::offset_of!(SceneManagerHandlers, scene_num) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManager {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Set Scene state\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `scene_id` - Scene ID\n * `state` - Scene new state"]
    pub fn scene_manager_set_scene_state(
        scene_manager: *mut SceneManager,
        scene_id: u32,
        state: u32,
    );
}
unsafe extern "C" {
    #[doc = "Get Scene state\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `scene_id` - Scene ID\n\n # Returns\n\nScene state"]
    pub fn scene_manager_get_scene_state(scene_manager: *const SceneManager, scene_id: u32) -> u32;
}
unsafe extern "C" {
    #[doc = "Scene Manager allocation and configuration\n\n Scene Manager allocates all scenes internally\n\n # Arguments\n\n* `app_scene_handlers` - SceneManagerHandlers instance\n * `context` - context to be set on Scene handlers calls\n\n # Returns\n\nSceneManager instance"]
    pub fn scene_manager_alloc(
        app_scene_handlers: *const SceneManagerHandlers,
        context: *mut core::ffi::c_void,
    ) -> *mut SceneManager;
}
unsafe extern "C" {
    #[doc = "Free Scene Manager with allocated Scenes\n\n # Arguments\n\n* `scene_manager` - SceneManager instance"]
    pub fn scene_manager_free(scene_manager: *mut SceneManager);
}
unsafe extern "C" {
    #[doc = "Custom event handler\n\n Calls Scene event handler with Custom event parameter\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `custom_event` - Custom event code\n\n # Returns\n\ntrue if event was consumed, false otherwise"]
    pub fn scene_manager_handle_custom_event(
        scene_manager: *mut SceneManager,
        custom_event: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Back event handler\n\n Calls Scene event handler with Back event parameter\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n\n # Returns\n\ntrue if event was consumed, false otherwise"]
    pub fn scene_manager_handle_back_event(scene_manager: *mut SceneManager) -> bool;
}
unsafe extern "C" {
    #[doc = "Tick event handler\n\n Calls Scene event handler with Tick event parameter\n\n # Arguments\n\n* `scene_manager` - SceneManager instance"]
    pub fn scene_manager_handle_tick_event(scene_manager: *mut SceneManager);
}
unsafe extern "C" {
    #[doc = "Add and run next Scene\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `next_scene_id` - next Scene ID"]
    pub fn scene_manager_next_scene(scene_manager: *mut SceneManager, next_scene_id: u32);
}
unsafe extern "C" {
    #[doc = "Run previous Scene\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n\n # Returns\n\ntrue if previous scene was found, false otherwise"]
    pub fn scene_manager_previous_scene(scene_manager: *mut SceneManager) -> bool;
}
unsafe extern "C" {
    #[doc = "Search previous Scene\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `scene_id` - Scene ID\n\n # Returns\n\ntrue if previous scene was found, false otherwise"]
    pub fn scene_manager_has_previous_scene(
        scene_manager: *const SceneManager,
        scene_id: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Search and switch to previous Scene\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `scene_id` - Scene ID\n\n # Returns\n\ntrue if previous scene was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_previous_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Search and switch to previous Scene, multiple choice\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `scene_ids` - Array of scene IDs\n * `scene_ids_size` - Array of scene IDs size\n\n # Returns\n\ntrue if one of previous scenes was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_previous_scene_one_of(
        scene_manager: *mut SceneManager,
        scene_ids: *const u32,
        scene_ids_size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Clear Scene stack and switch to another Scene\n\n # Arguments\n\n* `scene_manager` - SceneManager instance\n * `scene_id` - Scene ID\n\n # Returns\n\ntrue if previous scene was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_another_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Exit from current scene\n\n # Arguments\n\n* `scene_manager` - SceneManager instance"]
    pub fn scene_manager_stop(scene_manager: *mut SceneManager);
}
#[doc = "< Desktop layer: fullscreen with status bar on top of it. For internal usage."]
pub const ViewDispatcherTypeDesktop: ViewDispatcherType = ViewDispatcherType(0);
#[doc = "< Window layer: with status bar"]
pub const ViewDispatcherTypeWindow: ViewDispatcherType = ViewDispatcherType(1);
#[doc = "< Fullscreen layer: without status bar"]
pub const ViewDispatcherTypeFullscreen: ViewDispatcherType = ViewDispatcherType(2);
#[repr(transparent)]
#[doc = "ViewDispatcher view_port placement"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ViewDispatcherType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewDispatcher {
    _unused: [u8; 0],
}
#[doc = "Prototype for custom event callback"]
pub type ViewDispatcherCustomEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: u32) -> bool,
>;
#[doc = "Prototype for navigation event callback"]
pub type ViewDispatcherNavigationEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> bool>;
#[doc = "Prototype for tick event callback"]
pub type ViewDispatcherTickEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Allocate ViewDispatcher instance\n\n # Returns\n\npointer to ViewDispatcher instance"]
    pub fn view_dispatcher_alloc() -> *mut ViewDispatcher;
}
unsafe extern "C" {
    #[doc = "Allocate ViewDispatcher instance with an externally owned event loop. If\n this constructor is used instead of `view_dispatcher_alloc`, the burden of\n freeing the event loop is placed on the caller.\n\n # Arguments\n\n* `loop` - pointer to FuriEventLoop instance\n # Returns\n\npointer to ViewDispatcher instance"]
    pub fn view_dispatcher_alloc_ex(loop_: *mut FuriEventLoop) -> *mut ViewDispatcher;
}
unsafe extern "C" {
    #[doc = "Free ViewDispatcher instance\n\n All added views MUST be removed using view_dispatcher_remove_view()\n before calling this function.\n\n # Arguments\n\n* `view_dispatcher` - pointer to ViewDispatcher"]
    pub fn view_dispatcher_free(view_dispatcher: *mut ViewDispatcher);
}
unsafe extern "C" {
    #[doc = "Enable queue support\n\n > **Deprecated** Do NOT use in new code and remove all calls to it from existing code.\n The queue support is now always enabled during construction. If no queue support\n is required, consider using ViewHolder instead.\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance"]
    pub fn view_dispatcher_enable_queue(view_dispatcher: *mut ViewDispatcher);
}
unsafe extern "C" {
    #[doc = "Send custom event\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `event` (direction in) - The event"]
    pub fn view_dispatcher_send_custom_event(view_dispatcher: *mut ViewDispatcher, event: u32);
}
unsafe extern "C" {
    #[doc = "Set custom event handler\n\n Called on Custom Event, if it is not consumed by view\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `callback` - ViewDispatcherCustomEventCallback instance"]
    pub fn view_dispatcher_set_custom_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherCustomEventCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set navigation event handler\n\n Called on Input Short Back Event, if it is not consumed by view\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `callback` - ViewDispatcherNavigationEventCallback instance"]
    pub fn view_dispatcher_set_navigation_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherNavigationEventCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set tick event handler\n\n Requires the event loop to be owned by the view dispatcher, i.e.\n it should have been instantiated with `view_dispatcher_alloc`, not\n `view_dispatcher_alloc_ex`.\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `callback` - ViewDispatcherTickEventCallback\n * `tick_period` - callback call period"]
    pub fn view_dispatcher_set_tick_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherTickEventCallback,
        tick_period: u32,
    );
}
unsafe extern "C" {
    #[doc = "Set event callback context\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `context` - pointer to context"]
    pub fn view_dispatcher_set_event_callback_context(
        view_dispatcher: *mut ViewDispatcher,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Get event_loop instance\n\n Use the return value to connect additional supported primitives (message queues, timers, etc)\n to this ViewDispatcher instance's event loop.\n\n Do NOT call furi_event_loop_run() on the returned instance, it is done internally\n in the view_dispatcher_run() call.\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n\n # Returns\n\nThe event_loop instance."]
    pub fn view_dispatcher_get_event_loop(
        view_dispatcher: *mut ViewDispatcher,
    ) -> *mut FuriEventLoop;
}
unsafe extern "C" {
    #[doc = "Run ViewDispatcher\n\n This function will start the event loop and block until view_dispatcher_stop() is called\n or the current thread receives a FuriSignalExit signal.\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance"]
    pub fn view_dispatcher_run(view_dispatcher: *mut ViewDispatcher);
}
unsafe extern "C" {
    #[doc = "Stop ViewDispatcher\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance"]
    pub fn view_dispatcher_stop(view_dispatcher: *mut ViewDispatcher);
}
unsafe extern "C" {
    #[doc = "Add view to ViewDispatcher\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `view_id` - View id to register\n * `view` - View instance"]
    pub fn view_dispatcher_add_view(
        view_dispatcher: *mut ViewDispatcher,
        view_id: u32,
        view: *mut View,
    );
}
unsafe extern "C" {
    #[doc = "Remove view from ViewDispatcher\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `view_id` - View id to remove"]
    pub fn view_dispatcher_remove_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
unsafe extern "C" {
    #[doc = "Switch to View\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `view_id` - View id to register\n switching may be delayed till input events complementarity\n reached"]
    pub fn view_dispatcher_switch_to_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
unsafe extern "C" {
    #[doc = "Send ViewPort of this ViewDispatcher instance to front\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance"]
    pub fn view_dispatcher_send_to_front(view_dispatcher: *mut ViewDispatcher);
}
unsafe extern "C" {
    #[doc = "Send ViewPort of this ViewDispatcher instance to back\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance"]
    pub fn view_dispatcher_send_to_back(view_dispatcher: *mut ViewDispatcher);
}
unsafe extern "C" {
    #[doc = "Attach ViewDispatcher to GUI\n\n # Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n * `gui` - GUI instance to attach to\n * `type` (direction in) - The type"]
    pub fn view_dispatcher_attach_to_gui(
        view_dispatcher: *mut ViewDispatcher,
        gui: *mut Gui,
        type_: ViewDispatcherType,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewHolder {
    _unused: [u8; 0],
}
#[doc = "Free callback type"]
pub type FreeCallback =
    ::core::option::Option<unsafe extern "C" fn(free_context: *mut core::ffi::c_void)>;
#[doc = "Back callback type\n\n Will be called from the GUI thread"]
pub type BackCallback =
    ::core::option::Option<unsafe extern "C" fn(back_context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Allocate ViewHolder\n # Returns\n\npointer to ViewHolder instance"]
    pub fn view_holder_alloc() -> *mut ViewHolder;
}
unsafe extern "C" {
    #[doc = "Free ViewHolder and call Free callback\n\n The current view must be unset prior to freeing a ViewHolder instance.\n\n # Arguments\n\n* `view_holder` - pointer to ViewHolder"]
    pub fn view_holder_free(view_holder: *mut ViewHolder);
}
unsafe extern "C" {
    #[doc = "Set view for ViewHolder\n\n Pass NULL as the view parameter to unset the current view.\n\n # Arguments\n\n* `view_holder` - ViewHolder instance\n * `view` - View instance"]
    pub fn view_holder_set_view(view_holder: *mut ViewHolder, view: *mut View);
}
unsafe extern "C" {
    #[doc = "Set Free callback\n\n # Arguments\n\n* `view_holder` - ViewHolder instance\n * `free_callback` - callback pointer\n * `free_context` - callback context"]
    pub fn view_holder_set_free_callback(
        view_holder: *mut ViewHolder,
        free_callback: FreeCallback,
        free_context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Free callback context getter.\n\n Useful if your Free callback is a module destructor, so you can get an instance of the module using this method.\n\n # Arguments\n\n* `view_holder` - ViewHolder instance\n # Returns\n\nvoid* free callback context"]
    pub fn view_holder_get_free_context(view_holder: *mut ViewHolder) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Set the back key callback.\n\n The callback function will be called if the user has pressed the Back key\n and the current view did not handle this event.\n\n # Arguments\n\n* `view_holder` - ViewHolder instance\n * `back_callback` - pointer to the callback function\n * `back_context` - pointer to a user-specific object, can be NULL"]
    pub fn view_holder_set_back_callback(
        view_holder: *mut ViewHolder,
        back_callback: BackCallback,
        back_context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Attach ViewHolder to GUI\n\n # Arguments\n\n* `view_holder` - ViewHolder instance\n * `gui` - GUI instance to attach to"]
    pub fn view_holder_attach_to_gui(view_holder: *mut ViewHolder, gui: *mut Gui);
}
unsafe extern "C" {
    #[doc = "View Update Handler\n\n # Arguments\n\n* `view` - View Instance\n * `context` - ViewHolder instance"]
    pub fn view_holder_update(view: *mut View, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Send ViewPort of this ViewHolder instance to front\n\n # Arguments\n\n* `view_holder` - ViewHolder instance"]
    pub fn view_holder_send_to_front(view_holder: *mut ViewHolder);
}
unsafe extern "C" {
    #[doc = "Send ViewPort of this ViewHolder instance to back\n\n # Arguments\n\n* `view_holder` - ViewHolder instance"]
    pub fn view_holder_send_to_back(view_holder: *mut ViewHolder);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStack {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate and init ViewStack\n\n # Returns\n\nViewStack instance"]
    pub fn view_stack_alloc() -> *mut ViewStack;
}
unsafe extern "C" {
    #[doc = "Free ViewStack instance\n\n # Arguments\n\n* `view_stack` - instance"]
    pub fn view_stack_free(view_stack: *mut ViewStack);
}
unsafe extern "C" {
    #[doc = "Get View of ViewStack.\n Should this View to any view manager such as\n ViewDispatcher or ViewHolder.\n\n # Arguments\n\n* `view_stack` - instance"]
    pub fn view_stack_get_view(view_stack: *mut ViewStack) -> *mut View;
}
unsafe extern "C" {
    #[doc = "Add View to ViewStack.\n Adds View on top of ViewStack.\n\n # Arguments\n\n* `view_stack` - instance\n * `view` - view to add"]
    pub fn view_stack_add_view(view_stack: *mut ViewStack, view: *mut View);
}
unsafe extern "C" {
    #[doc = "Remove any View in ViewStack.\n If no View to remove found - ignore.\n\n # Arguments\n\n* `view_stack` - instance\n * `view` - view to remove"]
    pub fn view_stack_remove_view(view_stack: *mut ViewStack, view: *mut View);
}
unsafe extern "C" {
    pub static firmware_api_interface: *const ElfApiInterface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loader {
    _unused: [u8; 0],
}
pub const LoaderStatusOk: LoaderStatus = LoaderStatus(0);
pub const LoaderStatusErrorAppStarted: LoaderStatus = LoaderStatus(1);
pub const LoaderStatusErrorUnknownApp: LoaderStatus = LoaderStatus(2);
pub const LoaderStatusErrorInternal: LoaderStatus = LoaderStatus(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LoaderStatus(pub core::ffi::c_uchar);
pub const LoaderEventTypeApplicationBeforeLoad: LoaderEventType = LoaderEventType(0);
pub const LoaderEventTypeApplicationLoadFailed: LoaderEventType = LoaderEventType(1);
pub const LoaderEventTypeApplicationStopped: LoaderEventType = LoaderEventType(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LoaderEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LoaderEvent {
    pub type_: LoaderEventType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LoaderEvent"][::core::mem::size_of::<LoaderEvent>() - 1usize];
    ["Alignment of LoaderEvent"][::core::mem::align_of::<LoaderEvent>() - 1usize];
    ["Offset of field: LoaderEvent::type_"][::core::mem::offset_of!(LoaderEvent, type_) - 0usize];
};
unsafe extern "C" {
    #[doc = "Start application\n # Arguments\n\n* `instance` (direction in) - loader instance\n * `name` (direction in) - application name or id\n * `args` (direction in) - application arguments\n * `error_message` (direction out) - detailed error message, can be NULL\n # Returns\n\nLoaderStatus"]
    pub fn loader_start(
        instance: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
        error_message: *mut FuriString,
    ) -> LoaderStatus;
}
unsafe extern "C" {
    #[doc = "Start application with GUI error message\n # Arguments\n\n* `instance` (direction in) - loader instance\n * `name` (direction in) - application name or id\n * `args` (direction in) - application arguments\n # Returns\n\nLoaderStatus"]
    pub fn loader_start_with_gui_error(
        loader: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
    ) -> LoaderStatus;
}
unsafe extern "C" {
    #[doc = "Start application detached with GUI error message\n # Arguments\n\n* `instance` (direction in) - loader instance\n * `name` (direction in) - application name or id\n * `args` (direction in) - application arguments"]
    pub fn loader_start_detached_with_gui_error(
        loader: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Lock application start\n # Arguments\n\n* `instance` (direction in) - loader instance\n # Returns\n\ntrue on success"]
    pub fn loader_lock(instance: *mut Loader) -> bool;
}
unsafe extern "C" {
    #[doc = "Unlock application start\n # Arguments\n\n* `instance` (direction in) - loader instance"]
    pub fn loader_unlock(instance: *mut Loader);
}
unsafe extern "C" {
    #[doc = "Check if loader is locked\n # Arguments\n\n* `instance` (direction in) - loader instance\n # Returns\n\ntrue if locked"]
    pub fn loader_is_locked(instance: *mut Loader) -> bool;
}
unsafe extern "C" {
    #[doc = "Show loader menu\n # Arguments\n\n* `instance` (direction in) - loader instance"]
    pub fn loader_show_menu(instance: *mut Loader);
}
unsafe extern "C" {
    #[doc = "Get loader pubsub\n # Arguments\n\n* `instance` (direction in) - loader instance\n # Returns\n\nFuriPubSub*"]
    pub fn loader_get_pubsub(instance: *mut Loader) -> *mut FuriPubSub;
}
unsafe extern "C" {
    #[doc = "Send a signal to the currently running application\n\n # Arguments\n\n* `instance` (direction in) - pointer to the loader instance\n * `signal` (direction in) - signal value to be sent\n * `arg` (direction in, out) - optional argument (can be of any value, including NULL)\n\n # Returns\n\ntrue if the signal was handled by the application, false otherwise"]
    pub fn loader_signal(instance: *mut Loader, signal: u32, arg: *mut core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the name of the currently running application\n\n # Arguments\n\n* `instance` (direction in) - pointer to the loader instance\n * `name` (direction in, out) - pointer to the string to contain the name (must be allocated)\n # Returns\n\ntrue if it was possible to get an application name, false otherwise"]
    pub fn loader_get_application_name(instance: *mut Loader, name: *mut FuriString) -> bool;
}
#[doc = "< Metric measurement units"]
pub const LocaleMeasurementUnitsMetric: LocaleMeasurementUnits = LocaleMeasurementUnits(0);
#[doc = "< Imperial measurement units"]
pub const LocaleMeasurementUnitsImperial: LocaleMeasurementUnits = LocaleMeasurementUnits(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LocaleMeasurementUnits(pub core::ffi::c_uchar);
#[doc = "< 24-hour format"]
pub const LocaleTimeFormat24h: LocaleTimeFormat = LocaleTimeFormat(0);
#[doc = "< 12-hour format"]
pub const LocaleTimeFormat12h: LocaleTimeFormat = LocaleTimeFormat(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LocaleTimeFormat(pub core::ffi::c_uchar);
#[doc = "< Day/Month/Year"]
pub const LocaleDateFormatDMY: LocaleDateFormat = LocaleDateFormat(0);
#[doc = "< Month/Day/Year"]
pub const LocaleDateFormatMDY: LocaleDateFormat = LocaleDateFormat(1);
#[doc = "< Year/Month/Day"]
pub const LocaleDateFormatYMD: LocaleDateFormat = LocaleDateFormat(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LocaleDateFormat(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Get Locale measurement units\n\n # Returns\n\nThe locale measurement units."]
    pub fn locale_get_measurement_unit() -> LocaleMeasurementUnits;
}
unsafe extern "C" {
    #[doc = "Set locale measurement units\n\n # Arguments\n\n* `format` (direction in) - The locale measurements units"]
    pub fn locale_set_measurement_unit(format: LocaleMeasurementUnits);
}
unsafe extern "C" {
    #[doc = "Convert Fahrenheit to Celsius\n\n # Arguments\n\n* `temp_f` (direction in) - The Temperature in Fahrenheit\n\n # Returns\n\nThe Temperature in Celsius"]
    pub fn locale_fahrenheit_to_celsius(temp_f: f32) -> f32;
}
unsafe extern "C" {
    #[doc = "Convert Celsius to Fahrenheit\n\n # Arguments\n\n* `temp_c` (direction in) - The Temperature in Celsius\n\n # Returns\n\nThe Temperature in Fahrenheit"]
    pub fn locale_celsius_to_fahrenheit(temp_c: f32) -> f32;
}
unsafe extern "C" {
    #[doc = "Get Locale time format\n\n # Returns\n\nThe locale time format."]
    pub fn locale_get_time_format() -> LocaleTimeFormat;
}
unsafe extern "C" {
    #[doc = "Set Locale Time Format\n\n # Arguments\n\n* `format` (direction in) - The Locale Time Format"]
    pub fn locale_set_time_format(format: LocaleTimeFormat);
}
unsafe extern "C" {
    #[doc = "Format time to furi string\n\n # Arguments\n\n* `out_str` (direction out) - The FuriString to store formatted time\n * `datetime` (direction in) - Pointer to the datetime\n * `format` (direction in) - The Locale Time Format\n * `show_seconds` (direction in) - The show seconds flag"]
    pub fn locale_format_time(
        out_str: *mut FuriString,
        datetime: *const DateTime,
        format: LocaleTimeFormat,
        show_seconds: bool,
    );
}
unsafe extern "C" {
    #[doc = "Get Locale DateFormat\n\n # Returns\n\nThe Locale DateFormat."]
    pub fn locale_get_date_format() -> LocaleDateFormat;
}
unsafe extern "C" {
    #[doc = "Set Locale DateFormat\n\n # Arguments\n\n* `format` (direction in) - The Locale DateFormat"]
    pub fn locale_set_date_format(format: LocaleDateFormat);
}
unsafe extern "C" {
    #[doc = "Format date to furi string\n\n # Arguments\n\n* `out_str` (direction out) - The FuriString to store formatted date\n * `datetime` (direction in) - Pointer to the datetime\n * `format` (direction in) - The format\n * `separator` (direction in) - The separator"]
    pub fn locale_format_date(
        out_str: *mut FuriString,
        datetime: *const DateTime,
        format: LocaleDateFormat,
        separator: *const core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationApp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataSound {
    pub frequency: f32,
    pub volume: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageDataSound"]
        [::core::mem::size_of::<NotificationMessageDataSound>() - 8usize];
    ["Alignment of NotificationMessageDataSound"]
        [::core::mem::align_of::<NotificationMessageDataSound>() - 4usize];
    ["Offset of field: NotificationMessageDataSound::frequency"]
        [::core::mem::offset_of!(NotificationMessageDataSound, frequency) - 0usize];
    ["Offset of field: NotificationMessageDataSound::volume"]
        [::core::mem::offset_of!(NotificationMessageDataSound, volume) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLed {
    pub value: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageDataLed"]
        [::core::mem::size_of::<NotificationMessageDataLed>() - 1usize];
    ["Alignment of NotificationMessageDataLed"]
        [::core::mem::align_of::<NotificationMessageDataLed>() - 1usize];
    ["Offset of field: NotificationMessageDataLed::value"]
        [::core::mem::offset_of!(NotificationMessageDataLed, value) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataVibro {
    pub on: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageDataVibro"]
        [::core::mem::size_of::<NotificationMessageDataVibro>() - 1usize];
    ["Alignment of NotificationMessageDataVibro"]
        [::core::mem::align_of::<NotificationMessageDataVibro>() - 1usize];
    ["Offset of field: NotificationMessageDataVibro::on"]
        [::core::mem::offset_of!(NotificationMessageDataVibro, on) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataDelay {
    pub length: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageDataDelay"]
        [::core::mem::size_of::<NotificationMessageDataDelay>() - 4usize];
    ["Alignment of NotificationMessageDataDelay"]
        [::core::mem::align_of::<NotificationMessageDataDelay>() - 4usize];
    ["Offset of field: NotificationMessageDataDelay::length"]
        [::core::mem::offset_of!(NotificationMessageDataDelay, length) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataForcedSettings {
    pub speaker_volume: f32,
    pub vibro: bool,
    pub display_brightness: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageDataForcedSettings"]
        [::core::mem::size_of::<NotificationMessageDataForcedSettings>() - 12usize];
    ["Alignment of NotificationMessageDataForcedSettings"]
        [::core::mem::align_of::<NotificationMessageDataForcedSettings>() - 4usize];
    ["Offset of field: NotificationMessageDataForcedSettings::speaker_volume"]
        [::core::mem::offset_of!(NotificationMessageDataForcedSettings, speaker_volume) - 0usize];
    ["Offset of field: NotificationMessageDataForcedSettings::vibro"]
        [::core::mem::offset_of!(NotificationMessageDataForcedSettings, vibro) - 4usize];
    ["Offset of field: NotificationMessageDataForcedSettings::display_brightness"][::core::mem::offset_of!(
        NotificationMessageDataForcedSettings,
        display_brightness
    ) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLedBlink {
    pub on_time: u16,
    pub period: u16,
    pub color: Light,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageDataLedBlink"]
        [::core::mem::size_of::<NotificationMessageDataLedBlink>() - 6usize];
    ["Alignment of NotificationMessageDataLedBlink"]
        [::core::mem::align_of::<NotificationMessageDataLedBlink>() - 2usize];
    ["Offset of field: NotificationMessageDataLedBlink::on_time"]
        [::core::mem::offset_of!(NotificationMessageDataLedBlink, on_time) - 0usize];
    ["Offset of field: NotificationMessageDataLedBlink::period"]
        [::core::mem::offset_of!(NotificationMessageDataLedBlink, period) - 2usize];
    ["Offset of field: NotificationMessageDataLedBlink::color"]
        [::core::mem::offset_of!(NotificationMessageDataLedBlink, color) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union NotificationMessageData {
    pub sound: NotificationMessageDataSound,
    pub led: NotificationMessageDataLed,
    pub led_blink: NotificationMessageDataLedBlink,
    pub vibro: NotificationMessageDataVibro,
    pub delay: NotificationMessageDataDelay,
    pub forced_settings: NotificationMessageDataForcedSettings,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessageData"]
        [::core::mem::size_of::<NotificationMessageData>() - 12usize];
    ["Alignment of NotificationMessageData"]
        [::core::mem::align_of::<NotificationMessageData>() - 4usize];
    ["Offset of field: NotificationMessageData::sound"]
        [::core::mem::offset_of!(NotificationMessageData, sound) - 0usize];
    ["Offset of field: NotificationMessageData::led"]
        [::core::mem::offset_of!(NotificationMessageData, led) - 0usize];
    ["Offset of field: NotificationMessageData::led_blink"]
        [::core::mem::offset_of!(NotificationMessageData, led_blink) - 0usize];
    ["Offset of field: NotificationMessageData::vibro"]
        [::core::mem::offset_of!(NotificationMessageData, vibro) - 0usize];
    ["Offset of field: NotificationMessageData::delay"]
        [::core::mem::offset_of!(NotificationMessageData, delay) - 0usize];
    ["Offset of field: NotificationMessageData::forced_settings"]
        [::core::mem::offset_of!(NotificationMessageData, forced_settings) - 0usize];
};
pub const NotificationMessageTypeVibro: NotificationMessageType = NotificationMessageType(0);
pub const NotificationMessageTypeSoundOn: NotificationMessageType = NotificationMessageType(1);
pub const NotificationMessageTypeSoundOff: NotificationMessageType = NotificationMessageType(2);
pub const NotificationMessageTypeLedRed: NotificationMessageType = NotificationMessageType(3);
pub const NotificationMessageTypeLedGreen: NotificationMessageType = NotificationMessageType(4);
pub const NotificationMessageTypeLedBlue: NotificationMessageType = NotificationMessageType(5);
pub const NotificationMessageTypeLedBlinkStart: NotificationMessageType =
    NotificationMessageType(6);
pub const NotificationMessageTypeLedBlinkStop: NotificationMessageType = NotificationMessageType(7);
pub const NotificationMessageTypeLedBlinkColor: NotificationMessageType =
    NotificationMessageType(8);
pub const NotificationMessageTypeDelay: NotificationMessageType = NotificationMessageType(9);
pub const NotificationMessageTypeLedDisplayBacklight: NotificationMessageType =
    NotificationMessageType(10);
pub const NotificationMessageTypeLedDisplayBacklightEnforceOn: NotificationMessageType =
    NotificationMessageType(11);
pub const NotificationMessageTypeLedDisplayBacklightEnforceAuto: NotificationMessageType =
    NotificationMessageType(12);
pub const NotificationMessageTypeDoNotReset: NotificationMessageType = NotificationMessageType(13);
pub const NotificationMessageTypeForceSpeakerVolumeSetting: NotificationMessageType =
    NotificationMessageType(14);
pub const NotificationMessageTypeForceVibroSetting: NotificationMessageType =
    NotificationMessageType(15);
pub const NotificationMessageTypeForceDisplayBrightnessSetting: NotificationMessageType =
    NotificationMessageType(16);
pub const NotificationMessageTypeLedBrightnessSettingApply: NotificationMessageType =
    NotificationMessageType(17);
pub const NotificationMessageTypeLcdContrastUpdate: NotificationMessageType =
    NotificationMessageType(18);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NotificationMessageType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NotificationMessage {
    pub type_: NotificationMessageType,
    pub data: NotificationMessageData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NotificationMessage"][::core::mem::size_of::<NotificationMessage>() - 16usize];
    ["Alignment of NotificationMessage"][::core::mem::align_of::<NotificationMessage>() - 4usize];
    ["Offset of field: NotificationMessage::type_"]
        [::core::mem::offset_of!(NotificationMessage, type_) - 0usize];
    ["Offset of field: NotificationMessage::data"]
        [::core::mem::offset_of!(NotificationMessage, data) - 4usize];
};
pub type NotificationSequence = [*const NotificationMessage; 0usize];
unsafe extern "C" {
    pub fn notification_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
unsafe extern "C" {
    pub fn notification_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
unsafe extern "C" {
    #[doc = "Send internal (apply to permanent layer) notification message. Think twice before use.\n\n # Arguments\n\n* `app` - notification record content\n * `sequence` - notification sequence"]
    pub fn notification_internal_message(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
unsafe extern "C" {
    #[doc = "Send internal (apply to permanent layer) notification message and wait for notification end. Think twice before use.\n\n # Arguments\n\n* `app` - notification record content\n * `sequence` - notification sequence"]
    pub fn notification_internal_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
unsafe extern "C" {
    pub static message_click: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b2: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b3: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b4: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b5: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b6: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b7: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_c8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_cs8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_d8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_ds8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_e8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_f8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_fs8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_g8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_gs8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_a8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_as8: NotificationMessage;
}
unsafe extern "C" {
    pub static message_note_b8: NotificationMessage;
}
unsafe extern "C" {
    #[doc = "Messages"]
    pub static message_display_backlight_on: NotificationMessage;
}
unsafe extern "C" {
    pub static message_display_backlight_off: NotificationMessage;
}
unsafe extern "C" {
    pub static message_display_backlight_enforce_on: NotificationMessage;
}
unsafe extern "C" {
    pub static message_display_backlight_enforce_auto: NotificationMessage;
}
unsafe extern "C" {
    pub static message_red_255: NotificationMessage;
}
unsafe extern "C" {
    pub static message_green_255: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blue_255: NotificationMessage;
}
unsafe extern "C" {
    pub static message_red_0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_green_0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blue_0: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_start_10: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_start_100: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_stop: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_red: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_green: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_blue: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_cyan: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_magenta: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_yellow: NotificationMessage;
}
unsafe extern "C" {
    pub static message_blink_set_color_white: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_1: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_10: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_25: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_50: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_100: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_250: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_500: NotificationMessage;
}
unsafe extern "C" {
    pub static message_delay_1000: NotificationMessage;
}
unsafe extern "C" {
    pub static message_sound_off: NotificationMessage;
}
unsafe extern "C" {
    pub static message_vibro_on: NotificationMessage;
}
unsafe extern "C" {
    pub static message_vibro_off: NotificationMessage;
}
unsafe extern "C" {
    pub static message_do_not_reset: NotificationMessage;
}
unsafe extern "C" {
    pub static message_force_speaker_volume_setting_1f: NotificationMessage;
}
unsafe extern "C" {
    pub static message_force_vibro_setting_on: NotificationMessage;
}
unsafe extern "C" {
    pub static message_force_vibro_setting_off: NotificationMessage;
}
unsafe extern "C" {
    pub static message_force_display_brightness_setting_1f: NotificationMessage;
}
unsafe extern "C" {
    pub static message_lcd_contrast_update: NotificationMessage;
}
unsafe extern "C" {
    #[doc = "Message sequences"]
    pub static sequence_reset_red: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_reset_green: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_reset_blue: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_reset_rgb: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_reset_display: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_reset_sound: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_reset_vibro: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_vibro_on: NotificationSequence;
}
unsafe extern "C" {
    #[doc = "Display: backlight wakeup"]
    pub static sequence_display_backlight_on: NotificationSequence;
}
unsafe extern "C" {
    #[doc = "Display: backlight force off"]
    pub static sequence_display_backlight_off: NotificationSequence;
}
unsafe extern "C" {
    #[doc = "Display: backlight force off after a delay of 1000ms"]
    pub static sequence_display_backlight_off_delay_1000: NotificationSequence;
}
unsafe extern "C" {
    #[doc = "Display: backlight always on lock"]
    pub static sequence_display_backlight_enforce_on: NotificationSequence;
}
unsafe extern "C" {
    #[doc = "Display: backlight always on unlock"]
    pub static sequence_display_backlight_enforce_auto: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_charging: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_charged: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_not_charging: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_only_red_255: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_only_green_255: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_only_blue_255: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_red_255: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_green_255: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_set_blue_255: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_solid_yellow: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_blue_10: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_red_10: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_green_10: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_yellow_10: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_cyan_10: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_magenta_10: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_red_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_green_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_blue_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_yellow_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_cyan_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_magenta_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_white_100: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_start_blue: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_start_red: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_start_green: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_start_yellow: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_start_cyan: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_start_magenta: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_blink_stop: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_single_vibro: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_double_vibro: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_success: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_semi_success: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_error: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_audiovisual_alert: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_lcd_contrast_update: NotificationSequence;
}
unsafe extern "C" {
    pub static sequence_empty: NotificationSequence;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Power {
    _unused: [u8; 0],
}
pub const PowerBootModeNormal: PowerBootMode = PowerBootMode(0);
pub const PowerBootModeDfu: PowerBootMode = PowerBootMode(1);
pub const PowerBootModeUpdateStart: PowerBootMode = PowerBootMode(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PowerBootMode(pub core::ffi::c_uchar);
pub const PowerEventTypeStopCharging: PowerEventType = PowerEventType(0);
pub const PowerEventTypeStartCharging: PowerEventType = PowerEventType(1);
pub const PowerEventTypeFullyCharged: PowerEventType = PowerEventType(2);
pub const PowerEventTypeBatteryLevelChanged: PowerEventType = PowerEventType(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PowerEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub union PowerEventData {
    pub battery_level: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PowerEventData"][::core::mem::size_of::<PowerEventData>() - 1usize];
    ["Alignment of PowerEventData"][::core::mem::align_of::<PowerEventData>() - 1usize];
    ["Offset of field: PowerEventData::battery_level"]
        [::core::mem::offset_of!(PowerEventData, battery_level) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PowerEvent {
    pub type_: PowerEventType,
    pub data: PowerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PowerEvent"][::core::mem::size_of::<PowerEvent>() - 2usize];
    ["Alignment of PowerEvent"][::core::mem::align_of::<PowerEvent>() - 1usize];
    ["Offset of field: PowerEvent::type_"][::core::mem::offset_of!(PowerEvent, type_) - 0usize];
    ["Offset of field: PowerEvent::data"][::core::mem::offset_of!(PowerEvent, data) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PowerInfo {
    pub gauge_is_ok: bool,
    pub is_charging: bool,
    pub is_shutdown_requested: bool,
    pub current_charger: f32,
    pub current_gauge: f32,
    pub voltage_battery_charge_limit: f32,
    pub voltage_charger: f32,
    pub voltage_gauge: f32,
    pub voltage_vbus: f32,
    pub capacity_remaining: u32,
    pub capacity_full: u32,
    pub temperature_charger: f32,
    pub temperature_gauge: f32,
    pub charge: u8,
    pub health: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PowerInfo"][::core::mem::size_of::<PowerInfo>() - 48usize];
    ["Alignment of PowerInfo"][::core::mem::align_of::<PowerInfo>() - 4usize];
    ["Offset of field: PowerInfo::gauge_is_ok"]
        [::core::mem::offset_of!(PowerInfo, gauge_is_ok) - 0usize];
    ["Offset of field: PowerInfo::is_charging"]
        [::core::mem::offset_of!(PowerInfo, is_charging) - 1usize];
    ["Offset of field: PowerInfo::is_shutdown_requested"]
        [::core::mem::offset_of!(PowerInfo, is_shutdown_requested) - 2usize];
    ["Offset of field: PowerInfo::current_charger"]
        [::core::mem::offset_of!(PowerInfo, current_charger) - 4usize];
    ["Offset of field: PowerInfo::current_gauge"]
        [::core::mem::offset_of!(PowerInfo, current_gauge) - 8usize];
    ["Offset of field: PowerInfo::voltage_battery_charge_limit"]
        [::core::mem::offset_of!(PowerInfo, voltage_battery_charge_limit) - 12usize];
    ["Offset of field: PowerInfo::voltage_charger"]
        [::core::mem::offset_of!(PowerInfo, voltage_charger) - 16usize];
    ["Offset of field: PowerInfo::voltage_gauge"]
        [::core::mem::offset_of!(PowerInfo, voltage_gauge) - 20usize];
    ["Offset of field: PowerInfo::voltage_vbus"]
        [::core::mem::offset_of!(PowerInfo, voltage_vbus) - 24usize];
    ["Offset of field: PowerInfo::capacity_remaining"]
        [::core::mem::offset_of!(PowerInfo, capacity_remaining) - 28usize];
    ["Offset of field: PowerInfo::capacity_full"]
        [::core::mem::offset_of!(PowerInfo, capacity_full) - 32usize];
    ["Offset of field: PowerInfo::temperature_charger"]
        [::core::mem::offset_of!(PowerInfo, temperature_charger) - 36usize];
    ["Offset of field: PowerInfo::temperature_gauge"]
        [::core::mem::offset_of!(PowerInfo, temperature_gauge) - 40usize];
    ["Offset of field: PowerInfo::charge"][::core::mem::offset_of!(PowerInfo, charge) - 44usize];
    ["Offset of field: PowerInfo::health"][::core::mem::offset_of!(PowerInfo, health) - 45usize];
};
unsafe extern "C" {
    #[doc = "Power off device"]
    pub fn power_off(power: *mut Power);
}
unsafe extern "C" {
    #[doc = "Reboot device\n\n # Arguments\n\n* `mode` - PowerBootMode"]
    pub fn power_reboot(power: *mut Power, mode: PowerBootMode);
}
unsafe extern "C" {
    #[doc = "Get power info\n\n # Arguments\n\n* `power` - Power instance\n * `info` - PowerInfo instance"]
    pub fn power_get_info(power: *mut Power, info: *mut PowerInfo);
}
unsafe extern "C" {
    #[doc = "Get power event pubsub handler\n\n # Arguments\n\n* `power` - Power instance\n\n # Returns\n\nFuriPubSub instance"]
    pub fn power_get_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
unsafe extern "C" {
    #[doc = "Check battery health\n\n # Returns\n\ntrue if battery is healthy"]
    pub fn power_is_battery_healthy(power: *mut Power) -> bool;
}
unsafe extern "C" {
    #[doc = "Enable or disable battery low level notification message\n\n # Arguments\n\n* `power` - Power instance\n * `enable` - true - enable, false - disable"]
    pub fn power_enable_low_battery_level_notification(power: *mut Power, enable: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rpc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcSession {
    _unused: [u8; 0],
}
#[doc = "Callback to send to client any data (e.g. response to command)"]
pub type RpcSendBytesCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, bytes: *mut u8, bytes_len: usize),
>;
#[doc = "Callback to notify client that buffer is empty"]
pub type RpcBufferIsEmptyCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Callback to notify transport layer that close_session command\n is received. Any other actions lays on transport layer.\n No destruction or session close performed."]
pub type RpcSessionClosedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Callback to notify transport layer that session was closed\n and all operations were finished"]
pub type RpcSessionTerminatedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub const RpcOwnerUnknown: RpcOwner = RpcOwner(0);
pub const RpcOwnerBle: RpcOwner = RpcOwner(1);
pub const RpcOwnerUsb: RpcOwner = RpcOwner(2);
pub const RpcOwnerUart: RpcOwner = RpcOwner(3);
pub const RpcOwnerCount: RpcOwner = RpcOwner(4);
#[repr(transparent)]
#[doc = "RPC owner"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RpcOwner(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Get RPC session owner\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n # Returns\n\nsession owner"]
    pub fn rpc_session_get_owner(session: *mut RpcSession) -> RpcOwner;
}
unsafe extern "C" {
    #[doc = "Open RPC session\n\n USAGE:\n 1) rpc_session_open();\n 2) rpc_session_set_context();\n 3) rpc_session_set_send_bytes_callback();\n 4) rpc_session_set_close_callback();\n 5) while(1) {\n rpc_session_feed();\n }\n 6) rpc_session_close();\n\n\n # Arguments\n\n* `rpc` - instance\n * `owner` - owner of session\n # Returns\n\npointer to RpcSession descriptor, or\n NULL if RPC is busy and can't open session now"]
    pub fn rpc_session_open(rpc: *mut Rpc, owner: RpcOwner) -> *mut RpcSession;
}
unsafe extern "C" {
    #[doc = "Close RPC session\n It is guaranteed that no callbacks will be called\n as soon as session is closed. So no need in setting\n callbacks to NULL after session close.\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor"]
    pub fn rpc_session_close(session: *mut RpcSession);
}
unsafe extern "C" {
    #[doc = "Set session context for callbacks to pass\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n * `context` - context to pass to callbacks"]
    pub fn rpc_session_set_context(session: *mut RpcSession, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Set callback to send bytes to client\n WARN: It's forbidden to call RPC API within RpcSendBytesCallback\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n * `callback` - callback to send bytes to client (can be NULL)"]
    pub fn rpc_session_set_send_bytes_callback(
        session: *mut RpcSession,
        callback: RpcSendBytesCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set callback to notify that buffer is empty\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n * `callback` - callback to notify client that buffer is empty (can be NULL)\n * `context` - context to pass to callback"]
    pub fn rpc_session_set_buffer_is_empty_callback(
        session: *mut RpcSession,
        callback: RpcBufferIsEmptyCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set callback to be called when RPC command to close session is received\n WARN: It's forbidden to call RPC API within RpcSessionClosedCallback\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n * `callback` - callback to inform about RPC close session command (can be NULL)"]
    pub fn rpc_session_set_close_callback(
        session: *mut RpcSession,
        callback: RpcSessionClosedCallback,
    );
}
unsafe extern "C" {
    #[doc = "Set callback to be called when RPC session is closed\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n * `callback` - callback to inform about RPC session state"]
    pub fn rpc_session_set_terminated_callback(
        session: *mut RpcSession,
        callback: RpcSessionTerminatedCallback,
    );
}
unsafe extern "C" {
    #[doc = "Give bytes to RPC service to decode them and perform command\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n * `buffer` - buffer to provide to RPC service\n * `size` - size of buffer\n * `timeout` - max timeout to wait till all buffer will be consumed\n\n # Returns\n\nactually consumed bytes"]
    pub fn rpc_session_feed(
        session: *mut RpcSession,
        buffer: *const u8,
        size: usize,
        timeout: u32,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Get available size of RPC buffer\n\n # Arguments\n\n* `session` - pointer to RpcSession descriptor\n\n # Returns\n\nbytes available in buffer"]
    pub fn rpc_session_get_available_size(session: *mut RpcSession) -> usize;
}
pub const RpcAppSystemErrorCodeNone: RpcAppSystemErrorCode = RpcAppSystemErrorCode(0);
#[doc = "There are no errors"]
pub const RpcAppSystemErrorCodeParseFile: RpcAppSystemErrorCode = RpcAppSystemErrorCode(1);
#[doc = "File parsing error, or wrong file structure, or missing required parameters. more accurate data can be obtained through the debug port"]
pub const RpcAppSystemErrorCodeRegionLock: RpcAppSystemErrorCode = RpcAppSystemErrorCode(2);
#[doc = "Requested function is blocked by regional settings"]
pub const RpcAppSystemErrorCodeInternalParse: RpcAppSystemErrorCode = RpcAppSystemErrorCode(3);
#[repr(transparent)]
#[doc = "Enumeration of possible error codes for application which can be started through rpc"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RpcAppSystemErrorCode(pub core::ffi::c_uchar);
#[doc = "< No data is provided by the event."]
pub const RpcAppSystemEventDataTypeNone: RpcAppSystemEventDataType = RpcAppSystemEventDataType(0);
#[doc = "< Event data contains a zero-terminated string."]
pub const RpcAppSystemEventDataTypeString: RpcAppSystemEventDataType = RpcAppSystemEventDataType(1);
#[doc = "< Event data contains a signed 32-bit integer."]
pub const RpcAppSystemEventDataTypeInt32: RpcAppSystemEventDataType = RpcAppSystemEventDataType(2);
#[doc = "< Event data contains zero or more bytes."]
pub const RpcAppSystemEventDataTypeBytes: RpcAppSystemEventDataType = RpcAppSystemEventDataType(3);
#[repr(transparent)]
#[doc = "Enumeration of possible event data types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RpcAppSystemEventDataType(pub core::ffi::c_uchar);
#[doc = "Event data structure, containing the type and associated data.\n\n All below fields except for type are valid only if the respective type is set."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpcAppSystemEventData {
    #[doc = "< Type of the data. The meaning of other fields depends on this one."]
    pub type_: RpcAppSystemEventDataType,
    pub __bindgen_anon_1: RpcAppSystemEventData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpcAppSystemEventData__bindgen_ty_1 {
    #[doc = "< Pointer to a zero-terminated character string."]
    pub string: *const core::ffi::c_char,
    #[doc = "< Signed 32-bit integer value."]
    pub i32_: i32,
    #[doc = "< Byte array of arbitrary length."]
    pub bytes: RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Pointer to the byte array data."]
    pub ptr: *const u8,
    #[doc = "< Size of the byte array, in bytes."]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1::ptr"]
        [::core::mem::offset_of!(RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1, ptr) - 0usize];
    ["Offset of field: RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1::size"]
        [::core::mem::offset_of!(RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1, size) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RpcAppSystemEventData__bindgen_ty_1"]
        [::core::mem::size_of::<RpcAppSystemEventData__bindgen_ty_1>() - 8usize];
    ["Alignment of RpcAppSystemEventData__bindgen_ty_1"]
        [::core::mem::align_of::<RpcAppSystemEventData__bindgen_ty_1>() - 4usize];
    ["Offset of field: RpcAppSystemEventData__bindgen_ty_1::string"]
        [::core::mem::offset_of!(RpcAppSystemEventData__bindgen_ty_1, string) - 0usize];
    ["Offset of field: RpcAppSystemEventData__bindgen_ty_1::i32_"]
        [::core::mem::offset_of!(RpcAppSystemEventData__bindgen_ty_1, i32_) - 0usize];
    ["Offset of field: RpcAppSystemEventData__bindgen_ty_1::bytes"]
        [::core::mem::offset_of!(RpcAppSystemEventData__bindgen_ty_1, bytes) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RpcAppSystemEventData"][::core::mem::size_of::<RpcAppSystemEventData>() - 12usize];
    ["Alignment of RpcAppSystemEventData"]
        [::core::mem::align_of::<RpcAppSystemEventData>() - 4usize];
    ["Offset of field: RpcAppSystemEventData::type_"]
        [::core::mem::offset_of!(RpcAppSystemEventData, type_) - 0usize];
};
#[doc = "Denotes an invalid state.\n\n An event of this type shall never be passed into the callback."]
pub const RpcAppEventTypeInvalid: RpcAppSystemEventType = RpcAppSystemEventType(0);
#[doc = "The client side has closed the session.\n\n After receiving this event, the RPC context is no more valid."]
pub const RpcAppEventTypeSessionClose: RpcAppSystemEventType = RpcAppSystemEventType(1);
#[doc = "The client has requested the application to exit.\n\n The application must exit after receiving this command."]
pub const RpcAppEventTypeAppExit: RpcAppSystemEventType = RpcAppSystemEventType(2);
#[doc = "The client has requested the application to load a file.\n\n This command's meaning is application-specific, i.e. the application might or\n might not require additional commands after loading a file to do anything useful."]
pub const RpcAppEventTypeLoadFile: RpcAppSystemEventType = RpcAppSystemEventType(3);
#[doc = "The client has informed the application that a button has been pressed.\n\n This command's meaning is application-specific, e.g. to select a part of the\n previously loaded file or to invoke a particular function within the application."]
pub const RpcAppEventTypeButtonPress: RpcAppSystemEventType = RpcAppSystemEventType(4);
#[doc = "The client has informed the application that a button has been released.\n\n This command's meaning is application-specific, e.g. to cease\n all activities to be conducted while a button is being pressed."]
pub const RpcAppEventTypeButtonRelease: RpcAppSystemEventType = RpcAppSystemEventType(5);
#[doc = "The client has informed the application that a button has been pressed and released.\n\n This command's meaning is application-specific, e.g. to perform an action\n once without repeating it."]
pub const RpcAppEventTypeButtonPressRelease: RpcAppSystemEventType = RpcAppSystemEventType(6);
#[doc = "The client has sent a byte array of arbitrary size.\n\n This command's purpose is bi-directional exchange of arbitrary raw data.\n Useful for implementing higher-level protocols while using the RPC as a transport layer."]
pub const RpcAppEventTypeDataExchange: RpcAppSystemEventType = RpcAppSystemEventType(7);
#[repr(transparent)]
#[doc = "Enumeration of possible event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RpcAppSystemEventType(pub core::ffi::c_uchar);
#[doc = "RPC application subsystem event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpcAppSystemEvent {
    #[doc = "< Type of the event."]
    pub type_: RpcAppSystemEventType,
    #[doc = "< Data associated with the event."]
    pub data: RpcAppSystemEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RpcAppSystemEvent"][::core::mem::size_of::<RpcAppSystemEvent>() - 16usize];
    ["Alignment of RpcAppSystemEvent"][::core::mem::align_of::<RpcAppSystemEvent>() - 4usize];
    ["Offset of field: RpcAppSystemEvent::type_"]
        [::core::mem::offset_of!(RpcAppSystemEvent, type_) - 0usize];
    ["Offset of field: RpcAppSystemEvent::data"]
        [::core::mem::offset_of!(RpcAppSystemEvent, data) - 4usize];
};
#[doc = "Callback function type.\n\n A function of this type must be passed to rpc_system_app_set_callback() by the user code.\n\n The event pointer is valid ONLY inside the callback function.\n\n # Arguments\n\n* `event` (direction in) - pointer to the event object. Valid only inside the callback function.\n * `context` (direction in, out) - pointer to the user-defined context object."]
pub type RpcAppSystemCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *const RpcAppSystemEvent, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcAppSystem {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Set the callback function for use by an RpcAppSystem instance.\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be configured.\n * `callback` (direction in) - pointer to the function to be called upon message reception.\n * `context` (direction in, out) - pointer to the user-defined context object. Will be passed to the callback."]
    pub fn rpc_system_app_set_callback(
        rpc_app: *mut RpcAppSystem,
        callback: RpcAppSystemCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Send a notification that an RpcAppSystem instance has been started and is ready.\n\n Call this function once right after acquiring an RPC context and setting the callback.\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be used."]
    pub fn rpc_system_app_send_started(rpc_app: *mut RpcAppSystem);
}
unsafe extern "C" {
    #[doc = "Send a notification that the application using an RpcAppSystem instance is about to exit.\n\n Call this function when the application is about to exit (usually in the *_free() function).\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be used."]
    pub fn rpc_system_app_send_exited(rpc_app: *mut RpcAppSystem);
}
unsafe extern "C" {
    #[doc = "Send a confirmation that the application using an RpcAppSystem instance has handled the event.\n\n An explicit confirmation is required for the following event types:\n - RpcAppEventTypeAppExit\n - RpcAppEventTypeLoadFile\n - RpcAppEventTypeButtonPress\n - RpcAppEventTypeButtonRelease\n - RpcAppEventTypeButtonPressRelease\n - RpcAppEventTypeDataExchange\n\n Not confirming these events will result in a client-side timeout.\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be used.\n * `result` (direction in) - whether the command was successfully handled or not (true for success)."]
    pub fn rpc_system_app_confirm(rpc_app: *mut RpcAppSystem, result: bool);
}
unsafe extern "C" {
    #[doc = "Set the error code stored in an RpcAppSystem instance.\n\n The error code can be retrieved by the client at any time by using the GetError request.\n The error code value has no meaning within the subsystem, i.e. it is only passed through to the client.\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be modified.\n * `error_code` (direction in) - arbitrary error code to be set."]
    pub fn rpc_system_app_set_error_code(rpc_app: *mut RpcAppSystem, error_code: u32);
}
unsafe extern "C" {
    #[doc = "Set the error text stored in an RpcAppSystem instance.\n\n The error text can be retrieved by the client at any time by using the GetError request.\n The text has no meaning within the subsystem, i.e. it is only passed through to the client.\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be modified.\n * `error_text` (direction in) - Pointer to a zero-terminated string containing the error text."]
    pub fn rpc_system_app_set_error_text(
        rpc_app: *mut RpcAppSystem,
        error_text: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Reset the error code and text stored in an RpcAppSystem instance.\n\n Resets the error code to 0 and error text to \"\" (empty string).\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be reset."]
    pub fn rpc_system_app_error_reset(rpc_app: *mut RpcAppSystem);
}
unsafe extern "C" {
    #[doc = "Send a byte array of arbitrary data to the client using an RpcAppSystem instance.\n\n # Arguments\n\n* `rpc_app` (direction in, out) - pointer to the instance to be used.\n * `data` (direction in) - pointer to the data buffer to be sent.\n * `data_size` (direction in) - size of the data buffer, in bytes."]
    pub fn rpc_system_app_exchange_data(
        rpc_app: *mut RpcAppSystem,
        data: *const u8,
        data_size: usize,
    );
}
pub const BitLibParityEven: BitLibParity = BitLibParity(0);
pub const BitLibParityOdd: BitLibParity = BitLibParity(1);
pub const BitLibParityAlways0: BitLibParity = BitLibParity(2);
pub const BitLibParityAlways1: BitLibParity = BitLibParity(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BitLibParity(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Push a bit into a byte array.\n # Arguments\n\n* `data` - array to push bit into\n * `data_size` - array size\n * `bit` - bit to push"]
    pub fn bit_lib_push_bit(data: *mut u8, data_size: usize, bit: bool);
}
unsafe extern "C" {
    #[doc = "Set a bit in a byte array.\n # Arguments\n\n* `data` - array to set bit in\n * `position` - The position of the bit to set.\n * `bit` - bit value to set"]
    pub fn bit_lib_set_bit(data: *mut u8, position: usize, bit: bool);
}
unsafe extern "C" {
    #[doc = "Set the bit at the given position to the given value.\n # Arguments\n\n* `data` - The data to set the bit in.\n * `position` - The position of the bit to set.\n * `byte` - The data to set the bit to.\n * `length` - The length of the data."]
    pub fn bit_lib_set_bits(data: *mut u8, position: usize, byte: u8, length: u8);
}
unsafe extern "C" {
    #[doc = "Get the bit of a byte.\n # Arguments\n\n* `data` - The byte to get the bits from.\n * `position` - The position of the bit.\n # Returns\n\nThe bit."]
    pub fn bit_lib_get_bit(data: *const u8, position: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the bits of a data, as uint8_t.\n # Arguments\n\n* `data` - The data to get the bits from.\n * `position` - The position of the first bit.\n * `length` - The length of the bits.\n # Returns\n\nThe bits."]
    pub fn bit_lib_get_bits(data: *const u8, position: usize, length: u8) -> u8;
}
unsafe extern "C" {
    #[doc = "Get the bits of a data, as uint16_t.\n # Arguments\n\n* `data` - The data to get the bits from.\n * `position` - The position of the first bit.\n * `length` - The length of the bits.\n # Returns\n\nThe bits."]
    pub fn bit_lib_get_bits_16(data: *const u8, position: usize, length: u8) -> u16;
}
unsafe extern "C" {
    #[doc = "Get the bits of a data, as uint32_t.\n # Arguments\n\n* `data` - The data to get the bits from.\n * `position` - The position of the first bit.\n * `length` - The length of the bits.\n # Returns\n\nThe bits."]
    pub fn bit_lib_get_bits_32(data: *const u8, position: usize, length: u8) -> u32;
}
unsafe extern "C" {
    #[doc = "Get the bits of a data, as uint64_t.\n # Arguments\n\n* `data` - The data to get the bits from.\n * `position` - The position of the first bit.\n * `length` - The length of the bits.\n # Returns\n\nThe bits."]
    pub fn bit_lib_get_bits_64(data: *const u8, position: usize, length: u8) -> u64;
}
unsafe extern "C" {
    #[doc = "Test parity of given bits\n # Arguments\n\n* `bits` - Bits to test parity of\n * `parity` - Parity to test against\n # Returns\n\ntrue if parity is correct, false otherwise"]
    pub fn bit_lib_test_parity_32(bits: u32, parity: BitLibParity) -> bool;
}
unsafe extern "C" {
    #[doc = "Test parity of bit array, check parity for every parity_length block from start\n\n # Arguments\n\n* `data` - Bit array\n * `position` - Start position\n * `length` - Bit count\n * `parity` - Parity to test against\n * `parity_length` - Parity block length\n # Returns\n\ntrue\n false"]
    pub fn bit_lib_test_parity(
        data: *const u8,
        position: usize,
        length: u8,
        parity: BitLibParity,
        parity_length: u8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add parity to bit array\n\n # Arguments\n\n* `data` - Source bit array\n * `position` - Start position\n * `dest` - Destination bit array\n * `dest_position` - Destination position\n * `source_length` - Source bit count\n * `parity_length` - Parity block length\n * `parity` - Parity to test against\n # Returns\n\nsize_t"]
    pub fn bit_lib_add_parity(
        data: *const u8,
        position: usize,
        dest: *mut u8,
        dest_position: usize,
        source_length: u8,
        parity_length: u8,
        parity: BitLibParity,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Remove bit every n in array and shift array left. Useful to remove parity.\n\n # Arguments\n\n* `data` - Bit array\n * `position` - Start position\n * `length` - Bit count\n * `n` - every n bit will be removed\n # Returns\n\nsize_t"]
    pub fn bit_lib_remove_bit_every_nth(data: *mut u8, position: usize, length: u8, n: u8)
    -> usize;
}
unsafe extern "C" {
    #[doc = "Copy bits from source to destination.\n\n # Arguments\n\n* `data` - destination array\n * `position` - position in destination array\n * `length` - length of bits to copy\n * `source` - source array\n * `source_position` - position in source array"]
    pub fn bit_lib_copy_bits(
        data: *mut u8,
        position: usize,
        length: usize,
        source: *const u8,
        source_position: usize,
    );
}
unsafe extern "C" {
    #[doc = "Reverse bits in bit array\n\n # Arguments\n\n* `data` - Bit array\n * `position` - start position\n * `length` - length of bits to reverse"]
    pub fn bit_lib_reverse_bits(data: *mut u8, position: usize, length: u8);
}
unsafe extern "C" {
    #[doc = "Count 1 bits in data\n\n # Arguments\n\n* `data` -\n # Returns\n\nuint8_t set bit count"]
    pub fn bit_lib_get_bit_count(data: u32) -> u8;
}
unsafe extern "C" {
    #[doc = "Print data as bit array\n\n # Arguments\n\n* `data` -\n * `length` -"]
    pub fn bit_lib_print_bits(data: *const u8, length: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitLibRegion {
    pub mark: core::ffi::c_char,
    pub start: usize,
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BitLibRegion"][::core::mem::size_of::<BitLibRegion>() - 12usize];
    ["Alignment of BitLibRegion"][::core::mem::align_of::<BitLibRegion>() - 4usize];
    ["Offset of field: BitLibRegion::mark"][::core::mem::offset_of!(BitLibRegion, mark) - 0usize];
    ["Offset of field: BitLibRegion::start"][::core::mem::offset_of!(BitLibRegion, start) - 4usize];
    ["Offset of field: BitLibRegion::length"]
        [::core::mem::offset_of!(BitLibRegion, length) - 8usize];
};
unsafe extern "C" {
    #[doc = "Print data as bit array and mark regions. Regions needs to be sorted by start position.\n\n # Arguments\n\n* `regions` -\n * `region_count` -\n * `data` -\n * `length` -"]
    pub fn bit_lib_print_regions(
        regions: *const BitLibRegion,
        region_count: usize,
        data: *const u8,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Reverse bits in uint16_t, faster than generic bit_lib_reverse_bits.\n\n # Arguments\n\n* `data` -\n # Returns\n\nuint16_t"]
    pub fn bit_lib_reverse_16_fast(data: u16) -> u16;
}
unsafe extern "C" {
    #[doc = "Reverse bits in uint8_t, faster than generic bit_lib_reverse_bits.\n\n # Arguments\n\n* `byte` - Byte\n # Returns\n\nuint8_t the reversed byte"]
    pub fn bit_lib_reverse_8_fast(byte: u8) -> u8;
}
unsafe extern "C" {
    #[doc = "Slow, but generic CRC8 implementation\n\n # Arguments\n\n* `data` -\n * `data_size` -\n * `polynom` - CRC polynom\n * `init` - init value\n * `ref_in` - true if the right bit is older\n * `ref_out` - true to reverse output\n * `xor_out` - xor output with this value\n # Returns\n\nuint8_t"]
    pub fn bit_lib_crc8(
        data: *const u8,
        data_size: usize,
        polynom: u8,
        init: u8,
        ref_in: bool,
        ref_out: bool,
        xor_out: u8,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = "Slow, but generic CRC16 implementation\n\n # Arguments\n\n* `data` -\n * `data_size` -\n * `polynom` - CRC polynom\n * `init` - init value\n * `ref_in` - true if the right bit is older\n * `ref_out` - true to reverse output\n * `xor_out` - xor output with this value\n # Returns\n\nuint16_t"]
    pub fn bit_lib_crc16(
        data: *const u8,
        data_size: usize,
        polynom: u16,
        init: u16,
        ref_in: bool,
        ref_out: bool,
        xor_out: u16,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = "Convert number to bytes in big endian order\n\n # Arguments\n\n* `src` - number to convert\n * `len` - max used bytes count\n * `dest` - destination\n # Returns\n\nvoid"]
    pub fn bit_lib_num_to_bytes_be(src: u64, len: u8, dest: *mut u8);
}
unsafe extern "C" {
    #[doc = "Convert number to bytes in little endian order\n\n # Arguments\n\n* `src` - number to convert\n * `len` - max used bytes count\n * `dest` - destination\n # Returns\n\nvoid"]
    pub fn bit_lib_num_to_bytes_le(src: u64, len: u8, dest: *mut u8);
}
unsafe extern "C" {
    #[doc = "Convert bytes to number in big endian order\n\n # Arguments\n\n* `src` - byte array\n * `len` - max used bytes count\n # Returns\n\nuint64_t"]
    pub fn bit_lib_bytes_to_num_be(src: *const u8, len: u8) -> u64;
}
unsafe extern "C" {
    #[doc = "Convert bytes to number in little endian order\n\n # Arguments\n\n* `src` - byte array\n * `len` - max used bytes count\n # Returns\n\nuint64_t"]
    pub fn bit_lib_bytes_to_num_le(src: *const u8, len: u8) -> u64;
}
unsafe extern "C" {
    #[doc = "Convert bytes in binary-coded decimal encoding to number\n\n # Arguments\n\n* `src` - byte array\n * `len` - max used bytes count\n * `is_bcd` - will be true if all processed bytes is BCD encoded (no A-F nibbles)\n # Returns\n\nuint64_t"]
    pub fn bit_lib_bytes_to_num_bcd(src: *const u8, len: u8, is_bcd: *mut bool) -> u64;
}
#[doc = "Optional arguments to pass along with profile template as\n FuriHalBleProfileParams for tuning profile behavior"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleProfileHidParams {
    #[doc = "< Prefix for device name. Length must be less than 8"]
    pub device_name_prefix: *const core::ffi::c_char,
    #[doc = "< XOR mask for device address, for uniqueness"]
    pub mac_xor: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleProfileHidParams"][::core::mem::size_of::<BleProfileHidParams>() - 8usize];
    ["Alignment of BleProfileHidParams"][::core::mem::align_of::<BleProfileHidParams>() - 4usize];
    ["Offset of field: BleProfileHidParams::device_name_prefix"]
        [::core::mem::offset_of!(BleProfileHidParams, device_name_prefix) - 0usize];
    ["Offset of field: BleProfileHidParams::mac_xor"]
        [::core::mem::offset_of!(BleProfileHidParams, mac_xor) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleServiceHid {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DigitalSignal {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Append one period to the end of the DigitalSignal instance.\n\n # Arguments\n\n* `signal` (direction in, out) - pointer to a the instance to append to.\n * `ticks` (direction in) - the period length, in 10 picosecond units."]
    pub fn digital_signal_add_period(signal: *mut DigitalSignal, ticks: u32);
}
unsafe extern "C" {
    #[doc = "Append one period to the end of the DigitalSignal instance, with the level specified.\n\n If the level is the same as the last level contained in the instance, then it is extened\n by the given ticks value. Otherwise, the behaviour is identical to digital_signal_add_period().\n\n Example 1: add tc with HIGH level\n ```\n before:\n ... ------+\n ta | tb\n +-------\n after:\n ... ------+ +-------\n ta | tb | tc\n +------+\n ```\n Example 2: add tc with LOW level\n ```\n before:\n ... ------+\n ta | tb\n +-------\n after:\n ... ------+\n ta | tb + tc\n +--------------\n ```\n\n # Arguments\n\n* `signal` (direction in, out) - pointer to the instance to append to.\n * `ticks` (direction in) - the period length, in 10 picosecond units.\n * `level` (direction in) - the level to be set during the period."]
    pub fn digital_signal_add_period_with_level(
        signal: *mut DigitalSignal,
        ticks: u32,
        level: bool,
    );
}
unsafe extern "C" {
    #[doc = "Get the current start level contained in the DigitalSignal instance.\n\n If not explicitly set with digital_signal_set_start_level(), it defaults to false.\n\n # Arguments\n\n* `signal` (direction in) - pointer to the instance to be queried.\n # Returns\n\nthe start level value."]
    pub fn digital_signal_get_start_level(signal: *const DigitalSignal) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the start level contained in the DigitalSignal instance.\n\n # Arguments\n\n* `signal` (direction in, out) - pointer to the instance to be modified.\n * `level` (direction in) - signal level to be set as the start level."]
    pub fn digital_signal_set_start_level(signal: *mut DigitalSignal, level: bool);
}
unsafe extern "C" {
    #[doc = "Get the number of periods currently stored in a DigitalSignal instance.\n\n # Arguments\n\n* `signal` (direction in) - pointer to the instance to be queried.\n # Returns\n\nthe number of periods stored in the instance."]
    pub fn digital_signal_get_size(signal: *const DigitalSignal) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DigitalSequence {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Register a signal within a DigitalSequence instance by its index.\n\n This function must be called for each signal to be used in the sequence. The DigitalSequence\n instance does not own the signals, therefore, their lifetime must be no less than the instance's.\n\n The user is responsible for creation and deletion of DigitalSignal instances and\n also for keeping track of their respective indices.\n\n # Arguments\n\n* `sequence` (direction in, out) - pointer to the instance to be modified.\n * `signal_index` (direction in) - index to register the signal under (must be less than 32).\n * `signal` (direction in) - pointer to the DigitalSignal instance to be registered."]
    pub fn digital_sequence_register_signal(
        sequence: *mut DigitalSequence,
        signal_index: u8,
        signal: *const DigitalSignal,
    );
}
unsafe extern "C" {
    #[doc = "Append a signal index to a DigitalSequence instance.\n\n The signal under the index must be registered beforehand by calling digital_sequence_set_signal().\n\n # Arguments\n\n* `sequence` (direction in, out) - pointer to the instance to be modified.\n * `signal_index` (direction in) - signal index to be appended to the sequence (must be less than 32)."]
    pub fn digital_sequence_add_signal(sequence: *mut DigitalSequence, signal_index: u8);
}
unsafe extern "C" {
    #[doc = "Transmit the sequence contained in the DigitalSequence instance.\n\n Must contain at least one registered signal and one signal index.\n\n NOTE: The current implementation will properly initialise the GPIO provided during construction,\n but it is the caller's responsibility to reconfigure it back before reusing for other purposes.\n This is due to performance reasons.\n\n # Arguments\n\n* `sequence` (direction in) - pointer to the sequence to be transmitted."]
    pub fn digital_sequence_transmit(sequence: *mut DigitalSequence);
}
unsafe extern "C" {
    #[doc = "Read register\n\n # Arguments\n\n* `handle` - - pointer t FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `val` - - pointer to the variable to store the read value"]
    pub fn st25r3916_read_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, val: *mut u8);
}
unsafe extern "C" {
    #[doc = "Read multiple registers\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg_start` - - start register address\n * `values` - - pointer to the buffer to store the read values\n * `length` - - number of registers to read"]
    pub fn st25r3916_read_burst_regs(
        handle: *mut FuriHalSpiBusHandle,
        reg_start: u8,
        values: *mut u8,
        length: u8,
    );
}
unsafe extern "C" {
    #[doc = "Write register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `val` - - value to write"]
    pub fn st25r3916_write_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, val: u8);
}
unsafe extern "C" {
    #[doc = "Write multiple registers\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg_start` - - start register address\n * `values` - - pointer to buffer to write\n * `length` - - number of registers to write"]
    pub fn st25r3916_write_burst_regs(
        handle: *mut FuriHalSpiBusHandle,
        reg_start: u8,
        values: *const u8,
        length: u8,
    );
}
unsafe extern "C" {
    #[doc = "Write fifo register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `buff` - - buffer to write to FIFO\n * `length` - - number of bytes to write"]
    pub fn st25r3916_reg_write_fifo(
        handle: *mut FuriHalSpiBusHandle,
        buff: *const u8,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Read fifo register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `buff` - - buffer to store the read values\n * `length` - - number of bytes to read"]
    pub fn st25r3916_reg_read_fifo(handle: *mut FuriHalSpiBusHandle, buff: *mut u8, length: usize);
}
unsafe extern "C" {
    #[doc = "Write PTA memory register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `values` - - pointer to buffer to write\n * `length` - - number of bytes to write"]
    pub fn st25r3916_write_pta_mem(
        handle: *mut FuriHalSpiBusHandle,
        values: *const u8,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Read PTA memory register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `values` - - buffer to store the read values\n * `length` - - number of bytes to read"]
    pub fn st25r3916_read_pta_mem(handle: *mut FuriHalSpiBusHandle, values: *mut u8, length: usize);
}
unsafe extern "C" {
    #[doc = "Write PTF memory register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `values` - - pointer to buffer to write\n * `length` - - number of bytes to write"]
    pub fn st25r3916_write_ptf_mem(
        handle: *mut FuriHalSpiBusHandle,
        values: *const u8,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Read PTTSN memory register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `values` - - pointer to buffer to write\n * `length` - - number of bytes to write"]
    pub fn st25r3916_write_pttsn_mem(
        handle: *mut FuriHalSpiBusHandle,
        values: *mut u8,
        length: usize,
    );
}
unsafe extern "C" {
    #[doc = "Send Direct command\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `cmd` - - direct command"]
    pub fn st25r3916_direct_cmd(handle: *mut FuriHalSpiBusHandle, cmd: u8);
}
unsafe extern "C" {
    #[doc = "Read test register\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `val` - - pointer to the variable to store the read value"]
    pub fn st25r3916_read_test_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, val: *mut u8);
}
unsafe extern "C" {
    #[doc = "Write test register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `val` - - value to write"]
    pub fn st25r3916_write_test_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, val: u8);
}
unsafe extern "C" {
    #[doc = "Clear register bits\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `clr_mask` - - bit mask to clear"]
    pub fn st25r3916_clear_reg_bits(handle: *mut FuriHalSpiBusHandle, reg: u8, clr_mask: u8);
}
unsafe extern "C" {
    #[doc = "Set register bits\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `set_mask` - - bit mask to set"]
    pub fn st25r3916_set_reg_bits(handle: *mut FuriHalSpiBusHandle, reg: u8, set_mask: u8);
}
unsafe extern "C" {
    #[doc = "Change register bits\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `mask` - - bit mask to change\n * `value` - - new register value to write"]
    pub fn st25r3916_change_reg_bits(
        handle: *mut FuriHalSpiBusHandle,
        reg: u8,
        mask: u8,
        value: u8,
    );
}
unsafe extern "C" {
    #[doc = "Modify register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `clr_mask` - - bit mask to clear\n * `set_mask` - - bit mask to set"]
    pub fn st25r3916_modify_reg(
        handle: *mut FuriHalSpiBusHandle,
        reg: u8,
        clr_mask: u8,
        set_mask: u8,
    );
}
unsafe extern "C" {
    #[doc = "Change test register bits\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `mask` - - bit mask to change\n * `value` - - new register value to write"]
    pub fn st25r3916_change_test_reg_bits(
        handle: *mut FuriHalSpiBusHandle,
        reg: u8,
        mask: u8,
        value: u8,
    );
}
unsafe extern "C" {
    #[doc = "Check register\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `reg` - - register address\n * `mask` - - bit mask to check\n * `val` - - expected register value\n\n # Returns\n\ntrue if register value matches the expected value, false otherwise"]
    pub fn st25r3916_check_reg(
        handle: *mut FuriHalSpiBusHandle,
        reg: u8,
        mask: u8,
        val: u8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Mask st25r3916 interrupts\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `mask` - - mask of interrupts to be disabled"]
    pub fn st25r3916_mask_irq(handle: *mut FuriHalSpiBusHandle, mask: u32);
}
unsafe extern "C" {
    #[doc = "Get st25r3916 interrupts\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n\n # Returns\n\nreceived interrupts"]
    pub fn st25r3916_get_irq(handle: *mut FuriHalSpiBusHandle) -> u32;
}
unsafe extern "C" {
    #[doc = "Write FIFO\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `buff` - - buffer to write to FIFO\n * `bits` - - number of bits to write"]
    pub fn st25r3916_write_fifo(handle: *mut FuriHalSpiBusHandle, buff: *const u8, bits: usize);
}
unsafe extern "C" {
    #[doc = "Read FIFO\n\n # Arguments\n\n* `handle` - - pointer to FuriHalSpiBusHandle instance\n * `buff` - - buffer to read from FIFO\n * `buff_size` - - buffer size n bytes\n * `buff_bits` - - pointer to number of bits read\n\n # Returns\n\ntrue if read success, false otherwise"]
    pub fn st25r3916_read_fifo(
        handle: *mut FuriHalSpiBusHandle,
        buff: *mut u8,
        buff_size: usize,
        buff_bits: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Resolver for API entries using a pre-sorted table with hashes\n # Arguments\n\n* `interface` - pointer to HashtableApiInterface\n * `hash` - gnu hash of function name\n * `address` - output for function address\n # Returns\n\ntrue if the table contains a function"]
    pub fn elf_resolve_from_hashtable(
        interface: *const ElfApiInterface,
        hash: u32,
        address: *mut Elf32_Addr,
    ) -> bool;
}
unsafe extern "C" {
    pub fn elf_symbolname_hash(s: *const core::ffi::c_char) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompositeApiResolver {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate composite API resolver\n # Returns\n\nCompositeApiResolver* instance"]
    pub fn composite_api_resolver_alloc() -> *mut CompositeApiResolver;
}
unsafe extern "C" {
    #[doc = "Free composite API resolver\n # Arguments\n\n* `resolver` - Instance"]
    pub fn composite_api_resolver_free(resolver: *mut CompositeApiResolver);
}
unsafe extern "C" {
    #[doc = "Add API resolver to composite resolver\n # Arguments\n\n* `resolver` - Instance\n * `interface` - API resolver"]
    pub fn composite_api_resolver_add(
        resolver: *mut CompositeApiResolver,
        interface: *const ElfApiInterface,
    );
}
unsafe extern "C" {
    #[doc = "Get API interface from composite resolver\n # Arguments\n\n* `resolver` - Instance\n # Returns\n\nAPI interface"]
    pub fn composite_api_resolver_get(
        resolver: *mut CompositeApiResolver,
    ) -> *const ElfApiInterface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PluginManager {
    _unused: [u8; 0],
}
pub const PluginManagerErrorNone: PluginManagerError = PluginManagerError(0);
pub const PluginManagerErrorLoaderError: PluginManagerError = PluginManagerError(1);
pub const PluginManagerErrorApplicationIdMismatch: PluginManagerError = PluginManagerError(2);
pub const PluginManagerErrorAPIVersionMismatch: PluginManagerError = PluginManagerError(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PluginManagerError(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Allocates new PluginManager\n # Arguments\n\n* `application_id` - Application ID filter - only plugins with matching ID will be loaded\n * `api_version` - Application API version filter - only plugins with matching API version\n * `api_interface` - Application API interface - used to resolve plugins' API imports\n If plugin uses private application's API, use CompoundApiInterface\n # Returns\n\nnew PluginManager instance"]
    pub fn plugin_manager_alloc(
        application_id: *const core::ffi::c_char,
        api_version: u32,
        api_interface: *const ElfApiInterface,
    ) -> *mut PluginManager;
}
unsafe extern "C" {
    #[doc = "Frees PluginManager\n # Arguments\n\n* `manager` - PluginManager instance"]
    pub fn plugin_manager_free(manager: *mut PluginManager);
}
unsafe extern "C" {
    #[doc = "Loads single plugin by full path\n # Arguments\n\n* `manager` - PluginManager instance\n * `path` - Path to plugin\n # Returns\n\nError code"]
    pub fn plugin_manager_load_single(
        manager: *mut PluginManager,
        path: *const core::ffi::c_char,
    ) -> PluginManagerError;
}
unsafe extern "C" {
    #[doc = "Loads all plugins from specified directory\n # Arguments\n\n* `manager` - PluginManager instance\n * `path` - Path to directory\n # Returns\n\nError code"]
    pub fn plugin_manager_load_all(
        manager: *mut PluginManager,
        path: *const core::ffi::c_char,
    ) -> PluginManagerError;
}
unsafe extern "C" {
    #[doc = "Returns number of loaded plugins\n # Arguments\n\n* `manager` - PluginManager instance\n # Returns\n\nNumber of loaded plugins"]
    pub fn plugin_manager_get_count(manager: *mut PluginManager) -> u32;
}
unsafe extern "C" {
    #[doc = "Returns plugin descriptor by index\n # Arguments\n\n* `manager` - PluginManager instance\n * `index` - Plugin index\n # Returns\n\nPlugin descriptor"]
    pub fn plugin_manager_get(
        manager: *mut PluginManager,
        index: u32,
    ) -> *const FlipperAppPluginDescriptor;
}
unsafe extern "C" {
    #[doc = "Returns plugin entry point by index\n # Arguments\n\n* `manager` - PluginManager instance\n * `index` - Plugin index\n # Returns\n\nPlugin entry point"]
    pub fn plugin_manager_get_ep(
        manager: *mut PluginManager,
        index: u32,
    ) -> *const core::ffi::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperFormat {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate FlipperFormat as string.\n\n # Returns\n\nFlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_string_alloc() -> *mut FlipperFormat;
}
unsafe extern "C" {
    #[doc = "Allocate FlipperFormat as file.\n\n # Arguments\n\n* `storage` - The storage\n\n # Returns\n\nFlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
unsafe extern "C" {
    #[doc = "Allocate FlipperFormat as file, buffered mode.\n\n # Arguments\n\n* `storage` - The storage\n\n # Returns\n\nFlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_buffered_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
unsafe extern "C" {
    #[doc = "Open existing file. Use only if FlipperFormat allocated as a file.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `path` - File path\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open existing file, buffered mode. Use only if FlipperFormat allocated as a\n buffered file.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `path` - File path\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_buffered_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open existing file for writing and add values to the end of file. Use only if\n FlipperFormat allocated as a file.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `path` - File path\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_file_open_append(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open file. Creates a new file, or deletes the contents of the file if it\n already exists. Use only if FlipperFormat allocated as a file.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `path` - File path\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_file_open_always(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open file. Creates a new file, or deletes the contents of the file if it\n already exists, buffered mode. Use only if FlipperFormat allocated as a\n buffered file.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `path` - File path\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_buffered_file_open_always(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open file. Creates a new file, fails if file already exists. Use only if\n FlipperFormat allocated as a file.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `path` - File path\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_file_open_new(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Closes the file, use only if FlipperFormat allocated as a file.\n\n # Arguments\n\n* `flipper_format` - The flipper format\n\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    #[doc = "Closes the file, use only if FlipperFormat allocated as a buffered file.\n\n # Arguments\n\n* `flipper_format` - The flipper format\n\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_buffered_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    #[doc = "Free FlipperFormat.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance"]
    pub fn flipper_format_free(flipper_format: *mut FlipperFormat);
}
unsafe extern "C" {
    #[doc = "Set FlipperFormat mode.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `strict_mode` - True obligates not to skip valid fields. False by\n default."]
    pub fn flipper_format_set_strict_mode(flipper_format: *mut FlipperFormat, strict_mode: bool);
}
unsafe extern "C" {
    #[doc = "Rewind the RW pointer.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_rewind(flipper_format: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    #[doc = "Move the RW pointer at the end. Can be useful if you want to add some data\n after reading.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_seek_to_end(flipper_format: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    #[doc = "Check if the key exists.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n\n # Returns\n\ntrue key exists\n false key is not exists"]
    pub fn flipper_format_key_exist(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read the header (file type and version).\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `filetype` - File type string\n * `version` - Version Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: *mut u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write the header (file type and version).\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `filetype` - File type string\n * `version` - Version Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write the header (file type and version). Plain C string version.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `filetype` - File type string\n * `version` - Version Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_header_cstr(
        flipper_format: *mut FlipperFormat,
        filetype: *const core::ffi::c_char,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the count of values by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - The key\n * `count` - The count\n\n # Returns\n\nbool"]
    pub fn flipper_format_get_value_count(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        count: *mut u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read a string by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and string\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and string. Plain C string version.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read array of uint64 in hex format by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u64,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and array of uint64 in hex format\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u64,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read array of uint32 by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and array of uint32\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read array of int32 by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut i32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and array of int32\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read array of bool by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut bool,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and array of bool\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read array of float by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut f32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and array of float\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read array of hex-formatted bytes by key\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_read_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u8,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write key and array of hex-formatted bytes\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` - Values count\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write comment\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `data` - Comment text\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_comment(
        flipper_format: *mut FlipperFormat,
        data: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write comment. Plain C string version.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `data` - Comment text\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_comment_cstr(
        flipper_format: *mut FlipperFormat,
        data: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write empty line (Improves readability for human based parsing)\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_write_empty_line(flipper_format: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    #[doc = "Removes the first matching key and its value. Sets the RW pointer to a\n position of deleted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_delete_key(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a string value. Sets the RW\n pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a string value. Plain C\n version. Sets the RW pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a uint32 array value. Sets the\n RW pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a int32 array value. Sets the\n RW pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a bool array value. Sets the\n RW pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a float array value. Sets the\n RW pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to an array of hex-formatted\n bytes. Sets the RW pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a string value, or adds the\n key and value if the key did not exist. Sets the RW pointer to a position at\n the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a string value, or adds the\n key and value if the key did not exist. Plain C version. Sets the RW pointer\n to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a uint32 array value, or adds\n the key and value if the key did not exist. Sets the RW pointer to a position\n at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a int32 array value, or adds\n the key and value if the key did not exist. Sets the RW pointer to a position\n at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a bool array value, or adds\n the key and value if the key did not exist. Sets the RW pointer to a position\n at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to a float array value, or adds\n the key and value if the key did not exist. Sets the RW pointer to a position\n at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Updates the value of the first matching key to an array of hex-formatted\n bytes, or adds the key and value if the key did not exist. Sets the RW\n pointer to a position at the end of inserted data.\n\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `key` - Key\n * `data` - Value\n * `data_size` (direction in) - The data size\n\n # Returns\n\nTrue on success"]
    pub fn flipper_format_insert_or_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stream {
    _unused: [u8; 0],
}
pub const StreamOffsetFromCurrent: StreamOffset = StreamOffset(0);
pub const StreamOffsetFromStart: StreamOffset = StreamOffset(1);
pub const StreamOffsetFromEnd: StreamOffset = StreamOffset(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StreamOffset(pub core::ffi::c_uchar);
pub const StreamDirectionForward: StreamDirection = StreamDirection(0);
pub const StreamDirectionBackward: StreamDirection = StreamDirection(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StreamDirection(pub core::ffi::c_uchar);
pub type StreamWriteCB = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut Stream, context: *const core::ffi::c_void) -> bool,
>;
unsafe extern "C" {
    #[doc = "Free Stream\n # Arguments\n\n* `stream` - Stream instance"]
    pub fn stream_free(stream: *mut Stream);
}
unsafe extern "C" {
    #[doc = "Clean (empty) Stream\n # Arguments\n\n* `stream` - Stream instance"]
    pub fn stream_clean(stream: *mut Stream);
}
unsafe extern "C" {
    #[doc = "Indicates that the RW pointer is at the end of the stream\n # Arguments\n\n* `stream` - Stream instance\n # Returns\n\ntrue if RW pointer is at the end of the stream\n false if RW pointer is not at the end of the stream"]
    pub fn stream_eof(stream: *mut Stream) -> bool;
}
unsafe extern "C" {
    #[doc = "Moves the RW pointer.\n # Arguments\n\n* `stream` - Stream instance\n * `offset` - how much to move the pointer\n * `offset_type` - starting from what\n # Returns\n\ntrue\n false"]
    pub fn stream_seek(stream: *mut Stream, offset: i32, offset_type: StreamOffset) -> bool;
}
unsafe extern "C" {
    #[doc = "Seek to next occurrence of the character\n\n # Arguments\n\n* `stream` - Pointer to the stream instance\n * `c` (direction in) - The Character\n * `direction` (direction in) - The Direction\n\n # Returns\n\ntrue on success"]
    pub fn stream_seek_to_char(
        stream: *mut Stream,
        c: core::ffi::c_char,
        direction: StreamDirection,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Gets the value of the RW pointer\n # Arguments\n\n* `stream` - Stream instance\n # Returns\n\nsize_t value of the RW pointer"]
    pub fn stream_tell(stream: *mut Stream) -> usize;
}
unsafe extern "C" {
    #[doc = "Gets the size of the stream\n # Arguments\n\n* `stream` - Stream instance\n # Returns\n\nsize_t size of the stream"]
    pub fn stream_size(stream: *mut Stream) -> usize;
}
unsafe extern "C" {
    #[doc = "Write N bytes to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `data` - data to write\n * `size` - size of data to be written\n # Returns\n\nsize_t how many bytes was written"]
    pub fn stream_write(stream: *mut Stream, data: *const u8, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Read N bytes from stream\n # Arguments\n\n* `stream` - Stream instance\n * `data` - data to be read\n * `count` - size of data to be read\n # Returns\n\nsize_t how many bytes was read"]
    pub fn stream_read(stream: *mut Stream, data: *mut u8, count: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Delete N chars from the stream and write data by calling write_callback(context)\n # Arguments\n\n* `stream` - Stream instance\n * `delete_size` - size of data to be deleted\n * `write_callback` - write callback\n * `context` - write callback context\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete_and_insert(
        stream: *mut Stream,
        delete_size: usize,
        write_callback: StreamWriteCB,
        context: *const core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read line from a stream (supports LF and CRLF line endings)\n # Arguments\n\n* `stream` -\n * `str_result` -\n # Returns\n\ntrue if line length is not zero\n false otherwise"]
    pub fn stream_read_line(stream: *mut Stream, str_result: *mut FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Moves the RW pointer to the start\n # Arguments\n\n* `stream` - Stream instance"]
    pub fn stream_rewind(stream: *mut Stream) -> bool;
}
unsafe extern "C" {
    #[doc = "Write char to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `c` - char value\n # Returns\n\nsize_t how many bytes was written"]
    pub fn stream_write_char(stream: *mut Stream, c: core::ffi::c_char) -> usize;
}
unsafe extern "C" {
    #[doc = "Write string to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `string` - string value\n # Returns\n\nsize_t how many bytes was written"]
    pub fn stream_write_string(stream: *mut Stream, string: *mut FuriString) -> usize;
}
unsafe extern "C" {
    #[doc = "Write const char* to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `string` - c-string value\n # Returns\n\nsize_t how many bytes was written"]
    pub fn stream_write_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> usize;
}
unsafe extern "C" {
    #[doc = "Write formatted string to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `format` -\n * `...` -\n # Returns\n\nsize_t how many bytes was written"]
    pub fn stream_write_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
    -> usize;
}
unsafe extern "C" {
    #[doc = "Write formatted string to the stream, va_list version\n # Arguments\n\n* `stream` - Stream instance\n * `format` -\n * `args` -\n # Returns\n\nsize_t how many bytes was written"]
    pub fn stream_write_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Insert N chars to the stream, starting at the current pointer.\n Data will be inserted, not overwritten, so the stream will be increased in size.\n # Arguments\n\n* `stream` - Stream instance\n * `data` - data to be inserted\n * `size` - size of data to be inserted\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_insert(stream: *mut Stream, data: *const u8, size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Insert char to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `c` - char value\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_insert_char(stream: *mut Stream, c: core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Insert string to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `string` - string value\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_insert_string(stream: *mut Stream, string: *mut FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Insert const char* to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `string` - c-string value\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_insert_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Insert formatted string to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `format` -\n * `...` -\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_insert_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
    -> bool;
}
unsafe extern "C" {
    #[doc = "Insert formatted string to the stream, va_list version\n # Arguments\n\n* `stream` - Stream instance\n * `format` -\n * `args` -\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_insert_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Delete N chars from the stream and insert char to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `delete_size` - size of data to be deleted\n * `c` - char value\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete_and_insert_char(
        stream: *mut Stream,
        delete_size: usize,
        c: core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Delete N chars from the stream and insert string to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `delete_size` - size of data to be deleted\n * `string` - string value\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete_and_insert_string(
        stream: *mut Stream,
        delete_size: usize,
        string: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Delete N chars from the stream and insert const char* to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `delete_size` - size of data to be deleted\n * `string` - c-string value\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete_and_insert_cstring(
        stream: *mut Stream,
        delete_size: usize,
        string: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Delete N chars from the stream and insert formatted string to the stream\n # Arguments\n\n* `stream` - Stream instance\n * `delete_size` - size of data to be deleted\n * `format` -\n * `...` -\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete_and_insert_format(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Delete N chars from the stream and insert formatted string to the stream, va_list version\n # Arguments\n\n* `stream` - Stream instance\n * `delete_size` - size of data to be deleted\n * `format` -\n * `args` -\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete_and_insert_vaformat(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Remove N chars from the stream, starting at the current pointer.\n The size may be larger than stream size, the stream will be cleared from current RW pointer to the end.\n # Arguments\n\n* `stream` - Stream instance\n * `size` - how many chars need to be deleted\n # Returns\n\ntrue if the operation was successful\n false on error"]
    pub fn stream_delete(stream: *mut Stream, size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Copy data from one stream to another. Data will be copied from current RW pointer and to current RW pointer.\n # Arguments\n\n* `stream_from` -\n * `stream_to` -\n * `size` -\n # Returns\n\nsize_t"]
    pub fn stream_copy(stream_from: *mut Stream, stream_to: *mut Stream, size: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Copy data from one stream to another. Data will be copied from start of one stream and to start of other stream.\n # Arguments\n\n* `stream_from` -\n * `stream_to` -\n # Returns\n\nsize_t"]
    pub fn stream_copy_full(stream_from: *mut Stream, stream_to: *mut Stream) -> usize;
}
unsafe extern "C" {
    #[doc = "Splits one stream into two others. The original stream will remain untouched.\n # Arguments\n\n* `stream` -\n * `stream_left` -\n * `stream_right` -\n # Returns\n\ntrue\n false"]
    pub fn stream_split(
        stream: *mut Stream,
        stream_left: *mut Stream,
        stream_right: *mut Stream,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Loads data to the stream from a file. Data will be loaded to the current RW pointer. RW pointer will be moved to the end of the stream.\n # Arguments\n\n* `stream` - Stream instance\n * `storage` -\n * `path` -\n # Returns\n\nsize_t"]
    pub fn stream_load_from_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Writes data from a stream to a file. Data will be saved starting from the current RW pointer. RW pointer will be moved to the end of the stream.\n # Arguments\n\n* `stream` - Stream instance\n * `storage` -\n * `path` -\n * `mode` -\n # Returns\n\nsize_t"]
    pub fn stream_save_to_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        mode: FS_OpenMode,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Dump stream inner data (size, RW position, content)\n # Arguments\n\n* `stream` - Stream instance"]
    pub fn stream_dump_data(stream: *mut Stream);
}
unsafe extern "C" {
    #[doc = "Returns the underlying stream instance.\n Use only if you know what you are doing.\n # Arguments\n\n* `flipper_format` -\n # Returns\n\nStream*"]
    pub fn flipper_format_get_raw_stream(flipper_format: *mut FlipperFormat) -> *mut Stream;
}
pub const FlipperStreamValueIgnore: FlipperStreamValue = FlipperStreamValue(0);
pub const FlipperStreamValueStr: FlipperStreamValue = FlipperStreamValue(1);
pub const FlipperStreamValueHex: FlipperStreamValue = FlipperStreamValue(2);
pub const FlipperStreamValueFloat: FlipperStreamValue = FlipperStreamValue(3);
pub const FlipperStreamValueInt32: FlipperStreamValue = FlipperStreamValue(4);
pub const FlipperStreamValueUint32: FlipperStreamValue = FlipperStreamValue(5);
pub const FlipperStreamValueHexUint64: FlipperStreamValue = FlipperStreamValue(6);
pub const FlipperStreamValueBool: FlipperStreamValue = FlipperStreamValue(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FlipperStreamValue(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperStreamWriteData {
    pub key: *const core::ffi::c_char,
    pub type_: FlipperStreamValue,
    pub data: *const core::ffi::c_void,
    pub data_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlipperStreamWriteData"][::core::mem::size_of::<FlipperStreamWriteData>() - 16usize];
    ["Alignment of FlipperStreamWriteData"]
        [::core::mem::align_of::<FlipperStreamWriteData>() - 4usize];
    ["Offset of field: FlipperStreamWriteData::key"]
        [::core::mem::offset_of!(FlipperStreamWriteData, key) - 0usize];
    ["Offset of field: FlipperStreamWriteData::type_"]
        [::core::mem::offset_of!(FlipperStreamWriteData, type_) - 4usize];
    ["Offset of field: FlipperStreamWriteData::data"]
        [::core::mem::offset_of!(FlipperStreamWriteData, data) - 8usize];
    ["Offset of field: FlipperStreamWriteData::data_size"]
        [::core::mem::offset_of!(FlipperStreamWriteData, data_size) - 12usize];
};
unsafe extern "C" {
    #[doc = "Writes a key/value pair to the stream.\n # Arguments\n\n* `stream` -\n * `write_data` -\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_stream_write_value_line(
        stream: *mut Stream,
        write_data: *mut FlipperStreamWriteData,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Reads a value by key from a stream.\n # Arguments\n\n* `stream` -\n * `key` -\n * `type` -\n * `_data` -\n * `data_size` -\n * `strict_mode` -\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_stream_read_value_line(
        stream: *mut Stream,
        key: *const core::ffi::c_char,
        type_: FlipperStreamValue,
        _data: *mut core::ffi::c_void,
        data_size: usize,
        strict_mode: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the count of values by key from a stream.\n # Arguments\n\n* `stream` -\n * `key` -\n * `count` -\n * `strict_mode` -\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_stream_get_value_count(
        stream: *mut Stream,
        key: *const core::ffi::c_char,
        count: *mut u32,
        strict_mode: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Removes a key and the corresponding value string from the stream and inserts a new key/value pair.\n # Arguments\n\n* `stream` -\n * `write_data` -\n * `strict_mode` -\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_stream_delete_key_and_write(
        stream: *mut Stream,
        write_data: *mut FlipperStreamWriteData,
        strict_mode: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Writes a comment string to the stream.\n # Arguments\n\n* `stream` -\n * `data` -\n # Returns\n\ntrue\n false"]
    pub fn flipper_format_stream_write_comment_cstr(
        stream: *mut Stream,
        data: *const core::ffi::c_char,
    ) -> bool;
}
pub type iButtonProtocolId = i32;
pub const iButtonProtocolIdInvalid: _bindgen_ty_2 = _bindgen_ty_2(-1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_2(pub core::ffi::c_schar);
pub const iButtonProtocolFeatureExtData: iButtonProtocolFeature = iButtonProtocolFeature(1);
pub const iButtonProtocolFeatureWriteId: iButtonProtocolFeature = iButtonProtocolFeature(2);
pub const iButtonProtocolFeatureWriteCopy: iButtonProtocolFeature = iButtonProtocolFeature(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct iButtonProtocolFeature(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonEditableData {
    pub ptr: *mut u8,
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iButtonEditableData"][::core::mem::size_of::<iButtonEditableData>() - 8usize];
    ["Alignment of iButtonEditableData"][::core::mem::align_of::<iButtonEditableData>() - 4usize];
    ["Offset of field: iButtonEditableData::ptr"]
        [::core::mem::offset_of!(iButtonEditableData, ptr) - 0usize];
    ["Offset of field: iButtonEditableData::size"]
        [::core::mem::offset_of!(iButtonEditableData, size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonKey {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate a key object\n # Arguments\n\n* `[in]` - data_size maximum data size held by the key\n # Returns\n\npointer to the key object"]
    pub fn ibutton_key_alloc(data_size: usize) -> *mut iButtonKey;
}
unsafe extern "C" {
    #[doc = "Destroy the key object, free resources\n # Arguments\n\n* `[in]` - key pointer to the key object"]
    pub fn ibutton_key_free(key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Get the protocol id held by the key\n # Arguments\n\n* `[in]` - key pointer to the key object\n # Returns\n\nprotocol id held by the key"]
    pub fn ibutton_key_get_protocol_id(key: *const iButtonKey) -> iButtonProtocolId;
}
unsafe extern "C" {
    #[doc = "Set the protocol id held by the key\n # Arguments\n\n* `[in]` - key pointer to the key object\n * `[in]` - protocol_id new protocol id"]
    pub fn ibutton_key_set_protocol_id(key: *mut iButtonKey, protocol_id: iButtonProtocolId);
}
unsafe extern "C" {
    #[doc = "Reset the protocol id and data held by the key\n # Arguments\n\n* `[in]` - key pointer to the key object"]
    pub fn ibutton_key_reset(key: *mut iButtonKey);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonProtocols {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate an iButtonProtocols object\n # Returns\n\npointer to an iButtonProtocols object"]
    pub fn ibutton_protocols_alloc() -> *mut iButtonProtocols;
}
unsafe extern "C" {
    #[doc = "Destroy an iButtonProtocols object, free resources\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object"]
    pub fn ibutton_protocols_free(protocols: *mut iButtonProtocols);
}
unsafe extern "C" {
    #[doc = "Get the total number of available protocols"]
    pub fn ibutton_protocols_get_protocol_count() -> u32;
}
unsafe extern "C" {
    #[doc = "Get maximum data size out of all protocols available\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n # Returns\n\nmaximum data size in bytes"]
    pub fn ibutton_protocols_get_max_data_size(protocols: *mut iButtonProtocols) -> usize;
}
unsafe extern "C" {
    #[doc = "Get the protocol id based on its name\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - name pointer to a string containing the name\n # Returns\n\nprotocol id on success on iButtonProtocolIdInvalid on failure"]
    pub fn ibutton_protocols_get_id_by_name(
        protocols: *mut iButtonProtocols,
        name: *const core::ffi::c_char,
    ) -> iButtonProtocolId;
}
unsafe extern "C" {
    #[doc = "Get the manufacturer name based on the protocol id\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - id id of the protocol in question\n # Returns\n\npointer to a statically allocated string with manufacturer name"]
    pub fn ibutton_protocols_get_manufacturer(
        protocols: *mut iButtonProtocols,
        id: iButtonProtocolId,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get the protocol name based on the protocol id\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - id id of the protocol in question\n # Returns\n\npointer to a statically allocated string with protocol name"]
    pub fn ibutton_protocols_get_name(
        protocols: *mut iButtonProtocols,
        id: iButtonProtocolId,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get protocol features bitmask by protocol id\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - id id of the protocol in question"]
    pub fn ibutton_protocols_get_features(
        protocols: *mut iButtonProtocols,
        id: iButtonProtocolId,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = "Read a physical device (a key or an emulator)\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[out]` - key pointer to the key to read into (must be allocated before)\n # Returns\n\ntrue on success, false on failure"]
    pub fn ibutton_protocols_read(protocols: *mut iButtonProtocols, key: *mut iButtonKey) -> bool;
}
unsafe extern "C" {
    #[doc = "Write the key to a blank\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be written\n # Returns\n\ntrue on success, false on failure"]
    pub fn ibutton_protocols_write_id(
        protocols: *mut iButtonProtocols,
        key: *mut iButtonKey,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write the key to another one of the same type\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be written\n # Returns\n\ntrue on success, false on failure"]
    pub fn ibutton_protocols_write_copy(
        protocols: *mut iButtonProtocols,
        key: *mut iButtonKey,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Start emulating the key\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be emulated"]
    pub fn ibutton_protocols_emulate_start(protocols: *mut iButtonProtocols, key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Stop emulating the key\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be emulated"]
    pub fn ibutton_protocols_emulate_stop(protocols: *mut iButtonProtocols, key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Save the key data to a file.\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be saved\n * `[in]` - file_name full absolute path to the file name\n # Returns\n\ntrue on success, false on failure"]
    pub fn ibutton_protocols_save(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        file_name: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Load the key from a file.\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[out]` - key pointer to the key to load into (must be allocated before)\n * `[in]` - file_name full absolute path to the file name\n # Returns\n\ntrue on success, false on failure"]
    pub fn ibutton_protocols_load(
        protocols: *mut iButtonProtocols,
        key: *mut iButtonKey,
        file_name: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Format a string containing defice UID\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be rendered\n * `[out]` - result pointer to the FuriString instance (must be initialized)"]
    pub fn ibutton_protocols_render_uid(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Format a string containing device full data\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be rendered\n * `[out]` - result pointer to the FuriString instance (must be initialized)"]
    pub fn ibutton_protocols_render_data(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Format a string containing device brief data\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be rendered\n * `[out]` - result pointer to the FuriString instance (must be initialized)"]
    pub fn ibutton_protocols_render_brief_data(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Format a string containing error message (for invalid keys)\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be rendered\n * `[out]` - result pointer to the FuriString instance (must be initialized)"]
    pub fn ibutton_protocols_render_error(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Check whether the key data is valid\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be checked\n # Returns\n\ntrue if data is valid, false otherwise"]
    pub fn ibutton_protocols_is_valid(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get a pointer to the key's editable data (for in-place editing)\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in]` - key pointer to the key to be checked\n * `[out]` - editable pointer to a structure to contain the editable data"]
    pub fn ibutton_protocols_get_editable_data(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        editable: *mut iButtonEditableData,
    );
}
unsafe extern "C" {
    #[doc = "Make all necessary internal adjustments after editing the key\n # Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n * `[in,out]` - key pointer to the key to be adjusted"]
    pub fn ibutton_protocols_apply_edits(protocols: *mut iButtonProtocols, key: *const iButtonKey);
}
pub const iButtonWorkerWriteOK: iButtonWorkerWriteResult = iButtonWorkerWriteResult(0);
pub const iButtonWorkerWriteSameKey: iButtonWorkerWriteResult = iButtonWorkerWriteResult(1);
pub const iButtonWorkerWriteNoDetect: iButtonWorkerWriteResult = iButtonWorkerWriteResult(2);
pub const iButtonWorkerWriteCannotWrite: iButtonWorkerWriteResult = iButtonWorkerWriteResult(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct iButtonWorkerWriteResult(pub core::ffi::c_uchar);
pub type iButtonWorkerReadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type iButtonWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, result: iButtonWorkerWriteResult),
>;
pub type iButtonWorkerEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, emulated: bool)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonWorker {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate ibutton worker\n # Returns\n\niButtonWorker*"]
    pub fn ibutton_worker_alloc(protocols: *mut iButtonProtocols) -> *mut iButtonWorker;
}
unsafe extern "C" {
    #[doc = "Free ibutton worker\n # Arguments\n\n* `worker` -"]
    pub fn ibutton_worker_free(worker: *mut iButtonWorker);
}
unsafe extern "C" {
    #[doc = "Start ibutton worker thread\n # Arguments\n\n* `worker` -"]
    pub fn ibutton_worker_start_thread(worker: *mut iButtonWorker);
}
unsafe extern "C" {
    #[doc = "Stop ibutton worker thread\n # Arguments\n\n* `worker` -"]
    pub fn ibutton_worker_stop_thread(worker: *mut iButtonWorker);
}
unsafe extern "C" {
    #[doc = "Set \"read success\" callback\n # Arguments\n\n* `worker` -\n * `callback` -\n * `context` -"]
    pub fn ibutton_worker_read_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start read mode\n # Arguments\n\n* `worker` -\n * `key` -"]
    pub fn ibutton_worker_read_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Set \"write event\" callback\n # Arguments\n\n* `worker` -\n * `callback` -\n * `context` -"]
    pub fn ibutton_worker_write_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start write blank mode\n # Arguments\n\n* `worker` -\n * `key` -"]
    pub fn ibutton_worker_write_id_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Start write copy mode\n # Arguments\n\n* `worker` -\n * `key` -"]
    pub fn ibutton_worker_write_copy_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Set \"emulate success\" callback\n # Arguments\n\n* `worker` -\n * `callback` -\n * `context` -"]
    pub fn ibutton_worker_emulate_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start emulate mode\n # Arguments\n\n* `worker` -\n * `key` -"]
    pub fn ibutton_worker_emulate_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
unsafe extern "C" {
    #[doc = "Stop all modes\n # Arguments\n\n* `worker` -"]
    pub fn ibutton_worker_stop(worker: *mut iButtonWorker);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredDecoderHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredEncoderHandler {
    _unused: [u8; 0],
}
pub const InfraredProtocolUnknown: InfraredProtocol = InfraredProtocol(-1);
pub const InfraredProtocolNEC: InfraredProtocol = InfraredProtocol(0);
pub const InfraredProtocolNECext: InfraredProtocol = InfraredProtocol(1);
pub const InfraredProtocolNEC42: InfraredProtocol = InfraredProtocol(2);
pub const InfraredProtocolNEC42ext: InfraredProtocol = InfraredProtocol(3);
pub const InfraredProtocolSamsung32: InfraredProtocol = InfraredProtocol(4);
pub const InfraredProtocolRC6: InfraredProtocol = InfraredProtocol(5);
pub const InfraredProtocolRC5: InfraredProtocol = InfraredProtocol(6);
pub const InfraredProtocolRC5X: InfraredProtocol = InfraredProtocol(7);
pub const InfraredProtocolSIRC: InfraredProtocol = InfraredProtocol(8);
pub const InfraredProtocolSIRC15: InfraredProtocol = InfraredProtocol(9);
pub const InfraredProtocolSIRC20: InfraredProtocol = InfraredProtocol(10);
pub const InfraredProtocolKaseikyo: InfraredProtocol = InfraredProtocol(11);
pub const InfraredProtocolRCA: InfraredProtocol = InfraredProtocol(12);
pub const InfraredProtocolPioneer: InfraredProtocol = InfraredProtocol(13);
pub const InfraredProtocolMAX: InfraredProtocol = InfraredProtocol(14);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct InfraredProtocol(pub core::ffi::c_schar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredMessage {
    pub protocol: InfraredProtocol,
    pub address: u32,
    pub command: u32,
    pub repeat: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of InfraredMessage"][::core::mem::size_of::<InfraredMessage>() - 16usize];
    ["Alignment of InfraredMessage"][::core::mem::align_of::<InfraredMessage>() - 4usize];
    ["Offset of field: InfraredMessage::protocol"]
        [::core::mem::offset_of!(InfraredMessage, protocol) - 0usize];
    ["Offset of field: InfraredMessage::address"]
        [::core::mem::offset_of!(InfraredMessage, address) - 4usize];
    ["Offset of field: InfraredMessage::command"]
        [::core::mem::offset_of!(InfraredMessage, command) - 8usize];
    ["Offset of field: InfraredMessage::repeat"]
        [::core::mem::offset_of!(InfraredMessage, repeat) - 12usize];
};
pub const InfraredStatusError: InfraredStatus = InfraredStatus(0);
pub const InfraredStatusOk: InfraredStatus = InfraredStatus(1);
pub const InfraredStatusDone: InfraredStatus = InfraredStatus(2);
pub const InfraredStatusReady: InfraredStatus = InfraredStatus(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct InfraredStatus(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Initialize decoder.\n\n # Returns\n\nreturns pointer to INFRARED decoder handler if success, otherwise - error."]
    pub fn infrared_alloc_decoder() -> *mut InfraredDecoderHandler;
}
unsafe extern "C" {
    #[doc = "Provide to decoder next timing.\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED decoders. Should be acquired with `infrared_alloc_decoder().`\n * `level` (direction in) - - high(true) or low(false) level of input signal to analyze.\n it should alternate every call, otherwise it is an error case,\n and decoder resets its state and start decoding from the start.\n * `duration` (direction in) - - duration of steady high/low input signal.\n # Returns\n\nif message is ready, returns pointer to decoded message, returns NULL.\n Note: ownership of returned ptr belongs to handler. So pointer is valid\n up to next infrared_free_decoder(), infrared_reset_decoder(),\n infrared_decode(), infrared_check_decoder_ready() calls."]
    pub fn infrared_decode(
        handler: *mut InfraredDecoderHandler,
        level: bool,
        duration: u32,
    ) -> *const InfraredMessage;
}
unsafe extern "C" {
    #[doc = "Check whether decoder is ready.\n Functionality is quite similar to infrared_decode(), but with no timing providing.\n Some protocols (e.g. Sony SIRC) has variable payload length, which means we\n can't recognize end of message right after receiving last bit. That's why\n application should call to infrared_check_decoder_ready() after some timeout to\n retrieve decoded message, if so.\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED decoders. Should be acquired with `infrared_alloc_decoder().`\n # Returns\n\nif message is ready, returns pointer to decoded message, returns NULL.\n Note: ownership of returned ptr belongs to handler. So pointer is valid\n up to next infrared_free_decoder(), infrared_reset_decoder(),\n infrared_decode(), infrared_check_decoder_ready() calls."]
    pub fn infrared_check_decoder_ready(
        handler: *mut InfraredDecoderHandler,
    ) -> *const InfraredMessage;
}
unsafe extern "C" {
    #[doc = "Deinitialize decoder and free allocated memory.\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED decoders. Should be acquired with `infrared_alloc_decoder().`"]
    pub fn infrared_free_decoder(handler: *mut InfraredDecoderHandler);
}
unsafe extern "C" {
    #[doc = "Reset INFRARED decoder.\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED decoders. Should be acquired with `infrared_alloc_decoder().`"]
    pub fn infrared_reset_decoder(handler: *mut InfraredDecoderHandler);
}
unsafe extern "C" {
    #[doc = "Get protocol name by protocol enum.\n\n # Arguments\n\n* `protocol` (direction in) - - protocol identifier.\n # Returns\n\nstring to protocol name."]
    pub fn infrared_get_protocol_name(protocol: InfraredProtocol) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get protocol enum by protocol name.\n\n # Arguments\n\n* `protocol_name` (direction in) - - string to protocol name.\n # Returns\n\nprotocol identifier."]
    pub fn infrared_get_protocol_by_name(
        protocol_name: *const core::ffi::c_char,
    ) -> InfraredProtocol;
}
unsafe extern "C" {
    #[doc = "Get address length by protocol enum.\n\n # Arguments\n\n* `protocol` (direction in) - - protocol identifier.\n # Returns\n\nlength of address in bits."]
    pub fn infrared_get_protocol_address_length(protocol: InfraredProtocol) -> u8;
}
unsafe extern "C" {
    #[doc = "Get command length by protocol enum.\n\n # Arguments\n\n* `protocol` (direction in) - - protocol identifier.\n # Returns\n\nlength of command in bits."]
    pub fn infrared_get_protocol_command_length(protocol: InfraredProtocol) -> u8;
}
unsafe extern "C" {
    #[doc = "Checks whether protocol valid.\n\n # Arguments\n\n* `protocol` (direction in) - - protocol identifier.\n # Returns\n\ntrue if protocol is valid, false otherwise."]
    pub fn infrared_is_protocol_valid(protocol: InfraredProtocol) -> bool;
}
unsafe extern "C" {
    #[doc = "Allocate INFRARED encoder.\n\n # Returns\n\nencoder handler."]
    pub fn infrared_alloc_encoder() -> *mut InfraredEncoderHandler;
}
unsafe extern "C" {
    #[doc = "Free encoder handler previously allocated with `infrared_alloc_encoder().`\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED encoder. Should be acquired with `infrared_alloc_encoder().`"]
    pub fn infrared_free_encoder(handler: *mut InfraredEncoderHandler);
}
unsafe extern "C" {
    #[doc = "Encode previously set INFRARED message.\n Usage:\n 1) alloc with `infrared_alloc_encoder()`\n 2) set message to encode with `infrared_reset_encoder()`\n 3) call for `infrared_encode()` to continuously get one at a time timings.\n 4) when `infrared_encode()` returns InfraredStatusDone, it means new message is fully encoded.\n 5) to encode additional timings, just continue calling `infrared_encode().`\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED encoder. Should be acquired with `infrared_alloc_encoder().`\n * `duration` (direction out) - - encoded timing.\n * `level` (direction out) - - encoded level.\n\n # Returns\n\nstatus of encode operation."]
    pub fn infrared_encode(
        handler: *mut InfraredEncoderHandler,
        duration: *mut u32,
        level: *mut bool,
    ) -> InfraredStatus;
}
unsafe extern "C" {
    #[doc = "Reset INFRARED encoder and set new message to encode. If it's not called after receiveing\n InfraredStatusDone in `infrared_encode(),` encoder will encode repeat messages\n till the end of time.\n\n # Arguments\n\n* `handler` (direction in) - - handler to INFRARED encoder. Should be acquired with `infrared_alloc_encoder().`\n * `message` (direction in) - - message to encode."]
    pub fn infrared_reset_encoder(
        handler: *mut InfraredEncoderHandler,
        message: *const InfraredMessage,
    );
}
unsafe extern "C" {
    #[doc = "Get PWM frequency value for selected protocol\n\n # Arguments\n\n* `protocol` (direction in) - - protocol to get from PWM frequency\n\n # Returns\n\nfrequency"]
    pub fn infrared_get_protocol_frequency(protocol: InfraredProtocol) -> u32;
}
unsafe extern "C" {
    #[doc = "Get PWM duty cycle value for selected protocol\n\n # Arguments\n\n* `protocol` (direction in) - - protocol to get from PWM duty cycle\n\n # Returns\n\nduty cycle"]
    pub fn infrared_get_protocol_duty_cycle(protocol: InfraredProtocol) -> f32;
}
unsafe extern "C" {
    #[doc = "Get the minimum count of signal repeats for the selected protocol\n\n # Arguments\n\n* `protocol` (direction in) - - protocol to get the repeat count from\n\n # Returns\n\nrepeat count"]
    pub fn infrared_get_protocol_min_repeat_count(protocol: InfraredProtocol) -> usize;
}
pub const FuriHalInfraredTxPinInternal: FuriHalInfraredTxPin = FuriHalInfraredTxPin(0);
pub const FuriHalInfraredTxPinExtPA7: FuriHalInfraredTxPin = FuriHalInfraredTxPin(1);
pub const FuriHalInfraredTxPinMax: FuriHalInfraredTxPin = FuriHalInfraredTxPin(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalInfraredTxPin(pub core::ffi::c_uchar);
#[doc = "< New data obtained"]
pub const FuriHalInfraredTxGetDataStateOk: FuriHalInfraredTxGetDataState =
    FuriHalInfraredTxGetDataState(0);
#[doc = "< New data obtained, and this is end of package"]
pub const FuriHalInfraredTxGetDataStateDone: FuriHalInfraredTxGetDataState =
    FuriHalInfraredTxGetDataState(1);
#[doc = "< New data obtained, and this is end of package and no more data available"]
pub const FuriHalInfraredTxGetDataStateLastDone: FuriHalInfraredTxGetDataState =
    FuriHalInfraredTxGetDataState(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalInfraredTxGetDataState(pub core::ffi::c_uchar);
#[doc = "Callback type for providing data to INFRARED DMA TX system. It is called every tim"]
pub type FuriHalInfraredTxGetDataISRCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        duration: *mut u32,
        level: *mut bool,
    ) -> FuriHalInfraredTxGetDataState,
>;
#[doc = "Callback type called every time signal is sent by DMA to Timer.\n\n Actually, it means there are 2 timings left to send for this signal, which is\n almost end. Don't use this callback to stop transmission, as far as there are\n next signal is charged for transmission by DMA."]
pub type FuriHalInfraredTxSignalSentISRCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Signature of callback function for receiving continuous INFRARED rx signal.\n\n # Arguments\n\n* `ctx` (direction in) - context to pass to callback\n * `level` (direction in) - level of input INFRARED rx signal\n * `duration` (direction in) - duration of continuous rx signal level in us"]
pub type FuriHalInfraredRxCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut core::ffi::c_void, level: bool, duration: u32),
>;
#[doc = "Signature of callback function for reaching silence timeout on INFRARED port.\n\n # Arguments\n\n* `ctx` (direction in) - context to pass to callback"]
pub type FuriHalInfraredRxTimeoutCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Initialize INFRARED RX timer to receive interrupts.\n\n It provides interrupts for every RX-signal edge changing with its duration."]
    pub fn furi_hal_infrared_async_rx_start();
}
unsafe extern "C" {
    #[doc = "Deinitialize INFRARED RX interrupt."]
    pub fn furi_hal_infrared_async_rx_stop();
}
unsafe extern "C" {
    #[doc = "Setup hal for receiving silence timeout.\n\n Should be used with 'furi_hal_infrared_timeout_irq_set_callback()'.\n\n # Arguments\n\n* `timeout_us` (direction in) - time to wait for silence on INFRARED port before\n generating IRQ."]
    pub fn furi_hal_infrared_async_rx_set_timeout(timeout_us: u32);
}
unsafe extern "C" {
    #[doc = "Setup callback for previously initialized INFRARED RX interrupt.\n\n # Arguments\n\n* `callback` (direction in) - callback to call when RX signal edge changing occurs\n * `ctx` (direction in) - context for callback"]
    pub fn furi_hal_infrared_async_rx_set_capture_isr_callback(
        callback: FuriHalInfraredRxCaptureCallback,
        ctx: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Setup callback for reaching silence timeout on INFRARED port.\n\n Should setup hal with 'furi_hal_infrared_setup_rx_timeout_irq()' first.\n\n # Arguments\n\n* `callback` (direction in) - callback for silence timeout\n * `ctx` (direction in) - context to pass to callback"]
    pub fn furi_hal_infrared_async_rx_set_timeout_isr_callback(
        callback: FuriHalInfraredRxTimeoutCallback,
        ctx: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Check if INFRARED is in use now.\n\n # Returns\n\ntrue if INFRARED is busy, false otherwise."]
    pub fn furi_hal_infrared_is_busy() -> bool;
}
unsafe extern "C" {
    #[doc = "Set callback providing new data.\n\n This function has to be called before furi_hal_infrared_async_tx_start().\n\n # Arguments\n\n* `callback` (direction in) - function to provide new data\n * `context` (direction in) - context for callback"]
    pub fn furi_hal_infrared_async_tx_set_data_isr_callback(
        callback: FuriHalInfraredTxGetDataISRCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start IR asynchronous transmission.\n\n It can be stopped by 2 reasons:\n 1. implicit call for furi_hal_infrared_async_tx_stop()\n 2. callback can provide FuriHalInfraredTxGetDataStateLastDone response which\n means no more data available for transmission.\n\n Any func (furi_hal_infrared_async_tx_stop() or\n furi_hal_infrared_async_tx_wait_termination()) has to be called to wait end of\n transmission and free resources.\n\n # Arguments\n\n* `freq` (direction in) - frequency for PWM\n * `duty_cycle` (direction in) - duty cycle for PWM"]
    pub fn furi_hal_infrared_async_tx_start(freq: u32, duty_cycle: f32);
}
unsafe extern "C" {
    #[doc = "Stop IR asynchronous transmission and free resources.\n\n Transmission will stop as soon as transmission reaches end of package\n (FuriHalInfraredTxGetDataStateDone or FuriHalInfraredTxGetDataStateLastDone)."]
    pub fn furi_hal_infrared_async_tx_stop();
}
unsafe extern "C" {
    #[doc = "Wait for end of IR asynchronous transmission and free resources.\n\n Transmission will stop as soon as transmission reaches end of transmission\n (FuriHalInfraredTxGetDataStateLastDone)."]
    pub fn furi_hal_infrared_async_tx_wait_termination();
}
unsafe extern "C" {
    #[doc = "Set callback for end of signal transmission\n\n # Arguments\n\n* `callback` (direction in) - function to call when signal is sent\n * `context` (direction in) - context for callback"]
    pub fn furi_hal_infrared_async_tx_set_signal_sent_isr_callback(
        callback: FuriHalInfraredTxSignalSentISRCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Detect which pin has an external IR module connected.\n\n External IR modules are detected by enabling a weak pull-up\n on supported pins and testing whether the input is still low.\n\n This method works best on modules that employ a FET with a\n strong pull-down or a BJT for driving IR LEDs.\n\n The module MUST pull the input voltage down to at least 0.9V\n or lower in order for it to be detected.\n\n If no module has been detected, FuriHalInfraredTxPinInternal is returned.\n\n # Returns\n\nnumeric identifier of the first pin with a module detected."]
    pub fn furi_hal_infrared_detect_tx_output() -> FuriHalInfraredTxPin;
}
unsafe extern "C" {
    #[doc = "Set which pin will be used to transmit infrared signals.\n\n # Arguments\n\n* `tx_pin` (direction in) - pin to be used for signal transmission."]
    pub fn furi_hal_infrared_set_tx_output(tx_pin: FuriHalInfraredTxPin);
}
unsafe extern "C" {
    #[doc = "Send message over INFRARED.\n\n # Arguments\n\n* `message` (direction in) - - message to send.\n * `times` (direction in) - - number of times message should be sent."]
    pub fn infrared_send(message: *const InfraredMessage, times: core::ffi::c_int);
}
unsafe extern "C" {
    #[doc = "Send raw data through infrared port.\n\n # Arguments\n\n* `timings` (direction in) - - array of timings to send.\n * `timings_cnt` (direction in) - - timings array size.\n * `start_from_mark` (direction in) - - true if timings starts from mark,\n otherwise from space"]
    pub fn infrared_send_raw(timings: *const u32, timings_cnt: u32, start_from_mark: bool);
}
unsafe extern "C" {
    #[doc = "Send raw data through infrared port, with additional settings.\n\n # Arguments\n\n* `timings` (direction in) - - array of timings to send.\n * `timings_cnt` (direction in) - - timings array size.\n * `start_from_mark` (direction in) - - true if timings starts from mark,\n otherwise from space\n * `duty_cycle` (direction in) - - duty cycle to generate on PWM\n * `frequency` (direction in) - - frequency to generate on PWM"]
    pub fn infrared_send_raw_ext(
        timings: *const u32,
        timings_cnt: u32,
        start_from_mark: bool,
        frequency: u32,
        duty_cycle: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorkerSignal {
    _unused: [u8; 0],
}
pub const InfraredWorkerGetSignalResponseNew: InfraredWorkerGetSignalResponse =
    InfraredWorkerGetSignalResponse(0);
#[doc = "Signal, provided by callback is new and encoder should be reseted"]
pub const InfraredWorkerGetSignalResponseSame: InfraredWorkerGetSignalResponse =
    InfraredWorkerGetSignalResponse(1);
#[doc = "Signal, provided by callback is same. No encoder resetting."]
pub const InfraredWorkerGetSignalResponseStop: InfraredWorkerGetSignalResponse =
    InfraredWorkerGetSignalResponse(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct InfraredWorkerGetSignalResponse(pub core::ffi::c_uchar);
#[doc = "Callback type for providing next signal to send. Should be used with\n infrared_worker_make_decoded_signal() or infrared_worker_make_raw_signal()"]
pub type InfraredWorkerGetSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse,
>;
#[doc = "Callback type for 'message is sent' event"]
pub type InfraredWorkerMessageSentCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Callback type to call by InfraredWorker thread when new signal is received"]
pub type InfraredWorkerReceivedSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        received_signal: *mut InfraredWorkerSignal,
    ),
>;
unsafe extern "C" {
    #[doc = "Allocate InfraredWorker\n\n # Returns\n\njust created instance of InfraredWorker"]
    pub fn infrared_worker_alloc() -> *mut InfraredWorker;
}
unsafe extern "C" {
    #[doc = "Free InfraredWorker\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance"]
    pub fn infrared_worker_free(instance: *mut InfraredWorker);
}
unsafe extern "C" {
    #[doc = "Start InfraredWorker thread, initialise furi_hal, prepare all work.\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance"]
    pub fn infrared_worker_rx_start(instance: *mut InfraredWorker);
}
unsafe extern "C" {
    #[doc = "Stop InfraredWorker thread, deinitialize furi_hal.\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance"]
    pub fn infrared_worker_rx_stop(instance: *mut InfraredWorker);
}
unsafe extern "C" {
    #[doc = "Set received data callback InfraredWorker\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance\n * `context` (direction in) - - context to pass to callbacks\n * `callback` (direction in) - - InfraredWorkerReceivedSignalCallback callback"]
    pub fn infrared_worker_rx_set_received_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerReceivedSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Enable blinking on receiving any signal on IR port.\n\n # Arguments\n\n* `instance` (direction in) - - instance of InfraredWorker\n * `enable` (direction in) - - true if you want to enable blinking\n false otherwise"]
    pub fn infrared_worker_rx_enable_blink_on_receiving(
        instance: *mut InfraredWorker,
        enable: bool,
    );
}
unsafe extern "C" {
    #[doc = "Enable decoding of received infrared signals.\n\n # Arguments\n\n* `instance` (direction in) - - instance of InfraredWorker\n * `enable` (direction in) - - true if you want to enable decoding\n false otherwise"]
    pub fn infrared_worker_rx_enable_signal_decoding(instance: *mut InfraredWorker, enable: bool);
}
unsafe extern "C" {
    #[doc = "Clarify is received signal either decoded or raw\n\n # Arguments\n\n* `signal` (direction in) - - received signal\n # Returns\n\ntrue if signal is decoded, false if signal is raw"]
    pub fn infrared_worker_signal_is_decoded(signal: *const InfraredWorkerSignal) -> bool;
}
unsafe extern "C" {
    #[doc = "Start transmitting signal. Callback InfraredWorkerGetSignalCallback should be\n set before this function is called, as it calls for it to fill buffer before\n starting transmission.\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance"]
    pub fn infrared_worker_tx_start(instance: *mut InfraredWorker);
}
unsafe extern "C" {
    #[doc = "Stop transmitting signal. Waits for end of current signal and stops transmission.\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance"]
    pub fn infrared_worker_tx_stop(instance: *mut InfraredWorker);
}
unsafe extern "C" {
    #[doc = "Set callback for providing next signal to send\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance\n * `context` (direction in) - - context to pass to callbacks\n * `callback` (direction in) - - InfraredWorkerGetSignalCallback callback"]
    pub fn infrared_worker_tx_set_get_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerGetSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set callback for end of signal transmitting\n\n # Arguments\n\n* `instance` (direction in) - - InfraredWorker instance\n * `context` (direction in) - - context to pass to callbacks\n * `callback` (direction in) - - InfraredWorkerMessageSentCallback callback"]
    pub fn infrared_worker_tx_set_signal_sent_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerMessageSentCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Callback to pass to infrared_worker_tx_set_get_signal_callback() if signal\n is steady and will not be changed between infrared_worker start and stop.\n Before starting transmission, desired steady signal must be set with\n infrared_worker_set_decoded_signal() or infrared_worker_set_raw_signal().\n\n This function should not be called directly.\n\n # Arguments\n\n* `context` (direction in) - - context\n * `instance` (direction out) - - InfraredWorker instance"]
    pub fn infrared_worker_tx_get_signal_steady_callback(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse;
}
unsafe extern "C" {
    #[doc = "Acquire raw signal from interface struct 'InfraredWorkerSignal'.\n First, you have to ensure that signal is raw.\n\n # Arguments\n\n* `signal` (direction in) - - received signal\n * `timings` (direction out) - - pointer to array of timings\n * `timings_cnt` (direction out) - - pointer to amount of timings"]
    pub fn infrared_worker_get_raw_signal(
        signal: *const InfraredWorkerSignal,
        timings: *mut *const u32,
        timings_cnt: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = "Acquire decoded message from interface struct 'InfraredWorkerSignal'.\n First, you have to ensure that signal is decoded.\n\n # Arguments\n\n* `signal` (direction in) - - received signal\n # Returns\n\ndecoded INFRARED message"]
    pub fn infrared_worker_get_decoded_signal(
        signal: *const InfraredWorkerSignal,
    ) -> *const InfraredMessage;
}
unsafe extern "C" {
    #[doc = "Set current decoded signal for InfraredWorker instance\n\n # Arguments\n\n* `instance` (direction out) - - InfraredWorker instance\n * `message` (direction in) - - decoded signal"]
    pub fn infrared_worker_set_decoded_signal(
        instance: *mut InfraredWorker,
        message: *const InfraredMessage,
    );
}
unsafe extern "C" {
    #[doc = "Set current raw signal for InfraredWorker instance\n\n # Arguments\n\n* `instance` (direction out) - - InfraredWorker instance\n * `timings` (direction in) - - array of raw timings\n * `timings_cnt` (direction in) - - size of array of raw timings\n * `frequency` (direction in) - - carrier frequency in Hertz\n * `duty_cycle` (direction in) - - carrier duty cycle (0.0 - 1.0)"]
    pub fn infrared_worker_set_raw_signal(
        instance: *mut InfraredWorker,
        timings: *const u32,
        timings_cnt: usize,
        frequency: u32,
        duty_cycle: f32,
    );
}
pub type ProtocolAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>;
pub type ProtocolFree =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolGetData =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> *mut u8>;
pub type ProtocolDecoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, level: bool, duration: u32) -> bool,
>;
pub type ProtocolEncoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> bool>;
pub type ProtocolEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> LevelDuration>;
pub type ProtocolRenderData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, result: *mut FuriString),
>;
pub type ProtocolWriteData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, data: *mut core::ffi::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDecoder {
    pub start: ProtocolDecoderStart,
    pub feed: ProtocolDecoderFeed,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ProtocolDecoder"][::core::mem::size_of::<ProtocolDecoder>() - 8usize];
    ["Alignment of ProtocolDecoder"][::core::mem::align_of::<ProtocolDecoder>() - 4usize];
    ["Offset of field: ProtocolDecoder::start"]
        [::core::mem::offset_of!(ProtocolDecoder, start) - 0usize];
    ["Offset of field: ProtocolDecoder::feed"]
        [::core::mem::offset_of!(ProtocolDecoder, feed) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolEncoder {
    pub start: ProtocolEncoderStart,
    pub yield_: ProtocolEncoderYield,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ProtocolEncoder"][::core::mem::size_of::<ProtocolEncoder>() - 8usize];
    ["Alignment of ProtocolEncoder"][::core::mem::align_of::<ProtocolEncoder>() - 4usize];
    ["Offset of field: ProtocolEncoder::start"]
        [::core::mem::offset_of!(ProtocolEncoder, start) - 0usize];
    ["Offset of field: ProtocolEncoder::yield_"]
        [::core::mem::offset_of!(ProtocolEncoder, yield_) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolBase {
    pub data_size: usize,
    pub name: *const core::ffi::c_char,
    pub manufacturer: *const core::ffi::c_char,
    pub features: u32,
    pub validate_count: u8,
    pub alloc: ProtocolAlloc,
    pub free: ProtocolFree,
    pub get_data: ProtocolGetData,
    pub decoder: ProtocolDecoder,
    pub encoder: ProtocolEncoder,
    pub render_uid: ProtocolRenderData,
    pub render_data: ProtocolRenderData,
    pub render_brief_data: ProtocolRenderData,
    pub write_data: ProtocolWriteData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ProtocolBase"][::core::mem::size_of::<ProtocolBase>() - 64usize];
    ["Alignment of ProtocolBase"][::core::mem::align_of::<ProtocolBase>() - 4usize];
    ["Offset of field: ProtocolBase::data_size"]
        [::core::mem::offset_of!(ProtocolBase, data_size) - 0usize];
    ["Offset of field: ProtocolBase::name"][::core::mem::offset_of!(ProtocolBase, name) - 4usize];
    ["Offset of field: ProtocolBase::manufacturer"]
        [::core::mem::offset_of!(ProtocolBase, manufacturer) - 8usize];
    ["Offset of field: ProtocolBase::features"]
        [::core::mem::offset_of!(ProtocolBase, features) - 12usize];
    ["Offset of field: ProtocolBase::validate_count"]
        [::core::mem::offset_of!(ProtocolBase, validate_count) - 16usize];
    ["Offset of field: ProtocolBase::alloc"]
        [::core::mem::offset_of!(ProtocolBase, alloc) - 20usize];
    ["Offset of field: ProtocolBase::free"][::core::mem::offset_of!(ProtocolBase, free) - 24usize];
    ["Offset of field: ProtocolBase::get_data"]
        [::core::mem::offset_of!(ProtocolBase, get_data) - 28usize];
    ["Offset of field: ProtocolBase::decoder"]
        [::core::mem::offset_of!(ProtocolBase, decoder) - 32usize];
    ["Offset of field: ProtocolBase::encoder"]
        [::core::mem::offset_of!(ProtocolBase, encoder) - 40usize];
    ["Offset of field: ProtocolBase::render_uid"]
        [::core::mem::offset_of!(ProtocolBase, render_uid) - 48usize];
    ["Offset of field: ProtocolBase::render_data"]
        [::core::mem::offset_of!(ProtocolBase, render_data) - 52usize];
    ["Offset of field: ProtocolBase::render_brief_data"]
        [::core::mem::offset_of!(ProtocolBase, render_brief_data) - 56usize];
    ["Offset of field: ProtocolBase::write_data"]
        [::core::mem::offset_of!(ProtocolBase, write_data) - 60usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDict {
    _unused: [u8; 0],
}
pub type ProtocolId = i32;
unsafe extern "C" {
    pub fn protocol_dict_alloc(
        protocols: *mut *const ProtocolBase,
        protocol_count: usize,
    ) -> *mut ProtocolDict;
}
unsafe extern "C" {
    pub fn protocol_dict_free(dict: *mut ProtocolDict);
}
unsafe extern "C" {
    pub fn protocol_dict_set_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *const u8,
        data_size: usize,
    );
}
unsafe extern "C" {
    pub fn protocol_dict_get_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut u8,
        data_size: usize,
    );
}
unsafe extern "C" {
    pub fn protocol_dict_get_data_size(dict: *mut ProtocolDict, protocol_index: usize) -> usize;
}
unsafe extern "C" {
    pub fn protocol_dict_get_max_data_size(dict: *mut ProtocolDict) -> usize;
}
unsafe extern "C" {
    pub fn protocol_dict_get_name(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn protocol_dict_get_manufacturer(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn protocol_dict_decoders_start(dict: *mut ProtocolDict);
}
unsafe extern "C" {
    pub fn protocol_dict_get_features(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
unsafe extern "C" {
    pub fn protocol_dict_decoders_feed(
        dict: *mut ProtocolDict,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
unsafe extern "C" {
    pub fn protocol_dict_decoders_feed_by_feature(
        dict: *mut ProtocolDict,
        feature: u32,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
unsafe extern "C" {
    pub fn protocol_dict_decoders_feed_by_id(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
unsafe extern "C" {
    pub fn protocol_dict_encoder_start(dict: *mut ProtocolDict, protocol_index: usize) -> bool;
}
unsafe extern "C" {
    pub fn protocol_dict_encoder_yield(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> LevelDuration;
}
unsafe extern "C" {
    pub fn protocol_dict_render_uid(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
unsafe extern "C" {
    pub fn protocol_dict_render_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
unsafe extern "C" {
    pub fn protocol_dict_render_brief_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
unsafe extern "C" {
    pub fn protocol_dict_get_validate_count(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
unsafe extern "C" {
    pub fn protocol_dict_get_protocol_by_name(
        dict: *mut ProtocolDict,
        name: *const core::ffi::c_char,
    ) -> ProtocolId;
}
unsafe extern "C" {
    pub fn protocol_dict_get_write_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDT5577 {
    pub block: [u32; 8usize],
    pub blocks_to_write: u32,
    pub mask: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LFRFIDT5577"][::core::mem::size_of::<LFRFIDT5577>() - 40usize];
    ["Alignment of LFRFIDT5577"][::core::mem::align_of::<LFRFIDT5577>() - 4usize];
    ["Offset of field: LFRFIDT5577::block"][::core::mem::offset_of!(LFRFIDT5577, block) - 0usize];
    ["Offset of field: LFRFIDT5577::blocks_to_write"]
        [::core::mem::offset_of!(LFRFIDT5577, blocks_to_write) - 32usize];
    ["Offset of field: LFRFIDT5577::mask"][::core::mem::offset_of!(LFRFIDT5577, mask) - 36usize];
};
unsafe extern "C" {
    #[doc = "Write T5577 tag data to tag\n\n # Arguments\n\n* `data` -"]
    pub fn t5577_write(data: *mut LFRFIDT5577);
}
unsafe extern "C" {
    pub fn t5577_write_with_pass(data: *mut LFRFIDT5577, password: u32);
}
unsafe extern "C" {
    pub fn t5577_write_with_mask(data: *mut LFRFIDT5577, page: u8, with_pass: bool, password: u32);
}
pub const LFRFIDFeatureASK: LFRFIDFeature = LFRFIDFeature(1);
#[doc = "ASK Demodulation"]
pub const LFRFIDFeaturePSK: LFRFIDFeature = LFRFIDFeature(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDFeature(pub core::ffi::c_uchar);
pub const LFRFIDProtocolEM4100: LFRFIDProtocol = LFRFIDProtocol(0);
pub const LFRFIDProtocolEM410032: LFRFIDProtocol = LFRFIDProtocol(1);
pub const LFRFIDProtocolEM410016: LFRFIDProtocol = LFRFIDProtocol(2);
pub const LFRFIDProtocolElectra: LFRFIDProtocol = LFRFIDProtocol(3);
pub const LFRFIDProtocolH10301: LFRFIDProtocol = LFRFIDProtocol(4);
pub const LFRFIDProtocolIdteck: LFRFIDProtocol = LFRFIDProtocol(5);
pub const LFRFIDProtocolIndala26: LFRFIDProtocol = LFRFIDProtocol(6);
pub const LFRFIDProtocolIOProxXSF: LFRFIDProtocol = LFRFIDProtocol(7);
pub const LFRFIDProtocolAwid: LFRFIDProtocol = LFRFIDProtocol(8);
pub const LFRFIDProtocolFDXA: LFRFIDProtocol = LFRFIDProtocol(9);
pub const LFRFIDProtocolFDXB: LFRFIDProtocol = LFRFIDProtocol(10);
pub const LFRFIDProtocolHidGeneric: LFRFIDProtocol = LFRFIDProtocol(11);
pub const LFRFIDProtocolHidExGeneric: LFRFIDProtocol = LFRFIDProtocol(12);
pub const LFRFIDProtocolPyramid: LFRFIDProtocol = LFRFIDProtocol(13);
pub const LFRFIDProtocolViking: LFRFIDProtocol = LFRFIDProtocol(14);
pub const LFRFIDProtocolJablotron: LFRFIDProtocol = LFRFIDProtocol(15);
pub const LFRFIDProtocolParadox: LFRFIDProtocol = LFRFIDProtocol(16);
pub const LFRFIDProtocolPACStanley: LFRFIDProtocol = LFRFIDProtocol(17);
pub const LFRFIDProtocolKeri: LFRFIDProtocol = LFRFIDProtocol(18);
pub const LFRFIDProtocolGallagher: LFRFIDProtocol = LFRFIDProtocol(19);
pub const LFRFIDProtocolNexwatch: LFRFIDProtocol = LFRFIDProtocol(20);
pub const LFRFIDProtocolSecurakey: LFRFIDProtocol = LFRFIDProtocol(21);
pub const LFRFIDProtocolGProxII: LFRFIDProtocol = LFRFIDProtocol(22);
pub const LFRFIDProtocolMax: LFRFIDProtocol = LFRFIDProtocol(23);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDProtocol(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub static mut lfrfid_protocols: [*const ProtocolBase; 0usize];
}
pub const LFRFIDWriteTypeT5577: LFRFIDWriteType = LFRFIDWriteType(0);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDWriteType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LFRFIDWriteRequest {
    pub write_type: LFRFIDWriteType,
    pub __bindgen_anon_1: LFRFIDWriteRequest__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LFRFIDWriteRequest__bindgen_ty_1 {
    pub t5577: LFRFIDT5577,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LFRFIDWriteRequest__bindgen_ty_1"]
        [::core::mem::size_of::<LFRFIDWriteRequest__bindgen_ty_1>() - 40usize];
    ["Alignment of LFRFIDWriteRequest__bindgen_ty_1"]
        [::core::mem::align_of::<LFRFIDWriteRequest__bindgen_ty_1>() - 4usize];
    ["Offset of field: LFRFIDWriteRequest__bindgen_ty_1::t5577"]
        [::core::mem::offset_of!(LFRFIDWriteRequest__bindgen_ty_1, t5577) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LFRFIDWriteRequest"][::core::mem::size_of::<LFRFIDWriteRequest>() - 44usize];
    ["Alignment of LFRFIDWriteRequest"][::core::mem::align_of::<LFRFIDWriteRequest>() - 4usize];
    ["Offset of field: LFRFIDWriteRequest::write_type"]
        [::core::mem::offset_of!(LFRFIDWriteRequest, write_type) - 0usize];
};
unsafe extern "C" {
    #[doc = "Save protocol from dictionary to file\n\n # Arguments\n\n* `dict` -\n * `protocol` -\n * `filename` -\n # Returns\n\ntrue\n false"]
    pub fn lfrfid_dict_file_save(
        dict: *mut ProtocolDict,
        protocol: ProtocolId,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Load protocol from file to dictionary\n\n # Arguments\n\n* `dict` -\n * `filename` -\n # Returns\n\nProtocolId"]
    pub fn lfrfid_dict_file_load(
        dict: *mut ProtocolDict,
        filename: *const core::ffi::c_char,
    ) -> ProtocolId;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawFile {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate a new LFRFIDRawFile instance\n\n # Arguments\n\n* `storage` -\n # Returns\n\nLFRFIDRawFile*"]
    pub fn lfrfid_raw_file_alloc(storage: *mut Storage) -> *mut LFRFIDRawFile;
}
unsafe extern "C" {
    #[doc = "Free a LFRFIDRawFile instance\n\n # Arguments\n\n* `file` -"]
    pub fn lfrfid_raw_file_free(file: *mut LFRFIDRawFile);
}
unsafe extern "C" {
    #[doc = "Open RAW file for writing\n\n # Arguments\n\n* `file` -\n * `file_path` -\n # Returns\n\nbool"]
    pub fn lfrfid_raw_file_open_write(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Open RAW file for reading\n # Arguments\n\n* `file` -\n * `file_path` -\n # Returns\n\nbool"]
    pub fn lfrfid_raw_file_open_read(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write RAW file header\n\n # Arguments\n\n* `file` -\n * `frequency` -\n * `duty_cycle` -\n * `max_buffer_size` -\n # Returns\n\nbool"]
    pub fn lfrfid_raw_file_write_header(
        file: *mut LFRFIDRawFile,
        frequency: f32,
        duty_cycle: f32,
        max_buffer_size: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Write data to RAW file\n\n # Arguments\n\n* `file` -\n * `buffer_data` -\n * `buffer_size` -\n # Returns\n\nbool"]
    pub fn lfrfid_raw_file_write_buffer(
        file: *mut LFRFIDRawFile,
        buffer_data: *mut u8,
        buffer_size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read RAW file header\n\n # Arguments\n\n* `file` -\n * `frequency` -\n * `duty_cycle` -\n # Returns\n\nbool"]
    pub fn lfrfid_raw_file_read_header(
        file: *mut LFRFIDRawFile,
        frequency: *mut f32,
        duty_cycle: *mut f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Read varint-encoded pair from RAW file\n\n # Arguments\n\n* `file` -\n * `duration` -\n * `pulse` -\n * `pass_end` - file was wrapped around, can be NULL\n # Returns\n\nbool"]
    pub fn lfrfid_raw_file_read_pair(
        file: *mut LFRFIDRawFile,
        duration: *mut u32,
        pulse: *mut u32,
        pass_end: *mut bool,
    ) -> bool;
}
pub const LFRFIDWorkerWriteOK: LFRFIDWorkerWriteResult = LFRFIDWorkerWriteResult(0);
pub const LFRFIDWorkerWriteProtocolCannotBeWritten: LFRFIDWorkerWriteResult =
    LFRFIDWorkerWriteResult(1);
pub const LFRFIDWorkerWriteFobCannotBeWritten: LFRFIDWorkerWriteResult = LFRFIDWorkerWriteResult(2);
pub const LFRFIDWorkerWriteTooLongToWrite: LFRFIDWorkerWriteResult = LFRFIDWorkerWriteResult(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDWorkerWriteResult(pub core::ffi::c_uchar);
pub const LFRFIDWorkerReadTypeAuto: LFRFIDWorkerReadType = LFRFIDWorkerReadType(0);
pub const LFRFIDWorkerReadTypeASKOnly: LFRFIDWorkerReadType = LFRFIDWorkerReadType(1);
pub const LFRFIDWorkerReadTypePSKOnly: LFRFIDWorkerReadType = LFRFIDWorkerReadType(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDWorkerReadType(pub core::ffi::c_uchar);
pub const LFRFIDWorkerReadSenseStart: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(0);
pub const LFRFIDWorkerReadSenseEnd: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(1);
pub const LFRFIDWorkerReadSenseCardStart: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(2);
pub const LFRFIDWorkerReadSenseCardEnd: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(3);
pub const LFRFIDWorkerReadStartASK: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(4);
pub const LFRFIDWorkerReadStartPSK: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(5);
pub const LFRFIDWorkerReadDone: LFRFIDWorkerReadResult = LFRFIDWorkerReadResult(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDWorkerReadResult(pub core::ffi::c_uchar);
pub const LFRFIDWorkerReadRawFileError: LFRFIDWorkerReadRawResult = LFRFIDWorkerReadRawResult(0);
pub const LFRFIDWorkerReadRawOverrun: LFRFIDWorkerReadRawResult = LFRFIDWorkerReadRawResult(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDWorkerReadRawResult(pub core::ffi::c_uchar);
pub const LFRFIDWorkerEmulateRawFileError: LFRFIDWorkerEmulateRawResult =
    LFRFIDWorkerEmulateRawResult(0);
pub const LFRFIDWorkerEmulateRawOverrun: LFRFIDWorkerEmulateRawResult =
    LFRFIDWorkerEmulateRawResult(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LFRFIDWorkerEmulateRawResult(pub core::ffi::c_uchar);
pub type LFRFIDWorkerReadCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: LFRFIDWorkerReadResult,
        protocol: ProtocolId,
        context: *mut core::ffi::c_void,
    ),
>;
pub type LFRFIDWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerWriteResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerReadRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerReadRawResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerEmulateRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerEmulateRawResult, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDWorker {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate LF-RFID worker\n # Returns\n\nLFRFIDWorker*"]
    pub fn lfrfid_worker_alloc(dict: *mut ProtocolDict) -> *mut LFRFIDWorker;
}
unsafe extern "C" {
    #[doc = "Free LF-RFID worker\n\n # Arguments\n\n* `worker` - The worker"]
    pub fn lfrfid_worker_free(worker: *mut LFRFIDWorker);
}
unsafe extern "C" {
    #[doc = "Start LF-RFID worker thread\n\n # Arguments\n\n* `worker` - The worker"]
    pub fn lfrfid_worker_start_thread(worker: *mut LFRFIDWorker);
}
unsafe extern "C" {
    #[doc = "Stop LF-RFID worker thread\n\n # Arguments\n\n* `worker` - The worker"]
    pub fn lfrfid_worker_stop_thread(worker: *mut LFRFIDWorker);
}
unsafe extern "C" {
    #[doc = "Start read mode\n\n # Arguments\n\n* `worker` - The worker\n * `type` - The type\n * `callback` - The callback\n * `context` - The context"]
    pub fn lfrfid_worker_read_start(
        worker: *mut LFRFIDWorker,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start write mode\n\n # Arguments\n\n* `worker` - The worker\n * `protocol` - The protocol\n * `callback` - The callback\n * `context` - The context"]
    pub fn lfrfid_worker_write_start(
        worker: *mut LFRFIDWorker,
        protocol: LFRFIDProtocol,
        callback: LFRFIDWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start emulate mode\n\n # Arguments\n\n* `worker` - The worker\n * `protocol` (direction in) - The protocol"]
    pub fn lfrfid_worker_emulate_start(worker: *mut LFRFIDWorker, protocol: LFRFIDProtocol);
}
unsafe extern "C" {
    #[doc = "Start raw read mode\n\n # Arguments\n\n* `worker` - The worker\n * `filename` - The filename\n * `type` - The type\n * `callback` - The callback\n * `context` - The context"]
    pub fn lfrfid_worker_read_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Emulate raw read mode\n\n # Arguments\n\n* `worker` - The worker\n * `filename` - The filename\n * `callback` - The callback\n * `context` - The context"]
    pub fn lfrfid_worker_emulate_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Stop all modes\n\n # Arguments\n\n* `worker` - The worker"]
    pub fn lfrfid_worker_stop(worker: *mut LFRFIDWorker);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawWorker {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate a new LFRFIDRawWorker instance\n\n # Returns\n\nLFRFIDRawWorker*"]
    pub fn lfrfid_raw_worker_alloc() -> *mut LFRFIDRawWorker;
}
unsafe extern "C" {
    #[doc = "Free a LFRFIDRawWorker instance\n\n # Arguments\n\n* `worker` - LFRFIDRawWorker instance"]
    pub fn lfrfid_raw_worker_free(worker: *mut LFRFIDRawWorker);
}
unsafe extern "C" {
    #[doc = "Start reading\n\n # Arguments\n\n* `worker` - LFRFIDRawWorker instance\n * `file_path` - path where file will be saved\n * `frequency` - HW frequency\n * `duty_cycle` - HW duty cycle\n * `callback` - callback for read event\n * `context` - context for callback"]
    pub fn lfrfid_raw_worker_start_read(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        frequency: f32,
        duty_cycle: f32,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start emulate\n\n # Arguments\n\n* `worker` - LFRFIDRawWorker instance\n * `file_path` - path to file that will be emulated\n * `callback` - callback for emulate event\n * `context` - context for callback"]
    pub fn lfrfid_raw_worker_start_emulate(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Stop worker\n\n # Arguments\n\n* `worker` -"]
    pub fn lfrfid_raw_worker_stop(worker: *mut LFRFIDRawWorker);
}
#[doc = "Line Coding Structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_line_coding {
    #[doc = "<Data terminal rate, in bits per second."]
    pub dwDTERate: u32,
    #[doc = "<Stop bits."]
    pub bCharFormat: u8,
    #[doc = "<Parity."]
    pub bParityType: u8,
    #[doc = "<Data bits (5,6,7,8 or 16)."]
    pub bDataBits: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of usb_cdc_line_coding"][::core::mem::size_of::<usb_cdc_line_coding>() - 7usize];
    ["Alignment of usb_cdc_line_coding"][::core::mem::align_of::<usb_cdc_line_coding>() - 1usize];
    ["Offset of field: usb_cdc_line_coding::dwDTERate"]
        [::core::mem::offset_of!(usb_cdc_line_coding, dwDTERate) - 0usize];
    ["Offset of field: usb_cdc_line_coding::bCharFormat"]
        [::core::mem::offset_of!(usb_cdc_line_coding, bCharFormat) - 4usize];
    ["Offset of field: usb_cdc_line_coding::bParityType"]
        [::core::mem::offset_of!(usb_cdc_line_coding, bParityType) - 5usize];
    ["Offset of field: usb_cdc_line_coding::bDataBits"]
        [::core::mem::offset_of!(usb_cdc_line_coding, bDataBits) - 6usize];
};
#[doc = "Triple-DES context structure\n\n DES/3DES are considered weak ciphers and their use constitutes a\n security risk. We recommend considering stronger ciphers\n instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_des3_context {
    #[doc = "< 3DES subkeys"]
    pub private_sk: [u32; 96usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mbedtls_des3_context"][::core::mem::size_of::<mbedtls_des3_context>() - 384usize];
    ["Alignment of mbedtls_des3_context"][::core::mem::align_of::<mbedtls_des3_context>() - 4usize];
    ["Offset of field: mbedtls_des3_context::private_sk"]
        [::core::mem::offset_of!(mbedtls_des3_context, private_sk) - 0usize];
};
pub type mjs_val_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mjs {
    _unused: [u8; 0],
}
pub const MJS_TYPE_UNDEFINED: mjs_type = mjs_type(0);
pub const MJS_TYPE_NULL: mjs_type = mjs_type(1);
pub const MJS_TYPE_BOOLEAN: mjs_type = mjs_type(2);
pub const MJS_TYPE_NUMBER: mjs_type = mjs_type(3);
pub const MJS_TYPE_STRING: mjs_type = mjs_type(4);
pub const MJS_TYPE_FOREIGN: mjs_type = mjs_type(5);
pub const MJS_TYPE_ARRAY_BUF: mjs_type = mjs_type(6);
pub const MJS_TYPE_ARRAY_BUF_VIEW: mjs_type = mjs_type(7);
pub const MJS_TYPE_OBJECT_GENERIC: mjs_type = mjs_type(8);
pub const MJS_TYPE_OBJECT_ARRAY: mjs_type = mjs_type(9);
pub const MJS_TYPE_OBJECT_FUNCTION: mjs_type = mjs_type(10);
pub const MJS_TYPES_CNT: mjs_type = mjs_type(11);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct mjs_type(pub core::ffi::c_uchar);
pub const MJS_OK: mjs_err = mjs_err(0);
pub const MJS_SYNTAX_ERROR: mjs_err = mjs_err(1);
pub const MJS_REFERENCE_ERROR: mjs_err = mjs_err(2);
pub const MJS_TYPE_ERROR: mjs_err = mjs_err(3);
pub const MJS_OUT_OF_MEMORY: mjs_err = mjs_err(4);
pub const MJS_INTERNAL_ERROR: mjs_err = mjs_err(5);
pub const MJS_NOT_IMPLEMENTED_ERROR: mjs_err = mjs_err(6);
pub const MJS_FILE_READ_ERROR: mjs_err = mjs_err(7);
pub const MJS_BAD_ARGS_ERROR: mjs_err = mjs_err(8);
pub const MJS_NEED_EXIT: mjs_err = mjs_err(9);
pub const MJS_ERRS_CNT: mjs_err = mjs_err(10);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct mjs_err(pub core::ffi::c_uchar);
pub use self::mjs_err as mjs_err_t;
pub type mjs_flags_poller_t = ::core::option::Option<unsafe extern "C" fn(mjs: *mut mjs)>;
unsafe extern "C" {
    pub fn mjs_create(context: *mut core::ffi::c_void) -> *mut mjs;
}
unsafe extern "C" {
    pub fn mjs_destroy(mjs: *mut mjs);
}
unsafe extern "C" {
    pub fn mjs_get_global(mjs: *mut mjs) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_own(mjs: *mut mjs, v: *mut mjs_val_t);
}
unsafe extern "C" {
    pub fn mjs_disown(mjs: *mut mjs, v: *mut mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_set_errorf(
        mjs: *mut mjs,
        err: mjs_err_t,
        fmt: *const core::ffi::c_char,
        ...
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_exit(mjs: *mut mjs);
}
unsafe extern "C" {
    pub fn mjs_set_exec_flags_poller(mjs: *mut mjs, poller: mjs_flags_poller_t);
}
unsafe extern "C" {
    pub fn mjs_get_context(mjs: *mut mjs) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn mjs_prepend_errorf(
        mjs: *mut mjs,
        err: mjs_err_t,
        fmt: *const core::ffi::c_char,
        ...
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_print_error(
        mjs: *mut mjs,
        fp: *mut FILE,
        msg: *const core::ffi::c_char,
        print_stack_trace: core::ffi::c_int,
    );
}
unsafe extern "C" {
    pub fn mjs_strerror(mjs: *mut mjs, err: mjs_err) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_get_stack_trace(mjs: *mut mjs) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_set_generate_jsc(mjs: *mut mjs, generate_jsc: core::ffi::c_int);
}
unsafe extern "C" {
    pub fn mjs_nargs(mjs: *mut mjs) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_arg(mjs: *mut mjs, n: core::ffi::c_int) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_return(mjs: *mut mjs, v: mjs_val_t);
}
pub const MJS_DATAVIEW_U8: mjs_dataview_type_t = mjs_dataview_type_t(0);
pub const MJS_DATAVIEW_I8: mjs_dataview_type_t = mjs_dataview_type_t(1);
pub const MJS_DATAVIEW_U16: mjs_dataview_type_t = mjs_dataview_type_t(2);
pub const MJS_DATAVIEW_I16: mjs_dataview_type_t = mjs_dataview_type_t(3);
pub const MJS_DATAVIEW_U32: mjs_dataview_type_t = mjs_dataview_type_t(4);
pub const MJS_DATAVIEW_I32: mjs_dataview_type_t = mjs_dataview_type_t(5);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct mjs_dataview_type_t(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn mjs_is_array_buf(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_is_data_view(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_is_typed_array(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_array_buf(
        mjs: *mut mjs,
        data: *mut core::ffi::c_char,
        buf_len: usize,
    ) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_array_buf_get_ptr(
        mjs: *mut mjs,
        buf: mjs_val_t,
        bytelen: *mut usize,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_dataview_get_buf(mjs: *mut mjs, obj: mjs_val_t) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_mk_array(mjs: *mut mjs) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_array_length(mjs: *mut mjs, arr: mjs_val_t) -> core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn mjs_array_push(mjs: *mut mjs, arr: mjs_val_t, v: mjs_val_t) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_array_get(arg1: *mut mjs, arr: mjs_val_t, index: core::ffi::c_ulong) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_array_set(
        mjs: *mut mjs,
        arr: mjs_val_t,
        index: core::ffi::c_ulong,
        v: mjs_val_t,
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_is_array(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_array_del(mjs: *mut mjs, arr: mjs_val_t, index: core::ffi::c_ulong);
}
unsafe extern "C" {
    pub fn mjs_exec(
        arg1: *mut mjs,
        src: *const core::ffi::c_char,
        res: *mut mjs_val_t,
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_exec_file(
        mjs: *mut mjs,
        path: *const core::ffi::c_char,
        res: *mut mjs_val_t,
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_apply(
        mjs: *mut mjs,
        res: *mut mjs_val_t,
        func: mjs_val_t,
        this_val: mjs_val_t,
        nargs: core::ffi::c_int,
        args: *mut mjs_val_t,
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_call(
        mjs: *mut mjs,
        res: *mut mjs_val_t,
        func: mjs_val_t,
        this_val: mjs_val_t,
        nargs: core::ffi::c_int,
        ...
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_get_this(mjs: *mut mjs) -> mjs_val_t;
}
pub const MJS_FFI_CTYPE_NONE: mjs_ffi_ctype = mjs_ffi_ctype(0);
pub const MJS_FFI_CTYPE_USERDATA: mjs_ffi_ctype = mjs_ffi_ctype(1);
pub const MJS_FFI_CTYPE_CALLBACK: mjs_ffi_ctype = mjs_ffi_ctype(2);
pub const MJS_FFI_CTYPE_INT: mjs_ffi_ctype = mjs_ffi_ctype(3);
pub const MJS_FFI_CTYPE_BOOL: mjs_ffi_ctype = mjs_ffi_ctype(4);
pub const MJS_FFI_CTYPE_DOUBLE: mjs_ffi_ctype = mjs_ffi_ctype(5);
pub const MJS_FFI_CTYPE_FLOAT: mjs_ffi_ctype = mjs_ffi_ctype(6);
pub const MJS_FFI_CTYPE_CHAR_PTR: mjs_ffi_ctype = mjs_ffi_ctype(7);
pub const MJS_FFI_CTYPE_VOID_PTR: mjs_ffi_ctype = mjs_ffi_ctype(8);
pub const MJS_FFI_CTYPE_STRUCT_MG_STR_PTR: mjs_ffi_ctype = mjs_ffi_ctype(9);
pub const MJS_FFI_CTYPE_STRUCT_MG_STR: mjs_ffi_ctype = mjs_ffi_ctype(10);
pub const MJS_FFI_CTYPE_INVALID: mjs_ffi_ctype = mjs_ffi_ctype(11);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct mjs_ffi_ctype(pub core::ffi::c_uchar);
pub type mjs_ffi_resolver_t = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut core::ffi::c_void,
        symbol: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_void,
>;
unsafe extern "C" {
    pub fn mjs_set_ffi_resolver(
        mjs: *mut mjs,
        dlsym: mjs_ffi_resolver_t,
        handle: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn mjs_ffi_resolve(
        mjs: *mut mjs,
        symbol: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn mjs_is_object(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_is_object_based(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_object(mjs: *mut mjs) -> mjs_val_t;
}
pub const MJS_STRUCT_FIELD_TYPE_INVALID: mjs_struct_field_type = mjs_struct_field_type(0);
pub const MJS_STRUCT_FIELD_TYPE_STRUCT: mjs_struct_field_type = mjs_struct_field_type(1);
pub const MJS_STRUCT_FIELD_TYPE_STRUCT_PTR: mjs_struct_field_type = mjs_struct_field_type(2);
pub const MJS_STRUCT_FIELD_TYPE_INT: mjs_struct_field_type = mjs_struct_field_type(3);
pub const MJS_STRUCT_FIELD_TYPE_BOOL: mjs_struct_field_type = mjs_struct_field_type(4);
pub const MJS_STRUCT_FIELD_TYPE_DOUBLE: mjs_struct_field_type = mjs_struct_field_type(5);
pub const MJS_STRUCT_FIELD_TYPE_FLOAT: mjs_struct_field_type = mjs_struct_field_type(6);
pub const MJS_STRUCT_FIELD_TYPE_CHAR_PTR: mjs_struct_field_type = mjs_struct_field_type(7);
pub const MJS_STRUCT_FIELD_TYPE_VOID_PTR: mjs_struct_field_type = mjs_struct_field_type(8);
pub const MJS_STRUCT_FIELD_TYPE_MG_STR_PTR: mjs_struct_field_type = mjs_struct_field_type(9);
pub const MJS_STRUCT_FIELD_TYPE_MG_STR: mjs_struct_field_type = mjs_struct_field_type(10);
pub const MJS_STRUCT_FIELD_TYPE_DATA: mjs_struct_field_type = mjs_struct_field_type(11);
pub const MJS_STRUCT_FIELD_TYPE_INT8: mjs_struct_field_type = mjs_struct_field_type(12);
pub const MJS_STRUCT_FIELD_TYPE_INT16: mjs_struct_field_type = mjs_struct_field_type(13);
pub const MJS_STRUCT_FIELD_TYPE_UINT8: mjs_struct_field_type = mjs_struct_field_type(14);
pub const MJS_STRUCT_FIELD_TYPE_UINT16: mjs_struct_field_type = mjs_struct_field_type(15);
pub const MJS_STRUCT_FIELD_TYPE_CUSTOM: mjs_struct_field_type = mjs_struct_field_type(16);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct mjs_struct_field_type(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mjs_c_struct_member {
    pub name: *const core::ffi::c_char,
    pub offset: core::ffi::c_int,
    pub type_: mjs_struct_field_type,
    pub arg: *const core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mjs_c_struct_member"][::core::mem::size_of::<mjs_c_struct_member>() - 16usize];
    ["Alignment of mjs_c_struct_member"][::core::mem::align_of::<mjs_c_struct_member>() - 4usize];
    ["Offset of field: mjs_c_struct_member::name"]
        [::core::mem::offset_of!(mjs_c_struct_member, name) - 0usize];
    ["Offset of field: mjs_c_struct_member::offset"]
        [::core::mem::offset_of!(mjs_c_struct_member, offset) - 4usize];
    ["Offset of field: mjs_c_struct_member::type_"]
        [::core::mem::offset_of!(mjs_c_struct_member, type_) - 8usize];
    ["Offset of field: mjs_c_struct_member::arg"]
        [::core::mem::offset_of!(mjs_c_struct_member, arg) - 12usize];
};
unsafe extern "C" {
    pub fn mjs_struct_to_obj(
        mjs: *mut mjs,
        base: *const core::ffi::c_void,
        members: *const mjs_c_struct_member,
    ) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_get(
        mjs: *mut mjs,
        obj: mjs_val_t,
        name: *const core::ffi::c_char,
        name_len: usize,
    ) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_get_v(mjs: *mut mjs, obj: mjs_val_t, name: mjs_val_t) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_get_v_proto(mjs: *mut mjs, obj: mjs_val_t, key: mjs_val_t) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_set(
        mjs: *mut mjs,
        obj: mjs_val_t,
        name: *const core::ffi::c_char,
        len: usize,
        val: mjs_val_t,
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_set_v(mjs: *mut mjs, obj: mjs_val_t, name: mjs_val_t, val: mjs_val_t) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_del(
        mjs: *mut mjs,
        obj: mjs_val_t,
        name: *const core::ffi::c_char,
        len: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_next(mjs: *mut mjs, obj: mjs_val_t, iterator: *mut mjs_val_t) -> mjs_val_t;
}
pub type mjs_custom_obj_destructor_t =
    ::core::option::Option<unsafe extern "C" fn(mjs: *mut mjs, object: mjs_val_t)>;
pub type mjs_func_ptr_t = ::core::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub fn mjs_mk_null() -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_is_null(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_undefined() -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_is_undefined(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_number(mjs: *mut mjs, num: f64) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_get_double(mjs: *mut mjs, v: mjs_val_t) -> f64;
}
unsafe extern "C" {
    pub fn mjs_get_int(mjs: *mut mjs, v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_get_int32(mjs: *mut mjs, v: mjs_val_t) -> i32;
}
unsafe extern "C" {
    pub fn mjs_is_number(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_foreign(mjs: *mut mjs, ptr: *mut core::ffi::c_void) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_mk_foreign_func(mjs: *mut mjs, fn_: mjs_func_ptr_t) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_get_ptr(mjs: *mut mjs, v: mjs_val_t) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn mjs_is_foreign(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_boolean(mjs: *mut mjs, v: core::ffi::c_int) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_get_bool(mjs: *mut mjs, v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_is_boolean(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_function(mjs: *mut mjs, off: usize) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_is_function(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_mk_string(
        mjs: *mut mjs,
        str_: *const core::ffi::c_char,
        len: usize,
        copy: core::ffi::c_int,
    ) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_is_string(v: mjs_val_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_get_string(
        mjs: *mut mjs,
        v: *mut mjs_val_t,
        len: *mut usize,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_get_cstring(mjs: *mut mjs, v: *mut mjs_val_t) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_strcmp(
        mjs: *mut mjs,
        a: *mut mjs_val_t,
        b: *const core::ffi::c_char,
        len: usize,
    ) -> core::ffi::c_int;
}
pub type MjsPrintCallback = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut core::ffi::c_void, format: *const core::ffi::c_char, ...),
>;
unsafe extern "C" {
    pub fn mjs_typeof(v: mjs_val_t) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_fprintf(v: mjs_val_t, mjs: *mut mjs, fp: *mut FILE);
}
unsafe extern "C" {
    pub fn mjs_sprintf(v: mjs_val_t, mjs: *mut mjs, buf: *mut core::ffi::c_char, buflen: usize);
}
unsafe extern "C" {
    pub fn mjs_disasm_all(
        mjs: *mut mjs,
        print_cb: MjsPrintCallback,
        print_ctx: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn mjs_dump(
        mjs: *mut mjs,
        do_disasm: core::ffi::c_int,
        print_cb: MjsPrintCallback,
        print_ctx: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn mjs_get_bcode_filename_by_offset(
        mjs: *mut mjs,
        offset: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mjs_get_lineno_by_offset(mjs: *mut mjs, offset: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_get_offset_by_call_frame_num(
        mjs: *mut mjs,
        cf_num: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mjs_to_string(
        mjs: *mut mjs,
        v: *mut mjs_val_t,
        p: *mut *mut core::ffi::c_char,
        sizep: *mut usize,
        need_free: *mut core::ffi::c_int,
    ) -> mjs_err_t;
}
unsafe extern "C" {
    pub fn mjs_to_boolean_v(mjs: *mut mjs, v: mjs_val_t) -> mjs_val_t;
}
unsafe extern "C" {
    pub fn mjs_is_truthy(mjs: *mut mjs, v: mjs_val_t) -> core::ffi::c_int;
}
pub type pb_type_t = uint_least8_t;
pub type pb_size_t = uint_least16_t;
pub type pb_ssize_t = int_least16_t;
pub type pb_byte_t = uint_least8_t;
pub type pb_istream_t = pb_istream_s;
pub type pb_ostream_t = pb_ostream_s;
pub type pb_field_iter_t = pb_field_iter_s;
pub type pb_msgdesc_t = pb_msgdesc_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_msgdesc_s {
    pub field_info: *const u32,
    pub submsg_info: *const *const pb_msgdesc_t,
    pub default_value: *const pb_byte_t,
    pub field_callback: ::core::option::Option<
        unsafe extern "C" fn(
            istream: *mut pb_istream_t,
            ostream: *mut pb_ostream_t,
            field: *const pb_field_iter_t,
        ) -> bool,
    >,
    pub field_count: pb_size_t,
    pub required_field_count: pb_size_t,
    pub largest_tag: pb_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_msgdesc_s"][::core::mem::size_of::<pb_msgdesc_s>() - 24usize];
    ["Alignment of pb_msgdesc_s"][::core::mem::align_of::<pb_msgdesc_s>() - 4usize];
    ["Offset of field: pb_msgdesc_s::field_info"]
        [::core::mem::offset_of!(pb_msgdesc_s, field_info) - 0usize];
    ["Offset of field: pb_msgdesc_s::submsg_info"]
        [::core::mem::offset_of!(pb_msgdesc_s, submsg_info) - 4usize];
    ["Offset of field: pb_msgdesc_s::default_value"]
        [::core::mem::offset_of!(pb_msgdesc_s, default_value) - 8usize];
    ["Offset of field: pb_msgdesc_s::field_callback"]
        [::core::mem::offset_of!(pb_msgdesc_s, field_callback) - 12usize];
    ["Offset of field: pb_msgdesc_s::field_count"]
        [::core::mem::offset_of!(pb_msgdesc_s, field_count) - 16usize];
    ["Offset of field: pb_msgdesc_s::required_field_count"]
        [::core::mem::offset_of!(pb_msgdesc_s, required_field_count) - 18usize];
    ["Offset of field: pb_msgdesc_s::largest_tag"]
        [::core::mem::offset_of!(pb_msgdesc_s, largest_tag) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_field_iter_s {
    pub descriptor: *const pb_msgdesc_t,
    pub message: *mut core::ffi::c_void,
    pub index: pb_size_t,
    pub field_info_index: pb_size_t,
    pub required_field_index: pb_size_t,
    pub submessage_index: pb_size_t,
    pub tag: pb_size_t,
    pub data_size: pb_size_t,
    pub array_size: pb_size_t,
    pub type_: pb_type_t,
    pub pField: *mut core::ffi::c_void,
    pub pData: *mut core::ffi::c_void,
    pub pSize: *mut core::ffi::c_void,
    pub submsg_desc: *const pb_msgdesc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_field_iter_s"][::core::mem::size_of::<pb_field_iter_s>() - 40usize];
    ["Alignment of pb_field_iter_s"][::core::mem::align_of::<pb_field_iter_s>() - 4usize];
    ["Offset of field: pb_field_iter_s::descriptor"]
        [::core::mem::offset_of!(pb_field_iter_s, descriptor) - 0usize];
    ["Offset of field: pb_field_iter_s::message"]
        [::core::mem::offset_of!(pb_field_iter_s, message) - 4usize];
    ["Offset of field: pb_field_iter_s::index"]
        [::core::mem::offset_of!(pb_field_iter_s, index) - 8usize];
    ["Offset of field: pb_field_iter_s::field_info_index"]
        [::core::mem::offset_of!(pb_field_iter_s, field_info_index) - 10usize];
    ["Offset of field: pb_field_iter_s::required_field_index"]
        [::core::mem::offset_of!(pb_field_iter_s, required_field_index) - 12usize];
    ["Offset of field: pb_field_iter_s::submessage_index"]
        [::core::mem::offset_of!(pb_field_iter_s, submessage_index) - 14usize];
    ["Offset of field: pb_field_iter_s::tag"]
        [::core::mem::offset_of!(pb_field_iter_s, tag) - 16usize];
    ["Offset of field: pb_field_iter_s::data_size"]
        [::core::mem::offset_of!(pb_field_iter_s, data_size) - 18usize];
    ["Offset of field: pb_field_iter_s::array_size"]
        [::core::mem::offset_of!(pb_field_iter_s, array_size) - 20usize];
    ["Offset of field: pb_field_iter_s::type_"]
        [::core::mem::offset_of!(pb_field_iter_s, type_) - 22usize];
    ["Offset of field: pb_field_iter_s::pField"]
        [::core::mem::offset_of!(pb_field_iter_s, pField) - 24usize];
    ["Offset of field: pb_field_iter_s::pData"]
        [::core::mem::offset_of!(pb_field_iter_s, pData) - 28usize];
    ["Offset of field: pb_field_iter_s::pSize"]
        [::core::mem::offset_of!(pb_field_iter_s, pSize) - 32usize];
    ["Offset of field: pb_field_iter_s::submsg_desc"]
        [::core::mem::offset_of!(pb_field_iter_s, submsg_desc) - 36usize];
};
pub type pb_field_t = pb_field_iter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_bytes_array_s {
    pub size: pb_size_t,
    pub bytes: [pb_byte_t; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_bytes_array_s"][::core::mem::size_of::<pb_bytes_array_s>() - 4usize];
    ["Alignment of pb_bytes_array_s"][::core::mem::align_of::<pb_bytes_array_s>() - 2usize];
    ["Offset of field: pb_bytes_array_s::size"]
        [::core::mem::offset_of!(pb_bytes_array_s, size) - 0usize];
    ["Offset of field: pb_bytes_array_s::bytes"]
        [::core::mem::offset_of!(pb_bytes_array_s, bytes) - 2usize];
};
pub type pb_bytes_array_t = pb_bytes_array_s;
pub type pb_callback_t = pb_callback_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pb_callback_s {
    pub funcs: pb_callback_s__bindgen_ty_1,
    pub arg: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pb_callback_s__bindgen_ty_1 {
    pub decode: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            field: *const pb_field_t,
            arg: *mut *mut core::ffi::c_void,
        ) -> bool,
    >,
    pub encode: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            field: *const pb_field_t,
            arg: *const *mut core::ffi::c_void,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_callback_s__bindgen_ty_1"]
        [::core::mem::size_of::<pb_callback_s__bindgen_ty_1>() - 4usize];
    ["Alignment of pb_callback_s__bindgen_ty_1"]
        [::core::mem::align_of::<pb_callback_s__bindgen_ty_1>() - 4usize];
    ["Offset of field: pb_callback_s__bindgen_ty_1::decode"]
        [::core::mem::offset_of!(pb_callback_s__bindgen_ty_1, decode) - 0usize];
    ["Offset of field: pb_callback_s__bindgen_ty_1::encode"]
        [::core::mem::offset_of!(pb_callback_s__bindgen_ty_1, encode) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_callback_s"][::core::mem::size_of::<pb_callback_s>() - 8usize];
    ["Alignment of pb_callback_s"][::core::mem::align_of::<pb_callback_s>() - 4usize];
    ["Offset of field: pb_callback_s::funcs"]
        [::core::mem::offset_of!(pb_callback_s, funcs) - 0usize];
    ["Offset of field: pb_callback_s::arg"][::core::mem::offset_of!(pb_callback_s, arg) - 4usize];
};
unsafe extern "C" {
    pub fn pb_default_field_callback(
        istream: *mut pb_istream_t,
        ostream: *mut pb_ostream_t,
        field: *const pb_field_t,
    ) -> bool;
}
pub const PB_WT_VARINT: pb_wire_type_t = pb_wire_type_t(0);
pub const PB_WT_64BIT: pb_wire_type_t = pb_wire_type_t(1);
pub const PB_WT_STRING: pb_wire_type_t = pb_wire_type_t(2);
pub const PB_WT_32BIT: pb_wire_type_t = pb_wire_type_t(5);
pub const PB_WT_PACKED: pb_wire_type_t = pb_wire_type_t(255);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct pb_wire_type_t(pub core::ffi::c_uchar);
pub type pb_extension_type_t = pb_extension_type_s;
pub type pb_extension_t = pb_extension_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_type_s {
    pub decode: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_istream_t,
            extension: *mut pb_extension_t,
            tag: u32,
            wire_type: pb_wire_type_t,
        ) -> bool,
    >,
    pub encode: ::core::option::Option<
        unsafe extern "C" fn(stream: *mut pb_ostream_t, extension: *const pb_extension_t) -> bool,
    >,
    pub arg: *const core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_extension_type_s"][::core::mem::size_of::<pb_extension_type_s>() - 12usize];
    ["Alignment of pb_extension_type_s"][::core::mem::align_of::<pb_extension_type_s>() - 4usize];
    ["Offset of field: pb_extension_type_s::decode"]
        [::core::mem::offset_of!(pb_extension_type_s, decode) - 0usize];
    ["Offset of field: pb_extension_type_s::encode"]
        [::core::mem::offset_of!(pb_extension_type_s, encode) - 4usize];
    ["Offset of field: pb_extension_type_s::arg"]
        [::core::mem::offset_of!(pb_extension_type_s, arg) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_extension_s {
    pub type_: *const pb_extension_type_t,
    pub dest: *mut core::ffi::c_void,
    pub next: *mut pb_extension_t,
    pub found: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_extension_s"][::core::mem::size_of::<pb_extension_s>() - 16usize];
    ["Alignment of pb_extension_s"][::core::mem::align_of::<pb_extension_s>() - 4usize];
    ["Offset of field: pb_extension_s::type_"]
        [::core::mem::offset_of!(pb_extension_s, type_) - 0usize];
    ["Offset of field: pb_extension_s::dest"]
        [::core::mem::offset_of!(pb_extension_s, dest) - 4usize];
    ["Offset of field: pb_extension_s::next"]
        [::core::mem::offset_of!(pb_extension_s, next) - 8usize];
    ["Offset of field: pb_extension_s::found"]
        [::core::mem::offset_of!(pb_extension_s, found) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_istream_s {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(stream: *mut pb_istream_t, buf: *mut pb_byte_t, count: usize) -> bool,
    >,
    pub state: *mut core::ffi::c_void,
    pub bytes_left: usize,
    pub errmsg: *const core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_istream_s"][::core::mem::size_of::<pb_istream_s>() - 16usize];
    ["Alignment of pb_istream_s"][::core::mem::align_of::<pb_istream_s>() - 4usize];
    ["Offset of field: pb_istream_s::callback"]
        [::core::mem::offset_of!(pb_istream_s, callback) - 0usize];
    ["Offset of field: pb_istream_s::state"][::core::mem::offset_of!(pb_istream_s, state) - 4usize];
    ["Offset of field: pb_istream_s::bytes_left"]
        [::core::mem::offset_of!(pb_istream_s, bytes_left) - 8usize];
    ["Offset of field: pb_istream_s::errmsg"]
        [::core::mem::offset_of!(pb_istream_s, errmsg) - 12usize];
};
unsafe extern "C" {
    pub fn pb_decode(
        stream: *mut pb_istream_t,
        fields: *const pb_msgdesc_t,
        dest_struct: *mut core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_ex(
        stream: *mut pb_istream_t,
        fields: *const pb_msgdesc_t,
        dest_struct: *mut core::ffi::c_void,
        flags: core::ffi::c_uint,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_release(fields: *const pb_msgdesc_t, dest_struct: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Functions for manipulating streams *"]
    pub fn pb_istream_from_buffer(buf: *const pb_byte_t, msglen: usize) -> pb_istream_t;
}
unsafe extern "C" {
    pub fn pb_read(stream: *mut pb_istream_t, buf: *mut pb_byte_t, count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Helper functions for writing field callbacks *"]
    pub fn pb_decode_tag(
        stream: *mut pb_istream_t,
        wire_type: *mut pb_wire_type_t,
        tag: *mut u32,
        eof: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_skip_field(stream: *mut pb_istream_t, wire_type: pb_wire_type_t) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_varint(stream: *mut pb_istream_t, dest: *mut u64) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_varint32(stream: *mut pb_istream_t, dest: *mut u32) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_bool(stream: *mut pb_istream_t, dest: *mut bool) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_svarint(stream: *mut pb_istream_t, dest: *mut i64) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_fixed32(stream: *mut pb_istream_t, dest: *mut core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn pb_decode_fixed64(stream: *mut pb_istream_t, dest: *mut core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn pb_make_string_substream(
        stream: *mut pb_istream_t,
        substream: *mut pb_istream_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_close_string_substream(
        stream: *mut pb_istream_t,
        substream: *mut pb_istream_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_ostream_s {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            buf: *const pb_byte_t,
            count: usize,
        ) -> bool,
    >,
    pub state: *mut core::ffi::c_void,
    pub max_size: usize,
    pub bytes_written: usize,
    pub errmsg: *const core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pb_ostream_s"][::core::mem::size_of::<pb_ostream_s>() - 20usize];
    ["Alignment of pb_ostream_s"][::core::mem::align_of::<pb_ostream_s>() - 4usize];
    ["Offset of field: pb_ostream_s::callback"]
        [::core::mem::offset_of!(pb_ostream_s, callback) - 0usize];
    ["Offset of field: pb_ostream_s::state"][::core::mem::offset_of!(pb_ostream_s, state) - 4usize];
    ["Offset of field: pb_ostream_s::max_size"]
        [::core::mem::offset_of!(pb_ostream_s, max_size) - 8usize];
    ["Offset of field: pb_ostream_s::bytes_written"]
        [::core::mem::offset_of!(pb_ostream_s, bytes_written) - 12usize];
    ["Offset of field: pb_ostream_s::errmsg"]
        [::core::mem::offset_of!(pb_ostream_s, errmsg) - 16usize];
};
unsafe extern "C" {
    pub fn pb_encode(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_ex(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
        flags: core::ffi::c_uint,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_get_encoded_size(
        size: *mut usize,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Functions for manipulating streams *"]
    pub fn pb_ostream_from_buffer(buf: *mut pb_byte_t, bufsize: usize) -> pb_ostream_t;
}
unsafe extern "C" {
    pub fn pb_write(stream: *mut pb_ostream_t, buf: *const pb_byte_t, count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Helper functions for writing field callbacks *"]
    pub fn pb_encode_tag_for_field(
        stream: *mut pb_ostream_t,
        field: *const pb_field_iter_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_tag(
        stream: *mut pb_ostream_t,
        wiretype: pb_wire_type_t,
        field_number: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_varint(stream: *mut pb_ostream_t, value: u64) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_svarint(stream: *mut pb_ostream_t, value: i64) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_string(
        stream: *mut pb_ostream_t,
        buffer: *const pb_byte_t,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_fixed32(stream: *mut pb_ostream_t, value: *const core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_fixed64(stream: *mut pb_ostream_t, value: *const core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn pb_encode_submessage(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitBuffer {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate a BitBuffer instance.\n\n # Arguments\n\n* `capacity_bytes` (direction in) - maximum buffer capacity, in bytes\n\n # Returns\n\npointer to the allocated BitBuffer instance"]
    pub fn bit_buffer_alloc(capacity_bytes: usize) -> *mut BitBuffer;
}
unsafe extern "C" {
    #[doc = "Delete a BitBuffer instance.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance"]
    pub fn bit_buffer_free(buf: *mut BitBuffer);
}
unsafe extern "C" {
    #[doc = "Clear all data from a BitBuffer instance.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance"]
    pub fn bit_buffer_reset(buf: *mut BitBuffer);
}
unsafe extern "C" {
    #[doc = "Copy another BitBuffer instance's contents to this one, replacing all of the\n original data.\n\n The destination capacity must be no less than the source data\n size.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to copy into\n * `other` (direction in) - pointer to a BitBuffer instance to copy from"]
    pub fn bit_buffer_copy(buf: *mut BitBuffer, other: *const BitBuffer);
}
unsafe extern "C" {
    #[doc = "Copy all BitBuffer instance's contents to this one, starting from\n start_index, replacing all of the original data.\n\n The destination capacity must be no less than the source data\n size counting from start_index.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to copy into\n * `other` (direction in) - pointer to a BitBuffer instance to copy from\n * `start_index` (direction in) - index to begin copying source data from"]
    pub fn bit_buffer_copy_right(buf: *mut BitBuffer, other: *const BitBuffer, start_index: usize);
}
unsafe extern "C" {
    #[doc = "Copy all BitBuffer instance's contents to this one, ending with end_index,\n replacing all of the original data.\n\n The destination capacity must be no less than the source data\n size counting to end_index.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to copy into\n * `other` (direction in) - pointer to a BitBuffer instance to copy from\n * `end_index` (direction in) - index to end copying source data at"]
    pub fn bit_buffer_copy_left(buf: *mut BitBuffer, other: *const BitBuffer, end_index: usize);
}
unsafe extern "C" {
    #[doc = "Copy a byte array to a BitBuffer instance, replacing all of the original\n data.\n\n The destination capacity must be no less than the source data\n size.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to copy into\n * `data` (direction in) - pointer to the byte array to be copied\n * `size_bytes` (direction in) - size of the data to be copied, in bytes"]
    pub fn bit_buffer_copy_bytes(buf: *mut BitBuffer, data: *const u8, size_bytes: usize);
}
unsafe extern "C" {
    #[doc = "Copy a byte array to a BitBuffer instance, replacing all of the original\n data.\n\n The destination capacity must be no less than the source data\n size.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to copy into\n * `data` (direction in) - pointer to the byte array to be copied\n * `size_bits` (direction in) - size of the data to be copied, in bits"]
    pub fn bit_buffer_copy_bits(buf: *mut BitBuffer, data: *const u8, size_bits: usize);
}
unsafe extern "C" {
    #[doc = "Copy a byte with parity array to a BitBuffer instance, replacing all of the\n original data.\n\n The destination capacity must be no less than the source data\n size.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to copy into\n * `data` (direction in) - pointer to the byte array to be copied\n * `size_bits` (direction in) - size of the data to be copied, in bits\n > **Note:** Parity bits are placed starting with the most significant bit\n of each byte and moving up.\n > **Note:** Example: DDDDDDDD PDDDDDDD DPDDDDDD DDP..."]
    pub fn bit_buffer_copy_bytes_with_parity(
        buf: *mut BitBuffer,
        data: *const u8,
        size_bits: usize,
    );
}
unsafe extern "C" {
    #[doc = "Write a BitBuffer instance's entire contents to an arbitrary memory location.\n\n The destination memory must be allocated. Additionally, the\n destination capacity must be no less than the source data size.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to write from\n * `dest` (direction out) - pointer to the destination memory location\n * `size_bytes` (direction in) - maximum destination data size, in bytes"]
    pub fn bit_buffer_write_bytes(
        buf: *const BitBuffer,
        dest: *mut core::ffi::c_void,
        size_bytes: usize,
    );
}
unsafe extern "C" {
    #[doc = "Write a BitBuffer instance's entire contents to an arbitrary memory location.\n\n Additionally, place a parity bit after each byte.\n\n The destination memory must be allocated. Additionally, the\n destination capacity must be no less than the source data size\n plus parity.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to write from\n * `dest` (direction out) - pointer to the destination memory location\n * `size_bytes` (direction in) - maximum destination data size, in bytes\n * `bits_written` (direction out) - actual number of bits written, in bits\n > **Note:** Parity bits are placed starting with the most significant bit of\n each byte and moving up.\n > **Note:** Example: DDDDDDDD PDDDDDDD DPDDDDDD DDP..."]
    pub fn bit_buffer_write_bytes_with_parity(
        buf: *const BitBuffer,
        dest: *mut core::ffi::c_void,
        size_bytes: usize,
        bits_written: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = "Write a slice of BitBuffer instance's contents to an arbitrary memory\n location.\n\n The destination memory must be allocated. Additionally, the\n destination capacity must be no less than the requested slice\n size.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to write from\n * `dest` (direction out) - pointer to the destination memory location\n * `start_index` (direction in) - index to begin copying source data from\n * `size_bytes` (direction in) - data slice size, in bytes"]
    pub fn bit_buffer_write_bytes_mid(
        buf: *const BitBuffer,
        dest: *mut core::ffi::c_void,
        start_index: usize,
        size_bytes: usize,
    );
}
unsafe extern "C" {
    #[doc = "Check whether a BitBuffer instance contains a partial byte (i.e. the bit\n count is not divisible by 8).\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be checked\n\n # Returns\n\ntrue if the instance contains a partial byte, false otherwise"]
    pub fn bit_buffer_has_partial_byte(buf: *const BitBuffer) -> bool;
}
unsafe extern "C" {
    #[doc = "Check whether a BitBuffer instance's contents start with the designated byte.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be checked\n * `byte` (direction in) - byte value to be checked against\n\n # Returns\n\ntrue if data starts with designated byte, false otherwise"]
    pub fn bit_buffer_starts_with_byte(buf: *const BitBuffer, byte: u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Get a BitBuffer instance's capacity (i.e. the maximum possible amount of\n data), in bytes.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n\n # Returns\n\ncapacity, in bytes"]
    pub fn bit_buffer_get_capacity_bytes(buf: *const BitBuffer) -> usize;
}
unsafe extern "C" {
    #[doc = "Get a BitBuffer instance's data size (i.e. the amount of stored data), in\n bits.\n\n Might be not divisible by 8 (see bit_buffer_is_partial_byte).\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n\n # Returns\n\ndata size, in bits."]
    pub fn bit_buffer_get_size(buf: *const BitBuffer) -> usize;
}
unsafe extern "C" {
    #[doc = "Get a BitBuffer instance's data size (i.e. the amount of stored data), in\n bytes.\n\n If a partial byte is present, it is also counted.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n\n # Returns\n\ndata size, in bytes."]
    pub fn bit_buffer_get_size_bytes(buf: *const BitBuffer) -> usize;
}
unsafe extern "C" {
    #[doc = "Get a byte value at a specified index in a BitBuffer instance.\n\n The index must be valid (i.e. less than the instance's data size\n in bytes).\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n * `index` (direction in) - index of the byte in question\n\n # Returns\n\nbyte value"]
    pub fn bit_buffer_get_byte(buf: *const BitBuffer, index: usize) -> u8;
}
unsafe extern "C" {
    #[doc = "Get a byte value starting from the specified bit index in a BitBuffer\n instance.\n\n The resulting byte might correspond to a single byte (if the\n index is a multiple of 8), or two overlapping bytes combined. The\n index must be valid (i.e. less than the instance's data size in\n bits).\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n * `index_bits` (direction in) - bit index of the byte in question\n\n # Returns\n\nbyte value"]
    pub fn bit_buffer_get_byte_from_bit(buf: *const BitBuffer, index_bits: usize) -> u8;
}
unsafe extern "C" {
    #[doc = "Get the pointer to a BitBuffer instance's underlying data.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n\n # Returns\n\npointer to the underlying data"]
    pub fn bit_buffer_get_data(buf: *const BitBuffer) -> *const u8;
}
unsafe extern "C" {
    #[doc = "Get the pointer to the parity data of a BitBuffer instance.\n\n # Arguments\n\n* `buf` (direction in) - pointer to a BitBuffer instance to be queried\n\n # Returns\n\npointer to the parity data"]
    pub fn bit_buffer_get_parity(buf: *const BitBuffer) -> *const u8;
}
unsafe extern "C" {
    #[doc = "Set byte value at a specified index in a BitBuffer instance.\n\n The index must be valid (i.e. less than the instance's data\n size in bytes).\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be modified\n * `index` (direction in) - index of the byte in question\n * `byte` (direction in) - byte value to be set at index"]
    pub fn bit_buffer_set_byte(buf: *mut BitBuffer, index: usize, byte: u8);
}
unsafe extern "C" {
    #[doc = "Set byte and parity bit value at a specified index in a BitBuffer instance.\n\n The index must be valid (i.e. less than the instance's data\n size in bytes).\n\n # Arguments\n\n* `buff` (direction in, out) - pointer to a BitBuffer instance to be modified\n * `index` (direction in) - index of the byte in question\n * `byte` (direction in) - byte value to be set at index\n * `parity` (direction in) - parity bit value to be set at index"]
    pub fn bit_buffer_set_byte_with_parity(
        buff: *mut BitBuffer,
        index: usize,
        byte: u8,
        parity: bool,
    );
}
unsafe extern "C" {
    #[doc = "Resize a BitBuffer instance to a new size, in bits.\n\n May cause bugs. Use only if absolutely necessary.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be resized\n * `new_size` (direction in) - the new size of the buffer, in bits"]
    pub fn bit_buffer_set_size(buf: *mut BitBuffer, new_size: usize);
}
unsafe extern "C" {
    #[doc = "Resize a BitBuffer instance to a new size, in bytes.\n\n May cause bugs. Use only if absolutely necessary.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be resized\n * `new_size_bytes` (direction in) - the new size of the buffer, in bytes"]
    pub fn bit_buffer_set_size_bytes(buf: *mut BitBuffer, new_size_bytes: usize);
}
unsafe extern "C" {
    #[doc = "Append all BitBuffer's instance contents to this one.\n\n The destination capacity must be no less than its original\n data size plus source data size.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be appended to\n * `other` (direction in) - pointer to a BitBuffer instance to be appended"]
    pub fn bit_buffer_append(buf: *mut BitBuffer, other: *const BitBuffer);
}
unsafe extern "C" {
    #[doc = "Append a BitBuffer's instance contents to this one, starting from\n start_index.\n\n The destination capacity must be no less than the source data\n size counting from start_index.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be appended to\n * `other` (direction in) - pointer to a BitBuffer instance to be appended\n * `start_index` (direction in) - index to begin copying source data from"]
    pub fn bit_buffer_append_right(
        buf: *mut BitBuffer,
        other: *const BitBuffer,
        start_index: usize,
    );
}
unsafe extern "C" {
    #[doc = "Append a byte to a BitBuffer instance.\n\n The destination capacity must be no less its original data\n size plus one.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be appended to\n * `byte` (direction in) - byte value to be appended"]
    pub fn bit_buffer_append_byte(buf: *mut BitBuffer, byte: u8);
}
unsafe extern "C" {
    #[doc = "Append a byte array to a BitBuffer instance.\n\n The destination capacity must be no less its original data\n size plus source data size.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be appended to\n * `data` (direction in) - pointer to the byte array to be appended\n * `size_bytes` (direction in) - size of the data to be appended, in bytes"]
    pub fn bit_buffer_append_bytes(buf: *mut BitBuffer, data: *const u8, size_bytes: usize);
}
unsafe extern "C" {
    #[doc = "Append a bit to a BitBuffer instance.\n\n The destination capacity must be sufficient to accommodate the\n additional bit.\n\n # Arguments\n\n* `buf` (direction in, out) - pointer to a BitBuffer instance to be appended to\n * `bit` (direction in) - bit value to be appended"]
    pub fn bit_buffer_append_bit(buf: *mut BitBuffer, bit: bool);
}
#[doc = "< Display full(verbose) name."]
pub const NfcDeviceNameTypeFull: NfcDeviceNameType = NfcDeviceNameType(0);
#[doc = "< Display shortened name."]
pub const NfcDeviceNameTypeShort: NfcDeviceNameType = NfcDeviceNameType(1);
#[repr(transparent)]
#[doc = "Verbosity level of the displayed NFC device name."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcDeviceNameType(pub core::ffi::c_uchar);
#[doc = "Generic opaque type for protocol-specific NFC device data."]
pub type NfcDeviceData = core::ffi::c_void;
#[doc = "Allocate the protocol-specific NFC device data instance.\n\n # Returns\n\npointer to the allocated instance."]
pub type NfcDeviceAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut NfcDeviceData>;
#[doc = "Delete the protocol-specific NFC device data instance.\n\n # Arguments\n\n* `data` (direction in, out) - pointer to the instance to be deleted."]
pub type NfcDeviceFree = ::core::option::Option<unsafe extern "C" fn(data: *mut NfcDeviceData)>;
#[doc = "Reset the NFC device data instance.\n\n The behaviour is protocol-specific. Usually, required fields are zeroed or\n set to their initial values.\n\n # Arguments\n\n* `data` (direction in, out) - pointer to the instance to be reset."]
pub type NfcDeviceReset = ::core::option::Option<unsafe extern "C" fn(data: *mut NfcDeviceData)>;
#[doc = "Copy source instance's data into the destination so that they become equal.\n\n # Arguments\n\n* `data` (direction in, out) - pointer to the destination instance.\n * `other` (direction in) - pointer to the source instance."]
pub type NfcDeviceCopy = ::core::option::Option<
    unsafe extern "C" fn(data: *mut NfcDeviceData, other: *const NfcDeviceData),
>;
#[doc = "Deprecated. Do not use in new protocols.\n > **Deprecated** do not use in new protocols.\n\n # Arguments\n\n* `data` (direction in, out) - pointer to the instance to be tested.\n * `device_type` (direction in) - pointer to a FuriString containing a device type identifier.\n # Returns\n\ntrue if data was verified, false otherwise."]
pub type NfcDeviceVerify = ::core::option::Option<
    unsafe extern "C" fn(data: *mut NfcDeviceData, device_type: *const FuriString) -> bool,
>;
#[doc = "Load NFC device data from a FlipperFormat file.\n\n The FlipperFormat file structure must be initialised and open by the calling code.\n\n # Arguments\n\n* `data` (direction in, out) - pointer to the instance to be loaded into.\n * `ff` (direction in) - pointer to the FlipperFormat file instance.\n * `version` (direction in) - file format version to use when loading.\n # Returns\n\ntrue if loaded successfully, false otherwise."]
pub type NfcDeviceLoad = ::core::option::Option<
    unsafe extern "C" fn(data: *mut NfcDeviceData, ff: *mut FlipperFormat, version: u32) -> bool,
>;
#[doc = "Save NFC device data to a FlipperFormat file.\n\n The FlipperFormat file structure must be initialised and open by the calling code.\n\n # Arguments\n\n* `data` (direction in) - pointer to the instance to be saved.\n * `ff` (direction in) - pointer to the FlipperFormat file instance.\n # Returns\n\ntrue if saved successfully, false otherwise."]
pub type NfcDeviceSave = ::core::option::Option<
    unsafe extern "C" fn(data: *const NfcDeviceData, ff: *mut FlipperFormat) -> bool,
>;
#[doc = "Compare two NFC device data instances.\n\n # Arguments\n\n* `data` (direction in) - pointer to the first instance to be compared.\n * `other` (direction in) - pointer to the second instance to be compared.\n # Returns\n\ntrue if instances are equal, false otherwise."]
pub type NfcDeviceEqual = ::core::option::Option<
    unsafe extern "C" fn(data: *const NfcDeviceData, other: *const NfcDeviceData) -> bool,
>;
#[doc = "Get a protocol-specific stateful NFC device name.\n\n The return value may change depending on the instance's internal state and the name_type parameter.\n\n # Arguments\n\n* `data` (direction in) - pointer to the instance to be queried.\n * `name_type` (direction in) - type of the name to be displayed.\n # Returns\n\npointer to a statically allocated character string containing the appropriate name."]
pub type NfcDeviceGetName = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const NfcDeviceData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char,
>;
#[doc = "Get the NFC device's unique identifier (UID).\n\n The UID length is protocol-dependent. Additionally, a particular protocol might support\n several UID lengths.\n\n # Arguments\n\n* `data` (direction in) - pointer to the instance to be queried.\n * `uid_len` (direction out) - pointer to the variable to contain the UID length.\n # Returns\n\npointer to the byte array containing the device's UID."]
pub type NfcDeviceGetUid = ::core::option::Option<
    unsafe extern "C" fn(data: *const NfcDeviceData, uid_len: *mut usize) -> *const u8,
>;
#[doc = "Set the NFC device's unique identifier (UID).\n\n The UID length must be supported by the protocol in question.\n\n # Arguments\n\n* `data` (direction in, out) - pointer to the instance to be modified.\n * `uid` (direction in) - pointer to the byte array containing the new UID.\n * `uid_len` (direction in) - length of the UID.\n # Returns\n\ntrue if the UID was valid and set, false otherwise."]
pub type NfcDeviceSetUid = ::core::option::Option<
    unsafe extern "C" fn(data: *mut NfcDeviceData, uid: *const u8, uid_len: usize) -> bool,
>;
#[doc = "Get the NFC device data associated with the parent protocol.\n\n The protocol the instance's data is associated with must have a parent.\n\n # Arguments\n\n* `data` (direction in) - pointer to the instance to be queried.\n # Returns\n\npointer to the data instance associated with the parent protocol."]
pub type NfcDeviceGetBaseData =
    ::core::option::Option<unsafe extern "C" fn(data: *const NfcDeviceData) -> *mut NfcDeviceData>;
#[doc = "Generic NFC device interface.\n\n Each protocol must fill this structure with its own function implementations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcDeviceBase {
    #[doc = "< Pointer to a statically-allocated string with the protocol name."]
    pub protocol_name: *const core::ffi::c_char,
    #[doc = "< Pointer to the alloc() function."]
    pub alloc: NfcDeviceAlloc,
    #[doc = "< Pointer to the free() function."]
    pub free: NfcDeviceFree,
    #[doc = "< Pointer to the reset() function."]
    pub reset: NfcDeviceReset,
    #[doc = "< Pointer to the copy() function."]
    pub copy: NfcDeviceCopy,
    #[doc = "< Deprecated. Set to NULL in new protocols."]
    pub verify: NfcDeviceVerify,
    #[doc = "< Pointer to the load() function."]
    pub load: NfcDeviceLoad,
    #[doc = "< Pointer to the save() function."]
    pub save: NfcDeviceSave,
    #[doc = "< Pointer to the is_equal() function."]
    pub is_equal: NfcDeviceEqual,
    #[doc = "< Pointer to the get_name() function."]
    pub get_name: NfcDeviceGetName,
    #[doc = "< Pointer to the get_uid() function."]
    pub get_uid: NfcDeviceGetUid,
    #[doc = "< Pointer to the set_uid() function."]
    pub set_uid: NfcDeviceSetUid,
    #[doc = "< Pointer to the get_base_data() function."]
    pub get_base_data: NfcDeviceGetBaseData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcDeviceBase"][::core::mem::size_of::<NfcDeviceBase>() - 52usize];
    ["Alignment of NfcDeviceBase"][::core::mem::align_of::<NfcDeviceBase>() - 4usize];
    ["Offset of field: NfcDeviceBase::protocol_name"]
        [::core::mem::offset_of!(NfcDeviceBase, protocol_name) - 0usize];
    ["Offset of field: NfcDeviceBase::alloc"]
        [::core::mem::offset_of!(NfcDeviceBase, alloc) - 4usize];
    ["Offset of field: NfcDeviceBase::free"][::core::mem::offset_of!(NfcDeviceBase, free) - 8usize];
    ["Offset of field: NfcDeviceBase::reset"]
        [::core::mem::offset_of!(NfcDeviceBase, reset) - 12usize];
    ["Offset of field: NfcDeviceBase::copy"]
        [::core::mem::offset_of!(NfcDeviceBase, copy) - 16usize];
    ["Offset of field: NfcDeviceBase::verify"]
        [::core::mem::offset_of!(NfcDeviceBase, verify) - 20usize];
    ["Offset of field: NfcDeviceBase::load"]
        [::core::mem::offset_of!(NfcDeviceBase, load) - 24usize];
    ["Offset of field: NfcDeviceBase::save"]
        [::core::mem::offset_of!(NfcDeviceBase, save) - 28usize];
    ["Offset of field: NfcDeviceBase::is_equal"]
        [::core::mem::offset_of!(NfcDeviceBase, is_equal) - 32usize];
    ["Offset of field: NfcDeviceBase::get_name"]
        [::core::mem::offset_of!(NfcDeviceBase, get_name) - 36usize];
    ["Offset of field: NfcDeviceBase::get_uid"]
        [::core::mem::offset_of!(NfcDeviceBase, get_uid) - 40usize];
    ["Offset of field: NfcDeviceBase::set_uid"]
        [::core::mem::offset_of!(NfcDeviceBase, set_uid) - 44usize];
    ["Offset of field: NfcDeviceBase::get_base_data"]
        [::core::mem::offset_of!(NfcDeviceBase, get_base_data) - 48usize];
};
pub const Iso14443_3aErrorNone: Iso14443_3aError = Iso14443_3aError(0);
pub const Iso14443_3aErrorNotPresent: Iso14443_3aError = Iso14443_3aError(1);
pub const Iso14443_3aErrorColResFailed: Iso14443_3aError = Iso14443_3aError(2);
pub const Iso14443_3aErrorBufferOverflow: Iso14443_3aError = Iso14443_3aError(3);
pub const Iso14443_3aErrorCommunication: Iso14443_3aError = Iso14443_3aError(4);
pub const Iso14443_3aErrorFieldOff: Iso14443_3aError = Iso14443_3aError(5);
pub const Iso14443_3aErrorWrongCrc: Iso14443_3aError = Iso14443_3aError(6);
pub const Iso14443_3aErrorTimeout: Iso14443_3aError = Iso14443_3aError(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3aError(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aSensResp {
    pub sens_resp: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aSensResp"][::core::mem::size_of::<Iso14443_3aSensResp>() - 2usize];
    ["Alignment of Iso14443_3aSensResp"][::core::mem::align_of::<Iso14443_3aSensResp>() - 1usize];
    ["Offset of field: Iso14443_3aSensResp::sens_resp"]
        [::core::mem::offset_of!(Iso14443_3aSensResp, sens_resp) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aSddReq {
    pub sel_cmd: u8,
    pub sel_par: u8,
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aSddReq"][::core::mem::size_of::<Iso14443_3aSddReq>() - 6usize];
    ["Alignment of Iso14443_3aSddReq"][::core::mem::align_of::<Iso14443_3aSddReq>() - 1usize];
    ["Offset of field: Iso14443_3aSddReq::sel_cmd"]
        [::core::mem::offset_of!(Iso14443_3aSddReq, sel_cmd) - 0usize];
    ["Offset of field: Iso14443_3aSddReq::sel_par"]
        [::core::mem::offset_of!(Iso14443_3aSddReq, sel_par) - 1usize];
    ["Offset of field: Iso14443_3aSddReq::data"]
        [::core::mem::offset_of!(Iso14443_3aSddReq, data) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aSddResp {
    pub nfcid: [u8; 4usize],
    pub bss: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aSddResp"][::core::mem::size_of::<Iso14443_3aSddResp>() - 5usize];
    ["Alignment of Iso14443_3aSddResp"][::core::mem::align_of::<Iso14443_3aSddResp>() - 1usize];
    ["Offset of field: Iso14443_3aSddResp::nfcid"]
        [::core::mem::offset_of!(Iso14443_3aSddResp, nfcid) - 0usize];
    ["Offset of field: Iso14443_3aSddResp::bss"]
        [::core::mem::offset_of!(Iso14443_3aSddResp, bss) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aSelReq {
    pub sel_cmd: u8,
    pub sel_par: u8,
    pub nfcid: [u8; 4usize],
    pub bcc: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aSelReq"][::core::mem::size_of::<Iso14443_3aSelReq>() - 7usize];
    ["Alignment of Iso14443_3aSelReq"][::core::mem::align_of::<Iso14443_3aSelReq>() - 1usize];
    ["Offset of field: Iso14443_3aSelReq::sel_cmd"]
        [::core::mem::offset_of!(Iso14443_3aSelReq, sel_cmd) - 0usize];
    ["Offset of field: Iso14443_3aSelReq::sel_par"]
        [::core::mem::offset_of!(Iso14443_3aSelReq, sel_par) - 1usize];
    ["Offset of field: Iso14443_3aSelReq::nfcid"]
        [::core::mem::offset_of!(Iso14443_3aSelReq, nfcid) - 2usize];
    ["Offset of field: Iso14443_3aSelReq::bcc"]
        [::core::mem::offset_of!(Iso14443_3aSelReq, bcc) - 6usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aSelResp {
    pub sak: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aSelResp"][::core::mem::size_of::<Iso14443_3aSelResp>() - 1usize];
    ["Alignment of Iso14443_3aSelResp"][::core::mem::align_of::<Iso14443_3aSelResp>() - 1usize];
    ["Offset of field: Iso14443_3aSelResp::sak"]
        [::core::mem::offset_of!(Iso14443_3aSelResp, sak) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aData {
    pub uid: [u8; 10usize],
    pub uid_len: u8,
    pub atqa: [u8; 2usize],
    pub sak: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aData"][::core::mem::size_of::<Iso14443_3aData>() - 14usize];
    ["Alignment of Iso14443_3aData"][::core::mem::align_of::<Iso14443_3aData>() - 1usize];
    ["Offset of field: Iso14443_3aData::uid"]
        [::core::mem::offset_of!(Iso14443_3aData, uid) - 0usize];
    ["Offset of field: Iso14443_3aData::uid_len"]
        [::core::mem::offset_of!(Iso14443_3aData, uid_len) - 10usize];
    ["Offset of field: Iso14443_3aData::atqa"]
        [::core::mem::offset_of!(Iso14443_3aData, atqa) - 11usize];
    ["Offset of field: Iso14443_3aData::sak"]
        [::core::mem::offset_of!(Iso14443_3aData, sak) - 13usize];
};
unsafe extern "C" {
    pub fn iso14443_3a_alloc() -> *mut Iso14443_3aData;
}
unsafe extern "C" {
    pub fn iso14443_3a_free(data: *mut Iso14443_3aData);
}
unsafe extern "C" {
    pub fn iso14443_3a_reset(data: *mut Iso14443_3aData);
}
unsafe extern "C" {
    pub fn iso14443_3a_copy(data: *mut Iso14443_3aData, other: *const Iso14443_3aData);
}
unsafe extern "C" {
    pub fn iso14443_3a_verify(data: *mut Iso14443_3aData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3a_load(
        data: *mut Iso14443_3aData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3a_save(data: *const Iso14443_3aData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3a_is_equal(
        data: *const Iso14443_3aData,
        other: *const Iso14443_3aData,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3a_get_device_name(
        data: *const Iso14443_3aData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn iso14443_3a_get_uid(data: *const Iso14443_3aData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn iso14443_3a_set_uid(data: *mut Iso14443_3aData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3a_get_base_data(data: *const Iso14443_3aData) -> *mut Iso14443_3aData;
}
unsafe extern "C" {
    pub fn iso14443_3a_get_cuid(data: *const Iso14443_3aData) -> u32;
}
unsafe extern "C" {
    pub fn iso14443_3a_supports_iso14443_4(data: *const Iso14443_3aData) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3a_get_sak(data: *const Iso14443_3aData) -> u8;
}
unsafe extern "C" {
    pub fn iso14443_3a_get_atqa(data: *const Iso14443_3aData, atqa: *mut u8);
}
unsafe extern "C" {
    pub fn iso14443_3a_set_sak(data: *mut Iso14443_3aData, sak: u8);
}
unsafe extern "C" {
    pub fn iso14443_3a_set_atqa(data: *mut Iso14443_3aData, atqa: *const u8);
}
pub const MfClassicErrorNone: MfClassicError = MfClassicError(0);
pub const MfClassicErrorNotPresent: MfClassicError = MfClassicError(1);
pub const MfClassicErrorProtocol: MfClassicError = MfClassicError(2);
pub const MfClassicErrorAuth: MfClassicError = MfClassicError(3);
pub const MfClassicErrorPartialRead: MfClassicError = MfClassicError(4);
pub const MfClassicErrorTimeout: MfClassicError = MfClassicError(5);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicError(pub core::ffi::c_uchar);
pub const MfClassicTypeMini: MfClassicType = MfClassicType(0);
pub const MfClassicType1k: MfClassicType = MfClassicType(1);
pub const MfClassicType4k: MfClassicType = MfClassicType(2);
pub const MfClassicTypeNum: MfClassicType = MfClassicType(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicType(pub core::ffi::c_uchar);
pub const MfClassicActionDataRead: MfClassicAction = MfClassicAction(0);
pub const MfClassicActionDataWrite: MfClassicAction = MfClassicAction(1);
pub const MfClassicActionDataInc: MfClassicAction = MfClassicAction(2);
pub const MfClassicActionDataDec: MfClassicAction = MfClassicAction(3);
pub const MfClassicActionKeyARead: MfClassicAction = MfClassicAction(4);
pub const MfClassicActionKeyAWrite: MfClassicAction = MfClassicAction(5);
pub const MfClassicActionKeyBRead: MfClassicAction = MfClassicAction(6);
pub const MfClassicActionKeyBWrite: MfClassicAction = MfClassicAction(7);
pub const MfClassicActionACRead: MfClassicAction = MfClassicAction(8);
pub const MfClassicActionACWrite: MfClassicAction = MfClassicAction(9);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicAction(pub core::ffi::c_uchar);
pub const MfClassicValueCommandIncrement: MfClassicValueCommand = MfClassicValueCommand(0);
pub const MfClassicValueCommandDecrement: MfClassicValueCommand = MfClassicValueCommand(1);
pub const MfClassicValueCommandRestore: MfClassicValueCommand = MfClassicValueCommand(2);
pub const MfClassicValueCommandInvalid: MfClassicValueCommand = MfClassicValueCommand(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicValueCommand(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicBlock {
    pub data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicBlock"][::core::mem::size_of::<MfClassicBlock>() - 16usize];
    ["Alignment of MfClassicBlock"][::core::mem::align_of::<MfClassicBlock>() - 1usize];
    ["Offset of field: MfClassicBlock::data"]
        [::core::mem::offset_of!(MfClassicBlock, data) - 0usize];
};
pub const MfClassicKeyTypeA: MfClassicKeyType = MfClassicKeyType(0);
pub const MfClassicKeyTypeB: MfClassicKeyType = MfClassicKeyType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicKeyType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicKey {
    pub data: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicKey"][::core::mem::size_of::<MfClassicKey>() - 6usize];
    ["Alignment of MfClassicKey"][::core::mem::align_of::<MfClassicKey>() - 1usize];
    ["Offset of field: MfClassicKey::data"][::core::mem::offset_of!(MfClassicKey, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAccessBits {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicAccessBits"][::core::mem::size_of::<MfClassicAccessBits>() - 4usize];
    ["Alignment of MfClassicAccessBits"][::core::mem::align_of::<MfClassicAccessBits>() - 1usize];
    ["Offset of field: MfClassicAccessBits::data"]
        [::core::mem::offset_of!(MfClassicAccessBits, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicNt {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicNt"][::core::mem::size_of::<MfClassicNt>() - 4usize];
    ["Alignment of MfClassicNt"][::core::mem::align_of::<MfClassicNt>() - 1usize];
    ["Offset of field: MfClassicNt::data"][::core::mem::offset_of!(MfClassicNt, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAt {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicAt"][::core::mem::size_of::<MfClassicAt>() - 4usize];
    ["Alignment of MfClassicAt"][::core::mem::align_of::<MfClassicAt>() - 1usize];
    ["Offset of field: MfClassicAt::data"][::core::mem::offset_of!(MfClassicAt, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicNr {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicNr"][::core::mem::size_of::<MfClassicNr>() - 4usize];
    ["Alignment of MfClassicNr"][::core::mem::align_of::<MfClassicNr>() - 1usize];
    ["Offset of field: MfClassicNr::data"][::core::mem::offset_of!(MfClassicNr, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAr {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicAr"][::core::mem::size_of::<MfClassicAr>() - 4usize];
    ["Alignment of MfClassicAr"][::core::mem::align_of::<MfClassicAr>() - 1usize];
    ["Offset of field: MfClassicAr::data"][::core::mem::offset_of!(MfClassicAr, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAuthContext {
    pub block_num: u8,
    pub key: MfClassicKey,
    pub key_type: MfClassicKeyType,
    pub nt: MfClassicNt,
    pub nr: MfClassicNr,
    pub ar: MfClassicAr,
    pub at: MfClassicAt,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicAuthContext"][::core::mem::size_of::<MfClassicAuthContext>() - 24usize];
    ["Alignment of MfClassicAuthContext"][::core::mem::align_of::<MfClassicAuthContext>() - 1usize];
    ["Offset of field: MfClassicAuthContext::block_num"]
        [::core::mem::offset_of!(MfClassicAuthContext, block_num) - 0usize];
    ["Offset of field: MfClassicAuthContext::key"]
        [::core::mem::offset_of!(MfClassicAuthContext, key) - 1usize];
    ["Offset of field: MfClassicAuthContext::key_type"]
        [::core::mem::offset_of!(MfClassicAuthContext, key_type) - 7usize];
    ["Offset of field: MfClassicAuthContext::nt"]
        [::core::mem::offset_of!(MfClassicAuthContext, nt) - 8usize];
    ["Offset of field: MfClassicAuthContext::nr"]
        [::core::mem::offset_of!(MfClassicAuthContext, nr) - 12usize];
    ["Offset of field: MfClassicAuthContext::ar"]
        [::core::mem::offset_of!(MfClassicAuthContext, ar) - 16usize];
    ["Offset of field: MfClassicAuthContext::at"]
        [::core::mem::offset_of!(MfClassicAuthContext, at) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfClassicSectorTrailer {
    pub block: MfClassicBlock,
    pub __bindgen_anon_1: MfClassicSectorTrailer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicSectorTrailer__bindgen_ty_1 {
    pub key_a: MfClassicKey,
    pub access_bits: MfClassicAccessBits,
    pub key_b: MfClassicKey,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicSectorTrailer__bindgen_ty_1"]
        [::core::mem::size_of::<MfClassicSectorTrailer__bindgen_ty_1>() - 16usize];
    ["Alignment of MfClassicSectorTrailer__bindgen_ty_1"]
        [::core::mem::align_of::<MfClassicSectorTrailer__bindgen_ty_1>() - 1usize];
    ["Offset of field: MfClassicSectorTrailer__bindgen_ty_1::key_a"]
        [::core::mem::offset_of!(MfClassicSectorTrailer__bindgen_ty_1, key_a) - 0usize];
    ["Offset of field: MfClassicSectorTrailer__bindgen_ty_1::access_bits"]
        [::core::mem::offset_of!(MfClassicSectorTrailer__bindgen_ty_1, access_bits) - 6usize];
    ["Offset of field: MfClassicSectorTrailer__bindgen_ty_1::key_b"]
        [::core::mem::offset_of!(MfClassicSectorTrailer__bindgen_ty_1, key_b) - 10usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicSectorTrailer"][::core::mem::size_of::<MfClassicSectorTrailer>() - 16usize];
    ["Alignment of MfClassicSectorTrailer"]
        [::core::mem::align_of::<MfClassicSectorTrailer>() - 1usize];
    ["Offset of field: MfClassicSectorTrailer::block"]
        [::core::mem::offset_of!(MfClassicSectorTrailer, block) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicDeviceKeys {
    pub key_a_mask: u64,
    pub key_a: [MfClassicKey; 40usize],
    pub key_b_mask: u64,
    pub key_b: [MfClassicKey; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicDeviceKeys"][::core::mem::size_of::<MfClassicDeviceKeys>() - 496usize];
    ["Alignment of MfClassicDeviceKeys"][::core::mem::align_of::<MfClassicDeviceKeys>() - 8usize];
    ["Offset of field: MfClassicDeviceKeys::key_a_mask"]
        [::core::mem::offset_of!(MfClassicDeviceKeys, key_a_mask) - 0usize];
    ["Offset of field: MfClassicDeviceKeys::key_a"]
        [::core::mem::offset_of!(MfClassicDeviceKeys, key_a) - 8usize];
    ["Offset of field: MfClassicDeviceKeys::key_b_mask"]
        [::core::mem::offset_of!(MfClassicDeviceKeys, key_b_mask) - 248usize];
    ["Offset of field: MfClassicDeviceKeys::key_b"]
        [::core::mem::offset_of!(MfClassicDeviceKeys, key_b) - 256usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicData {
    pub iso14443_3a_data: *mut Iso14443_3aData,
    pub type_: MfClassicType,
    pub block_read_mask: [u32; 8usize],
    pub key_a_mask: u64,
    pub key_b_mask: u64,
    pub block: [MfClassicBlock; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicData"][::core::mem::size_of::<MfClassicData>() - 4152usize];
    ["Alignment of MfClassicData"][::core::mem::align_of::<MfClassicData>() - 8usize];
    ["Offset of field: MfClassicData::iso14443_3a_data"]
        [::core::mem::offset_of!(MfClassicData, iso14443_3a_data) - 0usize];
    ["Offset of field: MfClassicData::type_"]
        [::core::mem::offset_of!(MfClassicData, type_) - 4usize];
    ["Offset of field: MfClassicData::block_read_mask"]
        [::core::mem::offset_of!(MfClassicData, block_read_mask) - 8usize];
    ["Offset of field: MfClassicData::key_a_mask"]
        [::core::mem::offset_of!(MfClassicData, key_a_mask) - 40usize];
    ["Offset of field: MfClassicData::key_b_mask"]
        [::core::mem::offset_of!(MfClassicData, key_b_mask) - 48usize];
    ["Offset of field: MfClassicData::block"]
        [::core::mem::offset_of!(MfClassicData, block) - 56usize];
};
unsafe extern "C" {
    pub fn mf_classic_alloc() -> *mut MfClassicData;
}
unsafe extern "C" {
    pub fn mf_classic_free(data: *mut MfClassicData);
}
unsafe extern "C" {
    pub fn mf_classic_reset(data: *mut MfClassicData);
}
unsafe extern "C" {
    pub fn mf_classic_copy(data: *mut MfClassicData, other: *const MfClassicData);
}
unsafe extern "C" {
    pub fn mf_classic_verify(data: *mut MfClassicData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_load(data: *mut MfClassicData, ff: *mut FlipperFormat, version: u32) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_save(data: *const MfClassicData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_is_equal(data: *const MfClassicData, other: *const MfClassicData) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_get_device_name(
        data: *const MfClassicData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mf_classic_get_uid(data: *const MfClassicData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn mf_classic_set_uid(data: *mut MfClassicData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_get_base_data(data: *const MfClassicData) -> *mut Iso14443_3aData;
}
unsafe extern "C" {
    pub fn mf_classic_get_total_sectors_num(type_: MfClassicType) -> u8;
}
unsafe extern "C" {
    pub fn mf_classic_get_total_block_num(type_: MfClassicType) -> u16;
}
unsafe extern "C" {
    pub fn mf_classic_get_first_block_num_of_sector(sector: u8) -> u8;
}
unsafe extern "C" {
    pub fn mf_classic_get_blocks_num_in_sector(sector: u8) -> u8;
}
unsafe extern "C" {
    pub fn mf_classic_get_sector_trailer_num_by_sector(sector: u8) -> u8;
}
unsafe extern "C" {
    pub fn mf_classic_get_sector_trailer_num_by_block(block: u8) -> u8;
}
unsafe extern "C" {
    pub fn mf_classic_get_sector_trailer_by_sector(
        data: *const MfClassicData,
        sector_num: u8,
    ) -> *mut MfClassicSectorTrailer;
}
unsafe extern "C" {
    pub fn mf_classic_is_sector_trailer(block: u8) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_set_sector_trailer_read(
        data: *mut MfClassicData,
        block_num: u8,
        sec_tr: *mut MfClassicSectorTrailer,
    );
}
unsafe extern "C" {
    pub fn mf_classic_get_sector_by_block(block: u8) -> u8;
}
unsafe extern "C" {
    pub fn mf_classic_block_to_value(
        block: *const MfClassicBlock,
        value: *mut i32,
        addr: *mut u8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_value_to_block(value: i32, addr: u8, block: *mut MfClassicBlock);
}
unsafe extern "C" {
    pub fn mf_classic_is_key_found(
        data: *const MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_set_key_found(
        data: *mut MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
        key: u64,
    );
}
unsafe extern "C" {
    pub fn mf_classic_set_key_not_found(
        data: *mut MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
    );
}
unsafe extern "C" {
    pub fn mf_classic_get_key(
        data: *const MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
    ) -> MfClassicKey;
}
unsafe extern "C" {
    pub fn mf_classic_is_block_read(data: *const MfClassicData, block_num: u8) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_set_block_read(
        data: *mut MfClassicData,
        block_num: u8,
        block_data: *mut MfClassicBlock,
    );
}
unsafe extern "C" {
    pub fn mf_classic_is_sector_read(data: *const MfClassicData, sector_num: u8) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_get_read_sectors_and_keys(
        data: *const MfClassicData,
        sectors_read: *mut u8,
        keys_found: *mut u8,
    );
}
unsafe extern "C" {
    pub fn mf_classic_is_card_read(data: *const MfClassicData) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_is_value_block(sec_tr: *mut MfClassicSectorTrailer, block_num: u8) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_is_allowed_access_data_block(
        sec_tr: *mut MfClassicSectorTrailer,
        block_num: u8,
        key_type: MfClassicKeyType,
        action: MfClassicAction,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_classic_is_allowed_access(
        data: *mut MfClassicData,
        block_num: u8,
        key_type: MfClassicKeyType,
        action: MfClassicAction,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Crypto1 {
    pub odd: u32,
    pub even: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Crypto1"][::core::mem::size_of::<Crypto1>() - 8usize];
    ["Alignment of Crypto1"][::core::mem::align_of::<Crypto1>() - 4usize];
    ["Offset of field: Crypto1::odd"][::core::mem::offset_of!(Crypto1, odd) - 0usize];
    ["Offset of field: Crypto1::even"][::core::mem::offset_of!(Crypto1, even) - 4usize];
};
unsafe extern "C" {
    pub fn crypto1_alloc() -> *mut Crypto1;
}
unsafe extern "C" {
    pub fn crypto1_free(instance: *mut Crypto1);
}
unsafe extern "C" {
    pub fn crypto1_reset(crypto1: *mut Crypto1);
}
unsafe extern "C" {
    pub fn crypto1_init(crypto1: *mut Crypto1, key: u64);
}
unsafe extern "C" {
    pub fn crypto1_bit(crypto1: *mut Crypto1, in_: u8, is_encrypted: core::ffi::c_int) -> u8;
}
unsafe extern "C" {
    pub fn crypto1_byte(crypto1: *mut Crypto1, in_: u8, is_encrypted: core::ffi::c_int) -> u8;
}
unsafe extern "C" {
    pub fn crypto1_word(crypto1: *mut Crypto1, in_: u32, is_encrypted: core::ffi::c_int) -> u32;
}
unsafe extern "C" {
    pub fn crypto1_decrypt(crypto: *mut Crypto1, buff: *const BitBuffer, out: *mut BitBuffer);
}
unsafe extern "C" {
    pub fn crypto1_encrypt(
        crypto: *mut Crypto1,
        keystream: *mut u8,
        buff: *const BitBuffer,
        out: *mut BitBuffer,
    );
}
unsafe extern "C" {
    pub fn crypto1_encrypt_reader_nonce(
        crypto: *mut Crypto1,
        key: u64,
        cuid: u32,
        nt: *mut u8,
        nr: *mut u8,
        out: *mut BitBuffer,
        is_nested: bool,
    );
}
unsafe extern "C" {
    pub fn crypto1_lfsr_rollback_word(crypto1: *mut Crypto1, in_: u32, fb: core::ffi::c_int)
    -> u32;
}
unsafe extern "C" {
    pub fn crypto1_nonce_matches_encrypted_parity_bits(nt: u32, ks: u32, nt_par_enc: u8) -> bool;
}
unsafe extern "C" {
    pub fn crypto1_is_weak_prng_nonce(nonce: u32) -> bool;
}
unsafe extern "C" {
    pub fn crypto1_decrypt_nt_enc(cuid: u32, nt_enc: u32, known_key: MfClassicKey) -> u32;
}
unsafe extern "C" {
    pub fn crypto1_prng_successor(x: u32, n: u32) -> u32;
}
pub const Iso13239CrcTypeDefault: Iso13239CrcType = Iso13239CrcType(0);
pub const Iso13239CrcTypePicopass: Iso13239CrcType = Iso13239CrcType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso13239CrcType(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn iso13239_crc_append(type_: Iso13239CrcType, buf: *mut BitBuffer);
}
unsafe extern "C" {
    pub fn iso13239_crc_check(type_: Iso13239CrcType, buf: *const BitBuffer) -> bool;
}
unsafe extern "C" {
    pub fn iso13239_crc_trim(buf: *mut BitBuffer);
}
pub const Iso14443CrcTypeA: Iso14443CrcType = Iso14443CrcType(0);
pub const Iso14443CrcTypeB: Iso14443CrcType = Iso14443CrcType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443CrcType(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn iso14443_crc_append(type_: Iso14443CrcType, buf: *mut BitBuffer);
}
unsafe extern "C" {
    pub fn iso14443_crc_check(type_: Iso14443CrcType, buf: *const BitBuffer) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_crc_trim(buf: *mut BitBuffer);
}
pub const NfcProtocolIso14443_3a: NfcProtocol = NfcProtocol(0);
pub const NfcProtocolIso14443_3b: NfcProtocol = NfcProtocol(1);
pub const NfcProtocolIso14443_4a: NfcProtocol = NfcProtocol(2);
pub const NfcProtocolIso14443_4b: NfcProtocol = NfcProtocol(3);
pub const NfcProtocolIso15693_3: NfcProtocol = NfcProtocol(4);
pub const NfcProtocolFelica: NfcProtocol = NfcProtocol(5);
pub const NfcProtocolMfUltralight: NfcProtocol = NfcProtocol(6);
pub const NfcProtocolMfClassic: NfcProtocol = NfcProtocol(7);
pub const NfcProtocolMfPlus: NfcProtocol = NfcProtocol(8);
pub const NfcProtocolMfDesfire: NfcProtocol = NfcProtocol(9);
pub const NfcProtocolSlix: NfcProtocol = NfcProtocol(10);
pub const NfcProtocolSt25tb: NfcProtocol = NfcProtocol(11);
#[doc = "< Special value representing the number of available protocols."]
pub const NfcProtocolNum: NfcProtocol = NfcProtocol(12);
#[doc = "< Special value representing an invalid state."]
pub const NfcProtocolInvalid: NfcProtocol = NfcProtocol(13);
#[repr(transparent)]
#[doc = "Enumeration of all available NFC protocols.\n\n When implementing a new protocol, add its identifier before the\n NfcProtocolNum entry."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcProtocol(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Get the immediate parent of a specific protocol.\n\n # Arguments\n\n* `protocol` (direction in) - identifier of the protocol in question.\n # Returns\n\nparent protocol identifier if it has one, or NfcProtocolInvalid otherwise."]
    pub fn nfc_protocol_get_parent(protocol: NfcProtocol) -> NfcProtocol;
}
unsafe extern "C" {
    #[doc = "Determine if a specific protocol has a parent on an arbitrary level.\n\n Unlike nfc_protocol_get_parent(), this function will traverse the full protocol hierarchy\n and check each parent node for the matching protocol type.\n\n # Arguments\n\n* `protocol` (direction in) - identifier of the protocol in question.\n * `parent_protocol` (direction in) - identifier of the parent protocol in question.\n # Returns\n\ntrue if the parent of given type exists, false otherwise."]
    pub fn nfc_protocol_has_parent(protocol: NfcProtocol, parent_protocol: NfcProtocol) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcDevice {
    _unused: [u8; 0],
}
#[doc = "Loading callback function signature.\n\n A function with such signature can be set as a callback to indicate\n the completion (or a failure) of nfc_device_load() and nfc_device_save() functions.\n\n This facility is commonly used to control GUI elements, such as progress dialogs.\n\n # Arguments\n\n* `context` (direction in) - user-defined context that was passed in nfc_device_set_loading_callback().\n * `state` (direction in) - true if the data was loaded successfully, false otherwise."]
pub type NfcLoadingCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: bool)>;
unsafe extern "C" {
    #[doc = "Allocate an NfcDevice instance.\n\n A newly created instance does not hold any data and thus is considered invalid. The most common\n use case would be to set its data by calling nfc_device_set_data() right afterwards.\n\n # Returns\n\npointer to the allocated instance."]
    pub fn nfc_device_alloc() -> *mut NfcDevice;
}
unsafe extern "C" {
    #[doc = "Delete an NfcDevice instance.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be deleted."]
    pub fn nfc_device_free(instance: *mut NfcDevice);
}
unsafe extern "C" {
    #[doc = "Clear an NfcDevice instance.\n\n All data contained in the instance will be deleted and the instance itself will become invalid\n as if it was just allocated.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be cleared."]
    pub fn nfc_device_clear(instance: *mut NfcDevice);
}
unsafe extern "C" {
    #[doc = "Reset an NfcDevice instance.\n\n The data contained in the instance will be reset according to the protocol-defined procedure.\n Unlike the nfc_device_clear() function, the instance will remain valid.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be reset."]
    pub fn nfc_device_reset(instance: *mut NfcDevice);
}
unsafe extern "C" {
    #[doc = "Get the protocol identifier from an NfcDevice instance.\n\n If the instance is invalid, the return value will be NfcProtocolInvalid.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n # Returns\n\nprotocol identifier contained in the instance."]
    pub fn nfc_device_get_protocol(instance: *const NfcDevice) -> NfcProtocol;
}
unsafe extern "C" {
    #[doc = "Get the protocol-specific data from an NfcDevice instance.\n\n The protocol parameter's behaviour is a bit tricky. The function will check\n whether there is such a protocol somewhere in the protocol hierarchy and return\n the data exactly from that level.\n\n Example: Call nfc_device_get_data() on an instance with Mf DESFire protocol.\n The protocol hierarchy will look like the following:\n\n `Mf DESFire --> ISO14443-4A --> ISO14443-3A`\n\n Thus, the following values of the protocol parameter are valid:\n\n * NfcProtocolIso14443_3a\n * NfcProtocolIso14443_4a\n * NfcProtocolMfDesfire\n\n and passing them to the call would result in the respective data being returned.\n\n However, supplying a protocol identifier which is not in the hierarchy will\n result in a crash. This is to improve type safety.\n\n # Arguments\n\n* `instance` - pointer to the instance to be queried\n * `protocol` - protocol identifier of the data to be retrieved.\n # Returns\n\npointer to the instance's data."]
    pub fn nfc_device_get_data(
        instance: *const NfcDevice,
        protocol: NfcProtocol,
    ) -> *const NfcDeviceData;
}
unsafe extern "C" {
    #[doc = "Get the protocol name by its identifier.\n\n This function does not require an instance as its return result depends only\n the protocol identifier.\n\n # Arguments\n\n* `protocol` (direction in) - numeric identifier of the protocol in question.\n # Returns\n\npointer to a statically allocated string containing the protocol name."]
    pub fn nfc_device_get_protocol_name(protocol: NfcProtocol) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get the name of an NfcDevice instance.\n\n The return value may change depending on the instance's internal state and the name_type parameter.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n * `name_type` (direction in) - type of the name to be displayed.\n # Returns\n\npointer to a statically allocated string containing the device name."]
    pub fn nfc_device_get_name(
        instance: *const NfcDevice,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Get the unique identifier (UID) of an NfcDevice instance.\n\n The UID length is protocol-dependent. Additionally, a particular protocol might support\n several UID lengths.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n * `uid_len` (direction out) - pointer to the variable to contain the UID length.\n # Returns\n\npointer to the byte array containing the instance's UID."]
    pub fn nfc_device_get_uid(instance: *const NfcDevice, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    #[doc = "Set the unique identifier (UID) of an NfcDevice instance.\n\n The UID length must be supported by the instance's protocol.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `uid` (direction in) - pointer to the byte array containing the new UID.\n * `uid_len` (direction in) - length of the UID.\n # Returns\n\ntrue if the UID was valid and set, false otherwise."]
    pub fn nfc_device_set_uid(instance: *mut NfcDevice, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the data and protocol of an NfcDevice instance.\n\n Any data previously contained in the instance will be deleted.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `protocol` (direction in) - numeric identifier of the data's protocol.\n * `protocol_data` (direction in) - pointer to the protocol-specific data."]
    pub fn nfc_device_set_data(
        instance: *mut NfcDevice,
        protocol: NfcProtocol,
        protocol_data: *const NfcDeviceData,
    );
}
unsafe extern "C" {
    #[doc = "Copy (export) the data contained in an NfcDevice instance to an outside NfcDeviceData instance.\n\n This function does the inverse of nfc_device_set_data().\n\n The protocol identifier passed as the protocol parameter MUST match the one\n stored in the instance, otherwise a crash will occur.\n This is to improve type safety.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be copied from.\n * `protocol` (direction in) - numeric identifier of the instance's protocol.\n * `protocol_data` (direction out) - pointer to the destination data."]
    pub fn nfc_device_copy_data(
        instance: *const NfcDevice,
        protocol: NfcProtocol,
        protocol_data: *mut NfcDeviceData,
    );
}
unsafe extern "C" {
    #[doc = "Check whether an NfcDevice instance holds certain data.\n\n This function's behaviour is similar to nfc_device_is_equal(), with the difference\n that it takes NfcProtocol and NfcDeviceData* instead of the second NfcDevice*.\n\n The following code snippets [1] and [2] are equivalent:\n\n [1]\n ```c\n bool is_equal = nfc_device_is_equal(device1, device2);\n ```\n [2]\n ```c\n NfcProtocol protocol = nfc_device_get_protocol(device2);\n const NfcDeviceData* data = nfc_device_get_data(device2, protocol);\n bool is_equal = nfc_device_is_equal_data(device1, protocol, data);\n ```\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be compared.\n * `protocol` (direction in) - protocol identifier of the data to be compared.\n * `protocol_data` (direction in) - pointer to the NFC device data to be compared.\n # Returns\n\ntrue if the instance is of the right type and the data matches, false otherwise."]
    pub fn nfc_device_is_equal_data(
        instance: *const NfcDevice,
        protocol: NfcProtocol,
        protocol_data: *const NfcDeviceData,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Compare two NfcDevice instances to determine whether they are equal.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the first instance to be compared.\n * `other` (direction in) - pointer to the second instance to be compared.\n # Returns\n\ntrue if both instances are considered equal, false otherwise."]
    pub fn nfc_device_is_equal(instance: *const NfcDevice, other: *const NfcDevice) -> bool;
}
unsafe extern "C" {
    #[doc = "Set the loading callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `callback` (direction in) - pointer to a function to be called when the load operation completes.\n * `context` (direction in) - pointer to a user-specific context (will be passed to the callback)."]
    pub fn nfc_device_set_loading_callback(
        instance: *mut NfcDevice,
        callback: NfcLoadingCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Save NFC device data form an NfcDevice instance to a file.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be saved.\n * `path` (direction in) - pointer to a character string with a full file path.\n # Returns\n\ntrue if the data was successfully saved, false otherwise."]
    pub fn nfc_device_save(instance: *mut NfcDevice, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Load NFC device data to an NfcDevice instance from a file.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be loaded into.\n * `path` (direction in) - pointer to a character string with a full file path.\n # Returns\n\ntrue if the data was successfully loaded, false otherwise."]
    pub fn nfc_device_load(instance: *mut NfcDevice, path: *const core::ffi::c_char) -> bool;
}
pub const NfcDataGeneratorTypeMfUltralight: NfcDataGeneratorType = NfcDataGeneratorType(0);
pub const NfcDataGeneratorTypeMfUltralightEV1_11: NfcDataGeneratorType = NfcDataGeneratorType(1);
pub const NfcDataGeneratorTypeMfUltralightEV1_H11: NfcDataGeneratorType = NfcDataGeneratorType(2);
pub const NfcDataGeneratorTypeMfUltralightEV1_21: NfcDataGeneratorType = NfcDataGeneratorType(3);
pub const NfcDataGeneratorTypeMfUltralightEV1_H21: NfcDataGeneratorType = NfcDataGeneratorType(4);
pub const NfcDataGeneratorTypeNTAG203: NfcDataGeneratorType = NfcDataGeneratorType(5);
pub const NfcDataGeneratorTypeNTAG213: NfcDataGeneratorType = NfcDataGeneratorType(6);
pub const NfcDataGeneratorTypeNTAG215: NfcDataGeneratorType = NfcDataGeneratorType(7);
pub const NfcDataGeneratorTypeNTAG216: NfcDataGeneratorType = NfcDataGeneratorType(8);
pub const NfcDataGeneratorTypeNTAGI2C1k: NfcDataGeneratorType = NfcDataGeneratorType(9);
pub const NfcDataGeneratorTypeNTAGI2C2k: NfcDataGeneratorType = NfcDataGeneratorType(10);
pub const NfcDataGeneratorTypeNTAGI2CPlus1k: NfcDataGeneratorType = NfcDataGeneratorType(11);
pub const NfcDataGeneratorTypeNTAGI2CPlus2k: NfcDataGeneratorType = NfcDataGeneratorType(12);
pub const NfcDataGeneratorTypeMfClassicMini: NfcDataGeneratorType = NfcDataGeneratorType(13);
pub const NfcDataGeneratorTypeMfClassic1k_4b: NfcDataGeneratorType = NfcDataGeneratorType(14);
pub const NfcDataGeneratorTypeMfClassic1k_7b: NfcDataGeneratorType = NfcDataGeneratorType(15);
pub const NfcDataGeneratorTypeMfClassic4k_4b: NfcDataGeneratorType = NfcDataGeneratorType(16);
pub const NfcDataGeneratorTypeMfClassic4k_7b: NfcDataGeneratorType = NfcDataGeneratorType(17);
pub const NfcDataGeneratorTypeNum: NfcDataGeneratorType = NfcDataGeneratorType(18);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcDataGeneratorType(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn nfc_data_generator_get_name(type_: NfcDataGeneratorType) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn nfc_data_generator_fill_data(type_: NfcDataGeneratorType, nfc_device: *mut NfcDevice);
}
unsafe extern "C" {
    pub fn nfc_util_even_parity8(data: u8) -> u8;
}
unsafe extern "C" {
    pub fn nfc_util_even_parity32(data: u32) -> u8;
}
unsafe extern "C" {
    pub fn nfc_util_odd_parity8(data: u8) -> u8;
}
unsafe extern "C" {
    pub fn nfc_util_odd_parity(src: *const u8, dst: *mut u8, len: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Nfc {
    _unused: [u8; 0],
}
#[doc = "< User code explicitly aborted the current operation."]
pub const NfcEventTypeUserAbort: NfcEventType = NfcEventType(0);
#[doc = "< Reader's field was detected by the NFC hardware."]
pub const NfcEventTypeFieldOn: NfcEventType = NfcEventType(1);
#[doc = "< Reader's field was lost."]
pub const NfcEventTypeFieldOff: NfcEventType = NfcEventType(2);
#[doc = "< Data transmission has started."]
pub const NfcEventTypeTxStart: NfcEventType = NfcEventType(3);
#[doc = "< Data transmission has ended."]
pub const NfcEventTypeTxEnd: NfcEventType = NfcEventType(4);
#[doc = "< Data reception has started."]
pub const NfcEventTypeRxStart: NfcEventType = NfcEventType(5);
#[doc = "< Data reception has ended."]
pub const NfcEventTypeRxEnd: NfcEventType = NfcEventType(6);
#[doc = "< The listener has been activated by the reader."]
pub const NfcEventTypeListenerActivated: NfcEventType = NfcEventType(7);
#[doc = "< The card has been activated by the poller."]
pub const NfcEventTypePollerReady: NfcEventType = NfcEventType(8);
#[repr(transparent)]
#[doc = "Enumeration of possible Nfc event types.\n\n Not all technologies implement all events (this is due to hardware limitations)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcEventType(pub core::ffi::c_uchar);
#[doc = "Nfc event data structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcEventData {
    #[doc = "< Pointer to the received data buffer."]
    pub buffer: *mut BitBuffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcEventData"][::core::mem::size_of::<NfcEventData>() - 4usize];
    ["Alignment of NfcEventData"][::core::mem::align_of::<NfcEventData>() - 4usize];
    ["Offset of field: NfcEventData::buffer"]
        [::core::mem::offset_of!(NfcEventData, buffer) - 0usize];
};
#[doc = "Nfc event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcEvent {
    #[doc = "< Type of the emitted event."]
    pub type_: NfcEventType,
    #[doc = "< Event-specific data."]
    pub data: NfcEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcEvent"][::core::mem::size_of::<NfcEvent>() - 8usize];
    ["Alignment of NfcEvent"][::core::mem::align_of::<NfcEvent>() - 4usize];
    ["Offset of field: NfcEvent::type_"][::core::mem::offset_of!(NfcEvent, type_) - 0usize];
    ["Offset of field: NfcEvent::data"][::core::mem::offset_of!(NfcEvent, data) - 4usize];
};
#[doc = "< Continue operation normally."]
pub const NfcCommandContinue: NfcCommand = NfcCommand(0);
#[doc = "< Reset the current state."]
pub const NfcCommandReset: NfcCommand = NfcCommand(1);
#[doc = "< Stop the current operation."]
pub const NfcCommandStop: NfcCommand = NfcCommand(2);
#[doc = "< Switch Nfc hardware to low-power mode."]
pub const NfcCommandSleep: NfcCommand = NfcCommand(3);
#[repr(transparent)]
#[doc = "Enumeration of possible Nfc commands.\n\n The event callback must return one of these to determine the next action."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcCommand(pub core::ffi::c_uchar);
#[doc = "Nfc event callback type.\n\n A function of this type must be passed as the callback parameter upon start of a an Nfc instance.\n\n # Arguments\n\n* `[in]` - event Nfc event, passed by value, complete with protocol type and data.\n * `[in,out]` - context pointer to the user-specific context (set when starting an Nfc instance).\n # Returns\n\ncommand which the event producer must execute."]
pub type NfcEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: NfcEvent, context: *mut core::ffi::c_void) -> NfcCommand,
>;
#[doc = "< Configure the Nfc instance as a poller."]
pub const NfcModePoller: NfcMode = NfcMode(0);
#[doc = "< Configure the Nfc instance as a listener."]
pub const NfcModeListener: NfcMode = NfcMode(1);
#[doc = "< Operating mode count. Internal use."]
pub const NfcModeNum: NfcMode = NfcMode(2);
#[repr(transparent)]
#[doc = "Enumeration of possible operating modes.\n\n Not all technologies implement the listener operating mode."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcMode(pub core::ffi::c_uchar);
#[doc = "< Configure the Nfc instance to use the ISO14443-3A technology."]
pub const NfcTechIso14443a: NfcTech = NfcTech(0);
#[doc = "< Configure the Nfc instance to use the ISO14443-3B technology."]
pub const NfcTechIso14443b: NfcTech = NfcTech(1);
#[doc = "< Configure the Nfc instance to use the ISO15693 technology."]
pub const NfcTechIso15693: NfcTech = NfcTech(2);
#[doc = "< Configure the Nfc instance to use the FeliCa technology."]
pub const NfcTechFelica: NfcTech = NfcTech(3);
#[doc = "< Technologies count. Internal use."]
pub const NfcTechNum: NfcTech = NfcTech(4);
#[repr(transparent)]
#[doc = "Enumeration of available technologies."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcTech(pub core::ffi::c_uchar);
#[doc = "< No error has occurred."]
pub const NfcErrorNone: NfcError = NfcError(0);
#[doc = "< An unknown error has occured on the lower level."]
pub const NfcErrorInternal: NfcError = NfcError(1);
#[doc = "< Operation is taking too long (e.g. card does not respond)."]
pub const NfcErrorTimeout: NfcError = NfcError(2);
#[doc = "< An incomplete data frame has been received."]
pub const NfcErrorIncompleteFrame: NfcError = NfcError(3);
#[doc = "< Data has not been parsed due to wrong/unknown format."]
pub const NfcErrorDataFormat: NfcError = NfcError(4);
#[repr(transparent)]
#[doc = "Enumeration of possible Nfc error codes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcError(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Allocate an Nfc instance.\n\n Will exclusively take over the NFC HAL until deleted.\n\n # Returns\n\npointer to the allocated Nfc instance."]
    pub fn nfc_alloc() -> *mut Nfc;
}
unsafe extern "C" {
    #[doc = "Delete an Nfc instance.\n\n Will release the NFC HAL lock, making it available for use by others.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be deleted."]
    pub fn nfc_free(instance: *mut Nfc);
}
unsafe extern "C" {
    #[doc = "Configure the Nfc instance to work in a particular mode.\n\n Not all technologies implement the listener operating mode.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be configured.\n * `mode` (direction in) - required operating mode.\n * `tech` (direction in) - required technology configuration."]
    pub fn nfc_config(instance: *mut Nfc, mode: NfcMode, tech: NfcTech);
}
unsafe extern "C" {
    #[doc = "Set poller frame delay time.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `fdt_poll_fc` (direction in) - frame delay time, in carrier cycles."]
    pub fn nfc_set_fdt_poll_fc(instance: *mut Nfc, fdt_poll_fc: u32);
}
unsafe extern "C" {
    #[doc = "Set listener frame delay time.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `fdt_listen_fc` (direction in) - frame delay time, in carrier cycles."]
    pub fn nfc_set_fdt_listen_fc(instance: *mut Nfc, fdt_listen_fc: u32);
}
unsafe extern "C" {
    #[doc = "Set mask receive time.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `mask_rx_time_fc` (direction in) - mask receive time, in carrier cycles."]
    pub fn nfc_set_mask_receive_time_fc(instance: *mut Nfc, mask_rx_time_fc: u32);
}
unsafe extern "C" {
    #[doc = "Set frame delay time.\n\n Frame delay time is the minimum time between two consecutive poll frames.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `fdt_poll_poll_us` (direction in) - frame delay time, in microseconds."]
    pub fn nfc_set_fdt_poll_poll_us(instance: *mut Nfc, fdt_poll_poll_us: u32);
}
unsafe extern "C" {
    #[doc = "Set guard time.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be modified.\n * `guard_time_us` (direction in) - guard time, in microseconds."]
    pub fn nfc_set_guard_time_us(instance: *mut Nfc, guard_time_us: u32);
}
unsafe extern "C" {
    #[doc = "Start the Nfc instance.\n\n The instance must be configured to work with a specific technology\n in a specific operating mode with a nfc_config() call before starting.\n\n Once started, the user code will be receiving events through the provided\n callback which must handle them according to the logic required.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be started.\n * `callback` (direction in) - pointer to a user-defined callback function which will receive events.\n * `context` (direction in) - pointer to a user-specific context (will be passed to the callback)."]
    pub fn nfc_start(
        instance: *mut Nfc,
        callback: NfcEventCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Stop Nfc instance.\n\n The instance can only be stopped if it is running.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be stopped."]
    pub fn nfc_stop(instance: *mut Nfc);
}
unsafe extern "C" {
    #[doc = "Transmit and receive a data frame in poller mode.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n The data being transmitted and received may be either bit- or byte-oriented.\n It shall not contain any technology-specific sequences as start or stop bits\n and/or other special symbols, as this is handled on the underlying HAL level.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_poller_trx(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Transmit a data frame in listener mode.\n\n Used to transmit a response to the reader request in listener mode.\n\n The data being transmitted may be either bit- or byte-oriented.\n It shall not contain any technology-specific sequences as start or stop bits\n and/or other special symbols, as this is handled on the underlying HAL level.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_listener_tx(instance: *mut Nfc, tx_buffer: *const BitBuffer) -> NfcError;
}
pub const NfcIso14443aShortFrameSensReq: NfcIso14443aShortFrame = NfcIso14443aShortFrame(0);
pub const NfcIso14443aShortFrameAllReqa: NfcIso14443aShortFrame = NfcIso14443aShortFrame(1);
#[repr(transparent)]
#[doc = "Enumeration of possible ISO14443-3A short frame types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcIso14443aShortFrame(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Transmit an ISO14443-3A short frame and receive the response in poller mode.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `frame` (direction in) - type of short frame to be sent.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_iso14443a_poller_trx_short_frame(
        instance: *mut Nfc,
        frame: NfcIso14443aShortFrame,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Transmit an ISO14443-3A SDD frame and receive the response in poller mode.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_iso14443a_poller_trx_sdd_frame(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Transmit an ISO14443-3A data frame with custom parity bits and receive the response in poller mode.\n\n Same as nfc_poller_trx(), but uses the parity bits provided by the user code\n instead of calculating them automatically.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_iso14443a_poller_trx_custom_parity(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Transmit an ISO14443-3A frame with custom parity bits in listener mode.\n\n Same as nfc_listener_tx(), but uses the parity bits provided by the user code\n instead of calculating them automatically.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_iso14443a_listener_tx_custom_parity(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Set ISO14443-3A collision resolution parameters in listener mode.\n\n Configures the NFC hardware for automatic collision resolution.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be configured.\n * `uid` (direction in) - pointer to a byte array containing the UID.\n * `uid_len` (direction in) - UID length in bytes (must be supported by the protocol).\n * `atqa` (direction in) - ATQA byte value.\n * `sak` (direction in) - SAK byte value.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_iso14443a_listener_set_col_res_data(
        instance: *mut Nfc,
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Set FeliCa collision resolution parameters in listener mode.\n\n Configures the NFC hardware for automatic collision resolution.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be configured.\n * `idm` (direction in) - pointer to a byte array containing the IDm.\n * `idm_len` (direction in) - IDm length in bytes.\n * `pmm` (direction in) - pointer to a byte array containing the PMm.\n * `pmm_len` (direction in) - PMm length in bytes.\n * `sys_code` (direction in) - System code from SYS_C block\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_felica_listener_set_sensf_res_data(
        instance: *mut Nfc,
        idm: *const u8,
        idm_len: u8,
        pmm: *const u8,
        pmm_len: u8,
        sys_code: u16,
    ) -> NfcError;
}
unsafe extern "C" {
    #[doc = "Send ISO15693 Start of Frame pattern in listener mode\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be configured.\n # Returns\n\nNfcErrorNone on success, any other error code on failure."]
    pub fn nfc_iso15693_listener_tx_sof(instance: *mut Nfc) -> NfcError;
}
#[doc = "Generic Nfc instance type.\n\n Must be cast to a concrete type before use.\n Depending on the context, a pointer of this type\n may point to an object of the following types:\n - Nfc type,\n - Concrete poller type,\n - Concrete listener type."]
pub type NfcGenericInstance = core::ffi::c_void;
#[doc = "Generic Nfc event data type.\n\n Must be cast to a concrete type before use.\n Usually, it will be the protocol-specific event type."]
pub type NfcGenericEventData = core::ffi::c_void;
#[doc = "Generic Nfc event type.\n\n A generic Nfc event contains a protocol identifier, can be used to determine\n the remaing fields' type.\n\n If the value of the protocol field is NfcProtocolInvalid, then it means that\n the event was emitted from an Nfc instance, otherwise it originated from\n a concrete poller or listener instance.\n\n The event_data field is protocol-specific and should be cast to the appropriate type before use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcGenericEvent {
    #[doc = "< Protocol identifier of the instance that produced the event."]
    pub protocol: NfcProtocol,
    #[doc = "< Pointer to the protocol-specific instance that produced the event."]
    pub instance: *mut NfcGenericInstance,
    #[doc = "< Pointer to the protocol-specific event."]
    pub event_data: *mut NfcGenericEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcGenericEvent"][::core::mem::size_of::<NfcGenericEvent>() - 12usize];
    ["Alignment of NfcGenericEvent"][::core::mem::align_of::<NfcGenericEvent>() - 4usize];
    ["Offset of field: NfcGenericEvent::protocol"]
        [::core::mem::offset_of!(NfcGenericEvent, protocol) - 0usize];
    ["Offset of field: NfcGenericEvent::instance"]
        [::core::mem::offset_of!(NfcGenericEvent, instance) - 4usize];
    ["Offset of field: NfcGenericEvent::event_data"]
        [::core::mem::offset_of!(NfcGenericEvent, event_data) - 8usize];
};
#[doc = "Generic Nfc event callback type.\n\n A function of this type must be passed as the callback parameter upon start\n of a poller, listener or Nfc instance.\n\n # Arguments\n\n* `[in]` - event Nfc generic event, passed by value, complete with protocol type and data.\n * `[in,out]` - context pointer to the user-specific context (set when starting a poller/listener instance).\n # Returns\n\nthe command which the event producer must execute."]
pub type NfcGenericCallback = ::core::option::Option<
    unsafe extern "C" fn(event: NfcGenericEvent, context: *mut core::ffi::c_void) -> NfcCommand,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcListener {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate an NfcListener instance.\n\n # Arguments\n\n* `nfc` (direction in) - pointer to an Nfc instance.\n * `protocol` (direction in) - identifier of the protocol to be used.\n * `data` (direction in) - pointer to the data to use during emulation.\n # Returns\n\npointer to an allocated instance.\n\n [`nfc.h`]"]
    pub fn nfc_listener_alloc(
        nfc: *mut Nfc,
        protocol: NfcProtocol,
        data: *const NfcDeviceData,
    ) -> *mut NfcListener;
}
unsafe extern "C" {
    #[doc = "Delete an NfcListener instance.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be deleted."]
    pub fn nfc_listener_free(instance: *mut NfcListener);
}
unsafe extern "C" {
    #[doc = "Start an NfcListener instance.\n\n The callback logic is protocol-specific, so it cannot be described here in detail.\n However, the callback return value ALWAYS determines what the listener should do next:\n to continue whatever it was doing prior to the callback run or to stop.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be started.\n * `callback` (direction in) - pointer to a user-defined callback function which will receive events.\n * `context` (direction in) - pointer to a user-specific context (will be passed to the callback)."]
    pub fn nfc_listener_start(
        instance: *mut NfcListener,
        callback: NfcGenericCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Stop an NfcListener instance.\n\n The emulation process can be stopped explicitly (the other way is via the callback return value).\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be stopped."]
    pub fn nfc_listener_stop(instance: *mut NfcListener);
}
unsafe extern "C" {
    #[doc = "Get the protocol identifier an NfcListener instance was created with.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n # Returns\n\nidentifier of the protocol used by the instance."]
    pub fn nfc_listener_get_protocol(instance: *const NfcListener) -> NfcProtocol;
}
unsafe extern "C" {
    #[doc = "Get the data that was that was provided for emulation.\n\n The protocol identifier passed as the protocol parameter MUST match the one\n stored in the instance, otherwise a crash will occur.\n This is to improve type safety.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n * `protocol` (direction in) - assumed protocol identifier of the data to be retrieved.\n # Returns\n\npointer to the NFC device data."]
    pub fn nfc_listener_get_data(
        instance: *const NfcListener,
        protocol: NfcProtocol,
    ) -> *const NfcDeviceData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcPoller {
    _unused: [u8; 0],
}
#[doc = "Extended generic Nfc event type.\n\n An extended generic Nfc event contains protocol poller and it's parent protocol event data.\n If protocol has no parent, then events are produced by Nfc instance.\n\n The parent_event_data field is protocol-specific and should be cast to the appropriate type before use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcGenericEventEx {
    #[doc = "< Pointer to the protocol poller."]
    pub poller: *mut NfcGenericInstance,
    #[doc = "< Pointer to the protocol's parent poller event data."]
    pub parent_event_data: *mut NfcGenericEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcGenericEventEx"][::core::mem::size_of::<NfcGenericEventEx>() - 8usize];
    ["Alignment of NfcGenericEventEx"][::core::mem::align_of::<NfcGenericEventEx>() - 4usize];
    ["Offset of field: NfcGenericEventEx::poller"]
        [::core::mem::offset_of!(NfcGenericEventEx, poller) - 0usize];
    ["Offset of field: NfcGenericEventEx::parent_event_data"]
        [::core::mem::offset_of!(NfcGenericEventEx, parent_event_data) - 4usize];
};
#[doc = "Extended generic Nfc event callback type.\n\n A function of this type must be passed as the callback parameter upon extended start of a poller.\n\n # Arguments\n\n* `[in]` - event Nfc extended generic event, passed by value, complete with protocol type and data.\n * `[in,out]` - context pointer to the user-specific context (set when starting a poller/listener instance).\n # Returns\n\nthe command which the event producer must execute."]
pub type NfcGenericCallbackEx = ::core::option::Option<
    unsafe extern "C" fn(event: NfcGenericEventEx, context: *mut core::ffi::c_void) -> NfcCommand,
>;
unsafe extern "C" {
    #[doc = "Allocate an NfcPoller instance.\n\n # Arguments\n\n* `nfc` (direction in) - pointer to an Nfc instance.\n * `protocol` (direction in) - identifier of the protocol to be used.\n # Returns\n\npointer to an allocated instance.\n\n [`nfc.h`]"]
    pub fn nfc_poller_alloc(nfc: *mut Nfc, protocol: NfcProtocol) -> *mut NfcPoller;
}
unsafe extern "C" {
    #[doc = "Delete an NfcPoller instance.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be deleted."]
    pub fn nfc_poller_free(instance: *mut NfcPoller);
}
unsafe extern "C" {
    #[doc = "Start an NfcPoller instance.\n\n The callback logic is protocol-specific, so it cannot be described here in detail.\n However, the callback return value ALWAYS determines what the poller should do next:\n to continue whatever it was doing prior to the callback run or to stop.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be started.\n * `callback` (direction in) - pointer to a user-defined callback function which will receive events.\n * `context` (direction in) - pointer to a user-specific context (will be passed to the callback)."]
    pub fn nfc_poller_start(
        instance: *mut NfcPoller,
        callback: NfcGenericCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Start an NfcPoller instance in extended mode.\n\n When nfc poller is started in extended mode, callback will be called with parent protocol events\n and protocol instance. This mode enables to make custom poller state machines.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be started.\n * `callback` (direction in) - pointer to a user-defined callback function which will receive events.\n * `context` (direction in) - pointer to a user-specific context (will be passed to the callback)."]
    pub fn nfc_poller_start_ex(
        instance: *mut NfcPoller,
        callback: NfcGenericCallbackEx,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Stop an NfcPoller instance.\n\n The reading process can be stopped explicitly (the other way is via the callback return value).\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be stopped."]
    pub fn nfc_poller_stop(instance: *mut NfcPoller);
}
unsafe extern "C" {
    #[doc = "Detect whether there is a card supporting a particular protocol in the vicinity.\n\n The behaviour of this function is protocol-defined, in general, it will do whatever is\n necessary to determine whether a card supporting the current protocol is in the vicinity\n and whether it is functioning normally.\n\n It is used automatically inside NfcScanner, so there is usually no need\n to call it explicitly.\n\n [`nfc_scanner.h`]\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to perform the detection with.\n # Returns\n\ntrue if a supported card was detected, false otherwise."]
    pub fn nfc_poller_detect(instance: *mut NfcPoller) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the protocol identifier an NfcPoller instance was created with.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n # Returns\n\nidentifier of the protocol used by the instance."]
    pub fn nfc_poller_get_protocol(instance: *const NfcPoller) -> NfcProtocol;
}
unsafe extern "C" {
    #[doc = "Get the data that was that was gathered during the reading process.\n\n # Arguments\n\n* `instance` (direction in) - pointer to the instance to be queried.\n # Returns\n\npointer to the NFC device data."]
    pub fn nfc_poller_get_data(instance: *const NfcPoller) -> *const NfcDeviceData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcScanner {
    _unused: [u8; 0],
}
#[doc = "< One or more protocols have been detected."]
pub const NfcScannerEventTypeDetected: NfcScannerEventType = NfcScannerEventType(0);
#[repr(transparent)]
#[doc = "Event type passed to the user callback."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NfcScannerEventType(pub core::ffi::c_uchar);
#[doc = "Event data passed to the user callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcScannerEventData {
    #[doc = "< Number of detected protocols (one or more)."]
    pub protocol_num: usize,
    #[doc = "< Pointer to the array of detected protocol identifiers."]
    pub protocols: *mut NfcProtocol,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcScannerEventData"][::core::mem::size_of::<NfcScannerEventData>() - 8usize];
    ["Alignment of NfcScannerEventData"][::core::mem::align_of::<NfcScannerEventData>() - 4usize];
    ["Offset of field: NfcScannerEventData::protocol_num"]
        [::core::mem::offset_of!(NfcScannerEventData, protocol_num) - 0usize];
    ["Offset of field: NfcScannerEventData::protocols"]
        [::core::mem::offset_of!(NfcScannerEventData, protocols) - 4usize];
};
#[doc = "Event passed to the user callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcScannerEvent {
    #[doc = "< Type of event. Determines how the data must be handled."]
    pub type_: NfcScannerEventType,
    #[doc = "< Event-specific data. Handled accordingly to the even type."]
    pub data: NfcScannerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of NfcScannerEvent"][::core::mem::size_of::<NfcScannerEvent>() - 12usize];
    ["Alignment of NfcScannerEvent"][::core::mem::align_of::<NfcScannerEvent>() - 4usize];
    ["Offset of field: NfcScannerEvent::type_"]
        [::core::mem::offset_of!(NfcScannerEvent, type_) - 0usize];
    ["Offset of field: NfcScannerEvent::data"]
        [::core::mem::offset_of!(NfcScannerEvent, data) - 4usize];
};
#[doc = "User callback function signature.\n\n A function with such signature must be provided by the user upon calling nfc_scanner_start().\n\n # Arguments\n\n* `event` (direction in) - occurred event, complete with type and data.\n * `context` (direction in) - pointer to the context data provided in nfc_scanner_start() call."]
pub type NfcScannerCallback = ::core::option::Option<
    unsafe extern "C" fn(event: NfcScannerEvent, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Allocate an NfcScanner instance.\n\n # Arguments\n\n* `nfc` (direction in) - pointer to an Nfc instance.\n # Returns\n\npointer to the allocated NfcScanner instance.\n\n [`nfc.h`]"]
    pub fn nfc_scanner_alloc(nfc: *mut Nfc) -> *mut NfcScanner;
}
unsafe extern "C" {
    #[doc = "Delete an NfcScanner instance.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be deleted."]
    pub fn nfc_scanner_free(instance: *mut NfcScanner);
}
unsafe extern "C" {
    #[doc = "Start an NfcScanner.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be started.\n * `callback` (direction in) - pointer to the callback function (will be called upon a detection event).\n * `context` (direction in) - pointer to the caller-specific context (will be passed to the callback)."]
    pub fn nfc_scanner_start(
        instance: *mut NfcScanner,
        callback: NfcScannerCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Stop an NfcScanner.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be stopped."]
    pub fn nfc_scanner_stop(instance: *mut NfcScanner);
}
pub const FelicaErrorNone: FelicaError = FelicaError(0);
pub const FelicaErrorNotPresent: FelicaError = FelicaError(1);
pub const FelicaErrorColResFailed: FelicaError = FelicaError(2);
pub const FelicaErrorBufferOverflow: FelicaError = FelicaError(3);
pub const FelicaErrorCommunication: FelicaError = FelicaError(4);
pub const FelicaErrorFieldOff: FelicaError = FelicaError(5);
pub const FelicaErrorWrongCrc: FelicaError = FelicaError(6);
pub const FelicaErrorProtocol: FelicaError = FelicaError(7);
pub const FelicaErrorTimeout: FelicaError = FelicaError(8);
#[repr(transparent)]
#[doc = "Type of possible Felica errors"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FelicaError(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaBlockData {
    pub data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaBlockData"][::core::mem::size_of::<FelicaBlockData>() - 16usize];
    ["Alignment of FelicaBlockData"][::core::mem::align_of::<FelicaBlockData>() - 1usize];
    ["Offset of field: FelicaBlockData::data"]
        [::core::mem::offset_of!(FelicaBlockData, data) - 0usize];
};
#[doc = "Separate type for card key block. Used in authentication process"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaCardKey {
    pub data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaCardKey"][::core::mem::size_of::<FelicaCardKey>() - 16usize];
    ["Alignment of FelicaCardKey"][::core::mem::align_of::<FelicaCardKey>() - 1usize];
    ["Offset of field: FelicaCardKey::data"][::core::mem::offset_of!(FelicaCardKey, data) - 0usize];
};
#[doc = "In Felica there two types of auth. Internal is the first one, after\n which external became possible. Here are two flags representing which one\n was passed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaAuthenticationStatus {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaAuthenticationStatus"]
        [::core::mem::size_of::<FelicaAuthenticationStatus>() - 1usize];
    ["Alignment of FelicaAuthenticationStatus"]
        [::core::mem::align_of::<FelicaAuthenticationStatus>() - 1usize];
};
impl FelicaAuthenticationStatus {
    #[inline]
    pub fn internal(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_internal(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn internal_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_internal_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn external(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_external(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn external_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_external_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(internal: bool, external: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let internal: u8 = unsafe { ::core::mem::transmute(internal) };
            internal as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let external: u8 = unsafe { ::core::mem::transmute(external) };
            external as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Struct which controls the process of authentication and can be passed as\n a parameter to the application level. In order to force user to fill card key block data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaAuthenticationContext {
    #[doc = "< By default it is true, so auth is skipped. By setting this to false several auth steps will be performed in order to pass auth"]
    pub skip_auth: bool,
    #[doc = "< User must fill this field with known card key in order to pass auth"]
    pub card_key: FelicaCardKey,
    #[doc = "< Authentication status"]
    pub auth_status: FelicaAuthenticationStatus,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaAuthenticationContext"]
        [::core::mem::size_of::<FelicaAuthenticationContext>() - 18usize];
    ["Alignment of FelicaAuthenticationContext"]
        [::core::mem::align_of::<FelicaAuthenticationContext>() - 1usize];
    ["Offset of field: FelicaAuthenticationContext::skip_auth"]
        [::core::mem::offset_of!(FelicaAuthenticationContext, skip_auth) - 0usize];
    ["Offset of field: FelicaAuthenticationContext::card_key"]
        [::core::mem::offset_of!(FelicaAuthenticationContext, card_key) - 1usize];
    ["Offset of field: FelicaAuthenticationContext::auth_status"]
        [::core::mem::offset_of!(FelicaAuthenticationContext, auth_status) - 17usize];
};
#[doc = "Stucture for holding Felica session key which is calculated from rc and ck."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaSessionKey {
    pub data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaSessionKey"][::core::mem::size_of::<FelicaSessionKey>() - 16usize];
    ["Alignment of FelicaSessionKey"][::core::mem::align_of::<FelicaSessionKey>() - 1usize];
    ["Offset of field: FelicaSessionKey::data"]
        [::core::mem::offset_of!(FelicaSessionKey, data) - 0usize];
};
#[doc = "Structure used to hold authentication related fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaAuthentication {
    #[doc = "< Context for mbedtls des functions."]
    pub des_context: mbedtls_des3_context,
    #[doc = "< Calculated session key."]
    pub session_key: FelicaSessionKey,
    #[doc = "< Public auth context provided to upper levels."]
    pub context: FelicaAuthenticationContext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaAuthentication"][::core::mem::size_of::<FelicaAuthentication>() - 420usize];
    ["Alignment of FelicaAuthentication"][::core::mem::align_of::<FelicaAuthentication>() - 4usize];
    ["Offset of field: FelicaAuthentication::des_context"]
        [::core::mem::offset_of!(FelicaAuthentication, des_context) - 0usize];
    ["Offset of field: FelicaAuthentication::session_key"]
        [::core::mem::offset_of!(FelicaAuthentication, session_key) - 384usize];
    ["Offset of field: FelicaAuthentication::context"]
        [::core::mem::offset_of!(FelicaAuthentication, context) - 400usize];
};
#[doc = "Felica ID block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaIDm {
    pub data: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaIDm"][::core::mem::size_of::<FelicaIDm>() - 8usize];
    ["Alignment of FelicaIDm"][::core::mem::align_of::<FelicaIDm>() - 1usize];
    ["Offset of field: FelicaIDm::data"][::core::mem::offset_of!(FelicaIDm, data) - 0usize];
};
#[doc = "Felica PMm block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaPMm {
    pub data: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaPMm"][::core::mem::size_of::<FelicaPMm>() - 8usize];
    ["Alignment of FelicaPMm"][::core::mem::align_of::<FelicaPMm>() - 1usize];
    ["Offset of field: FelicaPMm::data"][::core::mem::offset_of!(FelicaPMm, data) - 0usize];
};
#[doc = "Felica block with status flags indicating last operation with it.\n See Felica manual for more details on status codes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaBlock {
    #[doc = "< Status flag 1, equals to 0 when success"]
    pub SF1: u8,
    #[doc = "< Status flag 2, equals to 0 when success"]
    pub SF2: u8,
    #[doc = "< Block data"]
    pub data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaBlock"][::core::mem::size_of::<FelicaBlock>() - 18usize];
    ["Alignment of FelicaBlock"][::core::mem::align_of::<FelicaBlock>() - 1usize];
    ["Offset of field: FelicaBlock::SF1"][::core::mem::offset_of!(FelicaBlock, SF1) - 0usize];
    ["Offset of field: FelicaBlock::SF2"][::core::mem::offset_of!(FelicaBlock, SF2) - 1usize];
    ["Offset of field: FelicaBlock::data"][::core::mem::offset_of!(FelicaBlock, data) - 2usize];
};
#[doc = "Felica filesystem structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaFileSystem {
    pub spad: [FelicaBlock; 14usize],
    pub reg: FelicaBlock,
    pub rc: FelicaBlock,
    pub mac: FelicaBlock,
    pub id: FelicaBlock,
    pub d_id: FelicaBlock,
    pub ser_c: FelicaBlock,
    pub sys_c: FelicaBlock,
    pub ckv: FelicaBlock,
    pub ck: FelicaBlock,
    pub mc: FelicaBlock,
    pub wcnt: FelicaBlock,
    pub mac_a: FelicaBlock,
    pub state: FelicaBlock,
    pub crc_check: FelicaBlock,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaFileSystem"][::core::mem::size_of::<FelicaFileSystem>() - 504usize];
    ["Alignment of FelicaFileSystem"][::core::mem::align_of::<FelicaFileSystem>() - 1usize];
    ["Offset of field: FelicaFileSystem::spad"]
        [::core::mem::offset_of!(FelicaFileSystem, spad) - 0usize];
    ["Offset of field: FelicaFileSystem::reg"]
        [::core::mem::offset_of!(FelicaFileSystem, reg) - 252usize];
    ["Offset of field: FelicaFileSystem::rc"]
        [::core::mem::offset_of!(FelicaFileSystem, rc) - 270usize];
    ["Offset of field: FelicaFileSystem::mac"]
        [::core::mem::offset_of!(FelicaFileSystem, mac) - 288usize];
    ["Offset of field: FelicaFileSystem::id"]
        [::core::mem::offset_of!(FelicaFileSystem, id) - 306usize];
    ["Offset of field: FelicaFileSystem::d_id"]
        [::core::mem::offset_of!(FelicaFileSystem, d_id) - 324usize];
    ["Offset of field: FelicaFileSystem::ser_c"]
        [::core::mem::offset_of!(FelicaFileSystem, ser_c) - 342usize];
    ["Offset of field: FelicaFileSystem::sys_c"]
        [::core::mem::offset_of!(FelicaFileSystem, sys_c) - 360usize];
    ["Offset of field: FelicaFileSystem::ckv"]
        [::core::mem::offset_of!(FelicaFileSystem, ckv) - 378usize];
    ["Offset of field: FelicaFileSystem::ck"]
        [::core::mem::offset_of!(FelicaFileSystem, ck) - 396usize];
    ["Offset of field: FelicaFileSystem::mc"]
        [::core::mem::offset_of!(FelicaFileSystem, mc) - 414usize];
    ["Offset of field: FelicaFileSystem::wcnt"]
        [::core::mem::offset_of!(FelicaFileSystem, wcnt) - 432usize];
    ["Offset of field: FelicaFileSystem::mac_a"]
        [::core::mem::offset_of!(FelicaFileSystem, mac_a) - 450usize];
    ["Offset of field: FelicaFileSystem::state"]
        [::core::mem::offset_of!(FelicaFileSystem, state) - 468usize];
    ["Offset of field: FelicaFileSystem::crc_check"]
        [::core::mem::offset_of!(FelicaFileSystem, crc_check) - 486usize];
};
#[doc = "Union which represents filesystem in junction with plain data dump"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union FelicaFSUnion {
    pub fs: FelicaFileSystem,
    pub dump: [u8; 504usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaFSUnion"][::core::mem::size_of::<FelicaFSUnion>() - 504usize];
    ["Alignment of FelicaFSUnion"][::core::mem::align_of::<FelicaFSUnion>() - 1usize];
    ["Offset of field: FelicaFSUnion::fs"][::core::mem::offset_of!(FelicaFSUnion, fs) - 0usize];
    ["Offset of field: FelicaFSUnion::dump"][::core::mem::offset_of!(FelicaFSUnion, dump) - 0usize];
};
#[doc = "Structure used to store Felica data and additional values about reading"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FelicaData {
    pub idm: FelicaIDm,
    pub pmm: FelicaPMm,
    pub blocks_total: u8,
    pub blocks_read: u8,
    pub data: FelicaFSUnion,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaData"][::core::mem::size_of::<FelicaData>() - 522usize];
    ["Alignment of FelicaData"][::core::mem::align_of::<FelicaData>() - 1usize];
    ["Offset of field: FelicaData::idm"][::core::mem::offset_of!(FelicaData, idm) - 0usize];
    ["Offset of field: FelicaData::pmm"][::core::mem::offset_of!(FelicaData, pmm) - 8usize];
    ["Offset of field: FelicaData::blocks_total"]
        [::core::mem::offset_of!(FelicaData, blocks_total) - 16usize];
    ["Offset of field: FelicaData::blocks_read"]
        [::core::mem::offset_of!(FelicaData, blocks_read) - 17usize];
    ["Offset of field: FelicaData::data"][::core::mem::offset_of!(FelicaData, data) - 18usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaCommandHeader {
    pub code: u8,
    pub idm: FelicaIDm,
    pub service_num: u8,
    pub service_code: u16,
    pub block_count: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaCommandHeader"][::core::mem::size_of::<FelicaCommandHeader>() - 13usize];
    ["Alignment of FelicaCommandHeader"][::core::mem::align_of::<FelicaCommandHeader>() - 1usize];
    ["Offset of field: FelicaCommandHeader::code"]
        [::core::mem::offset_of!(FelicaCommandHeader, code) - 0usize];
    ["Offset of field: FelicaCommandHeader::idm"]
        [::core::mem::offset_of!(FelicaCommandHeader, idm) - 1usize];
    ["Offset of field: FelicaCommandHeader::service_num"]
        [::core::mem::offset_of!(FelicaCommandHeader, service_num) - 9usize];
    ["Offset of field: FelicaCommandHeader::service_code"]
        [::core::mem::offset_of!(FelicaCommandHeader, service_code) - 10usize];
    ["Offset of field: FelicaCommandHeader::block_count"]
        [::core::mem::offset_of!(FelicaCommandHeader, block_count) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaCommandResponseHeader {
    pub length: u8,
    pub response_code: u8,
    pub idm: FelicaIDm,
    pub SF1: u8,
    pub SF2: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaCommandResponseHeader"]
        [::core::mem::size_of::<FelicaCommandResponseHeader>() - 12usize];
    ["Alignment of FelicaCommandResponseHeader"]
        [::core::mem::align_of::<FelicaCommandResponseHeader>() - 1usize];
    ["Offset of field: FelicaCommandResponseHeader::length"]
        [::core::mem::offset_of!(FelicaCommandResponseHeader, length) - 0usize];
    ["Offset of field: FelicaCommandResponseHeader::response_code"]
        [::core::mem::offset_of!(FelicaCommandResponseHeader, response_code) - 1usize];
    ["Offset of field: FelicaCommandResponseHeader::idm"]
        [::core::mem::offset_of!(FelicaCommandResponseHeader, idm) - 2usize];
    ["Offset of field: FelicaCommandResponseHeader::SF1"]
        [::core::mem::offset_of!(FelicaCommandResponseHeader, SF1) - 10usize];
    ["Offset of field: FelicaCommandResponseHeader::SF2"]
        [::core::mem::offset_of!(FelicaCommandResponseHeader, SF2) - 11usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaBlockListElement {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub block_number: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaBlockListElement"][::core::mem::size_of::<FelicaBlockListElement>() - 2usize];
    ["Alignment of FelicaBlockListElement"]
        [::core::mem::align_of::<FelicaBlockListElement>() - 1usize];
    ["Offset of field: FelicaBlockListElement::block_number"]
        [::core::mem::offset_of!(FelicaBlockListElement, block_number) - 1usize];
};
impl FelicaBlockListElement {
    #[inline]
    pub fn service_code(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_service_code(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn service_code_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_service_code_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn access_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_access_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn access_mode_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_access_mode_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        service_code: u8,
        access_mode: u8,
        length: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let service_code: u8 = unsafe { ::core::mem::transmute(service_code) };
            service_code as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let access_mode: u8 = unsafe { ::core::mem::transmute(access_mode) };
            access_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let length: u8 = unsafe { ::core::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FelicaPollerReadCommandResponse {
    pub length: u8,
    pub response_code: u8,
    pub idm: FelicaIDm,
    pub SF1: u8,
    pub SF2: u8,
    pub block_count: u8,
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaPollerReadCommandResponse"]
        [::core::mem::size_of::<FelicaPollerReadCommandResponse>() - 13usize];
    ["Alignment of FelicaPollerReadCommandResponse"]
        [::core::mem::align_of::<FelicaPollerReadCommandResponse>() - 1usize];
    ["Offset of field: FelicaPollerReadCommandResponse::length"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, length) - 0usize];
    ["Offset of field: FelicaPollerReadCommandResponse::response_code"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, response_code) - 1usize];
    ["Offset of field: FelicaPollerReadCommandResponse::idm"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, idm) - 2usize];
    ["Offset of field: FelicaPollerReadCommandResponse::SF1"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, SF1) - 10usize];
    ["Offset of field: FelicaPollerReadCommandResponse::SF2"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, SF2) - 11usize];
    ["Offset of field: FelicaPollerReadCommandResponse::block_count"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, block_count) - 12usize];
    ["Offset of field: FelicaPollerReadCommandResponse::data"]
        [::core::mem::offset_of!(FelicaPollerReadCommandResponse, data) - 13usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct FelicaListenerReadCommandResponse {
    pub header: FelicaCommandResponseHeader,
    pub block_count: u8,
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaListenerReadCommandResponse"]
        [::core::mem::size_of::<FelicaListenerReadCommandResponse>() - 13usize];
    ["Alignment of FelicaListenerReadCommandResponse"]
        [::core::mem::align_of::<FelicaListenerReadCommandResponse>() - 1usize];
    ["Offset of field: FelicaListenerReadCommandResponse::header"]
        [::core::mem::offset_of!(FelicaListenerReadCommandResponse, header) - 0usize];
    ["Offset of field: FelicaListenerReadCommandResponse::block_count"]
        [::core::mem::offset_of!(FelicaListenerReadCommandResponse, block_count) - 12usize];
    ["Offset of field: FelicaListenerReadCommandResponse::data"]
        [::core::mem::offset_of!(FelicaListenerReadCommandResponse, data) - 13usize];
};
pub type FelicaListenerWriteCommandResponse = FelicaCommandResponseHeader;
pub type FelicaPollerWriteCommandResponse = FelicaCommandResponseHeader;
unsafe extern "C" {
    pub fn felica_alloc() -> *mut FelicaData;
}
unsafe extern "C" {
    pub fn felica_free(data: *mut FelicaData);
}
unsafe extern "C" {
    pub fn felica_reset(data: *mut FelicaData);
}
unsafe extern "C" {
    pub fn felica_copy(data: *mut FelicaData, other: *const FelicaData);
}
unsafe extern "C" {
    pub fn felica_verify(data: *mut FelicaData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn felica_load(data: *mut FelicaData, ff: *mut FlipperFormat, version: u32) -> bool;
}
unsafe extern "C" {
    pub fn felica_save(data: *const FelicaData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn felica_is_equal(data: *const FelicaData, other: *const FelicaData) -> bool;
}
unsafe extern "C" {
    pub fn felica_get_device_name(
        data: *const FelicaData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn felica_get_uid(data: *const FelicaData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn felica_set_uid(data: *mut FelicaData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn felica_get_base_data(data: *const FelicaData) -> *mut FelicaData;
}
unsafe extern "C" {
    pub fn felica_calculate_session_key(
        ctx: *mut mbedtls_des3_context,
        ck: *const u8,
        rc: *const u8,
        out: *mut u8,
    );
}
unsafe extern "C" {
    pub fn felica_check_mac(
        ctx: *mut mbedtls_des3_context,
        session_key: *const u8,
        rc: *const u8,
        blocks: *const u8,
        block_count: u8,
        data: *mut u8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn felica_calculate_mac_read(
        ctx: *mut mbedtls_des3_context,
        session_key: *const u8,
        rc: *const u8,
        blocks: *const u8,
        block_count: u8,
        data: *const u8,
        mac: *mut u8,
    );
}
unsafe extern "C" {
    pub fn felica_calculate_mac_write(
        ctx: *mut mbedtls_des3_context,
        session_key: *const u8,
        rc: *const u8,
        wcnt: *const u8,
        data: *const u8,
        mac: *mut u8,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaListener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaPoller {
    _unused: [u8; 0],
}
#[doc = "< An error occured during activation procedure."]
pub const FelicaPollerEventTypeError: FelicaPollerEventType = FelicaPollerEventType(0);
#[doc = "< The card was activated and fully read by the poller."]
pub const FelicaPollerEventTypeReady: FelicaPollerEventType = FelicaPollerEventType(1);
#[doc = "< The card was activated and partly read by the poller."]
pub const FelicaPollerEventTypeIncomplete: FelicaPollerEventType = FelicaPollerEventType(2);
#[doc = "< Authentication context was requested by poller."]
pub const FelicaPollerEventTypeRequestAuthContext: FelicaPollerEventType = FelicaPollerEventType(3);
#[repr(transparent)]
#[doc = "Enumeration of possible Felica poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FelicaPollerEventType(pub core::ffi::c_uchar);
#[doc = "Felica poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union FelicaPollerEventData {
    #[doc = "< Error code indicating card activation fail reason."]
    pub error: FelicaError,
    #[doc = "< Authentication context to be filled by user."]
    pub auth_context: *mut FelicaAuthenticationContext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaPollerEventData"][::core::mem::size_of::<FelicaPollerEventData>() - 4usize];
    ["Alignment of FelicaPollerEventData"]
        [::core::mem::align_of::<FelicaPollerEventData>() - 4usize];
    ["Offset of field: FelicaPollerEventData::error"]
        [::core::mem::offset_of!(FelicaPollerEventData, error) - 0usize];
    ["Offset of field: FelicaPollerEventData::auth_context"]
        [::core::mem::offset_of!(FelicaPollerEventData, auth_context) - 0usize];
};
#[doc = "FelicaPoller poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FelicaPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: FelicaPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut FelicaPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FelicaPollerEvent"][::core::mem::size_of::<FelicaPollerEvent>() - 8usize];
    ["Alignment of FelicaPollerEvent"][::core::mem::align_of::<FelicaPollerEvent>() - 4usize];
    ["Offset of field: FelicaPollerEvent::type_"]
        [::core::mem::offset_of!(FelicaPollerEvent, type_) - 0usize];
    ["Offset of field: FelicaPollerEvent::data"]
        [::core::mem::offset_of!(FelicaPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Perform collision resolution procedure.\n\n Must ONLY be used inside the callback function.\n\n Perfoms the collision resolution procedure as defined in FeliCa standars. The data\n field will be filled with Felica data on success.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the Felica data structure to be filled.\n # Returns\n\nFelicaErrorNone on success, an error code on failure."]
    pub fn felica_poller_activate(
        instance: *mut FelicaPoller,
        data: *mut FelicaData,
    ) -> FelicaError;
}
unsafe extern "C" {
    pub fn felica_poller_sync_read(
        nfc: *mut Nfc,
        data: *mut FelicaData,
        card_key: *const FelicaCardKey,
    ) -> FelicaError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aListener {
    _unused: [u8; 0],
}
pub const Iso14443_3aListenerEventTypeFieldOff: Iso14443_3aListenerEventType =
    Iso14443_3aListenerEventType(0);
pub const Iso14443_3aListenerEventTypeHalted: Iso14443_3aListenerEventType =
    Iso14443_3aListenerEventType(1);
pub const Iso14443_3aListenerEventTypeReceivedStandardFrame: Iso14443_3aListenerEventType =
    Iso14443_3aListenerEventType(2);
pub const Iso14443_3aListenerEventTypeReceivedData: Iso14443_3aListenerEventType =
    Iso14443_3aListenerEventType(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3aListenerEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aListenerEventData {
    pub buffer: *mut BitBuffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aListenerEventData"]
        [::core::mem::size_of::<Iso14443_3aListenerEventData>() - 4usize];
    ["Alignment of Iso14443_3aListenerEventData"]
        [::core::mem::align_of::<Iso14443_3aListenerEventData>() - 4usize];
    ["Offset of field: Iso14443_3aListenerEventData::buffer"]
        [::core::mem::offset_of!(Iso14443_3aListenerEventData, buffer) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aListenerEvent {
    pub type_: Iso14443_3aListenerEventType,
    pub data: *mut Iso14443_3aListenerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aListenerEvent"]
        [::core::mem::size_of::<Iso14443_3aListenerEvent>() - 8usize];
    ["Alignment of Iso14443_3aListenerEvent"]
        [::core::mem::align_of::<Iso14443_3aListenerEvent>() - 4usize];
    ["Offset of field: Iso14443_3aListenerEvent::type_"]
        [::core::mem::offset_of!(Iso14443_3aListenerEvent, type_) - 0usize];
    ["Offset of field: Iso14443_3aListenerEvent::data"]
        [::core::mem::offset_of!(Iso14443_3aListenerEvent, data) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aPoller {
    _unused: [u8; 0],
}
#[doc = "< An error occured during activation procedure."]
pub const Iso14443_3aPollerEventTypeError: Iso14443_3aPollerEventType =
    Iso14443_3aPollerEventType(0);
#[doc = "< The card was activated by the poller."]
pub const Iso14443_3aPollerEventTypeReady: Iso14443_3aPollerEventType =
    Iso14443_3aPollerEventType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible Iso14443_3a poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3aPollerEventType(pub core::ffi::c_uchar);
#[doc = "Iso14443_3a poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union Iso14443_3aPollerEventData {
    #[doc = "< Error code indicating card activation fail reason."]
    pub error: Iso14443_3aError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aPollerEventData"]
        [::core::mem::size_of::<Iso14443_3aPollerEventData>() - 1usize];
    ["Alignment of Iso14443_3aPollerEventData"]
        [::core::mem::align_of::<Iso14443_3aPollerEventData>() - 1usize];
    ["Offset of field: Iso14443_3aPollerEventData::error"]
        [::core::mem::offset_of!(Iso14443_3aPollerEventData, error) - 0usize];
};
#[doc = "Iso14443_3a poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: Iso14443_3aPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut Iso14443_3aPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3aPollerEvent"][::core::mem::size_of::<Iso14443_3aPollerEvent>() - 8usize];
    ["Alignment of Iso14443_3aPollerEvent"]
        [::core::mem::align_of::<Iso14443_3aPollerEvent>() - 4usize];
    ["Offset of field: Iso14443_3aPollerEvent::type_"]
        [::core::mem::offset_of!(Iso14443_3aPollerEvent, type_) - 0usize];
    ["Offset of field: Iso14443_3aPollerEvent::data"]
        [::core::mem::offset_of!(Iso14443_3aPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3a frames in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nIso14443_3aErrorNone on success, an error code on failure."]
    pub fn iso14443_3a_poller_txrx(
        instance: *mut Iso14443_3aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> Iso14443_3aError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3a standard frames in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nIso14443_3aErrorNone on success, an error code on failure."]
    pub fn iso14443_3a_poller_send_standard_frame(
        instance: *mut Iso14443_3aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> Iso14443_3aError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3a frames with custom parity bits in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n Custom parity bits must be set in the tx_buffer. The rx_buffer will contain\n the received data with the parity bits.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nIso14443_3aErrorNone on success, an error code on failure."]
    pub fn iso14443_3a_poller_txrx_custom_parity(
        instance: *mut Iso14443_3aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> Iso14443_3aError;
}
unsafe extern "C" {
    #[doc = "Checks presence of Iso14443_3a complient card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n # Returns\n\nIso14443_3aErrorNone if card is present, an error code otherwise."]
    pub fn iso14443_3a_poller_check_presence(instance: *mut Iso14443_3aPoller) -> Iso14443_3aError;
}
unsafe extern "C" {
    #[doc = "Perform collision resolution procedure.\n\n Must ONLY be used inside the callback function.\n\n Perfoms the collision resolution procedure as defined in Iso14443-3a. The iso14443_3a_data\n field will be filled with Iso14443-3a data on success.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `iso14443_3a_data` (direction out) - pointer to the Iso14443_3a data structure to be filled.\n # Returns\n\nIso14443_3aErrorNone on success, an error code on failure."]
    pub fn iso14443_3a_poller_activate(
        instance: *mut Iso14443_3aPoller,
        iso14443_3a_data: *mut Iso14443_3aData,
    ) -> Iso14443_3aError;
}
unsafe extern "C" {
    #[doc = "Send HALT command to the card.\n\n Must ONLY be used inside the callback function.\n\n Halts card and changes internal Iso14443_3aPoller state to Idle.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n # Returns\n\nIso14443_3aErrorNone on success, an error code on failure."]
    pub fn iso14443_3a_poller_halt(instance: *mut Iso14443_3aPoller) -> Iso14443_3aError;
}
unsafe extern "C" {
    pub fn iso14443_3a_poller_sync_read(
        nfc: *mut Nfc,
        iso14443_3a_data: *mut Iso14443_3aData,
    ) -> Iso14443_3aError;
}
pub const Iso14443_3bErrorNone: Iso14443_3bError = Iso14443_3bError(0);
pub const Iso14443_3bErrorNotPresent: Iso14443_3bError = Iso14443_3bError(1);
pub const Iso14443_3bErrorColResFailed: Iso14443_3bError = Iso14443_3bError(2);
pub const Iso14443_3bErrorBufferOverflow: Iso14443_3bError = Iso14443_3bError(3);
pub const Iso14443_3bErrorCommunication: Iso14443_3bError = Iso14443_3bError(4);
pub const Iso14443_3bErrorFieldOff: Iso14443_3bError = Iso14443_3bError(5);
pub const Iso14443_3bErrorWrongCrc: Iso14443_3bError = Iso14443_3bError(6);
pub const Iso14443_3bErrorTimeout: Iso14443_3bError = Iso14443_3bError(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3bError(pub core::ffi::c_uchar);
pub const Iso14443_3bBitRateBoth106Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(0);
pub const Iso14443_3bBitRatePiccToPcd212Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(1);
pub const Iso14443_3bBitRatePiccToPcd424Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(2);
pub const Iso14443_3bBitRatePiccToPcd848Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(3);
pub const Iso14443_3bBitRatePcdToPicc212Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(4);
pub const Iso14443_3bBitRatePcdToPicc424Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(5);
pub const Iso14443_3bBitRatePcdToPicc848Kbit: Iso14443_3bBitRate = Iso14443_3bBitRate(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3bBitRate(pub core::ffi::c_uchar);
pub const Iso14443_3bFrameOptionNad: Iso14443_3bFrameOption = Iso14443_3bFrameOption(0);
pub const Iso14443_3bFrameOptionCid: Iso14443_3bFrameOption = Iso14443_3bFrameOption(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3bFrameOption(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3bData {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn iso14443_3b_alloc() -> *mut Iso14443_3bData;
}
unsafe extern "C" {
    pub fn iso14443_3b_free(data: *mut Iso14443_3bData);
}
unsafe extern "C" {
    pub fn iso14443_3b_reset(data: *mut Iso14443_3bData);
}
unsafe extern "C" {
    pub fn iso14443_3b_copy(data: *mut Iso14443_3bData, other: *const Iso14443_3bData);
}
unsafe extern "C" {
    pub fn iso14443_3b_verify(data: *mut Iso14443_3bData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_load(
        data: *mut Iso14443_3bData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_save(data: *const Iso14443_3bData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_is_equal(
        data: *const Iso14443_3bData,
        other: *const Iso14443_3bData,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_get_device_name(
        data: *const Iso14443_3bData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn iso14443_3b_get_uid(data: *const Iso14443_3bData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn iso14443_3b_set_uid(data: *mut Iso14443_3bData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_get_base_data(data: *const Iso14443_3bData) -> *mut Iso14443_3bData;
}
unsafe extern "C" {
    pub fn iso14443_3b_supports_iso14443_4(data: *const Iso14443_3bData) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_supports_bit_rate(
        data: *const Iso14443_3bData,
        bit_rate: Iso14443_3bBitRate,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_supports_frame_option(
        data: *const Iso14443_3bData,
        option: Iso14443_3bFrameOption,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_3b_get_application_data(
        data: *const Iso14443_3bData,
        data_size: *mut usize,
    ) -> *const u8;
}
unsafe extern "C" {
    pub fn iso14443_3b_get_frame_size_max(data: *const Iso14443_3bData) -> u16;
}
unsafe extern "C" {
    pub fn iso14443_3b_get_fwt_fc_max(data: *const Iso14443_3bData) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3bPoller {
    _unused: [u8; 0],
}
#[doc = "< An error occured during activation procedure."]
pub const Iso14443_3bPollerEventTypeError: Iso14443_3bPollerEventType =
    Iso14443_3bPollerEventType(0);
#[doc = "< The card was activated by the poller."]
pub const Iso14443_3bPollerEventTypeReady: Iso14443_3bPollerEventType =
    Iso14443_3bPollerEventType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible Iso14443_3b poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_3bPollerEventType(pub core::ffi::c_uchar);
#[doc = "Iso14443_3b poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union Iso14443_3bPollerEventData {
    #[doc = "< Error code indicating card activation fail reason."]
    pub error: Iso14443_3bError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3bPollerEventData"]
        [::core::mem::size_of::<Iso14443_3bPollerEventData>() - 1usize];
    ["Alignment of Iso14443_3bPollerEventData"]
        [::core::mem::align_of::<Iso14443_3bPollerEventData>() - 1usize];
    ["Offset of field: Iso14443_3bPollerEventData::error"]
        [::core::mem::offset_of!(Iso14443_3bPollerEventData, error) - 0usize];
};
#[doc = "Iso14443_3b poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3bPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: Iso14443_3bPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut Iso14443_3bPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_3bPollerEvent"][::core::mem::size_of::<Iso14443_3bPollerEvent>() - 8usize];
    ["Alignment of Iso14443_3bPollerEvent"]
        [::core::mem::align_of::<Iso14443_3bPollerEvent>() - 4usize];
    ["Offset of field: Iso14443_3bPollerEvent::type_"]
        [::core::mem::offset_of!(Iso14443_3bPollerEvent, type_) - 0usize];
    ["Offset of field: Iso14443_3bPollerEvent::data"]
        [::core::mem::offset_of!(Iso14443_3bPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3b frames in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nIso14443_3bErrorNone on success, an error code on failure."]
    pub fn iso14443_3b_poller_send_frame(
        instance: *mut Iso14443_3bPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> Iso14443_3bError;
}
unsafe extern "C" {
    #[doc = "Perform collision resolution procedure.\n\n Must ONLY be used inside the callback function.\n\n Perfoms the collision resolution procedure as defined in Iso14443-3b. The data\n field will be filled with Iso14443-3b data on success.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the Iso14443_3b data structure to be filled.\n # Returns\n\nIso14443_3bErrorNone on success, an error code on failure."]
    pub fn iso14443_3b_poller_activate(
        instance: *mut Iso14443_3bPoller,
        data: *mut Iso14443_3bData,
    ) -> Iso14443_3bError;
}
unsafe extern "C" {
    #[doc = "Send HALT command to the card.\n\n Must ONLY be used inside the callback function.\n\n Halts card and changes internal Iso14443_3bPoller state to Idle.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n # Returns\n\nIso14443_3bErrorNone on success, an error code on failure."]
    pub fn iso14443_3b_poller_halt(instance: *mut Iso14443_3bPoller) -> Iso14443_3bError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SimpleArray {
    _unused: [u8; 0],
}
pub type SimpleArrayData = core::ffi::c_void;
pub type SimpleArrayElement = core::ffi::c_void;
pub type SimpleArrayInit =
    ::core::option::Option<unsafe extern "C" fn(elem: *mut SimpleArrayElement)>;
pub type SimpleArrayReset =
    ::core::option::Option<unsafe extern "C" fn(elem: *mut SimpleArrayElement)>;
pub type SimpleArrayCopy = ::core::option::Option<
    unsafe extern "C" fn(elem: *mut SimpleArrayElement, other: *const SimpleArrayElement),
>;
#[doc = "Simple Array configuration structure. Defined per type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SimpleArrayConfig {
    #[doc = "< Initialisation (in-place constructor) method."]
    pub init: SimpleArrayInit,
    #[doc = "< Reset (custom destructor) method."]
    pub reset: SimpleArrayReset,
    #[doc = "< Copy (custom copy-constructor) method."]
    pub copy: SimpleArrayCopy,
    pub type_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SimpleArrayConfig"][::core::mem::size_of::<SimpleArrayConfig>() - 16usize];
    ["Alignment of SimpleArrayConfig"][::core::mem::align_of::<SimpleArrayConfig>() - 4usize];
    ["Offset of field: SimpleArrayConfig::init"]
        [::core::mem::offset_of!(SimpleArrayConfig, init) - 0usize];
    ["Offset of field: SimpleArrayConfig::reset"]
        [::core::mem::offset_of!(SimpleArrayConfig, reset) - 4usize];
    ["Offset of field: SimpleArrayConfig::copy"]
        [::core::mem::offset_of!(SimpleArrayConfig, copy) - 8usize];
    ["Offset of field: SimpleArrayConfig::type_size"]
        [::core::mem::offset_of!(SimpleArrayConfig, type_size) - 12usize];
};
unsafe extern "C" {
    #[doc = "Allocate a SimpleArray instance with the given configuration.\n\n # Arguments\n\n* `[in]` - config Pointer to the type-specific configuration\n # Returns\n\nPointer to the allocated SimpleArray instance"]
    pub fn simple_array_alloc(config: *const SimpleArrayConfig) -> *mut SimpleArray;
}
unsafe extern "C" {
    #[doc = "Free a SimpleArray instance and release its contents.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be freed"]
    pub fn simple_array_free(instance: *mut SimpleArray);
}
unsafe extern "C" {
    #[doc = "Initialise a SimpleArray instance by allocating additional space to contain\n the requested number of elements.\n If init() is specified in the config, then it is called for each element,\n otherwise the data is filled with zeroes.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be init'd\n * `[in]` - count Number of elements to be allocated and init'd"]
    pub fn simple_array_init(instance: *mut SimpleArray, count: u32);
}
unsafe extern "C" {
    #[doc = "Reset a SimpleArray instance and delete all of its elements.\n If reset() is specified in the config, then it is called for each element,\n otherwise the data is simply free()'d.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be reset"]
    pub fn simple_array_reset(instance: *mut SimpleArray);
}
unsafe extern "C" {
    #[doc = "Copy (duplicate) another SimpleArray instance to this one.\n If copy() is specified in the config, then it is called for each element,\n otherwise the data is simply memcpy()'d.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to copy to\n * `[in]` - other Pointer to the SimpleArray instance to copy from"]
    pub fn simple_array_copy(instance: *mut SimpleArray, other: *const SimpleArray);
}
unsafe extern "C" {
    #[doc = "Check if another SimpleArray instance is equal (the same object or holds the\n same data) to this one.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be compared\n * `[in]` - other Pointer to the SimpleArray instance to be compared\n # Returns\n\nTrue if instances are considered equal, false otherwise"]
    pub fn simple_array_is_equal(instance: *const SimpleArray, other: *const SimpleArray) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the count of elements currently contained in a SimpleArray instance.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to query the count from\n # Returns\n\nCount of elements contained in the instance"]
    pub fn simple_array_get_count(instance: *const SimpleArray) -> u32;
}
unsafe extern "C" {
    #[doc = "Get a pointer to an element contained in a SimpleArray instance.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get an element from\n * `[in]` - index Index of the element in question. MUST be less than total element count\n # Returns\n\nPointer to the element specified by index"]
    pub fn simple_array_get(instance: *mut SimpleArray, index: u32) -> *mut SimpleArrayElement;
}
unsafe extern "C" {
    #[doc = "Get a const pointer to an element contained in a SimpleArray instance.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get an element from\n * `[in]` - index Index of the element in question. MUST be less than total element count\n # Returns\n\nConst pointer to the element specified by index"]
    pub fn simple_array_cget(instance: *const SimpleArray, index: u32)
    -> *const SimpleArrayElement;
}
unsafe extern "C" {
    #[doc = "Get a pointer to the internal data of a SimpleArray instance.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get the data of\n # Returns\n\nPointer to the instance's internal data"]
    pub fn simple_array_get_data(instance: *mut SimpleArray) -> *mut SimpleArrayData;
}
unsafe extern "C" {
    #[doc = "Get a constant pointer to the internal data of a SimpleArray instance.\n\n # Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get the data of\n # Returns\n\nConstant pointer to the instance's internal data"]
    pub fn simple_array_cget_data(instance: *const SimpleArray) -> *const SimpleArrayData;
}
unsafe extern "C" {
    pub static simple_array_config_uint8_t: SimpleArrayConfig;
}
pub const Iso14443_4aErrorNone: Iso14443_4aError = Iso14443_4aError(0);
pub const Iso14443_4aErrorNotPresent: Iso14443_4aError = Iso14443_4aError(1);
pub const Iso14443_4aErrorProtocol: Iso14443_4aError = Iso14443_4aError(2);
pub const Iso14443_4aErrorTimeout: Iso14443_4aError = Iso14443_4aError(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4aError(pub core::ffi::c_uchar);
pub const Iso14443_4aBitRateBoth106Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(0);
pub const Iso14443_4aBitRatePiccToPcd212Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(1);
pub const Iso14443_4aBitRatePiccToPcd424Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(2);
pub const Iso14443_4aBitRatePiccToPcd848Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(3);
pub const Iso14443_4aBitRatePcdToPicc212Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(4);
pub const Iso14443_4aBitRatePcdToPicc424Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(5);
pub const Iso14443_4aBitRatePcdToPicc848Kbit: Iso14443_4aBitRate = Iso14443_4aBitRate(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4aBitRate(pub core::ffi::c_uchar);
pub const Iso14443_4aFrameOptionNad: Iso14443_4aFrameOption = Iso14443_4aFrameOption(0);
pub const Iso14443_4aFrameOptionCid: Iso14443_4aFrameOption = Iso14443_4aFrameOption(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4aFrameOption(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aAtsData {
    pub tl: u8,
    pub t0: u8,
    pub ta_1: u8,
    pub tb_1: u8,
    pub tc_1: u8,
    pub t1_tk: *mut SimpleArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4aAtsData"][::core::mem::size_of::<Iso14443_4aAtsData>() - 12usize];
    ["Alignment of Iso14443_4aAtsData"][::core::mem::align_of::<Iso14443_4aAtsData>() - 4usize];
    ["Offset of field: Iso14443_4aAtsData::tl"]
        [::core::mem::offset_of!(Iso14443_4aAtsData, tl) - 0usize];
    ["Offset of field: Iso14443_4aAtsData::t0"]
        [::core::mem::offset_of!(Iso14443_4aAtsData, t0) - 1usize];
    ["Offset of field: Iso14443_4aAtsData::ta_1"]
        [::core::mem::offset_of!(Iso14443_4aAtsData, ta_1) - 2usize];
    ["Offset of field: Iso14443_4aAtsData::tb_1"]
        [::core::mem::offset_of!(Iso14443_4aAtsData, tb_1) - 3usize];
    ["Offset of field: Iso14443_4aAtsData::tc_1"]
        [::core::mem::offset_of!(Iso14443_4aAtsData, tc_1) - 4usize];
    ["Offset of field: Iso14443_4aAtsData::t1_tk"]
        [::core::mem::offset_of!(Iso14443_4aAtsData, t1_tk) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aData {
    pub iso14443_3a_data: *mut Iso14443_3aData,
    pub ats_data: Iso14443_4aAtsData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4aData"][::core::mem::size_of::<Iso14443_4aData>() - 16usize];
    ["Alignment of Iso14443_4aData"][::core::mem::align_of::<Iso14443_4aData>() - 4usize];
    ["Offset of field: Iso14443_4aData::iso14443_3a_data"]
        [::core::mem::offset_of!(Iso14443_4aData, iso14443_3a_data) - 0usize];
    ["Offset of field: Iso14443_4aData::ats_data"]
        [::core::mem::offset_of!(Iso14443_4aData, ats_data) - 4usize];
};
unsafe extern "C" {
    pub fn iso14443_4a_alloc() -> *mut Iso14443_4aData;
}
unsafe extern "C" {
    pub fn iso14443_4a_free(data: *mut Iso14443_4aData);
}
unsafe extern "C" {
    pub fn iso14443_4a_reset(data: *mut Iso14443_4aData);
}
unsafe extern "C" {
    pub fn iso14443_4a_copy(data: *mut Iso14443_4aData, other: *const Iso14443_4aData);
}
unsafe extern "C" {
    pub fn iso14443_4a_verify(data: *mut Iso14443_4aData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4a_load(
        data: *mut Iso14443_4aData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4a_save(data: *const Iso14443_4aData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4a_is_equal(
        data: *const Iso14443_4aData,
        other: *const Iso14443_4aData,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4a_get_device_name(
        data: *const Iso14443_4aData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn iso14443_4a_get_uid(data: *const Iso14443_4aData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn iso14443_4a_set_uid(data: *mut Iso14443_4aData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4a_get_base_data(data: *const Iso14443_4aData) -> *mut Iso14443_3aData;
}
unsafe extern "C" {
    pub fn iso14443_4a_get_frame_size_max(data: *const Iso14443_4aData) -> u16;
}
unsafe extern "C" {
    pub fn iso14443_4a_get_fwt_fc_max(data: *const Iso14443_4aData) -> u32;
}
unsafe extern "C" {
    pub fn iso14443_4a_get_historical_bytes(
        data: *const Iso14443_4aData,
        count: *mut u32,
    ) -> *const u8;
}
unsafe extern "C" {
    pub fn iso14443_4a_supports_bit_rate(
        data: *const Iso14443_4aData,
        bit_rate: Iso14443_4aBitRate,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4a_supports_frame_option(
        data: *const Iso14443_4aData,
        option: Iso14443_4aFrameOption,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aListener {
    _unused: [u8; 0],
}
pub const Iso14443_4aListenerEventTypeHalted: Iso14443_4aListenerEventType =
    Iso14443_4aListenerEventType(0);
pub const Iso14443_4aListenerEventTypeFieldOff: Iso14443_4aListenerEventType =
    Iso14443_4aListenerEventType(1);
pub const Iso14443_4aListenerEventTypeReceivedData: Iso14443_4aListenerEventType =
    Iso14443_4aListenerEventType(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4aListenerEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aListenerEventData {
    pub buffer: *mut BitBuffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4aListenerEventData"]
        [::core::mem::size_of::<Iso14443_4aListenerEventData>() - 4usize];
    ["Alignment of Iso14443_4aListenerEventData"]
        [::core::mem::align_of::<Iso14443_4aListenerEventData>() - 4usize];
    ["Offset of field: Iso14443_4aListenerEventData::buffer"]
        [::core::mem::offset_of!(Iso14443_4aListenerEventData, buffer) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aListenerEvent {
    pub type_: Iso14443_4aListenerEventType,
    pub data: *mut Iso14443_4aListenerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4aListenerEvent"]
        [::core::mem::size_of::<Iso14443_4aListenerEvent>() - 8usize];
    ["Alignment of Iso14443_4aListenerEvent"]
        [::core::mem::align_of::<Iso14443_4aListenerEvent>() - 4usize];
    ["Offset of field: Iso14443_4aListenerEvent::type_"]
        [::core::mem::offset_of!(Iso14443_4aListenerEvent, type_) - 0usize];
    ["Offset of field: Iso14443_4aListenerEvent::data"]
        [::core::mem::offset_of!(Iso14443_4aListenerEvent, data) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aPoller {
    _unused: [u8; 0],
}
#[doc = "< An error occured during activation procedure."]
pub const Iso14443_4aPollerEventTypeError: Iso14443_4aPollerEventType =
    Iso14443_4aPollerEventType(0);
#[doc = "< The card was activated by the poller."]
pub const Iso14443_4aPollerEventTypeReady: Iso14443_4aPollerEventType =
    Iso14443_4aPollerEventType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible Iso14443_4a poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4aPollerEventType(pub core::ffi::c_uchar);
#[doc = "Iso14443_4a poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union Iso14443_4aPollerEventData {
    #[doc = "< Error code indicating card activation fail reason."]
    pub error: Iso14443_4aError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4aPollerEventData"]
        [::core::mem::size_of::<Iso14443_4aPollerEventData>() - 1usize];
    ["Alignment of Iso14443_4aPollerEventData"]
        [::core::mem::align_of::<Iso14443_4aPollerEventData>() - 1usize];
    ["Offset of field: Iso14443_4aPollerEventData::error"]
        [::core::mem::offset_of!(Iso14443_4aPollerEventData, error) - 0usize];
};
#[doc = "Iso14443_4a poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: Iso14443_4aPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut Iso14443_4aPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4aPollerEvent"][::core::mem::size_of::<Iso14443_4aPollerEvent>() - 8usize];
    ["Alignment of Iso14443_4aPollerEvent"]
        [::core::mem::align_of::<Iso14443_4aPollerEvent>() - 4usize];
    ["Offset of field: Iso14443_4aPollerEvent::type_"]
        [::core::mem::offset_of!(Iso14443_4aPollerEvent, type_) - 0usize];
    ["Offset of field: Iso14443_4aPollerEvent::data"]
        [::core::mem::offset_of!(Iso14443_4aPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_4a blocks in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer. The fwt parameter is calculated during activation procedure.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n # Returns\n\nIso14443_4aErrorNone on success, an error code on failure."]
    pub fn iso14443_4a_poller_send_block(
        instance: *mut Iso14443_4aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> Iso14443_4aError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_4a chained block in poller mode. Also it\n automatically modifies PCB packet byte with appropriate bits then resets them back\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer. The fwt parameter is calculated during activation procedure.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n # Returns\n\nIso14443_4aErrorNone on success, an error code on failure."]
    pub fn iso14443_4a_poller_send_chain_block(
        instance: *mut Iso14443_4aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> Iso14443_4aError;
}
unsafe extern "C" {
    #[doc = "Transmit Iso14443_4a R-block in poller mode. This block never contains\n data, but can contain CID and NAD, therefore in tx_buffer only two bytes can be added.\n The first one will represent CID, the second one will represent NAD.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with R-block repsonse\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `acknowledged` (direction in) - Sets appropriate bit in PCB byte. True - ACK, false - NAK\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n # Returns\n\nIso14443_4aErrorNone on success, an error code on failure."]
    pub fn iso14443_4a_poller_send_receive_ready_block(
        instance: *mut Iso14443_4aPoller,
        acknowledged: bool,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> Iso14443_4aError;
}
unsafe extern "C" {
    #[doc = "Transmit Iso14443_4a S-block in poller mode. S-block used to exchange control\n information between the card and the reader. Two different types of S-blocks\n are defined:\n - Waiting time extension containing a 1 byte long INF field and (deselect = false)\n - DESELECT containing no INF field (deselect = true)\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with R-block repsonse\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `deselect` (direction in) - Sets appropriate bit in PCB byte.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n # Returns\n\nIso14443_4aErrorNone on success, an error code on failure."]
    pub fn iso14443_4a_poller_send_supervisory_block(
        instance: *mut Iso14443_4aPoller,
        deselect: bool,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> Iso14443_4aError;
}
unsafe extern "C" {
    #[doc = "Send HALT command to the card.\n\n Must ONLY be used inside the callback function.\n\n Halts card and changes internal Iso14443_4aPoller state to Idle.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n # Returns\n\nIso14443_4aErrorNone on success, an error code on failure."]
    pub fn iso14443_4a_poller_halt(instance: *mut Iso14443_4aPoller) -> Iso14443_4aError;
}
unsafe extern "C" {
    #[doc = "Read Answer To Select (ATS) from the card.\n\n Must ONLY be used inside the callback function.\n\n Send Request Answer To Select (RATS) command to the card and parse the response.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the buffer to be filled with ATS data.\n # Returns\n\nIso14443_4aErrorNone on success, an error code on failure."]
    pub fn iso14443_4a_poller_read_ats(
        instance: *mut Iso14443_4aPoller,
        data: *mut Iso14443_4aAtsData,
    ) -> Iso14443_4aError;
}
pub const Iso14443_4bErrorNone: Iso14443_4bError = Iso14443_4bError(0);
pub const Iso14443_4bErrorNotPresent: Iso14443_4bError = Iso14443_4bError(1);
pub const Iso14443_4bErrorProtocol: Iso14443_4bError = Iso14443_4bError(2);
pub const Iso14443_4bErrorTimeout: Iso14443_4bError = Iso14443_4bError(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4bError(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4bData {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn iso14443_4b_alloc() -> *mut Iso14443_4bData;
}
unsafe extern "C" {
    pub fn iso14443_4b_free(data: *mut Iso14443_4bData);
}
unsafe extern "C" {
    pub fn iso14443_4b_reset(data: *mut Iso14443_4bData);
}
unsafe extern "C" {
    pub fn iso14443_4b_copy(data: *mut Iso14443_4bData, other: *const Iso14443_4bData);
}
unsafe extern "C" {
    pub fn iso14443_4b_verify(data: *mut Iso14443_4bData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4b_load(
        data: *mut Iso14443_4bData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4b_save(data: *const Iso14443_4bData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4b_is_equal(
        data: *const Iso14443_4bData,
        other: *const Iso14443_4bData,
    ) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4b_get_device_name(
        data: *const Iso14443_4bData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn iso14443_4b_get_uid(data: *const Iso14443_4bData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn iso14443_4b_set_uid(data: *mut Iso14443_4bData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn iso14443_4b_get_base_data(data: *const Iso14443_4bData) -> *mut Iso14443_3bData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4bPoller {
    _unused: [u8; 0],
}
#[doc = "< An error occured during activation procedure."]
pub const Iso14443_4bPollerEventTypeError: Iso14443_4bPollerEventType =
    Iso14443_4bPollerEventType(0);
#[doc = "< The card was activated by the poller."]
pub const Iso14443_4bPollerEventTypeReady: Iso14443_4bPollerEventType =
    Iso14443_4bPollerEventType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible Iso14443_4b poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso14443_4bPollerEventType(pub core::ffi::c_uchar);
#[doc = "Iso14443_4b poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union Iso14443_4bPollerEventData {
    #[doc = "< Error code indicating card activation fail reason."]
    pub error: Iso14443_4bError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4bPollerEventData"]
        [::core::mem::size_of::<Iso14443_4bPollerEventData>() - 1usize];
    ["Alignment of Iso14443_4bPollerEventData"]
        [::core::mem::align_of::<Iso14443_4bPollerEventData>() - 1usize];
    ["Offset of field: Iso14443_4bPollerEventData::error"]
        [::core::mem::offset_of!(Iso14443_4bPollerEventData, error) - 0usize];
};
#[doc = "Iso14443_4b poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4bPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: Iso14443_4bPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut Iso14443_4bPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso14443_4bPollerEvent"][::core::mem::size_of::<Iso14443_4bPollerEvent>() - 8usize];
    ["Alignment of Iso14443_4bPollerEvent"]
        [::core::mem::align_of::<Iso14443_4bPollerEvent>() - 4usize];
    ["Offset of field: Iso14443_4bPollerEvent::type_"]
        [::core::mem::offset_of!(Iso14443_4bPollerEvent, type_) - 0usize];
    ["Offset of field: Iso14443_4bPollerEvent::data"]
        [::core::mem::offset_of!(Iso14443_4bPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_4b blocks in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer. The fwt parameter is calculated during activation procedure.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n # Returns\n\nIso14443_4bErrorNone on success, an error code on failure."]
    pub fn iso14443_4b_poller_send_block(
        instance: *mut Iso14443_4bPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> Iso14443_4bError;
}
unsafe extern "C" {
    #[doc = "Send HALT command to the card.\n\n Must ONLY be used inside the callback function.\n\n Halts card and changes internal Iso14443_4aPoller state to Idle.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n # Returns\n\nIso14443_4bErrorNone on success, an error code on failure."]
    pub fn iso14443_4b_poller_halt(instance: *mut Iso14443_4bPoller) -> Iso14443_4bError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicListener {
    _unused: [u8; 0],
}
pub const MfClassicListenerEventTypeAuthContextPartCollected: MfClassicListenerEventType =
    MfClassicListenerEventType(0);
pub const MfClassicListenerEventTypeAuthContextFullCollected: MfClassicListenerEventType =
    MfClassicListenerEventType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicListenerEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfClassicListenerEventData {
    pub auth_context: MfClassicAuthContext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicListenerEventData"]
        [::core::mem::size_of::<MfClassicListenerEventData>() - 24usize];
    ["Alignment of MfClassicListenerEventData"]
        [::core::mem::align_of::<MfClassicListenerEventData>() - 1usize];
    ["Offset of field: MfClassicListenerEventData::auth_context"]
        [::core::mem::offset_of!(MfClassicListenerEventData, auth_context) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicListenerEvent {
    pub type_: MfClassicListenerEventType,
    pub data: *mut MfClassicListenerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicListenerEvent"][::core::mem::size_of::<MfClassicListenerEvent>() - 8usize];
    ["Alignment of MfClassicListenerEvent"]
        [::core::mem::align_of::<MfClassicListenerEvent>() - 4usize];
    ["Offset of field: MfClassicListenerEvent::type_"]
        [::core::mem::offset_of!(MfClassicListenerEvent, type_) - 0usize];
    ["Offset of field: MfClassicListenerEvent::data"]
        [::core::mem::offset_of!(MfClassicListenerEvent, data) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPoller {
    _unused: [u8; 0],
}
#[doc = "< Poller requests to fill the mode."]
pub const MfClassicPollerEventTypeRequestMode: MfClassicPollerEventType =
    MfClassicPollerEventType(0);
#[doc = "< Poller requests data to read sector."]
pub const MfClassicPollerEventTypeRequestReadSector: MfClassicPollerEventType =
    MfClassicPollerEventType(1);
#[doc = "< Poller requests sector trailer for writing block."]
pub const MfClassicPollerEventTypeRequestSectorTrailer: MfClassicPollerEventType =
    MfClassicPollerEventType(2);
#[doc = "< Poller requests data to write block."]
pub const MfClassicPollerEventTypeRequestWriteBlock: MfClassicPollerEventType =
    MfClassicPollerEventType(3);
#[doc = "< Poller requests key for sector authentication."]
pub const MfClassicPollerEventTypeRequestKey: MfClassicPollerEventType =
    MfClassicPollerEventType(4);
#[doc = "< Poller switches to next sector during dictionary attack."]
pub const MfClassicPollerEventTypeNextSector: MfClassicPollerEventType =
    MfClassicPollerEventType(5);
#[doc = "< Poller updates data."]
pub const MfClassicPollerEventTypeDataUpdate: MfClassicPollerEventType =
    MfClassicPollerEventType(6);
#[doc = "< Poller found key A."]
pub const MfClassicPollerEventTypeFoundKeyA: MfClassicPollerEventType = MfClassicPollerEventType(7);
#[doc = "< Poller found key B."]
pub const MfClassicPollerEventTypeFoundKeyB: MfClassicPollerEventType = MfClassicPollerEventType(8);
#[doc = "< Poller starts key attack."]
pub const MfClassicPollerEventTypeKeyAttackStart: MfClassicPollerEventType =
    MfClassicPollerEventType(9);
#[doc = "< Poller stops key attack."]
pub const MfClassicPollerEventTypeKeyAttackStop: MfClassicPollerEventType =
    MfClassicPollerEventType(10);
#[doc = "< Poller switches to next sector during key attack."]
pub const MfClassicPollerEventTypeKeyAttackNextSector: MfClassicPollerEventType =
    MfClassicPollerEventType(11);
#[doc = "< Poller detected card."]
pub const MfClassicPollerEventTypeCardDetected: MfClassicPollerEventType =
    MfClassicPollerEventType(12);
#[doc = "< Poller lost card."]
pub const MfClassicPollerEventTypeCardLost: MfClassicPollerEventType = MfClassicPollerEventType(13);
#[doc = "< Poller succeeded."]
pub const MfClassicPollerEventTypeSuccess: MfClassicPollerEventType = MfClassicPollerEventType(14);
#[doc = "< Poller failed."]
pub const MfClassicPollerEventTypeFail: MfClassicPollerEventType = MfClassicPollerEventType(15);
#[repr(transparent)]
#[doc = "Enumeration of possible MfClassic poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicPollerEventType(pub core::ffi::c_uchar);
#[doc = "< Poller reading mode."]
pub const MfClassicPollerModeRead: MfClassicPollerMode = MfClassicPollerMode(0);
#[doc = "< Poller writing mode."]
pub const MfClassicPollerModeWrite: MfClassicPollerMode = MfClassicPollerMode(1);
#[doc = "< Poller dictionary attack mode."]
pub const MfClassicPollerModeDictAttackStandard: MfClassicPollerMode = MfClassicPollerMode(2);
#[doc = "< Poller enhanced dictionary attack mode."]
pub const MfClassicPollerModeDictAttackEnhanced: MfClassicPollerMode = MfClassicPollerMode(3);
#[repr(transparent)]
#[doc = "MfClassic poller mode."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicPollerMode(pub core::ffi::c_uchar);
#[doc = "< No nested attack has taken place yet."]
pub const MfClassicNestedPhaseNone: MfClassicNestedPhase = MfClassicNestedPhase(0);
#[doc = "< Analyze nonces produced by the PRNG to determine if they fit a weak PRNG"]
pub const MfClassicNestedPhaseAnalyzePRNG: MfClassicNestedPhase = MfClassicNestedPhase(1);
#[doc = "< Search keys which match the expected PRNG properties and parity for collected nonces"]
pub const MfClassicNestedPhaseDictAttack: MfClassicNestedPhase = MfClassicNestedPhase(2);
#[doc = "< Verify candidate keys by authenticating to the sector with the key"]
pub const MfClassicNestedPhaseDictAttackVerify: MfClassicNestedPhase = MfClassicNestedPhase(3);
#[doc = "< Resume nested dictionary attack from the last tested (invalid) key"]
pub const MfClassicNestedPhaseDictAttackResume: MfClassicNestedPhase = MfClassicNestedPhase(4);
#[doc = "< Perform necessary calculations to recover the plaintext nonce during later collection phase (weak PRNG tags only)"]
pub const MfClassicNestedPhaseCalibrate: MfClassicNestedPhase = MfClassicNestedPhase(5);
#[doc = "< Collect the next plaintext static encrypted nonce for backdoor static encrypted nonce nested attack"]
pub const MfClassicNestedPhaseRecalibrate: MfClassicNestedPhase = MfClassicNestedPhase(6);
#[doc = "< Log nonces collected during nested authentication for key recovery"]
pub const MfClassicNestedPhaseCollectNtEnc: MfClassicNestedPhase = MfClassicNestedPhase(7);
#[doc = "< Nested attack has finished"]
pub const MfClassicNestedPhaseFinished: MfClassicNestedPhase = MfClassicNestedPhase(8);
#[repr(transparent)]
#[doc = "MfClassic poller nested attack phase."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicNestedPhase(pub core::ffi::c_uchar);
pub const MfClassicPrngTypeUnknown: MfClassicPrngType = MfClassicPrngType(0);
pub const MfClassicPrngTypeNoTag: MfClassicPrngType = MfClassicPrngType(1);
pub const MfClassicPrngTypeWeak: MfClassicPrngType = MfClassicPrngType(2);
pub const MfClassicPrngTypeHard: MfClassicPrngType = MfClassicPrngType(3);
#[repr(transparent)]
#[doc = "MfClassic pseudorandom number generator (PRNG) type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicPrngType(pub core::ffi::c_uchar);
pub const MfClassicBackdoorUnknown: MfClassicBackdoor = MfClassicBackdoor(0);
pub const MfClassicBackdoorNone: MfClassicBackdoor = MfClassicBackdoor(1);
pub const MfClassicBackdoorAuth1: MfClassicBackdoor = MfClassicBackdoor(2);
pub const MfClassicBackdoorAuth2: MfClassicBackdoor = MfClassicBackdoor(3);
pub const MfClassicBackdoorAuth3: MfClassicBackdoor = MfClassicBackdoor(4);
#[repr(transparent)]
#[doc = "MfClassic authentication backdoor type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfClassicBackdoor(pub core::ffi::c_uchar);
#[doc = "MfClassic poller request mode event data.\n\n This instance of this structure must be filled on MfClassicPollerEventTypeRequestMode event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataRequestMode {
    #[doc = "< Mode to be used by poller."]
    pub mode: MfClassicPollerMode,
    #[doc = "< Data to be used by poller."]
    pub data: *const MfClassicData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataRequestMode"]
        [::core::mem::size_of::<MfClassicPollerEventDataRequestMode>() - 8usize];
    ["Alignment of MfClassicPollerEventDataRequestMode"]
        [::core::mem::align_of::<MfClassicPollerEventDataRequestMode>() - 4usize];
    ["Offset of field: MfClassicPollerEventDataRequestMode::mode"]
        [::core::mem::offset_of!(MfClassicPollerEventDataRequestMode, mode) - 0usize];
    ["Offset of field: MfClassicPollerEventDataRequestMode::data"]
        [::core::mem::offset_of!(MfClassicPollerEventDataRequestMode, data) - 4usize];
};
#[doc = "MfClassic poller next sector event data.\n\n The instance of this structure is filled by poller and passed with\n MfClassicPollerEventTypeNextSector event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataDictAttackNextSector {
    #[doc = "< Current sector number."]
    pub current_sector: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataDictAttackNextSector"]
        [::core::mem::size_of::<MfClassicPollerEventDataDictAttackNextSector>() - 1usize];
    ["Alignment of MfClassicPollerEventDataDictAttackNextSector"]
        [::core::mem::align_of::<MfClassicPollerEventDataDictAttackNextSector>() - 1usize];
    ["Offset of field: MfClassicPollerEventDataDictAttackNextSector::current_sector"][::core::mem::offset_of!(
        MfClassicPollerEventDataDictAttackNextSector,
        current_sector
    ) - 0usize];
};
#[doc = "MfClassic poller update event data.\n\n The instance of this structure is filled by poller and passed with\n MfClassicPollerEventTypeDataUpdate event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataUpdate {
    #[doc = "< Number of sectors read."]
    pub sectors_read: u8,
    #[doc = "< Number of keys found."]
    pub keys_found: u8,
    #[doc = "< Current sector number."]
    pub current_sector: u8,
    #[doc = "< Nested attack phase."]
    pub nested_phase: MfClassicNestedPhase,
    #[doc = "< PRNG (weak or hard)."]
    pub prng_type: MfClassicPrngType,
    #[doc = "< Backdoor type."]
    pub backdoor: MfClassicBackdoor,
    #[doc = "< Target key for nested attack."]
    pub nested_target_key: u16,
    #[doc = "< Number of unique most significant bytes seen during Hardnested attack."]
    pub msb_count: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataUpdate"]
        [::core::mem::size_of::<MfClassicPollerEventDataUpdate>() - 10usize];
    ["Alignment of MfClassicPollerEventDataUpdate"]
        [::core::mem::align_of::<MfClassicPollerEventDataUpdate>() - 2usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::sectors_read"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, sectors_read) - 0usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::keys_found"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, keys_found) - 1usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::current_sector"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, current_sector) - 2usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::nested_phase"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, nested_phase) - 3usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::prng_type"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, prng_type) - 4usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::backdoor"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, backdoor) - 5usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::nested_target_key"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, nested_target_key) - 6usize];
    ["Offset of field: MfClassicPollerEventDataUpdate::msb_count"]
        [::core::mem::offset_of!(MfClassicPollerEventDataUpdate, msb_count) - 8usize];
};
#[doc = "MfClassic poller key request event data.\n\n The instance of this structure must be filled on MfClassicPollerEventTypeRequestKey event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataKeyRequest {
    #[doc = "< Key to be used by poller."]
    pub key: MfClassicKey,
    #[doc = "< Flag indicating if key is provided."]
    pub key_provided: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataKeyRequest"]
        [::core::mem::size_of::<MfClassicPollerEventDataKeyRequest>() - 7usize];
    ["Alignment of MfClassicPollerEventDataKeyRequest"]
        [::core::mem::align_of::<MfClassicPollerEventDataKeyRequest>() - 1usize];
    ["Offset of field: MfClassicPollerEventDataKeyRequest::key"]
        [::core::mem::offset_of!(MfClassicPollerEventDataKeyRequest, key) - 0usize];
    ["Offset of field: MfClassicPollerEventDataKeyRequest::key_provided"]
        [::core::mem::offset_of!(MfClassicPollerEventDataKeyRequest, key_provided) - 6usize];
};
#[doc = "MfClassic poller read sector request event data.\n\n The instance of this structure must be filled on MfClassicPollerEventTypeRequestReadSector event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataReadSectorRequest {
    #[doc = "< Sector number to be read."]
    pub sector_num: u8,
    #[doc = "< Key to be used by poller."]
    pub key: MfClassicKey,
    #[doc = "< Key type to be used by poller."]
    pub key_type: MfClassicKeyType,
    #[doc = "< Flag indicating if key is provided."]
    pub key_provided: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataReadSectorRequest"]
        [::core::mem::size_of::<MfClassicPollerEventDataReadSectorRequest>() - 9usize];
    ["Alignment of MfClassicPollerEventDataReadSectorRequest"]
        [::core::mem::align_of::<MfClassicPollerEventDataReadSectorRequest>() - 1usize];
    ["Offset of field: MfClassicPollerEventDataReadSectorRequest::sector_num"]
        [::core::mem::offset_of!(MfClassicPollerEventDataReadSectorRequest, sector_num) - 0usize];
    ["Offset of field: MfClassicPollerEventDataReadSectorRequest::key"]
        [::core::mem::offset_of!(MfClassicPollerEventDataReadSectorRequest, key) - 1usize];
    ["Offset of field: MfClassicPollerEventDataReadSectorRequest::key_type"]
        [::core::mem::offset_of!(MfClassicPollerEventDataReadSectorRequest, key_type) - 7usize];
    ["Offset of field: MfClassicPollerEventDataReadSectorRequest::key_provided"]
        [::core::mem::offset_of!(MfClassicPollerEventDataReadSectorRequest, key_provided) - 8usize];
};
#[doc = "MfClassic poller sector trailer request event data.\n\n The instance of this structure must be filled on MfClassicPollerEventTypeRequestSectorTrailer event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataSectorTrailerRequest {
    #[doc = "< Sector number to be read."]
    pub sector_num: u8,
    #[doc = "< Sector trailer to be used by poller."]
    pub sector_trailer: MfClassicBlock,
    #[doc = "< Flag indicating if sector trailer is provided."]
    pub sector_trailer_provided: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataSectorTrailerRequest"]
        [::core::mem::size_of::<MfClassicPollerEventDataSectorTrailerRequest>() - 18usize];
    ["Alignment of MfClassicPollerEventDataSectorTrailerRequest"]
        [::core::mem::align_of::<MfClassicPollerEventDataSectorTrailerRequest>() - 1usize];
    ["Offset of field: MfClassicPollerEventDataSectorTrailerRequest::sector_num"][::core::mem::offset_of!(
        MfClassicPollerEventDataSectorTrailerRequest,
        sector_num
    ) - 0usize];
    ["Offset of field: MfClassicPollerEventDataSectorTrailerRequest::sector_trailer"][::core::mem::offset_of!(
        MfClassicPollerEventDataSectorTrailerRequest,
        sector_trailer
    ) - 1usize];
    ["Offset of field: MfClassicPollerEventDataSectorTrailerRequest::sector_trailer_provided"][::core::mem::offset_of!(
        MfClassicPollerEventDataSectorTrailerRequest,
        sector_trailer_provided
    )
        - 17usize];
};
#[doc = "MfClassic poller write block request event data.\n\n The instance of this structure must be filled on MfClassicPollerEventTypeRequestWriteBlock event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventDataWriteBlockRequest {
    #[doc = "< Block number to be written."]
    pub block_num: u8,
    #[doc = "< Block to be written."]
    pub write_block: MfClassicBlock,
    #[doc = "< Flag indicating if block is provided."]
    pub write_block_provided: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventDataWriteBlockRequest"]
        [::core::mem::size_of::<MfClassicPollerEventDataWriteBlockRequest>() - 18usize];
    ["Alignment of MfClassicPollerEventDataWriteBlockRequest"]
        [::core::mem::align_of::<MfClassicPollerEventDataWriteBlockRequest>() - 1usize];
    ["Offset of field: MfClassicPollerEventDataWriteBlockRequest::block_num"]
        [::core::mem::offset_of!(MfClassicPollerEventDataWriteBlockRequest, block_num) - 0usize];
    ["Offset of field: MfClassicPollerEventDataWriteBlockRequest::write_block"]
        [::core::mem::offset_of!(MfClassicPollerEventDataWriteBlockRequest, write_block) - 1usize];
    ["Offset of field: MfClassicPollerEventDataWriteBlockRequest::write_block_provided"][::core::mem::offset_of!(
        MfClassicPollerEventDataWriteBlockRequest,
        write_block_provided
    )
        - 17usize];
};
#[doc = "MfClassic poller key attack event data.\n\n The instance of this structure is filled by poller and passed with\n MfClassicPollerEventTypeKeyAttackNextSector event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEventKeyAttackData {
    #[doc = "< Current sector number."]
    pub current_sector: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventKeyAttackData"]
        [::core::mem::size_of::<MfClassicPollerEventKeyAttackData>() - 1usize];
    ["Alignment of MfClassicPollerEventKeyAttackData"]
        [::core::mem::align_of::<MfClassicPollerEventKeyAttackData>() - 1usize];
    ["Offset of field: MfClassicPollerEventKeyAttackData::current_sector"]
        [::core::mem::offset_of!(MfClassicPollerEventKeyAttackData, current_sector) - 0usize];
};
#[doc = "MfClassic poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfClassicPollerEventData {
    #[doc = "< Error code on MfClassicPollerEventTypeFail event."]
    pub error: MfClassicError,
    #[doc = "< Poller mode context."]
    pub poller_mode: MfClassicPollerEventDataRequestMode,
    #[doc = "< Next sector context."]
    pub next_sector_data: MfClassicPollerEventDataDictAttackNextSector,
    #[doc = "< Key request context."]
    pub key_request_data: MfClassicPollerEventDataKeyRequest,
    #[doc = "< Data update context."]
    pub data_update: MfClassicPollerEventDataUpdate,
    #[doc = "< Read sector request context."]
    pub read_sector_request_data: MfClassicPollerEventDataReadSectorRequest,
    #[doc = "< Key attack context."]
    pub key_attack_data: MfClassicPollerEventKeyAttackData,
    #[doc = "< Sector trailer request context."]
    pub sec_tr_data: MfClassicPollerEventDataSectorTrailerRequest,
    #[doc = "< Write block request context."]
    pub write_block_data: MfClassicPollerEventDataWriteBlockRequest,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEventData"]
        [::core::mem::size_of::<MfClassicPollerEventData>() - 20usize];
    ["Alignment of MfClassicPollerEventData"]
        [::core::mem::align_of::<MfClassicPollerEventData>() - 4usize];
    ["Offset of field: MfClassicPollerEventData::error"]
        [::core::mem::offset_of!(MfClassicPollerEventData, error) - 0usize];
    ["Offset of field: MfClassicPollerEventData::poller_mode"]
        [::core::mem::offset_of!(MfClassicPollerEventData, poller_mode) - 0usize];
    ["Offset of field: MfClassicPollerEventData::next_sector_data"]
        [::core::mem::offset_of!(MfClassicPollerEventData, next_sector_data) - 0usize];
    ["Offset of field: MfClassicPollerEventData::key_request_data"]
        [::core::mem::offset_of!(MfClassicPollerEventData, key_request_data) - 0usize];
    ["Offset of field: MfClassicPollerEventData::data_update"]
        [::core::mem::offset_of!(MfClassicPollerEventData, data_update) - 0usize];
    ["Offset of field: MfClassicPollerEventData::read_sector_request_data"]
        [::core::mem::offset_of!(MfClassicPollerEventData, read_sector_request_data) - 0usize];
    ["Offset of field: MfClassicPollerEventData::key_attack_data"]
        [::core::mem::offset_of!(MfClassicPollerEventData, key_attack_data) - 0usize];
    ["Offset of field: MfClassicPollerEventData::sec_tr_data"]
        [::core::mem::offset_of!(MfClassicPollerEventData, sec_tr_data) - 0usize];
    ["Offset of field: MfClassicPollerEventData::write_block_data"]
        [::core::mem::offset_of!(MfClassicPollerEventData, write_block_data) - 0usize];
};
#[doc = "MfClassic poller event.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicPollerEvent {
    #[doc = "< Event type."]
    pub type_: MfClassicPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut MfClassicPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfClassicPollerEvent"][::core::mem::size_of::<MfClassicPollerEvent>() - 8usize];
    ["Alignment of MfClassicPollerEvent"][::core::mem::align_of::<MfClassicPollerEvent>() - 4usize];
    ["Offset of field: MfClassicPollerEvent::type_"]
        [::core::mem::offset_of!(MfClassicPollerEvent, type_) - 0usize];
    ["Offset of field: MfClassicPollerEvent::data"]
        [::core::mem::offset_of!(MfClassicPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Collect tag nonce during authentication.\n\n Must ONLY be used inside the callback function.\n\n Starts authentication procedure and collects tag nonce.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number for authentication.\n * `key_type` (direction in) - key type to be used for authentication.\n * `nt` (direction out) - pointer to the MfClassicNt structure to be filled with nonce data.\n * `backdoor_auth` (direction in) - flag indicating if backdoor authentication is used.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_get_nt(
        instance: *mut MfClassicPoller,
        block_num: u8,
        key_type: MfClassicKeyType,
        nt: *mut MfClassicNt,
        backdoor_auth: bool,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Collect tag nonce during nested authentication.\n\n Must ONLY be used inside the callback function.\n\n Starts nested authentication procedure and collects tag nonce.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number for authentication.\n * `key_type` (direction in) - key type to be used for authentication.\n * `nt` (direction out) - pointer to the MfClassicNt structure to be filled with nonce data.\n * `backdoor_auth` (direction in) - flag indicating if backdoor authentication is used.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_get_nt_nested(
        instance: *mut MfClassicPoller,
        block_num: u8,
        key_type: MfClassicKeyType,
        nt: *mut MfClassicNt,
        backdoor_auth: bool,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Perform authentication.\n\n Must ONLY be used inside the callback function.\n\n Perform authentication as specified in Mf Classic protocol. Initialize crypto state for futher\n communication with the tag.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number for authentication.\n * `key` (direction in) - key to be used for authentication.\n * `key_type` (direction in) - key type to be used for authentication.\n * `data` (direction out) - pointer to MfClassicAuthContext structure to be filled with authentication data.\n * `backdoor_auth` (direction in) - flag indicating if backdoor authentication is used.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_auth(
        instance: *mut MfClassicPoller,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicAuthContext,
        backdoor_auth: bool,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Perform nested authentication.\n\n Must ONLY be used inside the callback function.\n\n Perform nested authentication as specified in Mf Classic protocol.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number for authentication.\n * `key` (direction in) - key to be used for authentication.\n * `key_type` (direction in) - key type to be used for authentication.\n * `data` (direction out) - pointer to MfClassicAuthContext structure to be filled with authentication data.\n * `backdoor_auth` (direction in) - flag indicating if backdoor authentication is used.\n * `early_ret` (direction in) - return immediately after receiving encrypted nonce.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_auth_nested(
        instance: *mut MfClassicPoller,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicAuthContext,
        backdoor_auth: bool,
        early_ret: bool,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Halt the tag.\n\n Must ONLY be used inside the callback function.\n\n Halt the tag and reset crypto state of the poller.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_halt(instance: *mut MfClassicPoller) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Read block from tag.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number to be read.\n * `data` (direction out) - pointer to the MfClassicBlock structure to be filled with block data.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_read_block(
        instance: *mut MfClassicPoller,
        block_num: u8,
        data: *mut MfClassicBlock,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Write block to tag.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number to be written.\n * `data` (direction in) - pointer to the MfClassicBlock structure to be written.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_write_block(
        instance: *mut MfClassicPoller,
        block_num: u8,
        data: *mut MfClassicBlock,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Perform value command on tag.\n\n Must ONLY be used inside the callback function.\n\n Perform Increment, Decrement or Restore command on tag. The result is stored in internal transfer\n block of the tag. Use mf_classic_poller_value_transfer to transfer the result to the tag.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number to be used for value command.\n * `cmd` (direction in) - value command to be performed.\n * `data` (direction in) - value to be used for value command.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_value_cmd(
        instance: *mut MfClassicPoller,
        block_num: u8,
        cmd: MfClassicValueCommand,
        data: i32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Transfer internal transfer block to tag.\n\n Must ONLY be used inside the callback function.\n\n Transfer internal transfer block to tag. The block is filled by mf_classic_poller_value_cmd.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `block_num` (direction in) - block number to be used for value command.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_value_transfer(
        instance: *mut MfClassicPoller,
        block_num: u8,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3a standard frames in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_send_standard_frame(
        instance: *mut MfClassicPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt_fc: u32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3a frames in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_send_frame(
        instance: *mut MfClassicPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt_fc: u32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Iso14443_3a frames with custom parity bits in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n Custom parity bits must be set in the tx_buffer. The rx_buffer will contain\n the received data with the parity bits.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_send_custom_parity_frame(
        instance: *mut MfClassicPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt_fc: u32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    #[doc = "Transmit and receive Mifare Classic encrypted frames with custom parity bits in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the plain data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with decyphered received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nMfClassicErrorNone on success, an error code on failure."]
    pub fn mf_classic_poller_send_encrypted_frame(
        instance: *mut MfClassicPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt_fc: u32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_collect_nt(
        nfc: *mut Nfc,
        block_num: u8,
        key_type: MfClassicKeyType,
        nt: *mut MfClassicNt,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_auth(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicAuthContext,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_read_block(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicBlock,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_write_block(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicBlock,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_read_value(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        value: *mut i32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_change_value(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: i32,
        new_value: *mut i32,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_detect_type(
        nfc: *mut Nfc,
        type_: *mut MfClassicType,
    ) -> MfClassicError;
}
unsafe extern "C" {
    pub fn mf_classic_poller_sync_read(
        nfc: *mut Nfc,
        keys: *const MfClassicDeviceKeys,
        data: *mut MfClassicData,
    ) -> MfClassicError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireVersion {
    pub hw_vendor: u8,
    pub hw_type: u8,
    pub hw_subtype: u8,
    pub hw_major: u8,
    pub hw_minor: u8,
    pub hw_storage: u8,
    pub hw_proto: u8,
    pub sw_vendor: u8,
    pub sw_type: u8,
    pub sw_subtype: u8,
    pub sw_major: u8,
    pub sw_minor: u8,
    pub sw_storage: u8,
    pub sw_proto: u8,
    pub uid: [u8; 7usize],
    pub batch: [u8; 5usize],
    pub prod_week: u8,
    pub prod_year: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireVersion"][::core::mem::size_of::<MfDesfireVersion>() - 28usize];
    ["Alignment of MfDesfireVersion"][::core::mem::align_of::<MfDesfireVersion>() - 1usize];
    ["Offset of field: MfDesfireVersion::hw_vendor"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_vendor) - 0usize];
    ["Offset of field: MfDesfireVersion::hw_type"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_type) - 1usize];
    ["Offset of field: MfDesfireVersion::hw_subtype"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_subtype) - 2usize];
    ["Offset of field: MfDesfireVersion::hw_major"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_major) - 3usize];
    ["Offset of field: MfDesfireVersion::hw_minor"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_minor) - 4usize];
    ["Offset of field: MfDesfireVersion::hw_storage"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_storage) - 5usize];
    ["Offset of field: MfDesfireVersion::hw_proto"]
        [::core::mem::offset_of!(MfDesfireVersion, hw_proto) - 6usize];
    ["Offset of field: MfDesfireVersion::sw_vendor"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_vendor) - 7usize];
    ["Offset of field: MfDesfireVersion::sw_type"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_type) - 8usize];
    ["Offset of field: MfDesfireVersion::sw_subtype"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_subtype) - 9usize];
    ["Offset of field: MfDesfireVersion::sw_major"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_major) - 10usize];
    ["Offset of field: MfDesfireVersion::sw_minor"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_minor) - 11usize];
    ["Offset of field: MfDesfireVersion::sw_storage"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_storage) - 12usize];
    ["Offset of field: MfDesfireVersion::sw_proto"]
        [::core::mem::offset_of!(MfDesfireVersion, sw_proto) - 13usize];
    ["Offset of field: MfDesfireVersion::uid"]
        [::core::mem::offset_of!(MfDesfireVersion, uid) - 14usize];
    ["Offset of field: MfDesfireVersion::batch"]
        [::core::mem::offset_of!(MfDesfireVersion, batch) - 21usize];
    ["Offset of field: MfDesfireVersion::prod_week"]
        [::core::mem::offset_of!(MfDesfireVersion, prod_week) - 26usize];
    ["Offset of field: MfDesfireVersion::prod_year"]
        [::core::mem::offset_of!(MfDesfireVersion, prod_year) - 27usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFreeMemory {
    pub bytes_free: u32,
    pub is_present: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFreeMemory"][::core::mem::size_of::<MfDesfireFreeMemory>() - 8usize];
    ["Alignment of MfDesfireFreeMemory"][::core::mem::align_of::<MfDesfireFreeMemory>() - 4usize];
    ["Offset of field: MfDesfireFreeMemory::bytes_free"]
        [::core::mem::offset_of!(MfDesfireFreeMemory, bytes_free) - 0usize];
    ["Offset of field: MfDesfireFreeMemory::is_present"]
        [::core::mem::offset_of!(MfDesfireFreeMemory, is_present) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireKeySettings {
    pub is_master_key_changeable: bool,
    pub is_free_directory_list: bool,
    pub is_free_create_delete: bool,
    pub is_config_changeable: bool,
    pub change_key_id: u8,
    pub max_keys: u8,
    pub flags: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireKeySettings"][::core::mem::size_of::<MfDesfireKeySettings>() - 7usize];
    ["Alignment of MfDesfireKeySettings"][::core::mem::align_of::<MfDesfireKeySettings>() - 1usize];
    ["Offset of field: MfDesfireKeySettings::is_master_key_changeable"]
        [::core::mem::offset_of!(MfDesfireKeySettings, is_master_key_changeable) - 0usize];
    ["Offset of field: MfDesfireKeySettings::is_free_directory_list"]
        [::core::mem::offset_of!(MfDesfireKeySettings, is_free_directory_list) - 1usize];
    ["Offset of field: MfDesfireKeySettings::is_free_create_delete"]
        [::core::mem::offset_of!(MfDesfireKeySettings, is_free_create_delete) - 2usize];
    ["Offset of field: MfDesfireKeySettings::is_config_changeable"]
        [::core::mem::offset_of!(MfDesfireKeySettings, is_config_changeable) - 3usize];
    ["Offset of field: MfDesfireKeySettings::change_key_id"]
        [::core::mem::offset_of!(MfDesfireKeySettings, change_key_id) - 4usize];
    ["Offset of field: MfDesfireKeySettings::max_keys"]
        [::core::mem::offset_of!(MfDesfireKeySettings, max_keys) - 5usize];
    ["Offset of field: MfDesfireKeySettings::flags"]
        [::core::mem::offset_of!(MfDesfireKeySettings, flags) - 6usize];
};
pub type MfDesfireKeyVersion = u8;
pub const MfDesfireFileTypeStandard: MfDesfireFileType = MfDesfireFileType(0);
pub const MfDesfireFileTypeBackup: MfDesfireFileType = MfDesfireFileType(1);
pub const MfDesfireFileTypeValue: MfDesfireFileType = MfDesfireFileType(2);
pub const MfDesfireFileTypeLinearRecord: MfDesfireFileType = MfDesfireFileType(3);
pub const MfDesfireFileTypeCyclicRecord: MfDesfireFileType = MfDesfireFileType(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfDesfireFileType(pub core::ffi::c_uchar);
pub const MfDesfireFileCommunicationSettingsPlaintext: MfDesfireFileCommunicationSettings =
    MfDesfireFileCommunicationSettings(0);
pub const MfDesfireFileCommunicationSettingsAuthenticated: MfDesfireFileCommunicationSettings =
    MfDesfireFileCommunicationSettings(1);
pub const MfDesfireFileCommunicationSettingsEnciphered: MfDesfireFileCommunicationSettings =
    MfDesfireFileCommunicationSettings(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfDesfireFileCommunicationSettings(pub core::ffi::c_uchar);
pub type MfDesfireFileId = u8;
pub type MfDesfireFileAccessRights = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MfDesfireFileSettings {
    pub type_: MfDesfireFileType,
    pub comm: MfDesfireFileCommunicationSettings,
    pub access_rights: [MfDesfireFileAccessRights; 14usize],
    pub access_rights_len: u8,
    pub __bindgen_anon_1: MfDesfireFileSettings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfDesfireFileSettings__bindgen_ty_1 {
    pub data: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1,
    pub value: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2,
    pub record: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1 {
    pub size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Alignment of MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1::size"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1, size) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2 {
    pub lo_limit: u32,
    pub hi_limit: u32,
    pub limited_credit_value: u32,
    pub limited_credit_enabled: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2::lo_limit"][::core::mem::offset_of!(
        MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2,
        lo_limit
    ) - 0usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2::hi_limit"][::core::mem::offset_of!(
        MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2,
        hi_limit
    ) - 4usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2::limited_credit_value"][::core::mem::offset_of!(
        MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2,
        limited_credit_value
    )
        - 8usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2::limited_credit_enabled"]
        [::core::mem::offset_of!(
            MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2,
            limited_credit_enabled
        ) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3 {
    pub size: u32,
    pub max: u32,
    pub cur: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3>() - 12usize];
    ["Alignment of MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3>() - 4usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3::size"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3, size) - 0usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3::max"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3, max) - 4usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3::cur"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3, cur) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFileSettings__bindgen_ty_1"]
        [::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1>() - 16usize];
    ["Alignment of MfDesfireFileSettings__bindgen_ty_1"]
        [::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1>() - 4usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1::data"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1, data) - 0usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1::value"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1, value) - 0usize];
    ["Offset of field: MfDesfireFileSettings__bindgen_ty_1::record"]
        [::core::mem::offset_of!(MfDesfireFileSettings__bindgen_ty_1, record) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFileSettings"][::core::mem::size_of::<MfDesfireFileSettings>() - 48usize];
    ["Alignment of MfDesfireFileSettings"]
        [::core::mem::align_of::<MfDesfireFileSettings>() - 4usize];
    ["Offset of field: MfDesfireFileSettings::type_"]
        [::core::mem::offset_of!(MfDesfireFileSettings, type_) - 0usize];
    ["Offset of field: MfDesfireFileSettings::comm"]
        [::core::mem::offset_of!(MfDesfireFileSettings, comm) - 1usize];
    ["Offset of field: MfDesfireFileSettings::access_rights"]
        [::core::mem::offset_of!(MfDesfireFileSettings, access_rights) - 2usize];
    ["Offset of field: MfDesfireFileSettings::access_rights_len"]
        [::core::mem::offset_of!(MfDesfireFileSettings, access_rights_len) - 30usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileData {
    pub data: *mut SimpleArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireFileData"][::core::mem::size_of::<MfDesfireFileData>() - 4usize];
    ["Alignment of MfDesfireFileData"][::core::mem::align_of::<MfDesfireFileData>() - 4usize];
    ["Offset of field: MfDesfireFileData::data"]
        [::core::mem::offset_of!(MfDesfireFileData, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireApplicationId {
    pub data: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireApplicationId"][::core::mem::size_of::<MfDesfireApplicationId>() - 3usize];
    ["Alignment of MfDesfireApplicationId"]
        [::core::mem::align_of::<MfDesfireApplicationId>() - 1usize];
    ["Offset of field: MfDesfireApplicationId::data"]
        [::core::mem::offset_of!(MfDesfireApplicationId, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireApplication {
    pub key_settings: MfDesfireKeySettings,
    pub key_versions: *mut SimpleArray,
    pub file_ids: *mut SimpleArray,
    pub file_settings: *mut SimpleArray,
    pub file_data: *mut SimpleArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireApplication"][::core::mem::size_of::<MfDesfireApplication>() - 24usize];
    ["Alignment of MfDesfireApplication"][::core::mem::align_of::<MfDesfireApplication>() - 4usize];
    ["Offset of field: MfDesfireApplication::key_settings"]
        [::core::mem::offset_of!(MfDesfireApplication, key_settings) - 0usize];
    ["Offset of field: MfDesfireApplication::key_versions"]
        [::core::mem::offset_of!(MfDesfireApplication, key_versions) - 8usize];
    ["Offset of field: MfDesfireApplication::file_ids"]
        [::core::mem::offset_of!(MfDesfireApplication, file_ids) - 12usize];
    ["Offset of field: MfDesfireApplication::file_settings"]
        [::core::mem::offset_of!(MfDesfireApplication, file_settings) - 16usize];
    ["Offset of field: MfDesfireApplication::file_data"]
        [::core::mem::offset_of!(MfDesfireApplication, file_data) - 20usize];
};
pub const MfDesfireErrorNone: MfDesfireError = MfDesfireError(0);
pub const MfDesfireErrorNotPresent: MfDesfireError = MfDesfireError(1);
pub const MfDesfireErrorProtocol: MfDesfireError = MfDesfireError(2);
pub const MfDesfireErrorTimeout: MfDesfireError = MfDesfireError(3);
pub const MfDesfireErrorAuthentication: MfDesfireError = MfDesfireError(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfDesfireError(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireData {
    pub iso14443_4a_data: *mut Iso14443_4aData,
    pub version: MfDesfireVersion,
    pub free_memory: MfDesfireFreeMemory,
    pub master_key_settings: MfDesfireKeySettings,
    pub master_key_versions: *mut SimpleArray,
    pub application_ids: *mut SimpleArray,
    pub applications: *mut SimpleArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfireData"][::core::mem::size_of::<MfDesfireData>() - 60usize];
    ["Alignment of MfDesfireData"][::core::mem::align_of::<MfDesfireData>() - 4usize];
    ["Offset of field: MfDesfireData::iso14443_4a_data"]
        [::core::mem::offset_of!(MfDesfireData, iso14443_4a_data) - 0usize];
    ["Offset of field: MfDesfireData::version"]
        [::core::mem::offset_of!(MfDesfireData, version) - 4usize];
    ["Offset of field: MfDesfireData::free_memory"]
        [::core::mem::offset_of!(MfDesfireData, free_memory) - 32usize];
    ["Offset of field: MfDesfireData::master_key_settings"]
        [::core::mem::offset_of!(MfDesfireData, master_key_settings) - 40usize];
    ["Offset of field: MfDesfireData::master_key_versions"]
        [::core::mem::offset_of!(MfDesfireData, master_key_versions) - 48usize];
    ["Offset of field: MfDesfireData::application_ids"]
        [::core::mem::offset_of!(MfDesfireData, application_ids) - 52usize];
    ["Offset of field: MfDesfireData::applications"]
        [::core::mem::offset_of!(MfDesfireData, applications) - 56usize];
};
unsafe extern "C" {
    pub fn mf_desfire_alloc() -> *mut MfDesfireData;
}
unsafe extern "C" {
    pub fn mf_desfire_free(data: *mut MfDesfireData);
}
unsafe extern "C" {
    pub fn mf_desfire_reset(data: *mut MfDesfireData);
}
unsafe extern "C" {
    pub fn mf_desfire_copy(data: *mut MfDesfireData, other: *const MfDesfireData);
}
unsafe extern "C" {
    pub fn mf_desfire_verify(data: *mut MfDesfireData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn mf_desfire_load(data: *mut MfDesfireData, ff: *mut FlipperFormat, version: u32) -> bool;
}
unsafe extern "C" {
    pub fn mf_desfire_save(data: *const MfDesfireData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn mf_desfire_is_equal(data: *const MfDesfireData, other: *const MfDesfireData) -> bool;
}
unsafe extern "C" {
    pub fn mf_desfire_get_device_name(
        data: *const MfDesfireData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mf_desfire_get_uid(data: *const MfDesfireData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn mf_desfire_set_uid(data: *mut MfDesfireData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn mf_desfire_get_base_data(data: *const MfDesfireData) -> *mut Iso14443_4aData;
}
unsafe extern "C" {
    pub fn mf_desfire_get_application(
        data: *const MfDesfireData,
        app_id: *const MfDesfireApplicationId,
    ) -> *const MfDesfireApplication;
}
unsafe extern "C" {
    pub fn mf_desfire_get_file_settings(
        data: *const MfDesfireApplication,
        file_id: *const MfDesfireFileId,
    ) -> *const MfDesfireFileSettings;
}
unsafe extern "C" {
    pub fn mf_desfire_get_file_data(
        data: *const MfDesfireApplication,
        file_id: *const MfDesfireFileId,
    ) -> *const MfDesfireFileData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfirePoller {
    _unused: [u8; 0],
}
#[doc = "< Card was read successfully."]
pub const MfDesfirePollerEventTypeReadSuccess: MfDesfirePollerEventType =
    MfDesfirePollerEventType(0);
#[doc = "< Poller failed to read card."]
pub const MfDesfirePollerEventTypeReadFailed: MfDesfirePollerEventType =
    MfDesfirePollerEventType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible MfDesfire poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfDesfirePollerEventType(pub core::ffi::c_uchar);
#[doc = "MfDesfire poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfDesfirePollerEventData {
    #[doc = "< Error code indicating card reading fail reason."]
    pub error: MfDesfireError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfirePollerEventData"]
        [::core::mem::size_of::<MfDesfirePollerEventData>() - 1usize];
    ["Alignment of MfDesfirePollerEventData"]
        [::core::mem::align_of::<MfDesfirePollerEventData>() - 1usize];
    ["Offset of field: MfDesfirePollerEventData::error"]
        [::core::mem::offset_of!(MfDesfirePollerEventData, error) - 0usize];
};
#[doc = "MfDesfire poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfirePollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: MfDesfirePollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut MfDesfirePollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfDesfirePollerEvent"][::core::mem::size_of::<MfDesfirePollerEvent>() - 8usize];
    ["Alignment of MfDesfirePollerEvent"][::core::mem::align_of::<MfDesfirePollerEvent>() - 4usize];
    ["Offset of field: MfDesfirePollerEvent::type_"]
        [::core::mem::offset_of!(MfDesfirePollerEvent, type_) - 0usize];
    ["Offset of field: MfDesfirePollerEvent::data"]
        [::core::mem::offset_of!(MfDesfirePollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Transmit and receive MfDesfire chunks in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_send_chunks(
        instance: *mut MfDesfirePoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read MfDesfire card version.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfDesfireVersion structure to be filled with version data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_version(
        instance: *mut MfDesfirePoller,
        data: *mut MfDesfireVersion,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read free memory available on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfDesfireFreeMemory structure to be filled with free memory data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_free_memory(
        instance: *mut MfDesfirePoller,
        data: *mut MfDesfireFreeMemory,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read key settings on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfDesfireKeySettings structure to be filled with key settings data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_key_settings(
        instance: *mut MfDesfirePoller,
        data: *mut MfDesfireKeySettings,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read key version on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `key_num` (direction out) - key number.\n * `data` (direction in) - pointer to the MfDesfireKeyVersion structure to be filled with key version data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_key_version(
        instance: *mut MfDesfirePoller,
        key_num: u8,
        data: *mut MfDesfireKeyVersion,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read key versions on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the SimpleArray structure to be filled with key versions data.\n * `count` (direction in) - number of key versions to read.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_key_versions(
        instance: *mut MfDesfirePoller,
        data: *mut SimpleArray,
        count: u32,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read applications IDs on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the SimpleArray structure to be filled with application ids data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_application_ids(
        instance: *mut MfDesfirePoller,
        data: *mut SimpleArray,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Select application on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `id` (direction in) - pointer to the MfDesfireApplicationId structure with application id to select.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_select_application(
        instance: *mut MfDesfirePoller,
        id: *const MfDesfireApplicationId,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read file IDs for selected application on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the SimpleArray structure to be filled with file ids data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_ids(
        instance: *mut MfDesfirePoller,
        data: *mut SimpleArray,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read file settings on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `id` (direction in) - file id to read settings for.\n * `data` (direction out) - pointer to the MfDesfireFileSettings structure to be filled with file settings data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_settings(
        instance: *mut MfDesfirePoller,
        id: MfDesfireFileId,
        data: *mut MfDesfireFileSettings,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read multiple file settings on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `file_ids` (direction in) - pointer to the SimpleArray structure array with file ids to read settings for.\n * `data` (direction out) - pointer to the SimpleArray structure array to be filled with file settings data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_settings_multi(
        instance: *mut MfDesfirePoller,
        file_ids: *const SimpleArray,
        data: *mut SimpleArray,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read file data on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `id` (direction in) - file id to read data from.\n * `offset` (direction in) - offset in bytes to start reading from.\n * `size` (direction in) - number of bytes to read.\n * `data` (direction out) - pointer to the MfDesfireFileData structure to be filled with file data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_data(
        instance: *mut MfDesfirePoller,
        id: MfDesfireFileId,
        offset: u32,
        size: usize,
        data: *mut MfDesfireFileData,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read file value on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `id` (direction in) - file id to read value from.\n * `data` (direction out) - pointer to the MfDesfireFileData structure to be filled with file value.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_value(
        instance: *mut MfDesfirePoller,
        id: MfDesfireFileId,
        data: *mut MfDesfireFileData,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read file records on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `id` (direction in) - file id to read data from.\n * `offset` (direction in) - offset in bytes to start reading from.\n * `size` (direction in) - number of bytes to read.\n * `data` (direction out) - pointer to the MfDesfireFileData structure to be filled with file records data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_records(
        instance: *mut MfDesfirePoller,
        id: MfDesfireFileId,
        offset: u32,
        size: usize,
        data: *mut MfDesfireFileData,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read data from multiple files on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `file_ids` (direction in) - pointer to the SimpleArray structure array with files ids to read data from.\n * `file_settings` (direction in) - pointer to the SimpleArray structure array with files settings to read data from.\n * `data` (direction out) - pointer to the SimpleArray structure array to be filled with files data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_file_data_multi(
        instance: *mut MfDesfirePoller,
        file_ids: *const SimpleArray,
        file_settings: *const SimpleArray,
        data: *mut SimpleArray,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read application data for selected application on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfDesfireApplication structure to be filled with application data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_application(
        instance: *mut MfDesfirePoller,
        data: *mut MfDesfireApplication,
    ) -> MfDesfireError;
}
unsafe extern "C" {
    #[doc = "Read multiple applications data on MfDesfire card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `app_ids` (direction in) - pointer to the SimpleArray structure array with application ids to read data from.\n * `data` (direction out) - pointer to the SimpleArray structure array to be filled with applications data.\n # Returns\n\nMfDesfireErrorNone on success, an error code on failure."]
    pub fn mf_desfire_poller_read_applications(
        instance: *mut MfDesfirePoller,
        app_ids: *const SimpleArray,
        data: *mut SimpleArray,
    ) -> MfDesfireError;
}
pub const MfPlusErrorNone: MfPlusError = MfPlusError(0);
pub const MfPlusErrorUnknown: MfPlusError = MfPlusError(1);
pub const MfPlusErrorNotPresent: MfPlusError = MfPlusError(2);
pub const MfPlusErrorProtocol: MfPlusError = MfPlusError(3);
pub const MfPlusErrorAuth: MfPlusError = MfPlusError(4);
pub const MfPlusErrorPartialRead: MfPlusError = MfPlusError(5);
pub const MfPlusErrorTimeout: MfPlusError = MfPlusError(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfPlusError(pub core::ffi::c_uchar);
pub const MfPlusTypePlus: MfPlusType = MfPlusType(0);
pub const MfPlusTypeEV1: MfPlusType = MfPlusType(1);
pub const MfPlusTypeEV2: MfPlusType = MfPlusType(2);
pub const MfPlusTypeS: MfPlusType = MfPlusType(3);
pub const MfPlusTypeSE: MfPlusType = MfPlusType(4);
pub const MfPlusTypeX: MfPlusType = MfPlusType(5);
pub const MfPlusTypeUnknown: MfPlusType = MfPlusType(6);
pub const MfPlusTypeNum: MfPlusType = MfPlusType(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfPlusType(pub core::ffi::c_uchar);
pub const MfPlusSize1K: MfPlusSize = MfPlusSize(0);
pub const MfPlusSize2K: MfPlusSize = MfPlusSize(1);
pub const MfPlusSize4K: MfPlusSize = MfPlusSize(2);
pub const MfPlusSizeUnknown: MfPlusSize = MfPlusSize(3);
pub const MfPlusSizeNum: MfPlusSize = MfPlusSize(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfPlusSize(pub core::ffi::c_uchar);
pub const MfPlusSecurityLevel0: MfPlusSecurityLevel = MfPlusSecurityLevel(0);
pub const MfPlusSecurityLevel1: MfPlusSecurityLevel = MfPlusSecurityLevel(1);
pub const MfPlusSecurityLevel2: MfPlusSecurityLevel = MfPlusSecurityLevel(2);
pub const MfPlusSecurityLevel3: MfPlusSecurityLevel = MfPlusSecurityLevel(3);
pub const MfPlusSecurityLevelUnknown: MfPlusSecurityLevel = MfPlusSecurityLevel(4);
pub const MfPlusSecurityLevelNum: MfPlusSecurityLevel = MfPlusSecurityLevel(5);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfPlusSecurityLevel(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfPlusVersion {
    pub hw_vendor: u8,
    pub hw_type: u8,
    pub hw_subtype: u8,
    pub hw_major: u8,
    pub hw_minor: u8,
    pub hw_storage: u8,
    pub hw_proto: u8,
    pub sw_vendor: u8,
    pub sw_type: u8,
    pub sw_subtype: u8,
    pub sw_major: u8,
    pub sw_minor: u8,
    pub sw_storage: u8,
    pub sw_proto: u8,
    pub uid: [u8; 7usize],
    pub batch: [u8; 5usize],
    pub prod_week: u8,
    pub prod_year: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfPlusVersion"][::core::mem::size_of::<MfPlusVersion>() - 28usize];
    ["Alignment of MfPlusVersion"][::core::mem::align_of::<MfPlusVersion>() - 1usize];
    ["Offset of field: MfPlusVersion::hw_vendor"]
        [::core::mem::offset_of!(MfPlusVersion, hw_vendor) - 0usize];
    ["Offset of field: MfPlusVersion::hw_type"]
        [::core::mem::offset_of!(MfPlusVersion, hw_type) - 1usize];
    ["Offset of field: MfPlusVersion::hw_subtype"]
        [::core::mem::offset_of!(MfPlusVersion, hw_subtype) - 2usize];
    ["Offset of field: MfPlusVersion::hw_major"]
        [::core::mem::offset_of!(MfPlusVersion, hw_major) - 3usize];
    ["Offset of field: MfPlusVersion::hw_minor"]
        [::core::mem::offset_of!(MfPlusVersion, hw_minor) - 4usize];
    ["Offset of field: MfPlusVersion::hw_storage"]
        [::core::mem::offset_of!(MfPlusVersion, hw_storage) - 5usize];
    ["Offset of field: MfPlusVersion::hw_proto"]
        [::core::mem::offset_of!(MfPlusVersion, hw_proto) - 6usize];
    ["Offset of field: MfPlusVersion::sw_vendor"]
        [::core::mem::offset_of!(MfPlusVersion, sw_vendor) - 7usize];
    ["Offset of field: MfPlusVersion::sw_type"]
        [::core::mem::offset_of!(MfPlusVersion, sw_type) - 8usize];
    ["Offset of field: MfPlusVersion::sw_subtype"]
        [::core::mem::offset_of!(MfPlusVersion, sw_subtype) - 9usize];
    ["Offset of field: MfPlusVersion::sw_major"]
        [::core::mem::offset_of!(MfPlusVersion, sw_major) - 10usize];
    ["Offset of field: MfPlusVersion::sw_minor"]
        [::core::mem::offset_of!(MfPlusVersion, sw_minor) - 11usize];
    ["Offset of field: MfPlusVersion::sw_storage"]
        [::core::mem::offset_of!(MfPlusVersion, sw_storage) - 12usize];
    ["Offset of field: MfPlusVersion::sw_proto"]
        [::core::mem::offset_of!(MfPlusVersion, sw_proto) - 13usize];
    ["Offset of field: MfPlusVersion::uid"][::core::mem::offset_of!(MfPlusVersion, uid) - 14usize];
    ["Offset of field: MfPlusVersion::batch"]
        [::core::mem::offset_of!(MfPlusVersion, batch) - 21usize];
    ["Offset of field: MfPlusVersion::prod_week"]
        [::core::mem::offset_of!(MfPlusVersion, prod_week) - 26usize];
    ["Offset of field: MfPlusVersion::prod_year"]
        [::core::mem::offset_of!(MfPlusVersion, prod_year) - 27usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfPlusData {
    pub iso14443_4a_data: *mut Iso14443_4aData,
    pub version: MfPlusVersion,
    pub type_: MfPlusType,
    pub size: MfPlusSize,
    pub security_level: MfPlusSecurityLevel,
    pub device_name: *mut FuriString,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfPlusData"][::core::mem::size_of::<MfPlusData>() - 40usize];
    ["Alignment of MfPlusData"][::core::mem::align_of::<MfPlusData>() - 4usize];
    ["Offset of field: MfPlusData::iso14443_4a_data"]
        [::core::mem::offset_of!(MfPlusData, iso14443_4a_data) - 0usize];
    ["Offset of field: MfPlusData::version"][::core::mem::offset_of!(MfPlusData, version) - 4usize];
    ["Offset of field: MfPlusData::type_"][::core::mem::offset_of!(MfPlusData, type_) - 32usize];
    ["Offset of field: MfPlusData::size"][::core::mem::offset_of!(MfPlusData, size) - 33usize];
    ["Offset of field: MfPlusData::security_level"]
        [::core::mem::offset_of!(MfPlusData, security_level) - 34usize];
    ["Offset of field: MfPlusData::device_name"]
        [::core::mem::offset_of!(MfPlusData, device_name) - 36usize];
};
unsafe extern "C" {
    pub fn mf_plus_alloc() -> *mut MfPlusData;
}
unsafe extern "C" {
    pub fn mf_plus_free(data: *mut MfPlusData);
}
unsafe extern "C" {
    pub fn mf_plus_reset(data: *mut MfPlusData);
}
unsafe extern "C" {
    pub fn mf_plus_copy(data: *mut MfPlusData, other: *const MfPlusData);
}
unsafe extern "C" {
    pub fn mf_plus_verify(data: *mut MfPlusData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn mf_plus_load(data: *mut MfPlusData, ff: *mut FlipperFormat, version: u32) -> bool;
}
unsafe extern "C" {
    pub fn mf_plus_save(data: *const MfPlusData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn mf_plus_is_equal(data: *const MfPlusData, other: *const MfPlusData) -> bool;
}
unsafe extern "C" {
    pub fn mf_plus_get_device_name(
        data: *const MfPlusData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mf_plus_get_uid(data: *const MfPlusData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn mf_plus_set_uid(data: *mut MfPlusData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn mf_plus_get_base_data(data: *const MfPlusData) -> *mut Iso14443_4aData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfPlusPoller {
    _unused: [u8; 0],
}
#[doc = "< Card was read successfully."]
pub const MfPlusPollerEventTypeReadSuccess: MfPlusPollerEventType = MfPlusPollerEventType(0);
#[doc = "< Poller failed to read the card."]
pub const MfPlusPollerEventTypeReadFailed: MfPlusPollerEventType = MfPlusPollerEventType(1);
#[repr(transparent)]
#[doc = "Enumeration of possible MfPlus poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfPlusPollerEventType(pub core::ffi::c_uchar);
#[doc = "MIFARE Plus poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfPlusPollerEventData {
    #[doc = "< Error code indicating card reading fail reason."]
    pub error: MfPlusError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfPlusPollerEventData"][::core::mem::size_of::<MfPlusPollerEventData>() - 1usize];
    ["Alignment of MfPlusPollerEventData"]
        [::core::mem::align_of::<MfPlusPollerEventData>() - 1usize];
    ["Offset of field: MfPlusPollerEventData::error"]
        [::core::mem::offset_of!(MfPlusPollerEventData, error) - 0usize];
};
#[doc = "MIFARE Plus poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfPlusPollerEvent {
    #[doc = "< Type of emitted event."]
    pub type_: MfPlusPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut MfPlusPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfPlusPollerEvent"][::core::mem::size_of::<MfPlusPollerEvent>() - 8usize];
    ["Alignment of MfPlusPollerEvent"][::core::mem::align_of::<MfPlusPollerEvent>() - 4usize];
    ["Offset of field: MfPlusPollerEvent::type_"]
        [::core::mem::offset_of!(MfPlusPollerEvent, type_) - 0usize];
    ["Offset of field: MfPlusPollerEvent::data"]
        [::core::mem::offset_of!(MfPlusPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Read MfPlus card version.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfPlusVersion structure to be filled with version data.\n # Returns\n\nMfPlusErrorNone on success, an error code on failure."]
    pub fn mf_plus_poller_read_version(
        instance: *mut MfPlusPoller,
        data: *mut MfPlusVersion,
    ) -> MfPlusError;
}
pub const MfUltralightErrorNone: MfUltralightError = MfUltralightError(0);
pub const MfUltralightErrorNotPresent: MfUltralightError = MfUltralightError(1);
pub const MfUltralightErrorProtocol: MfUltralightError = MfUltralightError(2);
pub const MfUltralightErrorAuth: MfUltralightError = MfUltralightError(3);
pub const MfUltralightErrorTimeout: MfUltralightError = MfUltralightError(4);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightError(pub core::ffi::c_uchar);
pub const MfUltralightTypeOrigin: MfUltralightType = MfUltralightType(0);
pub const MfUltralightTypeNTAG203: MfUltralightType = MfUltralightType(1);
pub const MfUltralightTypeMfulC: MfUltralightType = MfUltralightType(2);
pub const MfUltralightTypeUL11: MfUltralightType = MfUltralightType(3);
pub const MfUltralightTypeUL21: MfUltralightType = MfUltralightType(4);
pub const MfUltralightTypeNTAG213: MfUltralightType = MfUltralightType(5);
pub const MfUltralightTypeNTAG215: MfUltralightType = MfUltralightType(6);
pub const MfUltralightTypeNTAG216: MfUltralightType = MfUltralightType(7);
pub const MfUltralightTypeNTAGI2C1K: MfUltralightType = MfUltralightType(8);
pub const MfUltralightTypeNTAGI2C2K: MfUltralightType = MfUltralightType(9);
pub const MfUltralightTypeNTAGI2CPlus1K: MfUltralightType = MfUltralightType(10);
pub const MfUltralightTypeNTAGI2CPlus2K: MfUltralightType = MfUltralightType(11);
pub const MfUltralightTypeNum: MfUltralightType = MfUltralightType(12);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightType(pub core::ffi::c_uchar);
pub const MfUltralightFeatureSupportReadVersion: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(1);
pub const MfUltralightFeatureSupportReadSignature: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(2);
pub const MfUltralightFeatureSupportReadCounter: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(4);
pub const MfUltralightFeatureSupportCheckTearingFlag: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(8);
pub const MfUltralightFeatureSupportFastRead: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(16);
pub const MfUltralightFeatureSupportIncCounter: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(32);
pub const MfUltralightFeatureSupportFastWrite: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(64);
pub const MfUltralightFeatureSupportCompatibleWrite: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(128);
pub const MfUltralightFeatureSupportPasswordAuth: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(256);
pub const MfUltralightFeatureSupportVcsl: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(512);
pub const MfUltralightFeatureSupportSectorSelect: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(1024);
pub const MfUltralightFeatureSupportSingleCounter: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(2048);
pub const MfUltralightFeatureSupportAsciiMirror: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(4096);
pub const MfUltralightFeatureSupportCounterInMemory: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(8192);
pub const MfUltralightFeatureSupportDynamicLock: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(16384);
pub const MfUltralightFeatureSupportAuthenticate: MfUltralightFeatureSupport =
    MfUltralightFeatureSupport(32768);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightFeatureSupport(pub core::ffi::c_ushort);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightPage {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightPage"][::core::mem::size_of::<MfUltralightPage>() - 4usize];
    ["Alignment of MfUltralightPage"][::core::mem::align_of::<MfUltralightPage>() - 1usize];
    ["Offset of field: MfUltralightPage::data"]
        [::core::mem::offset_of!(MfUltralightPage, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightPageReadCommandData {
    pub page: [MfUltralightPage; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightPageReadCommandData"]
        [::core::mem::size_of::<MfUltralightPageReadCommandData>() - 16usize];
    ["Alignment of MfUltralightPageReadCommandData"]
        [::core::mem::align_of::<MfUltralightPageReadCommandData>() - 1usize];
    ["Offset of field: MfUltralightPageReadCommandData::page"]
        [::core::mem::offset_of!(MfUltralightPageReadCommandData, page) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightVersion {
    pub header: u8,
    pub vendor_id: u8,
    pub prod_type: u8,
    pub prod_subtype: u8,
    pub prod_ver_major: u8,
    pub prod_ver_minor: u8,
    pub storage_size: u8,
    pub protocol_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightVersion"][::core::mem::size_of::<MfUltralightVersion>() - 8usize];
    ["Alignment of MfUltralightVersion"][::core::mem::align_of::<MfUltralightVersion>() - 1usize];
    ["Offset of field: MfUltralightVersion::header"]
        [::core::mem::offset_of!(MfUltralightVersion, header) - 0usize];
    ["Offset of field: MfUltralightVersion::vendor_id"]
        [::core::mem::offset_of!(MfUltralightVersion, vendor_id) - 1usize];
    ["Offset of field: MfUltralightVersion::prod_type"]
        [::core::mem::offset_of!(MfUltralightVersion, prod_type) - 2usize];
    ["Offset of field: MfUltralightVersion::prod_subtype"]
        [::core::mem::offset_of!(MfUltralightVersion, prod_subtype) - 3usize];
    ["Offset of field: MfUltralightVersion::prod_ver_major"]
        [::core::mem::offset_of!(MfUltralightVersion, prod_ver_major) - 4usize];
    ["Offset of field: MfUltralightVersion::prod_ver_minor"]
        [::core::mem::offset_of!(MfUltralightVersion, prod_ver_minor) - 5usize];
    ["Offset of field: MfUltralightVersion::storage_size"]
        [::core::mem::offset_of!(MfUltralightVersion, storage_size) - 6usize];
    ["Offset of field: MfUltralightVersion::protocol_type"]
        [::core::mem::offset_of!(MfUltralightVersion, protocol_type) - 7usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightSignature {
    pub data: [u8; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightSignature"][::core::mem::size_of::<MfUltralightSignature>() - 32usize];
    ["Alignment of MfUltralightSignature"]
        [::core::mem::align_of::<MfUltralightSignature>() - 1usize];
    ["Offset of field: MfUltralightSignature::data"]
        [::core::mem::offset_of!(MfUltralightSignature, data) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightCounter {
    pub counter: u32,
    pub data: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightCounter"][::core::mem::size_of::<MfUltralightCounter>() - 4usize];
    ["Alignment of MfUltralightCounter"][::core::mem::align_of::<MfUltralightCounter>() - 4usize];
    ["Offset of field: MfUltralightCounter::counter"]
        [::core::mem::offset_of!(MfUltralightCounter, counter) - 0usize];
    ["Offset of field: MfUltralightCounter::data"]
        [::core::mem::offset_of!(MfUltralightCounter, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightTearingFlag {
    pub data: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightTearingFlag"][::core::mem::size_of::<MfUltralightTearingFlag>() - 1usize];
    ["Alignment of MfUltralightTearingFlag"]
        [::core::mem::align_of::<MfUltralightTearingFlag>() - 1usize];
    ["Offset of field: MfUltralightTearingFlag::data"]
        [::core::mem::offset_of!(MfUltralightTearingFlag, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightAuthPassword {
    pub data: [u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightAuthPassword"]
        [::core::mem::size_of::<MfUltralightAuthPassword>() - 4usize];
    ["Alignment of MfUltralightAuthPassword"]
        [::core::mem::align_of::<MfUltralightAuthPassword>() - 1usize];
    ["Offset of field: MfUltralightAuthPassword::data"]
        [::core::mem::offset_of!(MfUltralightAuthPassword, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightC3DesAuthKey {
    pub data: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightC3DesAuthKey"]
        [::core::mem::size_of::<MfUltralightC3DesAuthKey>() - 16usize];
    ["Alignment of MfUltralightC3DesAuthKey"]
        [::core::mem::align_of::<MfUltralightC3DesAuthKey>() - 1usize];
    ["Offset of field: MfUltralightC3DesAuthKey::data"]
        [::core::mem::offset_of!(MfUltralightC3DesAuthKey, data) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightAuthPack {
    pub data: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightAuthPack"][::core::mem::size_of::<MfUltralightAuthPack>() - 2usize];
    ["Alignment of MfUltralightAuthPack"][::core::mem::align_of::<MfUltralightAuthPack>() - 1usize];
    ["Offset of field: MfUltralightAuthPack::data"]
        [::core::mem::offset_of!(MfUltralightAuthPack, data) - 0usize];
};
pub const MfUltralightMirrorNone: MfUltralightMirrorConf = MfUltralightMirrorConf(0);
pub const MfUltralightMirrorUid: MfUltralightMirrorConf = MfUltralightMirrorConf(1);
pub const MfUltralightMirrorCounter: MfUltralightMirrorConf = MfUltralightMirrorConf(2);
pub const MfUltralightMirrorUidCounter: MfUltralightMirrorConf = MfUltralightMirrorConf(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightMirrorConf(pub core::ffi::c_uchar);
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct MfUltralightConfigPages {
    pub mirror: MfUltralightConfigPages__bindgen_ty_1,
    pub rfui1: u8,
    pub mirror_page: u8,
    pub auth0: u8,
    pub access: MfUltralightConfigPages__bindgen_ty_2,
    pub vctid: u8,
    pub rfui2: [u8; 2usize],
    pub password: MfUltralightAuthPassword,
    pub pack: MfUltralightAuthPack,
    pub rfui3: [u8; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightConfigPages__bindgen_ty_1 {
    pub value: u8,
    pub __bindgen_anon_1: MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn rfui1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rfui1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfui1_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfui1_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strg_mod_en(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_strg_mod_en(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strg_mod_en_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_strg_mod_en_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rfui2(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfui2(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rfui2_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rfui2_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mirror_byte(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mirror_byte(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_byte_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_byte_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mirror_conf(&self) -> MfUltralightMirrorConf {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mirror_conf(&mut self, val: MfUltralightMirrorConf) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_conf_raw(this: *const Self) -> MfUltralightMirrorConf {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_conf_raw(this: *mut Self, val: MfUltralightMirrorConf) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rfui1: u8,
        strg_mod_en: bool,
        rfui2: bool,
        mirror_byte: u8,
        mirror_conf: MfUltralightMirrorConf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let rfui1: u8 = unsafe { ::core::mem::transmute(rfui1) };
            rfui1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let strg_mod_en: u8 = unsafe { ::core::mem::transmute(strg_mod_en) };
            strg_mod_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rfui2: u8 = unsafe { ::core::mem::transmute(rfui2) };
            rfui2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let mirror_byte: u8 = unsafe { ::core::mem::transmute(mirror_byte) };
            mirror_byte as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let mirror_conf: u8 = unsafe { ::core::mem::transmute(mirror_conf) };
            mirror_conf as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightConfigPages__bindgen_ty_1"]
        [::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_1>() - 1usize];
    ["Alignment of MfUltralightConfigPages__bindgen_ty_1"]
        [::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_1>() - 1usize];
    ["Offset of field: MfUltralightConfigPages__bindgen_ty_1::value"]
        [::core::mem::offset_of!(MfUltralightConfigPages__bindgen_ty_1, value) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightConfigPages__bindgen_ty_2 {
    pub value: u8,
    pub __bindgen_anon_1: MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1>() - 1usize];
    ["Alignment of MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1>() - 1usize];
};
impl MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn authlim(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_authlim(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn authlim_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_authlim_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nfc_cnt_pwd_prot(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nfc_cnt_pwd_prot(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nfc_cnt_pwd_prot_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_nfc_cnt_pwd_prot_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nfc_cnt_en(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nfc_cnt_en(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nfc_cnt_en_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_nfc_cnt_en_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn nfc_dis_sec1(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nfc_dis_sec1(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn nfc_dis_sec1_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_nfc_dis_sec1_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn cfglck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cfglck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn cfglck_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_cfglck_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn prot(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_prot(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn prot_raw(this: *const Self) -> bool {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_prot_raw(this: *mut Self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        authlim: u8,
        nfc_cnt_pwd_prot: bool,
        nfc_cnt_en: bool,
        nfc_dis_sec1: bool,
        cfglck: bool,
        prot: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let authlim: u8 = unsafe { ::core::mem::transmute(authlim) };
            authlim as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nfc_cnt_pwd_prot: u8 = unsafe { ::core::mem::transmute(nfc_cnt_pwd_prot) };
            nfc_cnt_pwd_prot as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nfc_cnt_en: u8 = unsafe { ::core::mem::transmute(nfc_cnt_en) };
            nfc_cnt_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nfc_dis_sec1: u8 = unsafe { ::core::mem::transmute(nfc_dis_sec1) };
            nfc_dis_sec1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cfglck: u8 = unsafe { ::core::mem::transmute(cfglck) };
            cfglck as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let prot: u8 = unsafe { ::core::mem::transmute(prot) };
            prot as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightConfigPages__bindgen_ty_2"]
        [::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_2>() - 1usize];
    ["Alignment of MfUltralightConfigPages__bindgen_ty_2"]
        [::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_2>() - 1usize];
    ["Offset of field: MfUltralightConfigPages__bindgen_ty_2::value"]
        [::core::mem::offset_of!(MfUltralightConfigPages__bindgen_ty_2, value) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightConfigPages"]
        [::core::mem::size_of::<MfUltralightConfigPages>() - 16usize];
    ["Alignment of MfUltralightConfigPages"]
        [::core::mem::align_of::<MfUltralightConfigPages>() - 1usize];
    ["Offset of field: MfUltralightConfigPages::mirror"]
        [::core::mem::offset_of!(MfUltralightConfigPages, mirror) - 0usize];
    ["Offset of field: MfUltralightConfigPages::rfui1"]
        [::core::mem::offset_of!(MfUltralightConfigPages, rfui1) - 1usize];
    ["Offset of field: MfUltralightConfigPages::mirror_page"]
        [::core::mem::offset_of!(MfUltralightConfigPages, mirror_page) - 2usize];
    ["Offset of field: MfUltralightConfigPages::auth0"]
        [::core::mem::offset_of!(MfUltralightConfigPages, auth0) - 3usize];
    ["Offset of field: MfUltralightConfigPages::access"]
        [::core::mem::offset_of!(MfUltralightConfigPages, access) - 4usize];
    ["Offset of field: MfUltralightConfigPages::vctid"]
        [::core::mem::offset_of!(MfUltralightConfigPages, vctid) - 5usize];
    ["Offset of field: MfUltralightConfigPages::rfui2"]
        [::core::mem::offset_of!(MfUltralightConfigPages, rfui2) - 6usize];
    ["Offset of field: MfUltralightConfigPages::password"]
        [::core::mem::offset_of!(MfUltralightConfigPages, password) - 8usize];
    ["Offset of field: MfUltralightConfigPages::pack"]
        [::core::mem::offset_of!(MfUltralightConfigPages, pack) - 12usize];
    ["Offset of field: MfUltralightConfigPages::rfui3"]
        [::core::mem::offset_of!(MfUltralightConfigPages, rfui3) - 14usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MfUltralightData {
    pub iso14443_3a_data: *mut Iso14443_3aData,
    pub type_: MfUltralightType,
    pub version: MfUltralightVersion,
    pub signature: MfUltralightSignature,
    pub counter: [MfUltralightCounter; 3usize],
    pub tearing_flag: [MfUltralightTearingFlag; 3usize],
    pub page: [MfUltralightPage; 510usize],
    pub pages_read: u16,
    pub pages_total: u16,
    pub auth_attempts: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightData"][::core::mem::size_of::<MfUltralightData>() - 2112usize];
    ["Alignment of MfUltralightData"][::core::mem::align_of::<MfUltralightData>() - 4usize];
    ["Offset of field: MfUltralightData::iso14443_3a_data"]
        [::core::mem::offset_of!(MfUltralightData, iso14443_3a_data) - 0usize];
    ["Offset of field: MfUltralightData::type_"]
        [::core::mem::offset_of!(MfUltralightData, type_) - 4usize];
    ["Offset of field: MfUltralightData::version"]
        [::core::mem::offset_of!(MfUltralightData, version) - 5usize];
    ["Offset of field: MfUltralightData::signature"]
        [::core::mem::offset_of!(MfUltralightData, signature) - 13usize];
    ["Offset of field: MfUltralightData::counter"]
        [::core::mem::offset_of!(MfUltralightData, counter) - 48usize];
    ["Offset of field: MfUltralightData::tearing_flag"]
        [::core::mem::offset_of!(MfUltralightData, tearing_flag) - 60usize];
    ["Offset of field: MfUltralightData::page"]
        [::core::mem::offset_of!(MfUltralightData, page) - 63usize];
    ["Offset of field: MfUltralightData::pages_read"]
        [::core::mem::offset_of!(MfUltralightData, pages_read) - 2104usize];
    ["Offset of field: MfUltralightData::pages_total"]
        [::core::mem::offset_of!(MfUltralightData, pages_total) - 2106usize];
    ["Offset of field: MfUltralightData::auth_attempts"]
        [::core::mem::offset_of!(MfUltralightData, auth_attempts) - 2108usize];
};
unsafe extern "C" {
    pub fn mf_ultralight_alloc() -> *mut MfUltralightData;
}
unsafe extern "C" {
    pub fn mf_ultralight_free(data: *mut MfUltralightData);
}
unsafe extern "C" {
    pub fn mf_ultralight_reset(data: *mut MfUltralightData);
}
unsafe extern "C" {
    pub fn mf_ultralight_copy(data: *mut MfUltralightData, other: *const MfUltralightData);
}
unsafe extern "C" {
    pub fn mf_ultralight_verify(
        data: *mut MfUltralightData,
        device_type: *const FuriString,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_load(
        data: *mut MfUltralightData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_save(data: *const MfUltralightData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_is_equal(
        data: *const MfUltralightData,
        other: *const MfUltralightData,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_device_name(
        data: *const MfUltralightData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_uid(data: *const MfUltralightData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn mf_ultralight_set_uid(
        data: *mut MfUltralightData,
        uid: *const u8,
        uid_len: usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_base_data(data: *const MfUltralightData) -> *mut Iso14443_3aData;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_type_by_version(version: *mut MfUltralightVersion)
    -> MfUltralightType;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_pages_total(type_: MfUltralightType) -> u16;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_feature_support_set(type_: MfUltralightType) -> u32;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_config_page_num(type_: MfUltralightType) -> u16;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_write_end_page(type_: MfUltralightType) -> u8;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_pwd_page_num(type_: MfUltralightType) -> u8;
}
unsafe extern "C" {
    pub fn mf_ultralight_is_page_pwd_or_pack(type_: MfUltralightType, page_num: u16) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_support_feature(feature_set: u32, features_to_check: u32) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_get_config_page(
        data: *const MfUltralightData,
        config: *mut *mut MfUltralightConfigPages,
    ) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_is_all_data_read(data: *const MfUltralightData) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_detect_protocol(iso14443_3a_data: *const Iso14443_3aData) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_is_counter_configured(data: *const MfUltralightData) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_3des_shift_data(arr: *mut u8);
}
unsafe extern "C" {
    pub fn mf_ultralight_3des_key_valid(data: *const MfUltralightData) -> bool;
}
unsafe extern "C" {
    pub fn mf_ultralight_3des_get_key(data: *const MfUltralightData) -> *const u8;
}
unsafe extern "C" {
    pub fn mf_ultralight_3des_encrypt(
        ctx: *mut mbedtls_des3_context,
        ck: *const u8,
        iv: *const u8,
        input: *const u8,
        length: u8,
        out: *mut u8,
    );
}
unsafe extern "C" {
    pub fn mf_ultralight_3des_decrypt(
        ctx: *mut mbedtls_des3_context,
        ck: *const u8,
        iv: *const u8,
        input: *const u8,
        length: u8,
        out: *mut u8,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightListener {
    _unused: [u8; 0],
}
pub const MfUltralightListenerEventTypeAuth: MfUltralightListenerEventType =
    MfUltralightListenerEventType(0);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightListenerEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MfUltralightListenerEventData {
    pub __bindgen_anon_1: MfUltralightListenerEventData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightListenerEventData__bindgen_ty_1 {
    pub password: MfUltralightAuthPassword,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightListenerEventData__bindgen_ty_1"]
        [::core::mem::size_of::<MfUltralightListenerEventData__bindgen_ty_1>() - 4usize];
    ["Alignment of MfUltralightListenerEventData__bindgen_ty_1"]
        [::core::mem::align_of::<MfUltralightListenerEventData__bindgen_ty_1>() - 1usize];
    ["Offset of field: MfUltralightListenerEventData__bindgen_ty_1::password"]
        [::core::mem::offset_of!(MfUltralightListenerEventData__bindgen_ty_1, password) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightListenerEventData"]
        [::core::mem::size_of::<MfUltralightListenerEventData>() - 4usize];
    ["Alignment of MfUltralightListenerEventData"]
        [::core::mem::align_of::<MfUltralightListenerEventData>() - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightListenerEvent {
    pub type_: MfUltralightListenerEventType,
    pub data: *mut MfUltralightListenerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightListenerEvent"]
        [::core::mem::size_of::<MfUltralightListenerEvent>() - 8usize];
    ["Alignment of MfUltralightListenerEvent"]
        [::core::mem::align_of::<MfUltralightListenerEvent>() - 4usize];
    ["Offset of field: MfUltralightListenerEvent::type_"]
        [::core::mem::offset_of!(MfUltralightListenerEvent, type_) - 0usize];
    ["Offset of field: MfUltralightListenerEvent::data"]
        [::core::mem::offset_of!(MfUltralightListenerEvent, data) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightPoller {
    _unused: [u8; 0],
}
#[doc = "< Poller requests for operating mode."]
pub const MfUltralightPollerEventTypeRequestMode: MfUltralightPollerEventType =
    MfUltralightPollerEventType(0);
#[doc = "< Poller requests to fill authentication context."]
pub const MfUltralightPollerEventTypeAuthRequest: MfUltralightPollerEventType =
    MfUltralightPollerEventType(1);
#[doc = "< Authentication succeeded."]
pub const MfUltralightPollerEventTypeAuthSuccess: MfUltralightPollerEventType =
    MfUltralightPollerEventType(2);
#[doc = "< Authentication failed."]
pub const MfUltralightPollerEventTypeAuthFailed: MfUltralightPollerEventType =
    MfUltralightPollerEventType(3);
#[doc = "< Poller read card successfully."]
pub const MfUltralightPollerEventTypeReadSuccess: MfUltralightPollerEventType =
    MfUltralightPollerEventType(4);
#[doc = "< Poller failed to read card."]
pub const MfUltralightPollerEventTypeReadFailed: MfUltralightPollerEventType =
    MfUltralightPollerEventType(5);
#[doc = "< Poller request card data for write operation."]
pub const MfUltralightPollerEventTypeRequestWriteData: MfUltralightPollerEventType =
    MfUltralightPollerEventType(6);
#[doc = "< Type of card for writing differs from presented one."]
pub const MfUltralightPollerEventTypeCardMismatch: MfUltralightPollerEventType =
    MfUltralightPollerEventType(7);
#[doc = "< Presented card is locked by password, AUTH0 or lock bytes."]
pub const MfUltralightPollerEventTypeCardLocked: MfUltralightPollerEventType =
    MfUltralightPollerEventType(8);
#[doc = "< Poller wrote card successfully."]
pub const MfUltralightPollerEventTypeWriteSuccess: MfUltralightPollerEventType =
    MfUltralightPollerEventType(9);
#[doc = "< Poller failed to write card."]
pub const MfUltralightPollerEventTypeWriteFail: MfUltralightPollerEventType =
    MfUltralightPollerEventType(10);
#[repr(transparent)]
#[doc = "Enumeration of possible MfUltralight poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightPollerEventType(pub core::ffi::c_uchar);
#[doc = "< Poller will only read card. It's a default mode."]
pub const MfUltralightPollerModeRead: MfUltralightPollerMode = MfUltralightPollerMode(0);
#[doc = "< Poller will write already saved card to another presented card."]
pub const MfUltralightPollerModeWrite: MfUltralightPollerMode = MfUltralightPollerMode(1);
#[repr(transparent)]
#[doc = "Enumeration of possible MfUltralight poller operating modes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MfUltralightPollerMode(pub core::ffi::c_uchar);
#[doc = "MfUltralight poller authentication context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightPollerAuthContext {
    #[doc = "< Password to be used for authentication."]
    pub password: MfUltralightAuthPassword,
    pub tdes_key: MfUltralightC3DesAuthKey,
    #[doc = "< Pack received on successfull authentication."]
    pub pack: MfUltralightAuthPack,
    #[doc = "< Set to true if authentication succeeded, false otherwise."]
    pub auth_success: bool,
    #[doc = "< Set to true if authentication should be skipped, false otherwise."]
    pub skip_auth: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightPollerAuthContext"]
        [::core::mem::size_of::<MfUltralightPollerAuthContext>() - 24usize];
    ["Alignment of MfUltralightPollerAuthContext"]
        [::core::mem::align_of::<MfUltralightPollerAuthContext>() - 1usize];
    ["Offset of field: MfUltralightPollerAuthContext::password"]
        [::core::mem::offset_of!(MfUltralightPollerAuthContext, password) - 0usize];
    ["Offset of field: MfUltralightPollerAuthContext::tdes_key"]
        [::core::mem::offset_of!(MfUltralightPollerAuthContext, tdes_key) - 4usize];
    ["Offset of field: MfUltralightPollerAuthContext::pack"]
        [::core::mem::offset_of!(MfUltralightPollerAuthContext, pack) - 20usize];
    ["Offset of field: MfUltralightPollerAuthContext::auth_success"]
        [::core::mem::offset_of!(MfUltralightPollerAuthContext, auth_success) - 22usize];
    ["Offset of field: MfUltralightPollerAuthContext::skip_auth"]
        [::core::mem::offset_of!(MfUltralightPollerAuthContext, skip_auth) - 23usize];
};
#[doc = "MfUltralight poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightPollerEventData {
    #[doc = "< Authentication context."]
    pub auth_context: MfUltralightPollerAuthContext,
    #[doc = "< Error code indicating reading fail reason."]
    pub error: MfUltralightError,
    pub write_data: *const MfUltralightData,
    pub poller_mode: MfUltralightPollerMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightPollerEventData"]
        [::core::mem::size_of::<MfUltralightPollerEventData>() - 24usize];
    ["Alignment of MfUltralightPollerEventData"]
        [::core::mem::align_of::<MfUltralightPollerEventData>() - 4usize];
    ["Offset of field: MfUltralightPollerEventData::auth_context"]
        [::core::mem::offset_of!(MfUltralightPollerEventData, auth_context) - 0usize];
    ["Offset of field: MfUltralightPollerEventData::error"]
        [::core::mem::offset_of!(MfUltralightPollerEventData, error) - 0usize];
    ["Offset of field: MfUltralightPollerEventData::write_data"]
        [::core::mem::offset_of!(MfUltralightPollerEventData, write_data) - 0usize];
    ["Offset of field: MfUltralightPollerEventData::poller_mode"]
        [::core::mem::offset_of!(MfUltralightPollerEventData, poller_mode) - 0usize];
};
#[doc = "MfUltralight poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: MfUltralightPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut MfUltralightPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MfUltralightPollerEvent"][::core::mem::size_of::<MfUltralightPollerEvent>() - 8usize];
    ["Alignment of MfUltralightPollerEvent"]
        [::core::mem::align_of::<MfUltralightPollerEvent>() - 4usize];
    ["Offset of field: MfUltralightPollerEvent::type_"]
        [::core::mem::offset_of!(MfUltralightPollerEvent, type_) - 0usize];
    ["Offset of field: MfUltralightPollerEvent::data"]
        [::core::mem::offset_of!(MfUltralightPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Perform authentication with password.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction in, out) - pointer to the authentication context.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_auth_pwd(
        instance: *mut MfUltralightPoller,
        data: *mut MfUltralightPollerAuthContext,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Start authentication procedure.\n\n Must ONLY be used inside the callback function.\n\n This function is used to start authentication process for Ultralight C cards.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `RndA` (direction in) - Randomly generated block which is required for authentication process.\n * `output` (direction out) - Authentication encryption result.\n # Returns\n\nMfUltralightErrorNone if card supports authentication command, an error code on otherwise."]
    pub fn mf_ultralight_poller_authenticate_start(
        instance: *mut MfUltralightPoller,
        RndA: *const u8,
        output: *mut u8,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "End authentication procedure\n\n This function is used to end authentication process for Ultralight C cards.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `RndB` (direction in) - Block received from the card (card generates it randomly) which is required for authentication process.\n * `request` (direction in) - Contains data of RndA + RndB', where RndB' is decoded and shifted RndB received from the card on previous step.\n * `response` (direction out) - Must return RndA' which an encrypted shifted RndA value received from the card and decrypted by this function."]
    pub fn mf_ultralight_poller_authenticate_end(
        instance: *mut MfUltralightPoller,
        RndB: *const u8,
        request: *const u8,
        response: *mut u8,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Read page from card.\n\n Must ONLY be used inside the callback function.\n\n Send read command and parse response. The response on this command is data of 4 pages starting\n from the page specified in the command.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `start_page` (direction in) - page number to be read.\n * `data` (direction out) - pointer to the MfUltralightPageReadCommandData structure to be filled with page data.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_read_page(
        instance: *mut MfUltralightPoller,
        start_page: u8,
        data: *mut MfUltralightPageReadCommandData,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Read page from sector.\n\n Must ONLY be used inside the callback function.\n\n This command should be used for NTAGI2C tags.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `sector` (direction in) - sector number to be read.\n * `tag` (direction in) - tag number to be read.\n * `data` (direction out) - pointer to the MfUltralightPageReadCommandData structure to be filled with page data.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_read_page_from_sector(
        instance: *mut MfUltralightPoller,
        sector: u8,
        tag: u8,
        data: *mut MfUltralightPageReadCommandData,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Write page to card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `page` (direction in) - page number to be written.\n * `data` (direction in) - pointer to the MfUltralightPage structure to be written.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_write_page(
        instance: *mut MfUltralightPoller,
        page: u8,
        data: *const MfUltralightPage,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Read version from card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfUltralightVersion structure to be filled.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_read_version(
        instance: *mut MfUltralightPoller,
        data: *mut MfUltralightVersion,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Read signature from card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the MfUltralightSignature structure to be filled.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_read_signature(
        instance: *mut MfUltralightPoller,
        data: *mut MfUltralightSignature,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Read counter from card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `counter_num` (direction in) - counter number to be read.\n * `data` (direction out) - pointer to the MfUltralightCounter structure to be filled.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_read_counter(
        instance: *mut MfUltralightPoller,
        counter_num: u8,
        data: *mut MfUltralightCounter,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    #[doc = "Read tearing flag from card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tearing_falg_num` (direction in) - tearing flag number to be read.\n * `data` (direction out) - pointer to the MfUltralightTearingFlag structure to be filled.\n # Returns\n\nMfUltralightErrorNone on success, an error code on failure."]
    pub fn mf_ultralight_poller_read_tearing_flag(
        instance: *mut MfUltralightPoller,
        tearing_falg_num: u8,
        data: *mut MfUltralightTearingFlag,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_read_page(
        nfc: *mut Nfc,
        page: u16,
        data: *mut MfUltralightPage,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_write_page(
        nfc: *mut Nfc,
        page: u16,
        data: *mut MfUltralightPage,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_read_version(
        nfc: *mut Nfc,
        data: *mut MfUltralightVersion,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_read_signature(
        nfc: *mut Nfc,
        data: *mut MfUltralightSignature,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_read_counter(
        nfc: *mut Nfc,
        counter_num: u8,
        data: *mut MfUltralightCounter,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_read_tearing_flag(
        nfc: *mut Nfc,
        flag_num: u8,
        data: *mut MfUltralightTearingFlag,
    ) -> MfUltralightError;
}
unsafe extern "C" {
    pub fn mf_ultralight_poller_sync_read_card(
        nfc: *mut Nfc,
        data: *mut MfUltralightData,
    ) -> MfUltralightError;
}
pub const Iso15693_3ErrorNone: Iso15693_3Error = Iso15693_3Error(0);
pub const Iso15693_3ErrorNotPresent: Iso15693_3Error = Iso15693_3Error(1);
pub const Iso15693_3ErrorBufferEmpty: Iso15693_3Error = Iso15693_3Error(2);
pub const Iso15693_3ErrorBufferOverflow: Iso15693_3Error = Iso15693_3Error(3);
pub const Iso15693_3ErrorFieldOff: Iso15693_3Error = Iso15693_3Error(4);
pub const Iso15693_3ErrorWrongCrc: Iso15693_3Error = Iso15693_3Error(5);
pub const Iso15693_3ErrorTimeout: Iso15693_3Error = Iso15693_3Error(6);
pub const Iso15693_3ErrorFormat: Iso15693_3Error = Iso15693_3Error(7);
pub const Iso15693_3ErrorIgnore: Iso15693_3Error = Iso15693_3Error(8);
pub const Iso15693_3ErrorNotSupported: Iso15693_3Error = Iso15693_3Error(9);
pub const Iso15693_3ErrorUidMismatch: Iso15693_3Error = Iso15693_3Error(10);
pub const Iso15693_3ErrorFullyHandled: Iso15693_3Error = Iso15693_3Error(11);
pub const Iso15693_3ErrorUnexpectedResponse: Iso15693_3Error = Iso15693_3Error(12);
pub const Iso15693_3ErrorInternal: Iso15693_3Error = Iso15693_3Error(13);
pub const Iso15693_3ErrorCustom: Iso15693_3Error = Iso15693_3Error(14);
pub const Iso15693_3ErrorUnknown: Iso15693_3Error = Iso15693_3Error(15);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Iso15693_3Error(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3SystemInfo {
    pub flags: u8,
    pub dsfid: u8,
    pub afi: u8,
    pub ic_ref: u8,
    pub block_count: u16,
    pub block_size: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso15693_3SystemInfo"][::core::mem::size_of::<Iso15693_3SystemInfo>() - 8usize];
    ["Alignment of Iso15693_3SystemInfo"][::core::mem::align_of::<Iso15693_3SystemInfo>() - 2usize];
    ["Offset of field: Iso15693_3SystemInfo::flags"]
        [::core::mem::offset_of!(Iso15693_3SystemInfo, flags) - 0usize];
    ["Offset of field: Iso15693_3SystemInfo::dsfid"]
        [::core::mem::offset_of!(Iso15693_3SystemInfo, dsfid) - 1usize];
    ["Offset of field: Iso15693_3SystemInfo::afi"]
        [::core::mem::offset_of!(Iso15693_3SystemInfo, afi) - 2usize];
    ["Offset of field: Iso15693_3SystemInfo::ic_ref"]
        [::core::mem::offset_of!(Iso15693_3SystemInfo, ic_ref) - 3usize];
    ["Offset of field: Iso15693_3SystemInfo::block_count"]
        [::core::mem::offset_of!(Iso15693_3SystemInfo, block_count) - 4usize];
    ["Offset of field: Iso15693_3SystemInfo::block_size"]
        [::core::mem::offset_of!(Iso15693_3SystemInfo, block_size) - 6usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3LockBits {
    pub dsfid: bool,
    pub afi: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso15693_3LockBits"][::core::mem::size_of::<Iso15693_3LockBits>() - 2usize];
    ["Alignment of Iso15693_3LockBits"][::core::mem::align_of::<Iso15693_3LockBits>() - 1usize];
    ["Offset of field: Iso15693_3LockBits::dsfid"]
        [::core::mem::offset_of!(Iso15693_3LockBits, dsfid) - 0usize];
    ["Offset of field: Iso15693_3LockBits::afi"]
        [::core::mem::offset_of!(Iso15693_3LockBits, afi) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3Settings {
    pub lock_bits: Iso15693_3LockBits,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso15693_3Settings"][::core::mem::size_of::<Iso15693_3Settings>() - 2usize];
    ["Alignment of Iso15693_3Settings"][::core::mem::align_of::<Iso15693_3Settings>() - 1usize];
    ["Offset of field: Iso15693_3Settings::lock_bits"]
        [::core::mem::offset_of!(Iso15693_3Settings, lock_bits) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3Data {
    pub uid: [u8; 8usize],
    pub system_info: Iso15693_3SystemInfo,
    pub settings: Iso15693_3Settings,
    pub block_data: *mut SimpleArray,
    pub block_security: *mut SimpleArray,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Iso15693_3Data"][::core::mem::size_of::<Iso15693_3Data>() - 28usize];
    ["Alignment of Iso15693_3Data"][::core::mem::align_of::<Iso15693_3Data>() - 4usize];
    ["Offset of field: Iso15693_3Data::uid"][::core::mem::offset_of!(Iso15693_3Data, uid) - 0usize];
    ["Offset of field: Iso15693_3Data::system_info"]
        [::core::mem::offset_of!(Iso15693_3Data, system_info) - 8usize];
    ["Offset of field: Iso15693_3Data::settings"]
        [::core::mem::offset_of!(Iso15693_3Data, settings) - 16usize];
    ["Offset of field: Iso15693_3Data::block_data"]
        [::core::mem::offset_of!(Iso15693_3Data, block_data) - 20usize];
    ["Offset of field: Iso15693_3Data::block_security"]
        [::core::mem::offset_of!(Iso15693_3Data, block_security) - 24usize];
};
unsafe extern "C" {
    pub fn iso15693_3_alloc() -> *mut Iso15693_3Data;
}
unsafe extern "C" {
    pub fn iso15693_3_free(data: *mut Iso15693_3Data);
}
unsafe extern "C" {
    pub fn iso15693_3_reset(data: *mut Iso15693_3Data);
}
unsafe extern "C" {
    pub fn iso15693_3_copy(data: *mut Iso15693_3Data, other: *const Iso15693_3Data);
}
unsafe extern "C" {
    pub fn iso15693_3_verify(data: *mut Iso15693_3Data, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn iso15693_3_load(data: *mut Iso15693_3Data, ff: *mut FlipperFormat, version: u32)
    -> bool;
}
unsafe extern "C" {
    pub fn iso15693_3_save(data: *const Iso15693_3Data, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn iso15693_3_is_equal(data: *const Iso15693_3Data, other: *const Iso15693_3Data) -> bool;
}
unsafe extern "C" {
    pub fn iso15693_3_get_device_name(
        data: *const Iso15693_3Data,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn iso15693_3_get_uid(data: *const Iso15693_3Data, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn iso15693_3_set_uid(data: *mut Iso15693_3Data, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn iso15693_3_get_base_data(data: *const Iso15693_3Data) -> *mut Iso15693_3Data;
}
unsafe extern "C" {
    pub fn iso15693_3_is_block_locked(data: *const Iso15693_3Data, block_index: u8) -> bool;
}
unsafe extern "C" {
    pub fn iso15693_3_get_manufacturer_id(data: *const Iso15693_3Data) -> u8;
}
unsafe extern "C" {
    pub fn iso15693_3_get_block_count(data: *const Iso15693_3Data) -> u16;
}
unsafe extern "C" {
    pub fn iso15693_3_get_block_size(data: *const Iso15693_3Data) -> u8;
}
unsafe extern "C" {
    pub fn iso15693_3_get_block_data(data: *const Iso15693_3Data, block_index: u8) -> *const u8;
}
pub type SlixTypeFeatures = u32;
pub const SlixErrorNone: SlixError = SlixError(0);
pub const SlixErrorTimeout: SlixError = SlixError(1);
pub const SlixErrorFormat: SlixError = SlixError(2);
pub const SlixErrorNotSupported: SlixError = SlixError(3);
pub const SlixErrorInternal: SlixError = SlixError(4);
pub const SlixErrorWrongPassword: SlixError = SlixError(5);
pub const SlixErrorUidMismatch: SlixError = SlixError(6);
pub const SlixErrorUnknown: SlixError = SlixError(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SlixError(pub core::ffi::c_uchar);
pub const SlixTypeSlix: SlixType = SlixType(0);
pub const SlixTypeSlixS: SlixType = SlixType(1);
pub const SlixTypeSlixL: SlixType = SlixType(2);
pub const SlixTypeSlix2: SlixType = SlixType(3);
pub const SlixTypeCount: SlixType = SlixType(4);
pub const SlixTypeUnknown: SlixType = SlixType(5);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SlixType(pub core::ffi::c_uchar);
pub const SlixPasswordTypeRead: SlixPasswordType = SlixPasswordType(0);
pub const SlixPasswordTypeWrite: SlixPasswordType = SlixPasswordType(1);
pub const SlixPasswordTypePrivacy: SlixPasswordType = SlixPasswordType(2);
pub const SlixPasswordTypeDestroy: SlixPasswordType = SlixPasswordType(3);
pub const SlixPasswordTypeEasAfi: SlixPasswordType = SlixPasswordType(4);
pub const SlixPasswordTypeCount: SlixPasswordType = SlixPasswordType(5);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SlixPasswordType(pub core::ffi::c_uchar);
pub type SlixPassword = u32;
pub type SlixSignature = [u8; 32usize];
pub type SlixPrivacy = bool;
pub type SlixRandomNumber = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixProtection {
    pub pointer: u8,
    pub condition: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixProtection"][::core::mem::size_of::<SlixProtection>() - 2usize];
    ["Alignment of SlixProtection"][::core::mem::align_of::<SlixProtection>() - 1usize];
    ["Offset of field: SlixProtection::pointer"]
        [::core::mem::offset_of!(SlixProtection, pointer) - 0usize];
    ["Offset of field: SlixProtection::condition"]
        [::core::mem::offset_of!(SlixProtection, condition) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixLockBits {
    pub eas: bool,
    pub ppl: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixLockBits"][::core::mem::size_of::<SlixLockBits>() - 2usize];
    ["Alignment of SlixLockBits"][::core::mem::align_of::<SlixLockBits>() - 1usize];
    ["Offset of field: SlixLockBits::eas"][::core::mem::offset_of!(SlixLockBits, eas) - 0usize];
    ["Offset of field: SlixLockBits::ppl"][::core::mem::offset_of!(SlixLockBits, ppl) - 1usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixSystemInfo {
    pub protection: SlixProtection,
    pub lock_bits: SlixLockBits,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixSystemInfo"][::core::mem::size_of::<SlixSystemInfo>() - 4usize];
    ["Alignment of SlixSystemInfo"][::core::mem::align_of::<SlixSystemInfo>() - 1usize];
    ["Offset of field: SlixSystemInfo::protection"]
        [::core::mem::offset_of!(SlixSystemInfo, protection) - 0usize];
    ["Offset of field: SlixSystemInfo::lock_bits"]
        [::core::mem::offset_of!(SlixSystemInfo, lock_bits) - 2usize];
};
pub const SlixCapabilitiesDefault: SlixCapabilities = SlixCapabilities(0);
pub const SlixCapabilitiesAcceptAllPasswords: SlixCapabilities = SlixCapabilities(1);
pub const SlixCapabilitiesCount: SlixCapabilities = SlixCapabilities(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SlixCapabilities(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixData {
    pub iso15693_3_data: *mut Iso15693_3Data,
    pub system_info: SlixSystemInfo,
    pub signature: SlixSignature,
    pub passwords: [SlixPassword; 5usize],
    pub privacy: SlixPrivacy,
    pub capabilities: SlixCapabilities,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixData"][::core::mem::size_of::<SlixData>() - 64usize];
    ["Alignment of SlixData"][::core::mem::align_of::<SlixData>() - 4usize];
    ["Offset of field: SlixData::iso15693_3_data"]
        [::core::mem::offset_of!(SlixData, iso15693_3_data) - 0usize];
    ["Offset of field: SlixData::system_info"]
        [::core::mem::offset_of!(SlixData, system_info) - 4usize];
    ["Offset of field: SlixData::signature"][::core::mem::offset_of!(SlixData, signature) - 8usize];
    ["Offset of field: SlixData::passwords"]
        [::core::mem::offset_of!(SlixData, passwords) - 40usize];
    ["Offset of field: SlixData::privacy"][::core::mem::offset_of!(SlixData, privacy) - 60usize];
    ["Offset of field: SlixData::capabilities"]
        [::core::mem::offset_of!(SlixData, capabilities) - 61usize];
};
unsafe extern "C" {
    pub fn slix_alloc() -> *mut SlixData;
}
unsafe extern "C" {
    pub fn slix_free(data: *mut SlixData);
}
unsafe extern "C" {
    pub fn slix_reset(data: *mut SlixData);
}
unsafe extern "C" {
    pub fn slix_copy(data: *mut SlixData, other: *const SlixData);
}
unsafe extern "C" {
    pub fn slix_verify(data: *mut SlixData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn slix_load(data: *mut SlixData, ff: *mut FlipperFormat, version: u32) -> bool;
}
unsafe extern "C" {
    pub fn slix_save(data: *const SlixData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn slix_is_equal(data: *const SlixData, other: *const SlixData) -> bool;
}
unsafe extern "C" {
    pub fn slix_get_device_name(
        data: *const SlixData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn slix_get_uid(data: *const SlixData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn slix_set_uid(data: *mut SlixData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn slix_get_base_data(data: *const SlixData) -> *const Iso15693_3Data;
}
unsafe extern "C" {
    pub fn slix_get_type(data: *const SlixData) -> SlixType;
}
unsafe extern "C" {
    pub fn slix_get_password(
        data: *const SlixData,
        password_type: SlixPasswordType,
    ) -> SlixPassword;
}
unsafe extern "C" {
    pub fn slix_get_counter(data: *const SlixData) -> u16;
}
unsafe extern "C" {
    pub fn slix_is_privacy_mode(data: *const SlixData) -> bool;
}
unsafe extern "C" {
    pub fn slix_is_block_protected(
        data: *const SlixData,
        password_type: SlixPasswordType,
        block_num: u8,
    ) -> bool;
}
unsafe extern "C" {
    pub fn slix_is_counter_increment_protected(data: *const SlixData) -> bool;
}
unsafe extern "C" {
    pub fn slix_type_has_features(slix_type: SlixType, features: SlixTypeFeatures) -> bool;
}
unsafe extern "C" {
    pub fn slix_type_supports_password(
        slix_type: SlixType,
        password_type: SlixPasswordType,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixPoller {
    _unused: [u8; 0],
}
#[doc = "< An error occured while reading card."]
pub const SlixPollerEventTypeError: SlixPollerEventType = SlixPollerEventType(0);
#[doc = "< Poller requests password to disable privacy mode."]
pub const SlixPollerEventTypePrivacyUnlockRequest: SlixPollerEventType = SlixPollerEventType(1);
#[doc = "< The card was successfully read by the poller."]
pub const SlixPollerEventTypeReady: SlixPollerEventType = SlixPollerEventType(2);
#[repr(transparent)]
#[doc = "Enumeration of possible Slix poller event types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SlixPollerEventType(pub core::ffi::c_uchar);
#[doc = "Slix poller privacy unlock context data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixPollerEventDataPrivacyUnlockContext {
    #[doc = "< Privacy password."]
    pub password: SlixPassword,
    #[doc = "< Filed to indicate that password was set or not."]
    pub password_set: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixPollerEventDataPrivacyUnlockContext"]
        [::core::mem::size_of::<SlixPollerEventDataPrivacyUnlockContext>() - 8usize];
    ["Alignment of SlixPollerEventDataPrivacyUnlockContext"]
        [::core::mem::align_of::<SlixPollerEventDataPrivacyUnlockContext>() - 4usize];
    ["Offset of field: SlixPollerEventDataPrivacyUnlockContext::password"]
        [::core::mem::offset_of!(SlixPollerEventDataPrivacyUnlockContext, password) - 0usize];
    ["Offset of field: SlixPollerEventDataPrivacyUnlockContext::password_set"]
        [::core::mem::offset_of!(SlixPollerEventDataPrivacyUnlockContext, password_set) - 4usize];
};
#[doc = "Slixs poller event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SlixPollerEventData {
    #[doc = "< Error code indicating card reaing fail reason."]
    pub error: SlixError,
    #[doc = "< Privacy unlock event context."]
    pub privacy_password: SlixPollerEventDataPrivacyUnlockContext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixPollerEventData"][::core::mem::size_of::<SlixPollerEventData>() - 8usize];
    ["Alignment of SlixPollerEventData"][::core::mem::align_of::<SlixPollerEventData>() - 4usize];
    ["Offset of field: SlixPollerEventData::error"]
        [::core::mem::offset_of!(SlixPollerEventData, error) - 0usize];
    ["Offset of field: SlixPollerEventData::privacy_password"]
        [::core::mem::offset_of!(SlixPollerEventData, privacy_password) - 0usize];
};
#[doc = "Slix poller event structure.\n\n Upon emission of an event, an instance of this struct will be passed to the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixPollerEvent {
    #[doc = "< Type of emmitted event."]
    pub type_: SlixPollerEventType,
    #[doc = "< Pointer to event specific data."]
    pub data: *mut SlixPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SlixPollerEvent"][::core::mem::size_of::<SlixPollerEvent>() - 8usize];
    ["Alignment of SlixPollerEvent"][::core::mem::align_of::<SlixPollerEvent>() - 4usize];
    ["Offset of field: SlixPollerEvent::type_"]
        [::core::mem::offset_of!(SlixPollerEvent, type_) - 0usize];
    ["Offset of field: SlixPollerEvent::data"]
        [::core::mem::offset_of!(SlixPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    #[doc = "Transmit and receive Slix frames in poller mode.\n\n Must ONLY be used inside the callback function.\n\n The rx_buffer will be filled with any data received as a response to data\n sent from tx_buffer, with a timeout defined by the fwt parameter.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `tx_buffer` (direction in) - pointer to the buffer containing the data to be transmitted.\n * `rx_buffer` (direction out) - pointer to the buffer to be filled with received data.\n * `fwt` (direction in) - frame wait time (response timeout), in carrier cycles.\n # Returns\n\nSlixErrorNone on success, an error code on failure."]
    pub fn slix_poller_send_frame(
        instance: *mut SlixPoller,
        tx_data: *const BitBuffer,
        rx_data: *mut BitBuffer,
        fwt: u32,
    ) -> SlixError;
}
unsafe extern "C" {
    #[doc = "Send get nxp system info command and parse response.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the SlixSystemInfo structure to be filled.\n # Returns\n\nSlixErrorNone on success, an error code on failure."]
    pub fn slix_poller_get_nxp_system_info(
        instance: *mut SlixPoller,
        data: *mut SlixSystemInfo,
    ) -> SlixError;
}
unsafe extern "C" {
    #[doc = "Read signature from card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the SlixSignature structure to be filled.\n # Returns\n\nSlixErrorNone on success, an error code on failure."]
    pub fn slix_poller_read_signature(
        instance: *mut SlixPoller,
        data: *mut SlixSignature,
    ) -> SlixError;
}
unsafe extern "C" {
    #[doc = "Get random number from card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `data` (direction out) - pointer to the SlixRandomNumber structure to be filled.\n # Returns\n\nSlixErrorNone on success, an error code on failure."]
    pub fn slix_poller_get_random_number(
        instance: *mut SlixPoller,
        data: *mut SlixRandomNumber,
    ) -> SlixError;
}
unsafe extern "C" {
    #[doc = "Set password to card.\n\n Must ONLY be used inside the callback function.\n\n # Arguments\n\n* `instance` (direction in, out) - pointer to the instance to be used in the transaction.\n * `type` (direction in) - SlixPasswordType instance.\n * `password` (direction in) - SlixPassword instance.\n * `random_number` (direction in) - SlixRandomNumber instance.\n # Returns\n\nSlixErrorNone on success, an error code on failure."]
    pub fn slix_poller_set_password(
        instance: *mut SlixPoller,
        type_: SlixPasswordType,
        password: SlixPassword,
        random_number: SlixRandomNumber,
    ) -> SlixError;
}
pub const St25tbErrorNone: St25tbError = St25tbError(0);
pub const St25tbErrorNotPresent: St25tbError = St25tbError(1);
pub const St25tbErrorColResFailed: St25tbError = St25tbError(2);
pub const St25tbErrorBufferOverflow: St25tbError = St25tbError(3);
pub const St25tbErrorCommunication: St25tbError = St25tbError(4);
pub const St25tbErrorFieldOff: St25tbError = St25tbError(5);
pub const St25tbErrorWrongCrc: St25tbError = St25tbError(6);
pub const St25tbErrorTimeout: St25tbError = St25tbError(7);
pub const St25tbErrorWriteFailed: St25tbError = St25tbError(8);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct St25tbError(pub core::ffi::c_uchar);
pub const St25tbType512At: St25tbType = St25tbType(0);
pub const St25tbType512Ac: St25tbType = St25tbType(1);
pub const St25tbTypeX512: St25tbType = St25tbType(2);
pub const St25tbType02k: St25tbType = St25tbType(3);
pub const St25tbType04k: St25tbType = St25tbType(4);
pub const St25tbTypeX4k: St25tbType = St25tbType(5);
pub const St25tbTypeNum: St25tbType = St25tbType(6);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct St25tbType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct St25tbData {
    pub uid: [u8; 8usize],
    pub type_: St25tbType,
    pub blocks: [u32; 128usize],
    pub system_otp_block: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbData"][::core::mem::size_of::<St25tbData>() - 528usize];
    ["Alignment of St25tbData"][::core::mem::align_of::<St25tbData>() - 4usize];
    ["Offset of field: St25tbData::uid"][::core::mem::offset_of!(St25tbData, uid) - 0usize];
    ["Offset of field: St25tbData::type_"][::core::mem::offset_of!(St25tbData, type_) - 8usize];
    ["Offset of field: St25tbData::blocks"][::core::mem::offset_of!(St25tbData, blocks) - 12usize];
    ["Offset of field: St25tbData::system_otp_block"]
        [::core::mem::offset_of!(St25tbData, system_otp_block) - 524usize];
};
unsafe extern "C" {
    pub fn st25tb_alloc() -> *mut St25tbData;
}
unsafe extern "C" {
    pub fn st25tb_free(data: *mut St25tbData);
}
unsafe extern "C" {
    pub fn st25tb_reset(data: *mut St25tbData);
}
unsafe extern "C" {
    pub fn st25tb_copy(data: *mut St25tbData, other: *const St25tbData);
}
unsafe extern "C" {
    pub fn st25tb_verify(data: *mut St25tbData, device_type: *const FuriString) -> bool;
}
unsafe extern "C" {
    pub fn st25tb_load(data: *mut St25tbData, ff: *mut FlipperFormat, version: u32) -> bool;
}
unsafe extern "C" {
    pub fn st25tb_save(data: *const St25tbData, ff: *mut FlipperFormat) -> bool;
}
unsafe extern "C" {
    pub fn st25tb_is_equal(data: *const St25tbData, other: *const St25tbData) -> bool;
}
unsafe extern "C" {
    pub fn st25tb_get_block_count(type_: St25tbType) -> u8;
}
unsafe extern "C" {
    pub fn st25tb_get_device_name(
        data: *const St25tbData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn st25tb_get_uid(data: *const St25tbData, uid_len: *mut usize) -> *const u8;
}
unsafe extern "C" {
    pub fn st25tb_set_uid(data: *mut St25tbData, uid: *const u8, uid_len: usize) -> bool;
}
unsafe extern "C" {
    pub fn st25tb_get_base_data(data: *const St25tbData) -> *mut St25tbData;
}
unsafe extern "C" {
    pub fn st25tb_get_type_from_uid(uid: *const u8) -> St25tbType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct St25tbPoller {
    _unused: [u8; 0],
}
pub const St25tbPollerEventTypeReady: St25tbPollerEventType = St25tbPollerEventType(0);
pub const St25tbPollerEventTypeRequestMode: St25tbPollerEventType = St25tbPollerEventType(1);
pub const St25tbPollerEventTypeFailure: St25tbPollerEventType = St25tbPollerEventType(2);
pub const St25tbPollerEventTypeSuccess: St25tbPollerEventType = St25tbPollerEventType(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct St25tbPollerEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct St25tbPollerReadyData {
    pub type_: St25tbType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbPollerReadyData"][::core::mem::size_of::<St25tbPollerReadyData>() - 1usize];
    ["Alignment of St25tbPollerReadyData"]
        [::core::mem::align_of::<St25tbPollerReadyData>() - 1usize];
    ["Offset of field: St25tbPollerReadyData::type_"]
        [::core::mem::offset_of!(St25tbPollerReadyData, type_) - 0usize];
};
pub const St25tbPollerModeRead: St25tbPollerMode = St25tbPollerMode(0);
pub const St25tbPollerModeWrite: St25tbPollerMode = St25tbPollerMode(1);
pub const St25tbPollerModeNum: St25tbPollerMode = St25tbPollerMode(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct St25tbPollerMode(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct St25tbPollerEventDataModeRequestWriteParams {
    pub block_number: u8,
    pub block_data: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbPollerEventDataModeRequestWriteParams"]
        [::core::mem::size_of::<St25tbPollerEventDataModeRequestWriteParams>() - 8usize];
    ["Alignment of St25tbPollerEventDataModeRequestWriteParams"]
        [::core::mem::align_of::<St25tbPollerEventDataModeRequestWriteParams>() - 4usize];
    ["Offset of field: St25tbPollerEventDataModeRequestWriteParams::block_number"][::core::mem::offset_of!(
        St25tbPollerEventDataModeRequestWriteParams,
        block_number
    ) - 0usize];
    ["Offset of field: St25tbPollerEventDataModeRequestWriteParams::block_data"]
        [::core::mem::offset_of!(St25tbPollerEventDataModeRequestWriteParams, block_data) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union St25tbPollerEventDataModeRequestParams {
    pub write_params: St25tbPollerEventDataModeRequestWriteParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbPollerEventDataModeRequestParams"]
        [::core::mem::size_of::<St25tbPollerEventDataModeRequestParams>() - 8usize];
    ["Alignment of St25tbPollerEventDataModeRequestParams"]
        [::core::mem::align_of::<St25tbPollerEventDataModeRequestParams>() - 4usize];
    ["Offset of field: St25tbPollerEventDataModeRequestParams::write_params"]
        [::core::mem::offset_of!(St25tbPollerEventDataModeRequestParams, write_params) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct St25tbPollerEventDataModeRequest {
    pub mode: St25tbPollerMode,
    pub params: St25tbPollerEventDataModeRequestParams,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbPollerEventDataModeRequest"]
        [::core::mem::size_of::<St25tbPollerEventDataModeRequest>() - 12usize];
    ["Alignment of St25tbPollerEventDataModeRequest"]
        [::core::mem::align_of::<St25tbPollerEventDataModeRequest>() - 4usize];
    ["Offset of field: St25tbPollerEventDataModeRequest::mode"]
        [::core::mem::offset_of!(St25tbPollerEventDataModeRequest, mode) - 0usize];
    ["Offset of field: St25tbPollerEventDataModeRequest::params"]
        [::core::mem::offset_of!(St25tbPollerEventDataModeRequest, params) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union St25tbPollerEventData {
    pub ready: St25tbPollerReadyData,
    pub mode_request: St25tbPollerEventDataModeRequest,
    pub error: St25tbError,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbPollerEventData"][::core::mem::size_of::<St25tbPollerEventData>() - 12usize];
    ["Alignment of St25tbPollerEventData"]
        [::core::mem::align_of::<St25tbPollerEventData>() - 4usize];
    ["Offset of field: St25tbPollerEventData::ready"]
        [::core::mem::offset_of!(St25tbPollerEventData, ready) - 0usize];
    ["Offset of field: St25tbPollerEventData::mode_request"]
        [::core::mem::offset_of!(St25tbPollerEventData, mode_request) - 0usize];
    ["Offset of field: St25tbPollerEventData::error"]
        [::core::mem::offset_of!(St25tbPollerEventData, error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct St25tbPollerEvent {
    pub type_: St25tbPollerEventType,
    pub data: *mut St25tbPollerEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of St25tbPollerEvent"][::core::mem::size_of::<St25tbPollerEvent>() - 8usize];
    ["Alignment of St25tbPollerEvent"][::core::mem::align_of::<St25tbPollerEvent>() - 4usize];
    ["Offset of field: St25tbPollerEvent::type_"]
        [::core::mem::offset_of!(St25tbPollerEvent, type_) - 0usize];
    ["Offset of field: St25tbPollerEvent::data"]
        [::core::mem::offset_of!(St25tbPollerEvent, data) - 4usize];
};
unsafe extern "C" {
    pub fn st25tb_poller_send_frame(
        instance: *mut St25tbPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_initiate(instance: *mut St25tbPoller, chip_id_ptr: *mut u8)
    -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_select(instance: *mut St25tbPoller, chip_id_ptr: *mut u8) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_get_uid(instance: *mut St25tbPoller, uid: *mut u8) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_read_block(
        instance: *mut St25tbPoller,
        block: *mut u32,
        block_number: u8,
    ) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_write_block(
        instance: *mut St25tbPoller,
        block: u32,
        block_number: u8,
    ) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_halt(instance: *mut St25tbPoller) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_sync_read_block(
        nfc: *mut Nfc,
        block_num: u8,
        block: *mut u32,
    ) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_sync_write_block(nfc: *mut Nfc, block_num: u8, block: u32) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_sync_detect_type(nfc: *mut Nfc, type_: *mut St25tbType) -> St25tbError;
}
unsafe extern "C" {
    pub fn st25tb_poller_sync_read(nfc: *mut Nfc, data: *mut St25tbData) -> St25tbError;
}
unsafe extern "C" {
    pub fn maxim_crc8(data: *const u8, data_size: u8, crc_init: u8) -> u8;
}
#[doc = "< Search for alarmed device"]
pub const OneWireHostSearchModeConditional: OneWireHostSearchMode = OneWireHostSearchMode(0);
#[doc = "< Search for all devices"]
pub const OneWireHostSearchModeNormal: OneWireHostSearchMode = OneWireHostSearchMode(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OneWireHostSearchMode(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireHost {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate OneWireHost instance\n # Arguments\n\n* `[in]` - gpio_pin connection pin\n # Returns\n\npointer to OneWireHost instance"]
    pub fn onewire_host_alloc(gpio_pin: *const GpioPin) -> *mut OneWireHost;
}
unsafe extern "C" {
    #[doc = "Destroy OneWireHost instance, free resources\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance"]
    pub fn onewire_host_free(host: *mut OneWireHost);
}
unsafe extern "C" {
    #[doc = "Reset the 1-Wire bus\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n # Returns\n\ntrue if presence was detected, false otherwise"]
    pub fn onewire_host_reset(host: *mut OneWireHost) -> bool;
}
unsafe extern "C" {
    #[doc = "Read one bit\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n # Returns\n\nreceived bit value"]
    pub fn onewire_host_read_bit(host: *mut OneWireHost) -> bool;
}
unsafe extern "C" {
    #[doc = "Read one byte\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n # Returns\n\nreceived byte value"]
    pub fn onewire_host_read(host: *mut OneWireHost) -> u8;
}
unsafe extern "C" {
    #[doc = "Read one or more bytes\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `[out]` - buffer received data buffer\n * `[in]` - count number of bytes to read"]
    pub fn onewire_host_read_bytes(host: *mut OneWireHost, buffer: *mut u8, count: u16);
}
unsafe extern "C" {
    #[doc = "Write one bit\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `value` - bit value to write"]
    pub fn onewire_host_write_bit(host: *mut OneWireHost, value: bool);
}
unsafe extern "C" {
    #[doc = "Write one byte\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `value` - byte value to write"]
    pub fn onewire_host_write(host: *mut OneWireHost, value: u8);
}
unsafe extern "C" {
    #[doc = "Write one or more bytes\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `[in]` - buffer pointer to the data to write\n * `[in]` - count size of the data to write"]
    pub fn onewire_host_write_bytes(host: *mut OneWireHost, buffer: *const u8, count: u16);
}
unsafe extern "C" {
    #[doc = "Start working with the bus\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance"]
    pub fn onewire_host_start(host: *mut OneWireHost);
}
unsafe extern "C" {
    #[doc = "Stop working with the bus\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance"]
    pub fn onewire_host_stop(host: *mut OneWireHost);
}
unsafe extern "C" {
    #[doc = "Reset previous search results\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance"]
    pub fn onewire_host_reset_search(host: *mut OneWireHost);
}
unsafe extern "C" {
    #[doc = "Set the family code to search for\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `[in]` - family_code device family code"]
    pub fn onewire_host_target_search(host: *mut OneWireHost, family_code: u8);
}
unsafe extern "C" {
    #[doc = "Search for devices on the 1-Wire bus\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `[out]` - new_addr pointer to the buffer to contain the unique ROM of the found device\n * `[in]` - mode search mode\n # Returns\n\ntrue on success, false otherwise"]
    pub fn onewire_host_search(
        host: *mut OneWireHost,
        new_addr: *mut u8,
        mode: OneWireHostSearchMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Enable overdrive mode\n # Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n * `[in]` - set true to turn overdrive on, false to turn it off"]
    pub fn onewire_host_set_overdrive(host: *mut OneWireHost, set: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireSlave {
    _unused: [u8; 0],
}
pub type OneWireSlaveResetCallback = ::core::option::Option<
    unsafe extern "C" fn(is_short: bool, context: *mut core::ffi::c_void) -> bool,
>;
pub type OneWireSlaveCommandCallback = ::core::option::Option<
    unsafe extern "C" fn(command: u8, context: *mut core::ffi::c_void) -> bool,
>;
pub type OneWireSlaveResultCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Allocate OneWireSlave instance\n # Arguments\n\n* `[in]` - gpio_pin connection pin\n # Returns\n\npointer to OneWireSlave instance"]
    pub fn onewire_slave_alloc(gpio_pin: *const GpioPin) -> *mut OneWireSlave;
}
unsafe extern "C" {
    #[doc = "Destroy OneWireSlave instance, free resources\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance"]
    pub fn onewire_slave_free(bus: *mut OneWireSlave);
}
unsafe extern "C" {
    #[doc = "Start working with the bus\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance"]
    pub fn onewire_slave_start(bus: *mut OneWireSlave);
}
unsafe extern "C" {
    #[doc = "Stop working with the bus\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance"]
    pub fn onewire_slave_stop(bus: *mut OneWireSlave);
}
unsafe extern "C" {
    #[doc = "Receive one bit\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n # Returns\n\nreceived bit value"]
    pub fn onewire_slave_receive_bit(bus: *mut OneWireSlave) -> bool;
}
unsafe extern "C" {
    #[doc = "Send one bit\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[in]` - value bit value to send\n # Returns\n\ntrue on success, false on failure"]
    pub fn onewire_slave_send_bit(bus: *mut OneWireSlave, value: bool) -> bool;
}
unsafe extern "C" {
    #[doc = "Send one or more bytes of data\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[in]` - data pointer to the data to send\n * `[in]` - data_size size of the data to send\n # Returns\n\ntrue on success, false on failure"]
    pub fn onewire_slave_send(bus: *mut OneWireSlave, data: *const u8, data_size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Receive one or more bytes of data\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[out]` - data pointer to the receive buffer\n * `[in]` - data_size number of bytes to receive\n # Returns\n\ntrue on success, false on failure"]
    pub fn onewire_slave_receive(bus: *mut OneWireSlave, data: *mut u8, data_size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Enable overdrive mode\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[in]` - set true to turn overdrive on, false to turn it off"]
    pub fn onewire_slave_set_overdrive(bus: *mut OneWireSlave, set: bool);
}
unsafe extern "C" {
    #[doc = "Set a callback function to be called on each reset.\n The return value of the callback determines whether the emulated device\n supports the short reset (passed as the is_short parameter).\n In most applications, it should also call onewire_slave_set_overdrive()\n to set the appropriate speed mode.\n\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[in]` - callback pointer to a callback function\n * `[in]` - context additional parameter to be passed to the callback"]
    pub fn onewire_slave_set_reset_callback(
        bus: *mut OneWireSlave,
        callback: OneWireSlaveResetCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set a callback function to be called on each command.\n The return value of the callback determines whether further operation\n is possible. As a rule of thumb, return true unless a critical error happened.\n\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[in]` - callback pointer to a callback function\n * `[in]` - context additional parameter to be passed to the callback"]
    pub fn onewire_slave_set_command_callback(
        bus: *mut OneWireSlave,
        callback: OneWireSlaveCommandCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set a callback to report emulation success\n # Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n * `[in]` - result_cb pointer to a callback function\n * `[in]` - context additional parameter to be passed to the callback"]
    pub fn onewire_slave_set_result_callback(
        bus: *mut OneWireSlave,
        result_cb: OneWireSlaveResultCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn __wrap_printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_vsnprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_puts(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_putchar(ch: core::ffi::c_int) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_putc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_snprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_fflush(stream: *mut FILE) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_fgetc(stream: *mut FILE) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_getc(stream: *mut FILE) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_getchar() -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap_fgets(
        str_: *mut core::ffi::c_char,
        n: usize,
        stream: *mut FILE,
    ) -> *mut core::ffi::c_char;
}
unsafe extern "C" {
    pub fn __wrap_ungetc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __wrap___assert(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        e: *const core::ffi::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __wrap___assert_func(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        e: *const core::ffi::c_char,
    ) -> !;
}
pub const SignalReaderEventTypeHalfBufferFilled: SignalReaderEventType = SignalReaderEventType(0);
pub const SignalReaderEventTypeFullBufferFilled: SignalReaderEventType = SignalReaderEventType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SignalReaderEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalReaderEventData {
    pub data: *mut u8,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SignalReaderEventData"][::core::mem::size_of::<SignalReaderEventData>() - 8usize];
    ["Alignment of SignalReaderEventData"]
        [::core::mem::align_of::<SignalReaderEventData>() - 4usize];
    ["Offset of field: SignalReaderEventData::data"]
        [::core::mem::offset_of!(SignalReaderEventData, data) - 0usize];
    ["Offset of field: SignalReaderEventData::len"]
        [::core::mem::offset_of!(SignalReaderEventData, len) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalReaderEvent {
    pub type_: SignalReaderEventType,
    pub data: *mut SignalReaderEventData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SignalReaderEvent"][::core::mem::size_of::<SignalReaderEvent>() - 8usize];
    ["Alignment of SignalReaderEvent"][::core::mem::align_of::<SignalReaderEvent>() - 4usize];
    ["Offset of field: SignalReaderEvent::type_"]
        [::core::mem::offset_of!(SignalReaderEvent, type_) - 0usize];
    ["Offset of field: SignalReaderEvent::data"]
        [::core::mem::offset_of!(SignalReaderEvent, data) - 4usize];
};
pub const SignalReaderTimeUnit64Mhz: SignalReaderTimeUnit = SignalReaderTimeUnit(0);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SignalReaderTimeUnit(pub core::ffi::c_uchar);
pub const SignalReaderPolarityNormal: SignalReaderPolarity = SignalReaderPolarity(0);
pub const SignalReaderPolarityInverted: SignalReaderPolarity = SignalReaderPolarity(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SignalReaderPolarity(pub core::ffi::c_uchar);
pub const SignalReaderTriggerNone: SignalReaderTrigger = SignalReaderTrigger(0);
pub const SignalReaderTriggerRisingFallingEdge: SignalReaderTrigger = SignalReaderTrigger(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SignalReaderTrigger(pub core::ffi::c_uchar);
pub type SignalReaderCallback = ::core::option::Option<
    unsafe extern "C" fn(event: SignalReaderEvent, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalReader {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn signal_reader_alloc(gpio_pin: *const GpioPin, size: u32) -> *mut SignalReader;
}
unsafe extern "C" {
    pub fn signal_reader_free(instance: *mut SignalReader);
}
unsafe extern "C" {
    pub fn signal_reader_set_pull(instance: *mut SignalReader, pull: GpioPull);
}
unsafe extern "C" {
    pub fn signal_reader_set_polarity(instance: *mut SignalReader, polarity: SignalReaderPolarity);
}
unsafe extern "C" {
    pub fn signal_reader_set_sample_rate(
        instance: *mut SignalReader,
        time_unit: SignalReaderTimeUnit,
        time: u32,
    );
}
unsafe extern "C" {
    pub fn signal_reader_set_trigger(instance: *mut SignalReader, trigger: SignalReaderTrigger);
}
unsafe extern "C" {
    pub fn signal_reader_start(
        instance: *mut SignalReader,
        callback: SignalReaderCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn signal_reader_stop(instance: *mut SignalReader);
}
#[doc = "Structure definition of some features of COMP instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_COMP_InitTypeDef {
    #[doc = "< Set comparator operating mode to adjust power and speed.\nThis parameter can be a value of COMP_LL_EC_POWERMODE\n\nThis feature can be modified afterwards using unitary function LL_COMP_SetPowerMode()."]
    pub PowerMode: u32,
    #[doc = "< Set comparator input plus (non-inverting input).\nThis parameter can be a value of COMP_LL_EC_INPUT_PLUS\n\nThis feature can be modified afterwards using unitary function LL_COMP_SetInputPlus()."]
    pub InputPlus: u32,
    #[doc = "< Set comparator input minus (inverting input).\nThis parameter can be a value of COMP_LL_EC_INPUT_MINUS\n\nThis feature can be modified afterwards using unitary function LL_COMP_SetInputMinus()."]
    pub InputMinus: u32,
    #[doc = "< Set comparator hysteresis mode of the input minus.\nThis parameter can be a value of COMP_LL_EC_INPUT_HYSTERESIS\n\nThis feature can be modified afterwards using unitary function LL_COMP_SetInputHysteresis()."]
    pub InputHysteresis: u32,
    #[doc = "< Set comparator output polarity.\nThis parameter can be a value of COMP_LL_EC_OUTPUT_POLARITY\n\nThis feature can be modified afterwards using unitary function LL_COMP_SetOutputPolarity()."]
    pub OutputPolarity: u32,
    #[doc = "< Set comparator blanking source.\nThis parameter can be a value of COMP_LL_EC_OUTPUT_BLANKING_SOURCE\n\nThis feature can be modified afterwards using unitary function LL_COMP_SetOutputBlankingSource()."]
    pub OutputBlankingSource: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_COMP_InitTypeDef"][::core::mem::size_of::<LL_COMP_InitTypeDef>() - 24usize];
    ["Alignment of LL_COMP_InitTypeDef"][::core::mem::align_of::<LL_COMP_InitTypeDef>() - 4usize];
    ["Offset of field: LL_COMP_InitTypeDef::PowerMode"]
        [::core::mem::offset_of!(LL_COMP_InitTypeDef, PowerMode) - 0usize];
    ["Offset of field: LL_COMP_InitTypeDef::InputPlus"]
        [::core::mem::offset_of!(LL_COMP_InitTypeDef, InputPlus) - 4usize];
    ["Offset of field: LL_COMP_InitTypeDef::InputMinus"]
        [::core::mem::offset_of!(LL_COMP_InitTypeDef, InputMinus) - 8usize];
    ["Offset of field: LL_COMP_InitTypeDef::InputHysteresis"]
        [::core::mem::offset_of!(LL_COMP_InitTypeDef, InputHysteresis) - 12usize];
    ["Offset of field: LL_COMP_InitTypeDef::OutputPolarity"]
        [::core::mem::offset_of!(LL_COMP_InitTypeDef, OutputPolarity) - 16usize];
    ["Offset of field: LL_COMP_InitTypeDef::OutputBlankingSource"]
        [::core::mem::offset_of!(LL_COMP_InitTypeDef, OutputBlankingSource) - 20usize];
};
unsafe extern "C" {
    pub fn LL_COMP_Init(
        COMPx: *mut COMP_TypeDef,
        COMP_InitStruct: *const LL_COMP_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "DMA_LL_ES_INIT DMA Exported Init structure\n # "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_DMA_InitTypeDef {
    #[doc = "< Specifies the peripheral base address for DMA transfer\nor as Source base address in case of memory to memory transfer direction.\n\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
    pub PeriphOrM2MSrcAddress: u32,
    #[doc = "< Specifies the memory base address for DMA transfer\nor as Destination base address in case of memory to memory transfer direction.\n\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
    pub MemoryOrM2MDstAddress: u32,
    #[doc = "< Specifies if the data will be transferred from memory to peripheral,\nfrom memory to memory or from peripheral to memory.\nThis parameter can be a value of DMA_LL_EC_DIRECTION\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetDataTransferDirection()."]
    pub Direction: u32,
    #[doc = "< Specifies the normal or circular operation mode.\nThis parameter can be a value of DMA_LL_EC_MODE\nThe circular buffer mode cannot be used if the memory to memory\ndata transfer direction is configured on the selected Channel\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetMode()."]
    pub Mode: u32,
    #[doc = "< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction\nis incremented or not.\nThis parameter can be a value of DMA_LL_EC_PERIPH\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetPeriphIncMode()."]
    pub PeriphOrM2MSrcIncMode: u32,
    #[doc = "< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction\nis incremented or not.\nThis parameter can be a value of DMA_LL_EC_MEMORY\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetMemoryIncMode()."]
    pub MemoryOrM2MDstIncMode: u32,
    #[doc = "< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)\nin case of memory to memory transfer direction.\nThis parameter can be a value of DMA_LL_EC_PDATAALIGN\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetPeriphSize()."]
    pub PeriphOrM2MSrcDataSize: u32,
    #[doc = "< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)\nin case of memory to memory transfer direction.\nThis parameter can be a value of DMA_LL_EC_MDATAALIGN\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetMemorySize()."]
    pub MemoryOrM2MDstDataSize: u32,
    #[doc = "< Specifies the number of data to transfer, in data unit.\nThe data unit is equal to the source buffer configuration set in PeripheralSize\nor MemorySize parameters depending in the transfer direction.\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetDataLength()."]
    pub NbData: u32,
    #[doc = "< Specifies the peripheral request.\nThis parameter can be a value of DMAMUX_LL_EC_REQUEST\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetPeriphRequest()."]
    pub PeriphRequest: u32,
    #[doc = "< Specifies the channel priority level.\nThis parameter can be a value of DMA_LL_EC_PRIORITY\n\nThis feature can be modified afterwards using unitary function LL_DMA_SetChannelPriorityLevel()."]
    pub Priority: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_DMA_InitTypeDef"][::core::mem::size_of::<LL_DMA_InitTypeDef>() - 44usize];
    ["Alignment of LL_DMA_InitTypeDef"][::core::mem::align_of::<LL_DMA_InitTypeDef>() - 4usize];
    ["Offset of field: LL_DMA_InitTypeDef::PeriphOrM2MSrcAddress"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, PeriphOrM2MSrcAddress) - 0usize];
    ["Offset of field: LL_DMA_InitTypeDef::MemoryOrM2MDstAddress"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, MemoryOrM2MDstAddress) - 4usize];
    ["Offset of field: LL_DMA_InitTypeDef::Direction"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, Direction) - 8usize];
    ["Offset of field: LL_DMA_InitTypeDef::Mode"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, Mode) - 12usize];
    ["Offset of field: LL_DMA_InitTypeDef::PeriphOrM2MSrcIncMode"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, PeriphOrM2MSrcIncMode) - 16usize];
    ["Offset of field: LL_DMA_InitTypeDef::MemoryOrM2MDstIncMode"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, MemoryOrM2MDstIncMode) - 20usize];
    ["Offset of field: LL_DMA_InitTypeDef::PeriphOrM2MSrcDataSize"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, PeriphOrM2MSrcDataSize) - 24usize];
    ["Offset of field: LL_DMA_InitTypeDef::MemoryOrM2MDstDataSize"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, MemoryOrM2MDstDataSize) - 28usize];
    ["Offset of field: LL_DMA_InitTypeDef::NbData"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, NbData) - 32usize];
    ["Offset of field: LL_DMA_InitTypeDef::PeriphRequest"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, PeriphRequest) - 36usize];
    ["Offset of field: LL_DMA_InitTypeDef::Priority"]
        [::core::mem::offset_of!(LL_DMA_InitTypeDef, Priority) - 40usize];
};
unsafe extern "C" {
    #[doc = "DMA_LL_EF_Init Initialization and de-initialization functions\n # "]
    pub fn LL_DMA_Init(
        DMAx: *mut DMA_TypeDef,
        Channel: u32,
        DMA_InitStruct: *mut LL_DMA_InitTypeDef,
    ) -> ErrorStatus;
}
unsafe extern "C" {
    pub fn LL_DMA_DeInit(DMAx: *mut DMA_TypeDef, Channel: u32) -> ErrorStatus;
}
#[doc = "LPTIM Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPTIM_InitTypeDef {
    #[doc = "< Specifies the source of the clock used by the LPTIM instance.\nThis parameter can be a value of LPTIM_LL_EC_CLK_SOURCE.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPTIM_SetClockSource()."]
    pub ClockSource: u32,
    #[doc = "< Specifies the prescaler division ratio.\nThis parameter can be a value of LPTIM_LL_EC_PRESCALER.\n\nThis feature can be modified afterwards using using unitary\nfunction LL_LPTIM_SetPrescaler()."]
    pub Prescaler: u32,
    #[doc = "< Specifies the waveform shape.\nThis parameter can be a value of LPTIM_LL_EC_OUTPUT_WAVEFORM.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPTIM_ConfigOutput()."]
    pub Waveform: u32,
    #[doc = "< Specifies waveform polarity.\nThis parameter can be a value of LPTIM_LL_EC_OUTPUT_POLARITY.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPTIM_ConfigOutput()."]
    pub Polarity: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_LPTIM_InitTypeDef"][::core::mem::size_of::<LL_LPTIM_InitTypeDef>() - 16usize];
    ["Alignment of LL_LPTIM_InitTypeDef"][::core::mem::align_of::<LL_LPTIM_InitTypeDef>() - 4usize];
    ["Offset of field: LL_LPTIM_InitTypeDef::ClockSource"]
        [::core::mem::offset_of!(LL_LPTIM_InitTypeDef, ClockSource) - 0usize];
    ["Offset of field: LL_LPTIM_InitTypeDef::Prescaler"]
        [::core::mem::offset_of!(LL_LPTIM_InitTypeDef, Prescaler) - 4usize];
    ["Offset of field: LL_LPTIM_InitTypeDef::Waveform"]
        [::core::mem::offset_of!(LL_LPTIM_InitTypeDef, Waveform) - 8usize];
    ["Offset of field: LL_LPTIM_InitTypeDef::Polarity"]
        [::core::mem::offset_of!(LL_LPTIM_InitTypeDef, Polarity) - 12usize];
};
unsafe extern "C" {
    #[doc = "LPTIM_LL_EF_Init Initialisation and deinitialisation functions\n # "]
    pub fn LL_LPTIM_DeInit(LPTIMx: *mut LPTIM_TypeDef) -> ErrorStatus;
}
unsafe extern "C" {
    pub fn LL_LPTIM_Init(
        LPTIMx: *mut LPTIM_TypeDef,
        LPTIM_InitStruct: *const LL_LPTIM_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "LL LPUART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPUART_InitTypeDef {
    #[doc = "< Specifies the Prescaler to compute the communication baud rate.\nThis parameter can be a value of LPUART_LL_EC_PRESCALER.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetPrescaler()."]
    pub PrescalerValue: u32,
    #[doc = "< This field defines expected LPUART communication baud rate.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetBaudRate()."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of LPUART_LL_EC_DATAWIDTH.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the number of stop bits transmitted.\nThis parameter can be a value of LPUART_LL_EC_STOPBITS.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetStopBitsLength()."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode.\nThis parameter can be a value of LPUART_LL_EC_PARITY.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetParity()."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled.\nThis parameter can be a value of LPUART_LL_EC_DIRECTION.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of LPUART_LL_EC_HWCONTROL.\n\nThis feature can be modified afterwards using unitary\nfunction LL_LPUART_SetHWFlowCtrl()."]
    pub HardwareFlowControl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_LPUART_InitTypeDef"][::core::mem::size_of::<LL_LPUART_InitTypeDef>() - 28usize];
    ["Alignment of LL_LPUART_InitTypeDef"]
        [::core::mem::align_of::<LL_LPUART_InitTypeDef>() - 4usize];
    ["Offset of field: LL_LPUART_InitTypeDef::PrescalerValue"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, PrescalerValue) - 0usize];
    ["Offset of field: LL_LPUART_InitTypeDef::BaudRate"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, BaudRate) - 4usize];
    ["Offset of field: LL_LPUART_InitTypeDef::DataWidth"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, DataWidth) - 8usize];
    ["Offset of field: LL_LPUART_InitTypeDef::StopBits"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, StopBits) - 12usize];
    ["Offset of field: LL_LPUART_InitTypeDef::Parity"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, Parity) - 16usize];
    ["Offset of field: LL_LPUART_InitTypeDef::TransferDirection"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, TransferDirection) - 20usize];
    ["Offset of field: LL_LPUART_InitTypeDef::HardwareFlowControl"]
        [::core::mem::offset_of!(LL_LPUART_InitTypeDef, HardwareFlowControl) - 24usize];
};
unsafe extern "C" {
    pub fn LL_LPUART_Init(
        LPUARTx: *mut USART_TypeDef,
        LPUART_InitStruct: *const LL_LPUART_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "RTC Init structures definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_RTC_InitTypeDef {
    #[doc = "< Specifies the RTC Hours Format.\nThis parameter can be a value of RTC_LL_EC_HOURFORMAT\n\nThis feature can be modified afterwards using unitary function\nLL_RTC_SetHourFormat()."]
    pub HourFormat: u32,
    #[doc = "< Specifies the RTC Asynchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F\n\nThis feature can be modified afterwards using unitary function\nLL_RTC_SetAsynchPrescaler()."]
    pub AsynchPrescaler: u32,
    #[doc = "< Specifies the RTC Synchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF\n\nThis feature can be modified afterwards using unitary function\nLL_RTC_SetSynchPrescaler()."]
    pub SynchPrescaler: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_RTC_InitTypeDef"][::core::mem::size_of::<LL_RTC_InitTypeDef>() - 12usize];
    ["Alignment of LL_RTC_InitTypeDef"][::core::mem::align_of::<LL_RTC_InitTypeDef>() - 4usize];
    ["Offset of field: LL_RTC_InitTypeDef::HourFormat"]
        [::core::mem::offset_of!(LL_RTC_InitTypeDef, HourFormat) - 0usize];
    ["Offset of field: LL_RTC_InitTypeDef::AsynchPrescaler"]
        [::core::mem::offset_of!(LL_RTC_InitTypeDef, AsynchPrescaler) - 4usize];
    ["Offset of field: LL_RTC_InitTypeDef::SynchPrescaler"]
        [::core::mem::offset_of!(LL_RTC_InitTypeDef, SynchPrescaler) - 8usize];
};
unsafe extern "C" {
    pub fn LL_RTC_Init(
        RTCx: *mut RTC_TypeDef,
        RTC_InitStruct: *mut LL_RTC_InitTypeDef,
    ) -> ErrorStatus;
}
unsafe extern "C" {
    pub fn LL_RTC_EnterInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
#[doc = "LL USART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_USART_InitTypeDef {
    #[doc = "< Specifies the Prescaler to compute the communication baud rate.\nThis parameter can be a value of USART_LL_EC_PRESCALER.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetPrescaler()."]
    pub PrescalerValue: u32,
    #[doc = "< This field defines expected Usart communication baud rate.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetBaudRate()."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of USART_LL_EC_DATAWIDTH.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the number of stop bits transmitted.\nThis parameter can be a value of USART_LL_EC_STOPBITS.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetStopBitsLength()."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode.\nThis parameter can be a value of USART_LL_EC_PARITY.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetParity()."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled.\nThis parameter can be a value of USART_LL_EC_DIRECTION.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of USART_LL_EC_HWCONTROL.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetHWFlowCtrl()."]
    pub HardwareFlowControl: u32,
    #[doc = "< Specifies whether USART oversampling mode is 16 or 8.\nThis parameter can be a value of USART_LL_EC_OVERSAMPLING.\n\nThis feature can be modified afterwards using unitary\nfunction LL_USART_SetOverSampling()."]
    pub OverSampling: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LL_USART_InitTypeDef"][::core::mem::size_of::<LL_USART_InitTypeDef>() - 32usize];
    ["Alignment of LL_USART_InitTypeDef"][::core::mem::align_of::<LL_USART_InitTypeDef>() - 4usize];
    ["Offset of field: LL_USART_InitTypeDef::PrescalerValue"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, PrescalerValue) - 0usize];
    ["Offset of field: LL_USART_InitTypeDef::BaudRate"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, BaudRate) - 4usize];
    ["Offset of field: LL_USART_InitTypeDef::DataWidth"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, DataWidth) - 8usize];
    ["Offset of field: LL_USART_InitTypeDef::StopBits"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, StopBits) - 12usize];
    ["Offset of field: LL_USART_InitTypeDef::Parity"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, Parity) - 16usize];
    ["Offset of field: LL_USART_InitTypeDef::TransferDirection"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, TransferDirection) - 20usize];
    ["Offset of field: LL_USART_InitTypeDef::HardwareFlowControl"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, HardwareFlowControl) - 24usize];
    ["Offset of field: LL_USART_InitTypeDef::OverSampling"]
        [::core::mem::offset_of!(LL_USART_InitTypeDef, OverSampling) - 28usize];
};
unsafe extern "C" {
    pub fn LL_USART_Init(
        USARTx: *mut USART_TypeDef,
        USART_InitStruct: *const LL_USART_InitTypeDef,
    ) -> ErrorStatus;
}
unsafe extern "C" {
    #[doc = "UTILS_EF_SYSTEM SYSTEM\n # "]
    pub fn LL_SetSystemCoreClock(HCLKFrequency: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockConst {
    pub te_long: u16,
    pub te_short: u16,
    pub te_delta: u16,
    pub min_count_bit_for_found: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzBlockConst"][::core::mem::size_of::<SubGhzBlockConst>() - 8usize];
    ["Alignment of SubGhzBlockConst"][::core::mem::align_of::<SubGhzBlockConst>() - 2usize];
    ["Offset of field: SubGhzBlockConst::te_long"]
        [::core::mem::offset_of!(SubGhzBlockConst, te_long) - 0usize];
    ["Offset of field: SubGhzBlockConst::te_short"]
        [::core::mem::offset_of!(SubGhzBlockConst, te_short) - 2usize];
    ["Offset of field: SubGhzBlockConst::te_delta"]
        [::core::mem::offset_of!(SubGhzBlockConst, te_delta) - 4usize];
    ["Offset of field: SubGhzBlockConst::min_count_bit_for_found"]
        [::core::mem::offset_of!(SubGhzBlockConst, min_count_bit_for_found) - 6usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockDecoder {
    pub parser_step: u32,
    pub te_last: u32,
    pub decode_data: u64,
    pub decode_count_bit: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzBlockDecoder"][::core::mem::size_of::<SubGhzBlockDecoder>() - 24usize];
    ["Alignment of SubGhzBlockDecoder"][::core::mem::align_of::<SubGhzBlockDecoder>() - 8usize];
    ["Offset of field: SubGhzBlockDecoder::parser_step"]
        [::core::mem::offset_of!(SubGhzBlockDecoder, parser_step) - 0usize];
    ["Offset of field: SubGhzBlockDecoder::te_last"]
        [::core::mem::offset_of!(SubGhzBlockDecoder, te_last) - 4usize];
    ["Offset of field: SubGhzBlockDecoder::decode_data"]
        [::core::mem::offset_of!(SubGhzBlockDecoder, decode_data) - 8usize];
    ["Offset of field: SubGhzBlockDecoder::decode_count_bit"]
        [::core::mem::offset_of!(SubGhzBlockDecoder, decode_count_bit) - 16usize];
};
unsafe extern "C" {
    #[doc = "Add data bit when decoding.\n # Arguments\n\n* `decoder` - Pointer to a SubGhzBlockDecoder instance\n * `bit` - data, 1bit"]
    pub fn subghz_protocol_blocks_add_bit(decoder: *mut SubGhzBlockDecoder, bit: u8);
}
unsafe extern "C" {
    #[doc = "Add data to_128 bit when decoding.\n # Arguments\n\n* `decoder` - Pointer to a SubGhzBlockDecoder instance\n * `head_64_bit` - Pointer to a head_64_bit\n * `bit` - data, 1bit"]
    pub fn subghz_protocol_blocks_add_to_128_bit(
        decoder: *mut SubGhzBlockDecoder,
        bit: u8,
        head_64_bit: *mut u64,
    );
}
unsafe extern "C" {
    #[doc = "Getting the hash sum of the last randomly received parcel.\n # Arguments\n\n* `decoder` - Pointer to a SubGhzBlockDecoder instance\n # Returns\n\nhash Hash sum"]
    pub fn subghz_protocol_blocks_get_hash_data(decoder: *mut SubGhzBlockDecoder, len: usize)
    -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolBlockEncoder {
    pub is_running: bool,
    pub repeat: usize,
    pub front: usize,
    pub size_upload: usize,
    pub upload: *mut LevelDuration,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocolBlockEncoder"]
        [::core::mem::size_of::<SubGhzProtocolBlockEncoder>() - 20usize];
    ["Alignment of SubGhzProtocolBlockEncoder"]
        [::core::mem::align_of::<SubGhzProtocolBlockEncoder>() - 4usize];
    ["Offset of field: SubGhzProtocolBlockEncoder::is_running"]
        [::core::mem::offset_of!(SubGhzProtocolBlockEncoder, is_running) - 0usize];
    ["Offset of field: SubGhzProtocolBlockEncoder::repeat"]
        [::core::mem::offset_of!(SubGhzProtocolBlockEncoder, repeat) - 4usize];
    ["Offset of field: SubGhzProtocolBlockEncoder::front"]
        [::core::mem::offset_of!(SubGhzProtocolBlockEncoder, front) - 8usize];
    ["Offset of field: SubGhzProtocolBlockEncoder::size_upload"]
        [::core::mem::offset_of!(SubGhzProtocolBlockEncoder, size_upload) - 12usize];
    ["Offset of field: SubGhzProtocolBlockEncoder::upload"]
        [::core::mem::offset_of!(SubGhzProtocolBlockEncoder, upload) - 16usize];
};
pub const SubGhzProtocolBlockAlignBitLeft: SubGhzProtocolBlockAlignBit =
    SubGhzProtocolBlockAlignBit(0);
pub const SubGhzProtocolBlockAlignBitRight: SubGhzProtocolBlockAlignBit =
    SubGhzProtocolBlockAlignBit(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SubGhzProtocolBlockAlignBit(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Set data bit when encoding HEX array.\n # Arguments\n\n* `bit_value` - The value of the bit to be set\n * `data_array` - Pointer to a HEX array\n * `set_index_bit` - Number set a bit in the array starting from the left\n * `max_size_array` - array size, check not to overflow"]
    pub fn subghz_protocol_blocks_set_bit_array(
        bit_value: bool,
        data_array: *mut u8,
        set_index_bit: usize,
        max_size_array: usize,
    );
}
unsafe extern "C" {
    #[doc = "Get data bit when encoding HEX array.\n # Arguments\n\n* `data_array` - Pointer to a HEX array\n * `read_index_bit` - Number get a bit in the array starting from the left\n # Returns\n\nbool value bit"]
    pub fn subghz_protocol_blocks_get_bit_array(data_array: *mut u8, read_index_bit: usize)
    -> bool;
}
unsafe extern "C" {
    #[doc = "Generating an upload from data.\n # Arguments\n\n* `data_array` - Pointer to a HEX array\n * `count_bit_data_array` - How many bits in the array are processed\n * `upload` - Pointer to a LevelDuration\n * `max_size_upload` - upload size, check not to overflow\n * `duration_bit` - duration 1 bit\n * `align_bit` - alignment of useful bits in an array"]
    pub fn subghz_protocol_blocks_get_upload_from_bit_array(
        data_array: *mut u8,
        count_bit_data_array: usize,
        upload: *mut LevelDuration,
        max_size_upload: usize,
        duration_bit: u32,
        align_bit: SubGhzProtocolBlockAlignBit,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzEnvironment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolRegistry {
    pub items: *mut *const SubGhzProtocol,
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocolRegistry"][::core::mem::size_of::<SubGhzProtocolRegistry>() - 8usize];
    ["Alignment of SubGhzProtocolRegistry"]
        [::core::mem::align_of::<SubGhzProtocolRegistry>() - 4usize];
    ["Offset of field: SubGhzProtocolRegistry::items"]
        [::core::mem::offset_of!(SubGhzProtocolRegistry, items) - 0usize];
    ["Offset of field: SubGhzProtocolRegistry::size"]
        [::core::mem::offset_of!(SubGhzProtocolRegistry, size) - 4usize];
};
unsafe extern "C" {
    #[doc = "Registration by name SubGhzProtocol.\n # Arguments\n\n* `protocol_registry` - SubGhzProtocolRegistry\n * `name` - Protocol name\n # Returns\n\nSubGhzProtocol* pointer to a SubGhzProtocol instance"]
    pub fn subghz_protocol_registry_get_by_name(
        protocol_registry: *const SubGhzProtocolRegistry,
        name: *const core::ffi::c_char,
    ) -> *const SubGhzProtocol;
}
unsafe extern "C" {
    #[doc = "Registration protocol by index in array SubGhzProtocol.\n # Arguments\n\n* `protocol_registry` - SubGhzProtocolRegistry\n * `index` - Protocol by index in array\n # Returns\n\nSubGhzProtocol* pointer to a SubGhzProtocol instance"]
    pub fn subghz_protocol_registry_get_by_index(
        protocol_registry: *const SubGhzProtocolRegistry,
        index: usize,
    ) -> *const SubGhzProtocol;
}
unsafe extern "C" {
    #[doc = "Getting the number of registered protocols.\n # Arguments\n\n* `protocol_registry` - SubGhzProtocolRegistry\n # Returns\n\nNumber of protocols"]
    pub fn subghz_protocol_registry_count(
        protocol_registry: *const SubGhzProtocolRegistry,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKey {
    pub name: *mut FuriString,
    pub key: u64,
    pub type_: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzKey"][::core::mem::size_of::<SubGhzKey>() - 24usize];
    ["Alignment of SubGhzKey"][::core::mem::align_of::<SubGhzKey>() - 8usize];
    ["Offset of field: SubGhzKey::name"][::core::mem::offset_of!(SubGhzKey, name) - 0usize];
    ["Offset of field: SubGhzKey::key"][::core::mem::offset_of!(SubGhzKey, key) - 8usize];
    ["Offset of field: SubGhzKey::type_"][::core::mem::offset_of!(SubGhzKey, type_) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKeyArray_s {
    pub size: usize,
    pub alloc: usize,
    pub ptr: *mut SubGhzKey,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzKeyArray_s"][::core::mem::size_of::<SubGhzKeyArray_s>() - 12usize];
    ["Alignment of SubGhzKeyArray_s"][::core::mem::align_of::<SubGhzKeyArray_s>() - 4usize];
    ["Offset of field: SubGhzKeyArray_s::size"]
        [::core::mem::offset_of!(SubGhzKeyArray_s, size) - 0usize];
    ["Offset of field: SubGhzKeyArray_s::alloc"]
        [::core::mem::offset_of!(SubGhzKeyArray_s, alloc) - 4usize];
    ["Offset of field: SubGhzKeyArray_s::ptr"]
        [::core::mem::offset_of!(SubGhzKeyArray_s, ptr) - 8usize];
};
pub type SubGhzKeyArray_t = [SubGhzKeyArray_s; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKeyArray_it_s {
    pub index: usize,
    pub array: *const SubGhzKeyArray_s,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzKeyArray_it_s"][::core::mem::size_of::<SubGhzKeyArray_it_s>() - 8usize];
    ["Alignment of SubGhzKeyArray_it_s"][::core::mem::align_of::<SubGhzKeyArray_it_s>() - 4usize];
    ["Offset of field: SubGhzKeyArray_it_s::index"]
        [::core::mem::offset_of!(SubGhzKeyArray_it_s, index) - 0usize];
    ["Offset of field: SubGhzKeyArray_it_s::array"]
        [::core::mem::offset_of!(SubGhzKeyArray_it_s, array) - 4usize];
};
pub type SubGhzKeyArray_it_t = [SubGhzKeyArray_it_s; 1usize];
pub type SubGhzKeyArray_ptr = *mut SubGhzKeyArray_s;
pub type SubGhzKeyArray_srcptr = *const SubGhzKeyArray_s;
pub type SubGhzKeyArray_ct = SubGhzKeyArray_t;
pub type SubGhzKeyArray_it_ct = SubGhzKeyArray_it_t;
pub type SubGhzKeyArray_subtype_ct = SubGhzKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKeystore {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate SubGhzEnvironment.\n # Returns\n\nSubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_alloc() -> *mut SubGhzEnvironment;
}
unsafe extern "C" {
    #[doc = "Free SubGhzEnvironment.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_free(instance: *mut SubGhzEnvironment);
}
unsafe extern "C" {
    #[doc = "Downloading the manufacture key file.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n * `filename` - Full path to the file\n # Returns\n\ntrue On success"]
    pub fn subghz_environment_load_keystore(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get pointer to a SubGhzKeystore* instance.\n # Returns\n\nSubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_get_keystore(instance: *mut SubGhzEnvironment)
    -> *mut SubGhzKeystore;
}
unsafe extern "C" {
    #[doc = "Set filename to work with Came Atomo.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n * `filename` - Full path to the file"]
    pub fn subghz_environment_set_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Get filename to work with Came Atomo.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nFull path to the file"]
    pub fn subghz_environment_get_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Set filename to work with Alutech at-4n.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n * `filename` - Full path to the file"]
    pub fn subghz_environment_set_alutech_at_4n_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Get filename to work with Alutech at-4n.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nFull path to the file"]
    pub fn subghz_environment_get_alutech_at_4n_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Set filename to work with Nice Flor-S.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n * `filename` - Full path to the file"]
    pub fn subghz_environment_set_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Get filename to work with Nice Flor-S.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nFull path to the file"]
    pub fn subghz_environment_get_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = "Set list of protocols to work.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n * `protocol_registry_items` - Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_set_protocol_registry(
        instance: *mut SubGhzEnvironment,
        protocol_registry_items: *const SubGhzProtocolRegistry,
    );
}
unsafe extern "C" {
    #[doc = "Get list of protocols to work.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nPointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_get_protocol_registry(
        instance: *mut SubGhzEnvironment,
    ) -> *const SubGhzProtocolRegistry;
}
unsafe extern "C" {
    #[doc = "Get list of protocols names.\n # Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n * `idx` - index protocols\n # Returns\n\nPointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_get_protocol_name_registry(
        instance: *mut SubGhzEnvironment,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzRadioPreset {
    pub name: *mut FuriString,
    pub frequency: u32,
    pub data: *mut u8,
    pub data_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzRadioPreset"][::core::mem::size_of::<SubGhzRadioPreset>() - 16usize];
    ["Alignment of SubGhzRadioPreset"][::core::mem::align_of::<SubGhzRadioPreset>() - 4usize];
    ["Offset of field: SubGhzRadioPreset::name"]
        [::core::mem::offset_of!(SubGhzRadioPreset, name) - 0usize];
    ["Offset of field: SubGhzRadioPreset::frequency"]
        [::core::mem::offset_of!(SubGhzRadioPreset, frequency) - 4usize];
    ["Offset of field: SubGhzRadioPreset::data"]
        [::core::mem::offset_of!(SubGhzRadioPreset, data) - 8usize];
    ["Offset of field: SubGhzRadioPreset::data_size"]
        [::core::mem::offset_of!(SubGhzRadioPreset, data_size) - 12usize];
};
pub const SubGhzProtocolStatusOk: SubGhzProtocolStatus = SubGhzProtocolStatus(0);
#[doc = "< General unclassified error"]
pub const SubGhzProtocolStatusError: SubGhzProtocolStatus = SubGhzProtocolStatus(-1);
#[doc = "< Missing or invalid file header"]
pub const SubGhzProtocolStatusErrorParserHeader: SubGhzProtocolStatus = SubGhzProtocolStatus(-2);
#[doc = "< Missing `Frequency`"]
pub const SubGhzProtocolStatusErrorParserFrequency: SubGhzProtocolStatus = SubGhzProtocolStatus(-3);
#[doc = "< Missing `Preset`"]
pub const SubGhzProtocolStatusErrorParserPreset: SubGhzProtocolStatus = SubGhzProtocolStatus(-4);
#[doc = "< Missing `Custom_preset_module`"]
pub const SubGhzProtocolStatusErrorParserCustomPreset: SubGhzProtocolStatus =
    SubGhzProtocolStatus(-5);
#[doc = "< Missing `Protocol` name"]
pub const SubGhzProtocolStatusErrorParserProtocolName: SubGhzProtocolStatus =
    SubGhzProtocolStatus(-6);
#[doc = "< Missing `Bit`"]
pub const SubGhzProtocolStatusErrorParserBitCount: SubGhzProtocolStatus = SubGhzProtocolStatus(-7);
#[doc = "< Missing `Key`"]
pub const SubGhzProtocolStatusErrorParserKey: SubGhzProtocolStatus = SubGhzProtocolStatus(-8);
#[doc = "< Missing `Te`"]
pub const SubGhzProtocolStatusErrorParserTe: SubGhzProtocolStatus = SubGhzProtocolStatus(-9);
#[doc = "< Missing some other mandatory keys"]
pub const SubGhzProtocolStatusErrorParserOthers: SubGhzProtocolStatus = SubGhzProtocolStatus(-10);
#[doc = "< Invalid bit count value"]
pub const SubGhzProtocolStatusErrorValueBitCount: SubGhzProtocolStatus = SubGhzProtocolStatus(-11);
#[doc = "< Payload encoder failure"]
pub const SubGhzProtocolStatusErrorEncoderGetUpload: SubGhzProtocolStatus =
    SubGhzProtocolStatus(-12);
#[doc = "< Protocol not found"]
pub const SubGhzProtocolStatusErrorProtocolNotFound: SubGhzProtocolStatus =
    SubGhzProtocolStatus(-13);
#[doc = "< Prevents enum down-size compiler optimization."]
pub const SubGhzProtocolStatusReserved: SubGhzProtocolStatus = SubGhzProtocolStatus(2147483647);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SubGhzProtocolStatus(pub core::ffi::c_int);
pub type SubGhzAlloc = ::core::option::Option<
    unsafe extern "C" fn(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void,
>;
pub type SubGhzFree = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzSerialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> SubGhzProtocolStatus,
>;
pub type SubGhzDeserialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus,
>;
pub type SubGhzDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, level: bool, duration: u32),
>;
pub type SubGhzDecoderReset =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void)>;
pub type SubGhzGetHashData =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void) -> u8>;
pub type SubGhzGetString = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, output: *mut FuriString),
>;
pub type SubGhzEncoderStop =
    ::core::option::Option<unsafe extern "C" fn(encoder: *mut core::ffi::c_void)>;
pub type SubGhzEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub feed: SubGhzDecoderFeed,
    pub reset: SubGhzDecoderReset,
    pub get_hash_data: SubGhzGetHashData,
    pub get_string: SubGhzGetString,
    pub serialize: SubGhzSerialize,
    pub deserialize: SubGhzDeserialize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocolDecoder"][::core::mem::size_of::<SubGhzProtocolDecoder>() - 32usize];
    ["Alignment of SubGhzProtocolDecoder"]
        [::core::mem::align_of::<SubGhzProtocolDecoder>() - 4usize];
    ["Offset of field: SubGhzProtocolDecoder::alloc"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, alloc) - 0usize];
    ["Offset of field: SubGhzProtocolDecoder::free"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, free) - 4usize];
    ["Offset of field: SubGhzProtocolDecoder::feed"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, feed) - 8usize];
    ["Offset of field: SubGhzProtocolDecoder::reset"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, reset) - 12usize];
    ["Offset of field: SubGhzProtocolDecoder::get_hash_data"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, get_hash_data) - 16usize];
    ["Offset of field: SubGhzProtocolDecoder::get_string"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, get_string) - 20usize];
    ["Offset of field: SubGhzProtocolDecoder::serialize"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, serialize) - 24usize];
    ["Offset of field: SubGhzProtocolDecoder::deserialize"]
        [::core::mem::offset_of!(SubGhzProtocolDecoder, deserialize) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub deserialize: SubGhzDeserialize,
    pub stop: SubGhzEncoderStop,
    pub yield_: SubGhzEncoderYield,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocolEncoder"][::core::mem::size_of::<SubGhzProtocolEncoder>() - 20usize];
    ["Alignment of SubGhzProtocolEncoder"]
        [::core::mem::align_of::<SubGhzProtocolEncoder>() - 4usize];
    ["Offset of field: SubGhzProtocolEncoder::alloc"]
        [::core::mem::offset_of!(SubGhzProtocolEncoder, alloc) - 0usize];
    ["Offset of field: SubGhzProtocolEncoder::free"]
        [::core::mem::offset_of!(SubGhzProtocolEncoder, free) - 4usize];
    ["Offset of field: SubGhzProtocolEncoder::deserialize"]
        [::core::mem::offset_of!(SubGhzProtocolEncoder, deserialize) - 8usize];
    ["Offset of field: SubGhzProtocolEncoder::stop"]
        [::core::mem::offset_of!(SubGhzProtocolEncoder, stop) - 12usize];
    ["Offset of field: SubGhzProtocolEncoder::yield_"]
        [::core::mem::offset_of!(SubGhzProtocolEncoder, yield_) - 16usize];
};
pub const SubGhzProtocolTypeUnknown: SubGhzProtocolType = SubGhzProtocolType(0);
pub const SubGhzProtocolTypeStatic: SubGhzProtocolType = SubGhzProtocolType(1);
pub const SubGhzProtocolTypeDynamic: SubGhzProtocolType = SubGhzProtocolType(2);
pub const SubGhzProtocolTypeRAW: SubGhzProtocolType = SubGhzProtocolType(3);
pub const SubGhzProtocolWeatherStation: SubGhzProtocolType = SubGhzProtocolType(4);
pub const SubGhzProtocolCustom: SubGhzProtocolType = SubGhzProtocolType(5);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SubGhzProtocolType(pub core::ffi::c_uchar);
pub const SubGhzProtocolFlag_RAW: SubGhzProtocolFlag = SubGhzProtocolFlag(1);
pub const SubGhzProtocolFlag_Decodable: SubGhzProtocolFlag = SubGhzProtocolFlag(2);
pub const SubGhzProtocolFlag_315: SubGhzProtocolFlag = SubGhzProtocolFlag(4);
pub const SubGhzProtocolFlag_433: SubGhzProtocolFlag = SubGhzProtocolFlag(8);
pub const SubGhzProtocolFlag_868: SubGhzProtocolFlag = SubGhzProtocolFlag(16);
pub const SubGhzProtocolFlag_AM: SubGhzProtocolFlag = SubGhzProtocolFlag(32);
pub const SubGhzProtocolFlag_FM: SubGhzProtocolFlag = SubGhzProtocolFlag(64);
pub const SubGhzProtocolFlag_Save: SubGhzProtocolFlag = SubGhzProtocolFlag(128);
pub const SubGhzProtocolFlag_Load: SubGhzProtocolFlag = SubGhzProtocolFlag(256);
pub const SubGhzProtocolFlag_Send: SubGhzProtocolFlag = SubGhzProtocolFlag(512);
pub const SubGhzProtocolFlag_BinRAW: SubGhzProtocolFlag = SubGhzProtocolFlag(1024);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SubGhzProtocolFlag(pub core::ffi::c_ushort);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocol {
    pub name: *const core::ffi::c_char,
    pub type_: SubGhzProtocolType,
    pub flag: SubGhzProtocolFlag,
    pub encoder: *const SubGhzProtocolEncoder,
    pub decoder: *const SubGhzProtocolDecoder,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocol"][::core::mem::size_of::<SubGhzProtocol>() - 16usize];
    ["Alignment of SubGhzProtocol"][::core::mem::align_of::<SubGhzProtocol>() - 4usize];
    ["Offset of field: SubGhzProtocol::name"]
        [::core::mem::offset_of!(SubGhzProtocol, name) - 0usize];
    ["Offset of field: SubGhzProtocol::type_"]
        [::core::mem::offset_of!(SubGhzProtocol, type_) - 4usize];
    ["Offset of field: SubGhzProtocol::flag"]
        [::core::mem::offset_of!(SubGhzProtocol, flag) - 6usize];
    ["Offset of field: SubGhzProtocol::encoder"]
        [::core::mem::offset_of!(SubGhzProtocol, encoder) - 8usize];
    ["Offset of field: SubGhzProtocol::decoder"]
        [::core::mem::offset_of!(SubGhzProtocol, decoder) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockGeneric {
    pub protocol_name: *const core::ffi::c_char,
    pub data: u64,
    pub serial: u32,
    pub data_count_bit: u16,
    pub btn: u8,
    pub cnt: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzBlockGeneric"][::core::mem::size_of::<SubGhzBlockGeneric>() - 32usize];
    ["Alignment of SubGhzBlockGeneric"][::core::mem::align_of::<SubGhzBlockGeneric>() - 8usize];
    ["Offset of field: SubGhzBlockGeneric::protocol_name"]
        [::core::mem::offset_of!(SubGhzBlockGeneric, protocol_name) - 0usize];
    ["Offset of field: SubGhzBlockGeneric::data"]
        [::core::mem::offset_of!(SubGhzBlockGeneric, data) - 8usize];
    ["Offset of field: SubGhzBlockGeneric::serial"]
        [::core::mem::offset_of!(SubGhzBlockGeneric, serial) - 16usize];
    ["Offset of field: SubGhzBlockGeneric::data_count_bit"]
        [::core::mem::offset_of!(SubGhzBlockGeneric, data_count_bit) - 20usize];
    ["Offset of field: SubGhzBlockGeneric::btn"]
        [::core::mem::offset_of!(SubGhzBlockGeneric, btn) - 22usize];
    ["Offset of field: SubGhzBlockGeneric::cnt"]
        [::core::mem::offset_of!(SubGhzBlockGeneric, cnt) - 24usize];
};
unsafe extern "C" {
    #[doc = "Get name preset.\n # Arguments\n\n* `preset_name` - name preset\n * `preset_str` - Output name preset"]
    pub fn subghz_block_generic_get_preset_name(
        preset_name: *const core::ffi::c_char,
        preset_str: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Serialize data SubGhzBlockGeneric.\n # Arguments\n\n* `instance` - Pointer to a SubGhzBlockGeneric instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n * `preset` - The modulation on which the signal was received, SubGhzRadioPreset\n # Returns\n\nStatus Error"]
    pub fn subghz_block_generic_serialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Deserialize data SubGhzBlockGeneric.\n # Arguments\n\n* `instance` - Pointer to a SubGhzBlockGeneric instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n # Returns\n\nStatus Error"]
    pub fn subghz_block_generic_deserialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Deserialize data SubGhzBlockGeneric.\n # Arguments\n\n* `instance` - Pointer to a SubGhzBlockGeneric instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n * `count_bit` - Count bit protocol\n # Returns\n\nStatus Error"]
    pub fn subghz_block_generic_deserialize_check_count_bit(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
        count_bit: u16,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Flip the data bitwise\n\n # Arguments\n\n* `key` - In data\n * `bit_count` - number of data bits\n\n # Returns\n\nReverse data"]
    pub fn subghz_protocol_blocks_reverse_key(key: u64, bit_count: u8) -> u64;
}
unsafe extern "C" {
    #[doc = "Get parity the data bitwise\n\n # Arguments\n\n* `key` - In data\n * `bit_count` - number of data bits\n\n # Returns\n\nparity"]
    pub fn subghz_protocol_blocks_get_parity(key: u64, bit_count: u8) -> u8;
}
unsafe extern "C" {
    #[doc = "CRC-4\n\n # Arguments\n\n* `message` - array of bytes to check\n * `size` - number of bytes in message\n * `polynomial` - CRC polynomial\n * `init` - starting crc value\n\n # Returns\n\nCRC value"]
    pub fn subghz_protocol_blocks_crc4(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "CRC-7\n\n # Arguments\n\n* `message` - array of bytes to check\n * `size` - number of bytes in message\n * `polynomial` - CRC polynomial\n * `init` - starting crc value\n\n # Returns\n\nCRC value"]
    pub fn subghz_protocol_blocks_crc7(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Generic Cyclic Redundancy Check CRC-8. Example polynomial: 0x31 = x8 + x5 +\n x4 + 1 (x8 is implicit) Example polynomial: 0x80 = x8 + x7 (a normal\n bit-by-bit parity XOR)\n\n # Arguments\n\n* `message` - array of bytes to check\n * `size` - number of bytes in message\n * `polynomial` - byte is from x^7 to x^0 (x^8 is implicitly one)\n * `init` - starting crc value\n\n # Returns\n\nCRC value"]
    pub fn subghz_protocol_blocks_crc8(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "\"Little-endian\" Cyclic Redundancy Check CRC-8 LE Input and output are\n reflected, i.e. least significant bit is shifted in first\n\n # Arguments\n\n* `message` - array of bytes to check\n * `size` - number of bytes in message\n * `polynomial` - CRC polynomial\n * `init` - starting crc value\n\n # Returns\n\nCRC value"]
    pub fn subghz_protocol_blocks_crc8le(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "CRC-16 LSB. Input and output are reflected, i.e. least significant bit is\n shifted in first. Note that poly and init already need to be reflected\n\n # Arguments\n\n* `message` - array of bytes to check\n * `size` - number of bytes in message\n * `polynomial` - CRC polynomial\n * `init` - starting crc value\n\n # Returns\n\nCRC value"]
    pub fn subghz_protocol_blocks_crc16lsb(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = "CRC-16\n\n # Arguments\n\n* `message` - array of bytes to check\n * `size` - number of bytes in message\n * `polynomial` - CRC polynomial\n * `init` - starting crc value\n\n # Returns\n\nCRC value"]
    pub fn subghz_protocol_blocks_crc16(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = "Digest-8 by \"LFSR-based Toeplitz hash\"\n\n # Arguments\n\n* `message` - bytes of message data\n * `size` - number of bytes to digest\n * `gen` - key stream generator, needs to includes the MSB if the\n LFSR is rolling\n * `key` - initial key\n\n # Returns\n\ndigest value"]
    pub fn subghz_protocol_blocks_lfsr_digest8(
        message: *const u8,
        size: usize,
        gen_: u8,
        key: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Digest-8 by \"LFSR-based Toeplitz hash\", byte reflect, bit reflect\n\n # Arguments\n\n* `message` - bytes of message data\n * `size` - number of bytes to digest\n * `gen` - key stream generator, needs to includes the MSB if the\n LFSR is rolling\n * `key` - initial key\n\n # Returns\n\ndigest value"]
    pub fn subghz_protocol_blocks_lfsr_digest8_reflect(
        message: *const u8,
        size: usize,
        gen_: u8,
        key: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = "Digest-16 by \"LFSR-based Toeplitz hash\"\n\n # Arguments\n\n* `message` - bytes of message data\n * `size` - number of bytes to digest\n * `gen` - key stream generator, needs to includes the MSB if the\n LFSR is rolling\n * `key` - initial key\n\n # Returns\n\ndigest value"]
    pub fn subghz_protocol_blocks_lfsr_digest16(
        message: *const u8,
        size: usize,
        gen_: u16,
        key: u16,
    ) -> u16;
}
unsafe extern "C" {
    #[doc = "Compute Addition of a number of bytes\n\n # Arguments\n\n* `message` - bytes of message data\n * `size` - number of bytes to sum\n\n # Returns\n\nsummation value"]
    pub fn subghz_protocol_blocks_add_bytes(message: *const u8, size: usize) -> u8;
}
unsafe extern "C" {
    #[doc = "Compute bit parity of a single byte (8 bits)\n\n # Arguments\n\n* `byte` - single byte to check\n\n # Returns\n\n1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_parity8(byte: u8) -> u8;
}
unsafe extern "C" {
    #[doc = "Compute bit parity of a number of bytes\n\n # Arguments\n\n* `message` - bytes of message data\n * `size` - number of bytes to sum\n\n # Returns\n\n1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_parity_bytes(message: *const u8, size: usize) -> u8;
}
unsafe extern "C" {
    #[doc = "Compute XOR (byte-wide parity) of a number of bytes\n\n # Arguments\n\n* `message` - bytes of message data\n * `size` - number of bytes to sum\n\n # Returns\n\nsummation value, per bit-position 1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_xor_bytes(message: *const u8, size: usize) -> u8;
}
unsafe extern "C" {
    pub static subghz_device_cc1101_preset_ook_270khz_async_regs: [u8; 0usize];
}
unsafe extern "C" {
    pub static subghz_device_cc1101_preset_ook_650khz_async_regs: [u8; 0usize];
}
unsafe extern "C" {
    pub static subghz_device_cc1101_preset_2fsk_dev2_38khz_async_regs: [u8; 0usize];
}
unsafe extern "C" {
    pub static subghz_device_cc1101_preset_2fsk_dev47_6khz_async_regs: [u8; 0usize];
}
unsafe extern "C" {
    pub static subghz_device_cc1101_preset_msk_99_97kb_async_regs: [u8; 0usize];
}
unsafe extern "C" {
    pub static subghz_device_cc1101_preset_gfsk_9_99kb_async_regs: [u8; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDeviceCC1101Int {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Key generation from simple data.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderSecPlus_v2 instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n * `serial` - Serial number, 32 bit\n * `btn` - Button number, 8 bit\n * `cnt` - Container value, 28 bit\n * `manufacture_name` - Name of manufacturer's key\n * `preset` - Modulation, SubGhzRadioPreset\n # Returns\n\ntrue On success"]
    pub fn subghz_protocol_secplus_v2_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u32,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Key generation from simple data.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderKeeloq instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n * `serial` - Serial number, 28 bit\n * `btn` - Button number, 4 bit\n * `cnt` - Container value, 16 bit\n * `manufacture_name` - Name of manufacturer's key\n * `preset` - Modulation, SubGhzRadioPreset\n # Returns\n\ntrue On success"]
    pub fn subghz_protocol_keeloq_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        manufacture_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderBinRAW {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn subghz_protocol_decoder_bin_raw_data_input_rssi(
        instance: *mut SubGhzProtocolDecoderBinRAW,
        rssi: f32,
    );
}
unsafe extern "C" {
    #[doc = "Validation of fixed parts SubGhzProtocolDecoderSecPlus_v1.\n # Arguments\n\n* `fixed` - fixed parts\n # Returns\n\ntrue On success"]
    pub fn subghz_protocol_secplus_v1_check_fixed(fixed: u32) -> bool;
}
pub type SubGhzProtocolDecoderBaseRxCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut SubGhzProtocolDecoderBase, context: *mut core::ffi::c_void),
>;
pub type SubGhzProtocolDecoderBaseSerialize = ::core::option::Option<
    unsafe extern "C" fn(decoder_base: *mut SubGhzProtocolDecoderBase, output: *mut FuriString),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderBase {
    pub protocol: *const SubGhzProtocol,
    pub callback: SubGhzProtocolDecoderBaseRxCallback,
    pub context: *mut core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocolDecoderBase"]
        [::core::mem::size_of::<SubGhzProtocolDecoderBase>() - 12usize];
    ["Alignment of SubGhzProtocolDecoderBase"]
        [::core::mem::align_of::<SubGhzProtocolDecoderBase>() - 4usize];
    ["Offset of field: SubGhzProtocolDecoderBase::protocol"]
        [::core::mem::offset_of!(SubGhzProtocolDecoderBase, protocol) - 0usize];
    ["Offset of field: SubGhzProtocolDecoderBase::callback"]
        [::core::mem::offset_of!(SubGhzProtocolDecoderBase, callback) - 4usize];
    ["Offset of field: SubGhzProtocolDecoderBase::context"]
        [::core::mem::offset_of!(SubGhzProtocolDecoderBase, context) - 8usize];
};
unsafe extern "C" {
    #[doc = "Getting a textual representation of the received data.\n # Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n * `output` - Resulting text"]
    pub fn subghz_protocol_decoder_base_get_string(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        output: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Serialize data SubGhzProtocolDecoderBase.\n # Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n * `preset` - The modulation on which the signal was received, SubGhzRadioPreset\n # Returns\n\nStatus Error"]
    pub fn subghz_protocol_decoder_base_serialize(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Deserialize data SubGhzProtocolDecoderBase.\n # Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n # Returns\n\nStatus Error"]
    pub fn subghz_protocol_decoder_base_deserialize(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Getting the hash sum of the last randomly received parcel.\n # Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n # Returns\n\nhash Hash sum"]
    pub fn subghz_protocol_decoder_base_get_hash_data(
        decoder_base: *mut SubGhzProtocolDecoderBase,
    ) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderBase {
    pub protocol: *const SubGhzProtocol,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SubGhzProtocolEncoderBase"]
        [::core::mem::size_of::<SubGhzProtocolEncoderBase>() - 4usize];
    ["Alignment of SubGhzProtocolEncoderBase"]
        [::core::mem::align_of::<SubGhzProtocolEncoderBase>() - 4usize];
    ["Offset of field: SubGhzProtocolEncoderBase::protocol"]
        [::core::mem::offset_of!(SubGhzProtocolEncoderBase, protocol) - 0usize];
};
pub type SubGhzProtocolEncoderRAWCallbackEnd =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderRAW {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderRAW {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub static subghz_protocol_raw_decoder: SubGhzProtocolDecoder;
}
unsafe extern "C" {
    pub static subghz_protocol_raw_encoder: SubGhzProtocolEncoder;
}
unsafe extern "C" {
    pub static subghz_protocol_raw: SubGhzProtocol;
}
unsafe extern "C" {
    #[doc = "Open file for writing\n # Arguments\n\n* `instance` - Pointer to a SubGhzProtocolDecoderRAW instance\n * `dev_name` - File name\n * `preset` - The modulation on which the signal was received, SubGhzRadioPreset\n # Returns\n\ntrue On success"]
    pub fn subghz_protocol_raw_save_to_file_init(
        instance: *mut SubGhzProtocolDecoderRAW,
        dev_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Stop writing file to flash\n # Arguments\n\n* `instance` - Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_raw_save_to_file_stop(instance: *mut SubGhzProtocolDecoderRAW);
}
unsafe extern "C" {
    #[doc = "Get the number of samples received SubGhzProtocolDecoderRAW.\n # Arguments\n\n* `instance` - Pointer to a SubGhzProtocolDecoderRAW instance\n # Returns\n\ncount of samples"]
    pub fn subghz_protocol_raw_get_sample_write(instance: *mut SubGhzProtocolDecoderRAW) -> usize;
}
unsafe extern "C" {
    #[doc = "Allocate SubGhzProtocolDecoderRAW.\n # Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nSubGhzProtocolDecoderRAW* pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Free SubGhzProtocolDecoderRAW.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_free(context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Reset decoder SubGhzProtocolDecoderRAW.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_reset(context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Parse a raw sequence of levels and durations received from the air.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n * `level` - Signal level true-high false-low\n * `duration` - Duration of this level in, us"]
    pub fn subghz_protocol_decoder_raw_feed(
        context: *mut core::ffi::c_void,
        level: bool,
        duration: u32,
    );
}
unsafe extern "C" {
    #[doc = "Deserialize data SubGhzProtocolDecoderRAW.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n # Returns\n\nstatus"]
    pub fn subghz_protocol_decoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Getting a textual representation of the received data.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n * `output` - Resulting text"]
    pub fn subghz_protocol_decoder_raw_get_string(
        context: *mut core::ffi::c_void,
        output: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Allocate SubGhzProtocolEncoderRAW.\n # Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nSubGhzProtocolEncoderRAW* pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Free SubGhzProtocolEncoderRAW.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_free(context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Forced transmission stop.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_stop(context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "pause writing to flash.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n * `pause` - pause writing"]
    pub fn subghz_protocol_raw_save_to_file_pause(
        instance: *mut SubGhzProtocolDecoderRAW,
        pause: bool,
    );
}
unsafe extern "C" {
    #[doc = "Set callback on completion of file transfer.\n # Arguments\n\n* `instance` - Pointer to a SubGhzProtocolEncoderRAW instance\n * `callback_end` - Callback, SubGhzProtocolEncoderRAWCallbackEnd\n * `context_end` - Context"]
    pub fn subghz_protocol_raw_file_encoder_worker_set_callback_end(
        instance: *mut SubGhzProtocolEncoderRAW,
        callback_end: SubGhzProtocolEncoderRAWCallbackEnd,
        context_end: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "File generation for RAW work.\n # Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n * `file_path` - File path\n * `radio_dev_name` - Radio device name"]
    pub fn subghz_protocol_raw_gen_fff_data(
        flipper_format: *mut FlipperFormat,
        file_path: *const core::ffi::c_char,
        radio_dev_name: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Deserialize and generating an upload to send.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n # Returns\n\nstatus"]
    pub fn subghz_protocol_encoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Getting the level and duration of the upload to be loaded into DMA.\n # Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n # Returns\n\nLevelDuration"]
    pub fn subghz_protocol_encoder_raw_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzReceiver {
    _unused: [u8; 0],
}
pub type SubGhzReceiverCallback = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut SubGhzReceiver,
        decoder_base: *mut SubGhzProtocolDecoderBase,
        context: *mut core::ffi::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = "Allocate and init SubGhzReceiver.\n # Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nSubGhzReceiver* pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_alloc_init(environment: *mut SubGhzEnvironment) -> *mut SubGhzReceiver;
}
unsafe extern "C" {
    #[doc = "Free SubGhzReceiver.\n # Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_free(instance: *mut SubGhzReceiver);
}
unsafe extern "C" {
    #[doc = "Parse a raw sequence of levels and durations received from the air.\n # Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n * `level` - Signal level true-high false-low\n * `duration` - Duration of this level in, us"]
    pub fn subghz_receiver_decode(instance: *mut SubGhzReceiver, level: bool, duration: u32);
}
unsafe extern "C" {
    #[doc = "Reset decoder SubGhzReceiver.\n # Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_reset(instance: *mut SubGhzReceiver);
}
unsafe extern "C" {
    #[doc = "Set a callback upon completion of successful decoding of one of the protocols.\n # Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n * `callback` - Callback, SubGhzReceiverCallback\n * `context` - Context"]
    pub fn subghz_receiver_set_rx_callback(
        instance: *mut SubGhzReceiver,
        callback: SubGhzReceiverCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Set the filter of receivers that will work at the moment.\n # Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n * `filter` - Filter, SubGhzProtocolFlag"]
    pub fn subghz_receiver_set_filter(instance: *mut SubGhzReceiver, filter: SubGhzProtocolFlag);
}
unsafe extern "C" {
    #[doc = "Search for a cattery by his name.\n # Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n * `decoder_name` - Receiver name\n # Returns\n\nSubGhzProtocolDecoderBase* pointer to a SubGhzProtocolDecoderBase instance"]
    pub fn subghz_receiver_search_decoder_base_by_name(
        instance: *mut SubGhzReceiver,
        decoder_name: *const core::ffi::c_char,
    ) -> *mut SubGhzProtocolDecoderBase;
}
pub type SubGhzFileEncoderWorkerCallbackEnd =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzFileEncoderWorker {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "End callback SubGhzWorker.\n # Arguments\n\n* `instance` - SubGhzFileEncoderWorker instance\n * `callback` - SubGhzFileEncoderWorkerCallbackEnd callback"]
    pub fn subghz_file_encoder_worker_callback_end(
        instance: *mut SubGhzFileEncoderWorker,
        callback_end: SubGhzFileEncoderWorkerCallbackEnd,
        context_end: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Allocate SubGhzFileEncoderWorker.\n # Returns\n\nSubGhzFileEncoderWorker* pointer to a SubGhzFileEncoderWorker instance"]
    pub fn subghz_file_encoder_worker_alloc() -> *mut SubGhzFileEncoderWorker;
}
unsafe extern "C" {
    #[doc = "Free SubGhzFileEncoderWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance"]
    pub fn subghz_file_encoder_worker_free(instance: *mut SubGhzFileEncoderWorker);
}
unsafe extern "C" {
    #[doc = "Getting the level and duration of the upload to be loaded into DMA.\n # Arguments\n\n* `context` - Pointer to a SubGhzFileEncoderWorker instance\n # Returns\n\nLevelDuration"]
    pub fn subghz_file_encoder_worker_get_level_duration(
        context: *mut core::ffi::c_void,
    ) -> LevelDuration;
}
unsafe extern "C" {
    #[doc = "Start SubGhzFileEncoderWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n * `file_path` - File path\n * `radio_device_name` - Radio device name\n # Returns\n\nbool - true if ok"]
    pub fn subghz_file_encoder_worker_start(
        instance: *mut SubGhzFileEncoderWorker,
        file_path: *const core::ffi::c_char,
        radio_device_name: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Stop SubGhzFileEncoderWorker\n # Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance"]
    pub fn subghz_file_encoder_worker_stop(instance: *mut SubGhzFileEncoderWorker);
}
unsafe extern "C" {
    #[doc = "Check if worker is running\n # Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n # Returns\n\nbool - true if running"]
    pub fn subghz_file_encoder_worker_is_running(instance: *mut SubGhzFileEncoderWorker) -> bool;
}
unsafe extern "C" {
    pub static subghz_protocol_registry: SubGhzProtocolRegistry;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzSetting {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn subghz_setting_alloc() -> *mut SubGhzSetting;
}
unsafe extern "C" {
    pub fn subghz_setting_free(instance: *mut SubGhzSetting);
}
unsafe extern "C" {
    pub fn subghz_setting_load(instance: *mut SubGhzSetting, file_path: *const core::ffi::c_char);
}
unsafe extern "C" {
    pub fn subghz_setting_get_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
unsafe extern "C" {
    pub fn subghz_setting_get_hopper_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
unsafe extern "C" {
    pub fn subghz_setting_get_preset_count(instance: *mut SubGhzSetting) -> usize;
}
unsafe extern "C" {
    pub fn subghz_setting_get_preset_name(
        instance: *mut SubGhzSetting,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn subghz_setting_get_inx_preset_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn subghz_setting_get_preset_data(instance: *mut SubGhzSetting, idx: usize) -> *mut u8;
}
unsafe extern "C" {
    pub fn subghz_setting_get_preset_data_size(instance: *mut SubGhzSetting, idx: usize) -> usize;
}
unsafe extern "C" {
    pub fn subghz_setting_get_preset_data_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> *mut u8;
}
unsafe extern "C" {
    pub fn subghz_setting_load_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
        fff_data_file: *mut FlipperFormat,
    ) -> bool;
}
unsafe extern "C" {
    pub fn subghz_setting_delete_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn subghz_setting_get_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
unsafe extern "C" {
    pub fn subghz_setting_get_hopper_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
unsafe extern "C" {
    pub fn subghz_setting_get_frequency_default_index(instance: *mut SubGhzSetting) -> u32;
}
unsafe extern "C" {
    pub fn subghz_setting_get_default_frequency(instance: *mut SubGhzSetting) -> u32;
}
unsafe extern "C" {
    pub fn subghz_devices_init();
}
unsafe extern "C" {
    pub fn subghz_devices_deinit();
}
unsafe extern "C" {
    pub fn subghz_devices_get_by_name(device_name: *const core::ffi::c_char)
    -> *const SubGhzDevice;
}
unsafe extern "C" {
    pub fn subghz_devices_get_name(device: *const SubGhzDevice) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn subghz_devices_begin(device: *const SubGhzDevice) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_end(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_is_connect(device: *const SubGhzDevice) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_reset(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_sleep(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_idle(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_load_preset(
        device: *const SubGhzDevice,
        preset: FuriHalSubGhzPreset,
        preset_data: *mut u8,
    );
}
unsafe extern "C" {
    pub fn subghz_devices_set_frequency(device: *const SubGhzDevice, frequency: u32) -> u32;
}
unsafe extern "C" {
    pub fn subghz_devices_is_frequency_valid(device: *const SubGhzDevice, frequency: u32) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_set_async_mirror_pin(device: *const SubGhzDevice, gpio: *const GpioPin);
}
unsafe extern "C" {
    pub fn subghz_devices_get_data_gpio(device: *const SubGhzDevice) -> *const GpioPin;
}
unsafe extern "C" {
    pub fn subghz_devices_set_tx(device: *const SubGhzDevice) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_flush_tx(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_start_async_tx(
        device: *const SubGhzDevice,
        callback: *mut core::ffi::c_void,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_is_async_complete_tx(device: *const SubGhzDevice) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_stop_async_tx(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_set_rx(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_flush_rx(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_start_async_rx(
        device: *const SubGhzDevice,
        callback: *mut core::ffi::c_void,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn subghz_devices_stop_async_rx(device: *const SubGhzDevice);
}
unsafe extern "C" {
    pub fn subghz_devices_get_rssi(device: *const SubGhzDevice) -> f32;
}
unsafe extern "C" {
    pub fn subghz_devices_get_lqi(device: *const SubGhzDevice) -> u8;
}
unsafe extern "C" {
    pub fn subghz_devices_rx_pipe_not_empty(device: *const SubGhzDevice) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_is_rx_data_crc_valid(device: *const SubGhzDevice) -> bool;
}
unsafe extern "C" {
    pub fn subghz_devices_read_packet(device: *const SubGhzDevice, data: *mut u8, size: *mut u8);
}
unsafe extern "C" {
    pub fn subghz_devices_write_packet(device: *const SubGhzDevice, data: *const u8, size: u8);
}
pub type SubGhzTxRxWorkerCallbackHaveRead =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTxRxWorker {
    _unused: [u8; 0],
}
pub const SubGhzTxRxWorkerStatusIDLE: SubGhzTxRxWorkerStatus = SubGhzTxRxWorkerStatus(0);
pub const SubGhzTxRxWorkerStatusTx: SubGhzTxRxWorkerStatus = SubGhzTxRxWorkerStatus(1);
pub const SubGhzTxRxWorkerStatusRx: SubGhzTxRxWorkerStatus = SubGhzTxRxWorkerStatus(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SubGhzTxRxWorkerStatus(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "SubGhzTxRxWorker, add data to transfer\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n * `data` - *data\n * `size` - data size\n # Returns\n\nbool true if ok"]
    pub fn subghz_tx_rx_worker_write(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "SubGhzTxRxWorker, get available data\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n # Returns\n\nsize_t data size"]
    pub fn subghz_tx_rx_worker_available(instance: *mut SubGhzTxRxWorker) -> usize;
}
unsafe extern "C" {
    #[doc = "SubGhzTxRxWorker, read data\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n * `data` - *data\n * `size` - max data size, which can be read\n # Returns\n\nsize_t data size, how much is actually read"]
    pub fn subghz_tx_rx_worker_read(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "allback SubGhzTxRxWorker when there is data to read in an empty buffer\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n * `callback` - SubGhzTxRxWorkerCallbackHaveRead callback\n * `context` -"]
    pub fn subghz_tx_rx_worker_set_callback_have_read(
        instance: *mut SubGhzTxRxWorker,
        callback: SubGhzTxRxWorkerCallbackHaveRead,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Allocate SubGhzTxRxWorker\n # Returns\n\nSubGhzTxRxWorker* Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_alloc() -> *mut SubGhzTxRxWorker;
}
unsafe extern "C" {
    #[doc = "Free SubGhzTxRxWorker\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_free(instance: *mut SubGhzTxRxWorker);
}
unsafe extern "C" {
    #[doc = "Start SubGhzTxRxWorker\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n * `device` - Pointer to a SubGhzDevice instance\n # Returns\n\nbool - true if ok"]
    pub fn subghz_tx_rx_worker_start(
        instance: *mut SubGhzTxRxWorker,
        device: *const SubGhzDevice,
        frequency: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Stop SubGhzTxRxWorker\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_stop(instance: *mut SubGhzTxRxWorker);
}
unsafe extern "C" {
    #[doc = "Check if worker is running\n # Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n # Returns\n\nbool - true if running"]
    pub fn subghz_tx_rx_worker_is_running(instance: *mut SubGhzTxRxWorker) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzWorker {
    _unused: [u8; 0],
}
pub type SubGhzWorkerOverrunCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzWorkerPairCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, level: bool, duration: u32),
>;
unsafe extern "C" {
    pub fn subghz_worker_rx_callback(level: bool, duration: u32, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Allocate SubGhzWorker.\n # Returns\n\nSubGhzWorker* Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_alloc() -> *mut SubGhzWorker;
}
unsafe extern "C" {
    #[doc = "Free SubGhzWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_free(instance: *mut SubGhzWorker);
}
unsafe extern "C" {
    #[doc = "Overrun callback SubGhzWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n * `callback` - SubGhzWorkerOverrunCallback callback"]
    pub fn subghz_worker_set_overrun_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerOverrunCallback,
    );
}
unsafe extern "C" {
    #[doc = "Pair callback SubGhzWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n * `callback` - SubGhzWorkerOverrunCallback callback"]
    pub fn subghz_worker_set_pair_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerPairCallback,
    );
}
unsafe extern "C" {
    #[doc = "Context callback SubGhzWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n * `context` -"]
    pub fn subghz_worker_set_context(instance: *mut SubGhzWorker, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Start SubGhzWorker.\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_start(instance: *mut SubGhzWorker);
}
unsafe extern "C" {
    #[doc = "Stop SubGhzWorker\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_stop(instance: *mut SubGhzWorker);
}
unsafe extern "C" {
    #[doc = "Check if worker is running.\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n # Returns\n\nbool - true if running"]
    pub fn subghz_worker_is_running(instance: *mut SubGhzWorker) -> bool;
}
unsafe extern "C" {
    #[doc = "Short duration filter setting.\n glues short durations into 1. The default setting is 30 us, if set to 0 the filter will be disabled\n # Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n * `timeout` - time in us"]
    pub fn subghz_worker_set_filter(instance: *mut SubGhzWorker, timeout: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTransmitter {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate and init SubGhzTransmitter.\n # Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n # Returns\n\nSubGhzTransmitter* pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_alloc_init(
        environment: *mut SubGhzEnvironment,
        protocol_name: *const core::ffi::c_char,
    ) -> *mut SubGhzTransmitter;
}
unsafe extern "C" {
    #[doc = "Free SubGhzTransmitter.\n # Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_free(instance: *mut SubGhzTransmitter);
}
unsafe extern "C" {
    #[doc = "Get protocol instance.\n # Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_get_protocol_instance(
        instance: *mut SubGhzTransmitter,
    ) -> *mut SubGhzProtocolEncoderBase;
}
unsafe extern "C" {
    #[doc = "Forced transmission stop.\n # Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_stop(instance: *mut SubGhzTransmitter) -> bool;
}
unsafe extern "C" {
    #[doc = "Deserialize and generating an upload to send.\n # Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance\n * `flipper_format` - Pointer to a FlipperFormat instance\n # Returns\n\nstatus"]
    pub fn subghz_transmitter_deserialize(
        instance: *mut SubGhzTransmitter,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
unsafe extern "C" {
    #[doc = "Getting the level and duration of the upload to be loaded into DMA.\n # Arguments\n\n* `context` - Pointer to a SubGhzTransmitter instance\n # Returns\n\nLevelDuration"]
    pub fn subghz_transmitter_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
pub type FuriApiLock = *mut FuriEventFlag;
unsafe extern "C" {
    #[doc = "Extract int value and trim arguments string\n\n # Arguments\n\n* `args` - - arguments string\n * `word` - first argument, output\n # Returns\n\ntrue - success\n false - arguments string does not contain int"]
    pub fn args_read_int_and_trim(args: *mut FuriString, value: *mut core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = "Extract first argument from arguments string and trim arguments string\n\n # Arguments\n\n* `args` - arguments string\n * `word` - first argument, output\n # Returns\n\ntrue - success\n false - arguments string does not contain anything"]
    pub fn args_read_string_and_trim(args: *mut FuriString, word: *mut FuriString) -> bool;
}
unsafe extern "C" {
    #[doc = "Extract the first quoted argument from the argument string and trim the argument string. If the argument is not quoted, calls args_read_string_and_trim.\n\n # Arguments\n\n* `args` - arguments string\n * `word` - first argument, output, without quotes\n # Returns\n\ntrue - success\n false - arguments string does not contain anything"]
    pub fn args_read_probably_quoted_string_and_trim(
        args: *mut FuriString,
        word: *mut FuriString,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert hex ASCII values to byte array\n\n # Arguments\n\n* `args` - arguments string\n * `bytes` - byte array pointer, output\n * `bytes_count` - needed bytes count\n # Returns\n\ntrue - success\n false - arguments string does not contain enough values, or contain non-hex ASCII values"]
    pub fn args_read_hex_bytes(args: *mut FuriString, bytes: *mut u8, bytes_count: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Get length of first word from arguments string\n\n # Arguments\n\n* `args` - arguments string\n # Returns\n\nsize_t length of first word"]
    pub fn args_get_first_word_length(args: *mut FuriString) -> usize;
}
unsafe extern "C" {
    #[doc = "Get length of arguments string\n\n # Arguments\n\n* `args` - arguments string\n # Returns\n\nsize_t length of arguments string"]
    pub fn args_length(args: *mut FuriString) -> usize;
}
unsafe extern "C" {
    #[doc = "Convert ASCII hex values to byte\n\n # Arguments\n\n* `hi_nibble` - ASCII hi nibble character\n * `low_nibble` - ASCII low nibble character\n * `byte` - byte pointer, output\n # Returns\n\nbool conversion status"]
    pub fn args_char_to_hex(
        hi_nibble: core::ffi::c_char,
        low_nibble: core::ffi::c_char,
        byte: *mut u8,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompressIcon {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Initialize icon compressor\n\n # Arguments\n\n* `decode_buf_size` (direction in) - The icon buffer size for decoding. Ensure that\n it's big enough for any icons that you are\n planning to decode with it.\n\n # Returns\n\nCompress Icon instance"]
    pub fn compress_icon_alloc(decode_buf_size: usize) -> *mut CompressIcon;
}
unsafe extern "C" {
    #[doc = "Free icon compressor\n\n # Arguments\n\n* `instance` - The Compress Icon instance"]
    pub fn compress_icon_free(instance: *mut CompressIcon);
}
unsafe extern "C" {
    #[doc = "Decompress icon\n\n output pointer set by this function is valid till next\n `compress_icon_decode` or `compress_icon_free` call\n\n # Arguments\n\n* `instance` - The Compress Icon instance\n * `icon_data` - pointer to icon data.\n * `output` (direction in) - pointer to decoded buffer pointer. Data in buffer is\n valid till next call. If icon data was not compressed,\n pointer within icon_data is returned"]
    pub fn compress_icon_decode(
        instance: *mut CompressIcon,
        icon_data: *const u8,
        output: *mut *mut u8,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Compress {
    _unused: [u8; 0],
}
pub const CompressTypeHeatshrink: CompressType = CompressType(0);
#[repr(transparent)]
#[doc = "Supported compression types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CompressType(pub core::ffi::c_uchar);
#[doc = "Configuration for heatshrink compression"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompressConfigHeatshrink {
    pub window_sz2: u16,
    pub lookahead_sz2: u16,
    pub input_buffer_sz: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CompressConfigHeatshrink"]
        [::core::mem::size_of::<CompressConfigHeatshrink>() - 6usize];
    ["Alignment of CompressConfigHeatshrink"]
        [::core::mem::align_of::<CompressConfigHeatshrink>() - 2usize];
    ["Offset of field: CompressConfigHeatshrink::window_sz2"]
        [::core::mem::offset_of!(CompressConfigHeatshrink, window_sz2) - 0usize];
    ["Offset of field: CompressConfigHeatshrink::lookahead_sz2"]
        [::core::mem::offset_of!(CompressConfigHeatshrink, lookahead_sz2) - 2usize];
    ["Offset of field: CompressConfigHeatshrink::input_buffer_sz"]
        [::core::mem::offset_of!(CompressConfigHeatshrink, input_buffer_sz) - 4usize];
};
unsafe extern "C" {
    #[doc = "Default configuration for heatshrink compression. Used for image assets."]
    pub static compress_config_heatshrink_default: CompressConfigHeatshrink;
}
unsafe extern "C" {
    #[doc = "Allocate encoder and decoder\n\n # Arguments\n\n* `type` - Compression type\n * `config` (direction in) - Configuration for compression, specific to type\n\n # Returns\n\nCompress instance"]
    pub fn compress_alloc(type_: CompressType, config: *const core::ffi::c_void) -> *mut Compress;
}
unsafe extern "C" {
    #[doc = "Free encoder and decoder\n\n # Arguments\n\n* `compress` - Compress instance"]
    pub fn compress_free(compress: *mut Compress);
}
unsafe extern "C" {
    #[doc = "Encode data\n\n # Arguments\n\n* `compress` - Compress instance\n * `data_in` - pointer to input data\n * `data_in_size` - size of input data\n * `data_out` - maximum size of output data\n * `data_out_size` (direction in) - The data out size\n * `data_res_size` - pointer to result output data size\n\n > **Note:** Prepends compressed stream with a header. If data is not compressible,\n it will be stored as is after the header.\n # Returns\n\ntrue on success"]
    pub fn compress_encode(
        compress: *mut Compress,
        data_in: *mut u8,
        data_in_size: usize,
        data_out: *mut u8,
        data_out_size: usize,
        data_res_size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Decode data\n\n # Arguments\n\n* `compress` - Compress instance\n * `data_in` - pointer to input data\n * `data_in_size` - size of input data\n * `data_out` - maximum size of output data\n * `data_out_size` (direction in) - The data out size\n * `data_res_size` - pointer to result output data size\n\n > **Note:** Expects compressed stream with a header, as produced by `compress_encode`.\n # Returns\n\ntrue on success"]
    pub fn compress_decode(
        compress: *mut Compress,
        data_in: *mut u8,
        data_in_size: usize,
        data_out: *mut u8,
        data_out_size: usize,
        data_res_size: *mut usize,
    ) -> bool;
}
#[doc = "I/O callback for streamed compression/decompression\n\n # Arguments\n\n* `context` - user context\n * `buffer` - buffer to read/write\n * `size` - size of buffer\n\n # Returns\n\nnumber of bytes read/written, 0 on end of stream, negative on error"]
pub type CompressIoCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, buffer: *mut u8, size: usize) -> i32,
>;
unsafe extern "C" {
    #[doc = "Decompress streamed data\n\n # Arguments\n\n* `compress` - Compress instance\n * `read_cb` - read callback\n * `read_context` - read callback context\n * `write_cb` - write callback\n * `write_context` - write callback context\n\n > **Note:** Does not expect a header, just compressed data stream.\n # Returns\n\ntrue on success"]
    pub fn compress_decode_streamed(
        compress: *mut Compress,
        read_cb: CompressIoCallback,
        read_context: *mut core::ffi::c_void,
        write_cb: CompressIoCallback,
        write_context: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompressStreamDecoder {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Allocate stream decoder\n\n # Arguments\n\n* `type` - Compression type\n * `config` (direction in) - Configuration for compression, specific to type\n * `read_cb` - The read callback for input (compressed) data\n * `read_context` - The read context\n\n # Returns\n\nCompressStreamDecoder instance"]
    pub fn compress_stream_decoder_alloc(
        type_: CompressType,
        config: *const core::ffi::c_void,
        read_cb: CompressIoCallback,
        read_context: *mut core::ffi::c_void,
    ) -> *mut CompressStreamDecoder;
}
unsafe extern "C" {
    #[doc = "Free stream decoder\n\n # Arguments\n\n* `instance` - The CompressStreamDecoder instance"]
    pub fn compress_stream_decoder_free(instance: *mut CompressStreamDecoder);
}
unsafe extern "C" {
    #[doc = "Read uncompressed data chunk from stream decoder\n\n # Arguments\n\n* `instance` - The CompressStreamDecoder instance\n * `data_out` - The data out\n * `data_out_size` (direction in) - The data out size\n\n # Returns\n\ntrue on success"]
    pub fn compress_stream_decoder_read(
        instance: *mut CompressStreamDecoder,
        data_out: *mut u8,
        data_out_size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Seek to position in uncompressed data stream\n\n # Arguments\n\n* `instance` - The CompressStreamDecoder instance\n * `position` (direction in) - The position\n\n # Returns\n\ntrue on success\n Backward seeking is not supported"]
    pub fn compress_stream_decoder_seek(
        instance: *mut CompressStreamDecoder,
        position: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get current position in uncompressed data stream\n\n # Arguments\n\n* `instance` - The CompressStreamDecoder instance\n\n # Returns\n\ncurrent position"]
    pub fn compress_stream_decoder_tell(instance: *mut CompressStreamDecoder) -> usize;
}
unsafe extern "C" {
    #[doc = "Reset stream decoder to the beginning\n Read callback must be repositioned by caller separately\n\n # Arguments\n\n* `instance` - The CompressStreamDecoder instance\n\n # Returns\n\ntrue on success"]
    pub fn compress_stream_decoder_rewind(instance: *mut CompressStreamDecoder) -> bool;
}
unsafe extern "C" {
    pub fn crc32_calc_buffer(crc: u32, buffer: *const core::ffi::c_void, size: usize) -> u32;
}
pub type FileCrcProgressCb =
    ::core::option::Option<unsafe extern "C" fn(progress: u8, context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    pub fn crc32_calc_file(
        file: *mut File,
        progress_cb: FileCrcProgressCb,
        context: *mut core::ffi::c_void,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DirWalk {
    _unused: [u8; 0],
}
#[doc = "< OK"]
pub const DirWalkOK: DirWalkResult = DirWalkResult(0);
#[doc = "< Error"]
pub const DirWalkError: DirWalkResult = DirWalkResult(1);
#[doc = "< Last element"]
pub const DirWalkLast: DirWalkResult = DirWalkResult(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DirWalkResult(pub core::ffi::c_uchar);
pub type DirWalkFilterCb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
        ctx: *mut core::ffi::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = "Allocate DirWalk\n # Arguments\n\n* `storage` -\n # Returns\n\nDirWalk*"]
    pub fn dir_walk_alloc(storage: *mut Storage) -> *mut DirWalk;
}
unsafe extern "C" {
    #[doc = "Free DirWalk\n # Arguments\n\n* `dir_walk` -"]
    pub fn dir_walk_free(dir_walk: *mut DirWalk);
}
unsafe extern "C" {
    #[doc = "Set recursive mode (true by default)\n # Arguments\n\n* `dir_walk` -\n * `recursive` -"]
    pub fn dir_walk_set_recursive(dir_walk: *mut DirWalk, recursive: bool);
}
unsafe extern "C" {
    #[doc = "Set filter callback (Should return true if the data is valid)\n # Arguments\n\n* `dir_walk` -\n * `cb` -\n * `context` -"]
    pub fn dir_walk_set_filter_cb(
        dir_walk: *mut DirWalk,
        cb: DirWalkFilterCb,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Open directory\n # Arguments\n\n* `dir_walk` -\n * `path` -\n # Returns\n\ntrue\n false"]
    pub fn dir_walk_open(dir_walk: *mut DirWalk, path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Get error id\n # Arguments\n\n* `dir_walk` -\n # Returns\n\nFS_Error"]
    pub fn dir_walk_get_error(dir_walk: *mut DirWalk) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Read next element from directory\n # Arguments\n\n* `dir_walk` -\n * `return_path` -\n * `fileinfo` -\n # Returns\n\nDirWalkResult"]
    pub fn dir_walk_read(
        dir_walk: *mut DirWalk,
        return_path: *mut FuriString,
        fileinfo: *mut FileInfo,
    ) -> DirWalkResult;
}
unsafe extern "C" {
    #[doc = "Close directory\n # Arguments\n\n* `dir_walk` -"]
    pub fn dir_walk_close(dir_walk: *mut DirWalk);
}
unsafe extern "C" {
    #[doc = "Compare two floating point numbers\n # Arguments\n\n* `a` - First number to compare\n * `b` - Second number to compare\n\n # Returns\n\nbool true if a equals b, false otherwise"]
    pub fn float_is_equal(a: f32, b: f32) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert ASCII hex value to nibble\n # Arguments\n\n* `c` - ASCII character\n * `nibble` - nibble pointer, output\n\n # Returns\n\nbool conversion status"]
    pub fn hex_char_to_hex_nibble(c: core::ffi::c_char, nibble: *mut u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert ASCII hex value to byte\n # Arguments\n\n* `hi` - hi nibble text\n * `low` - low nibble text\n * `value` - output value\n\n # Returns\n\nbool conversion status"]
    pub fn hex_char_to_uint8(hi: core::ffi::c_char, low: core::ffi::c_char, value: *mut u8)
    -> bool;
}
unsafe extern "C" {
    #[doc = "Convert ASCII hex values to uint8_t\n # Arguments\n\n* `value_str` - ASCII data\n * `value` - output value\n\n # Returns\n\nbool conversion status"]
    pub fn hex_chars_to_uint8(value_str: *const core::ffi::c_char, value: *mut u8) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert ASCII hex values to uint64_t\n # Arguments\n\n* `value_str` - ASCII 64 bi data\n * `value` - output value\n\n # Returns\n\nbool conversion status"]
    pub fn hex_chars_to_uint64(value_str: *const core::ffi::c_char, value: *mut u64) -> bool;
}
unsafe extern "C" {
    #[doc = "Convert uint8_t to ASCII hex values\n # Arguments\n\n* `src` - source data\n * `target` - output value\n * `length` - data length\n"]
    pub fn uint8_to_hex_chars(src: *const u8, target: *mut u8, length: core::ffi::c_int);
}
pub const KeysDictModeOpenExisting: KeysDictMode = KeysDictMode(0);
pub const KeysDictModeOpenAlways: KeysDictMode = KeysDictMode(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct KeysDictMode(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeysDict {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = "Check if the file list exists\n\n # Arguments\n\n* `path` - - list path\n\n # Returns\n\ntrue if list exists, false otherwise"]
    pub fn keys_dict_check_presence(path: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = "Open or create list\n Depending on mode, list will be opened or created.\n\n # Arguments\n\n* `path` - - Path of the file that contain the list\n * `mode` - - ListKeysMode value\n * `key_size` - - Size of each key in bytes\n\n # Returns\n\nReturns KeysDict list instance"]
    pub fn keys_dict_alloc(
        path: *const core::ffi::c_char,
        mode: KeysDictMode,
        key_size: usize,
    ) -> *mut KeysDict;
}
unsafe extern "C" {
    #[doc = "Close list\n\n # Arguments\n\n* `instance` - - KeysDict list instance"]
    pub fn keys_dict_free(instance: *mut KeysDict);
}
unsafe extern "C" {
    #[doc = "Get total number of keys in list\n\n # Arguments\n\n* `instance` - - KeysDict list instance\n\n # Returns\n\nReturns total number of keys in list"]
    pub fn keys_dict_get_total_keys(instance: *mut KeysDict) -> usize;
}
unsafe extern "C" {
    #[doc = "Rewind list\n\n # Arguments\n\n* `instance` - - KeysDict list instance\n\n # Returns\n\nReturns true if rewind was successful, false otherwise"]
    pub fn keys_dict_rewind(instance: *mut KeysDict) -> bool;
}
unsafe extern "C" {
    #[doc = "Check if key is present in list\n\n # Arguments\n\n* `instance` - - KeysDict list instance\n * `key` - - key to check\n * `key_size` - - Size of the key in bytes\n\n # Returns\n\nReturns true if key is present, false otherwise"]
    pub fn keys_dict_is_key_present(
        instance: *mut KeysDict,
        key: *const u8,
        key_size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get next key from the list\n This function will return next key from list. If there are no more\n keys, it will return false, and keys_dict_rewind() should be called.\n\n # Arguments\n\n* `instance` - - KeysDict list instance\n * `key` - - Array where to store key\n * `key_size` - - Size of key in bytes\n\n # Returns\n\nReturns true if key was successfully retrieved, false otherwise"]
    pub fn keys_dict_get_next_key(instance: *mut KeysDict, key: *mut u8, key_size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Add key to list\n\n # Arguments\n\n* `instance` - - KeysDict list instance\n * `key` - - Key to add\n * `key_size` - - Size of the key in bytes\n\n # Returns\n\nReturns true if key was successfully added, false otherwise"]
    pub fn keys_dict_add_key(instance: *mut KeysDict, key: *const u8, key_size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "Delete key from list\n\n # Arguments\n\n* `instance` - - KeysDict list instance\n * `key` - - Key to delete\n * `key_size` - - Size of the key in bytes\n\n # Returns\n\nReturns true if key was successfully deleted, false otherwise"]
    pub fn keys_dict_delete_key(instance: *mut KeysDict, key: *const u8, key_size: usize) -> bool;
}
pub const ManchesterEventShortLow: ManchesterEvent = ManchesterEvent(0);
pub const ManchesterEventShortHigh: ManchesterEvent = ManchesterEvent(2);
pub const ManchesterEventLongLow: ManchesterEvent = ManchesterEvent(4);
pub const ManchesterEventLongHigh: ManchesterEvent = ManchesterEvent(6);
pub const ManchesterEventReset: ManchesterEvent = ManchesterEvent(8);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ManchesterEvent(pub core::ffi::c_uchar);
pub const ManchesterStateStart1: ManchesterState = ManchesterState(0);
pub const ManchesterStateMid1: ManchesterState = ManchesterState(1);
pub const ManchesterStateMid0: ManchesterState = ManchesterState(2);
pub const ManchesterStateStart0: ManchesterState = ManchesterState(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ManchesterState(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn manchester_advance(
        state: ManchesterState,
        event: ManchesterEvent,
        next_state: *mut ManchesterState,
        data: *mut bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ManchesterEncoderState {
    pub prev_bit: bool,
    pub step: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ManchesterEncoderState"][::core::mem::size_of::<ManchesterEncoderState>() - 2usize];
    ["Alignment of ManchesterEncoderState"]
        [::core::mem::align_of::<ManchesterEncoderState>() - 1usize];
    ["Offset of field: ManchesterEncoderState::prev_bit"]
        [::core::mem::offset_of!(ManchesterEncoderState, prev_bit) - 0usize];
    ["Offset of field: ManchesterEncoderState::step"]
        [::core::mem::offset_of!(ManchesterEncoderState, step) - 1usize];
};
pub const ManchesterEncoderResultShortLow: ManchesterEncoderResult = ManchesterEncoderResult(0);
pub const ManchesterEncoderResultLongLow: ManchesterEncoderResult = ManchesterEncoderResult(1);
pub const ManchesterEncoderResultLongHigh: ManchesterEncoderResult = ManchesterEncoderResult(2);
pub const ManchesterEncoderResultShortHigh: ManchesterEncoderResult = ManchesterEncoderResult(3);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ManchesterEncoderResult(pub core::ffi::c_uchar);
unsafe extern "C" {
    pub fn manchester_encoder_reset(state: *mut ManchesterEncoderState);
}
unsafe extern "C" {
    pub fn manchester_encoder_advance(
        state: *mut ManchesterEncoderState,
        curr_bit: bool,
        result: *mut ManchesterEncoderResult,
    ) -> bool;
}
unsafe extern "C" {
    pub fn manchester_encoder_finish(state: *mut ManchesterEncoderState)
    -> ManchesterEncoderResult;
}
unsafe extern "C" {
    pub fn md5_calc_file(
        file: *mut File,
        path: *const core::ffi::c_char,
        output: *mut core::ffi::c_uchar,
        file_error: *mut FS_Error,
    ) -> bool;
}
unsafe extern "C" {
    pub fn md5_string_calc_file(
        file: *mut File,
        path: *const core::ffi::c_char,
        output: *mut FuriString,
        file_error: *mut FS_Error,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Generates detailed/random name based on furi_hal flags\n\n # Arguments\n\n* `name` - buffer to write random name\n * `max_name_size` - length of given buffer\n * `prefix` (direction in) - The prefix of the name"]
    pub fn name_generator_make_auto(
        name: *mut core::ffi::c_char,
        max_name_size: usize,
        prefix: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Generates random name\n\n # Arguments\n\n* `name` - buffer to write random name\n * `max_name_size` - length of given buffer"]
    pub fn name_generator_make_random(name: *mut core::ffi::c_char, max_name_size: usize);
}
unsafe extern "C" {
    #[doc = "Generates detailed name\n\n # Arguments\n\n* `name` - buffer to write random name\n * `max_name_size` - length of given buffer\n * `prefix` (direction in) - The prefix of the name"]
    pub fn name_generator_make_detailed(
        name: *mut core::ffi::c_char,
        max_name_size: usize,
        prefix: *const core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = "Extract filename without extension from path.\n\n # Arguments\n\n* `path` - path string\n * `filename` - output filename string. Must be initialized before."]
    pub fn path_extract_filename_no_ext(path: *const core::ffi::c_char, filename: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Extract filename string from path.\n\n # Arguments\n\n* `path` - path string\n * `filename` - output filename string. Must be initialized before.\n * `trim_ext` - true - get filename without extension"]
    pub fn path_extract_filename(path: *mut FuriString, filename: *mut FuriString, trim_ext: bool);
}
unsafe extern "C" {
    #[doc = "Extract file extension from path.\n\n # Arguments\n\n* `path` - path string\n * `ext` - output extension string\n * `ext_len_max` - maximum extension string length"]
    pub fn path_extract_extension(
        path: *mut FuriString,
        ext: *mut core::ffi::c_char,
        ext_len_max: usize,
    );
}
unsafe extern "C" {
    #[doc = "Extract last path component\n\n # Arguments\n\n* `path` - path string\n * `filename` - output string. Must be initialized before."]
    pub fn path_extract_basename(path: *const core::ffi::c_char, basename: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Extract path, except for last component\n\n # Arguments\n\n* `path` - path string\n * `filename` - output string. Must be initialized before."]
    pub fn path_extract_dirname(path: *const core::ffi::c_char, dirname: *mut FuriString);
}
unsafe extern "C" {
    #[doc = "Appends new component to path, adding path delimiter\n\n # Arguments\n\n* `path` - path string\n * `suffix` - path part to apply"]
    pub fn path_append(path: *mut FuriString, suffix: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = "Appends new component to path, adding path delimiter\n\n # Arguments\n\n* `path` - first path part\n * `suffix` - second path part\n * `out_path` - output string to combine parts into. Must be initialized"]
    pub fn path_concat(
        path: *const core::ffi::c_char,
        suffix: *const core::ffi::c_char,
        out_path: *mut FuriString,
    );
}
unsafe extern "C" {
    #[doc = "Check that path contains only ascii characters\n\n # Arguments\n\n* `path` -\n # Returns\n\ntrue\n false"]
    pub fn path_contains_only_ascii(path: *const core::ffi::c_char) -> bool;
}
pub const PipeRoleAlice: PipeRole = PipeRole(0);
pub const PipeRoleBob: PipeRole = PipeRole(1);
#[repr(transparent)]
#[doc = "The role of a pipe side\n\n Both roles are equal, as they can both read and write the data. This status\n might be helpful in determining the role of a thread w.r.t. another thread in\n an application that builds on the pipe."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PipeRole(pub core::ffi::c_uchar);
pub const PipeStateOpen: PipeState = PipeState(0);
pub const PipeStateBroken: PipeState = PipeState(1);
#[repr(transparent)]
#[doc = "The state of a pipe\n\n - `PipeStateOpen`: Both pipe sides are in place, meaning data that is sent\n down the pipe _might_ be read by the peer, and new data sent by the peer\n _might_ arrive.\n - `PipeStateBroken`: The other side of the pipe has been freed, meaning\n data that is written will never reach its destination, and no new data\n will appear in the buffer.\n\n A broken pipe can never become open again, because there's no way to connect\n a side of a pipe to another side of a pipe."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PipeState(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipeSide {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipeSideBundle {
    pub alices_side: *mut PipeSide,
    pub bobs_side: *mut PipeSide,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PipeSideBundle"][::core::mem::size_of::<PipeSideBundle>() - 8usize];
    ["Alignment of PipeSideBundle"][::core::mem::align_of::<PipeSideBundle>() - 4usize];
    ["Offset of field: PipeSideBundle::alices_side"]
        [::core::mem::offset_of!(PipeSideBundle, alices_side) - 0usize];
    ["Offset of field: PipeSideBundle::bobs_side"]
        [::core::mem::offset_of!(PipeSideBundle, bobs_side) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipeSideReceiveSettings {
    pub capacity: usize,
    pub trigger_level: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of PipeSideReceiveSettings"][::core::mem::size_of::<PipeSideReceiveSettings>() - 8usize];
    ["Alignment of PipeSideReceiveSettings"]
        [::core::mem::align_of::<PipeSideReceiveSettings>() - 4usize];
    ["Offset of field: PipeSideReceiveSettings::capacity"]
        [::core::mem::offset_of!(PipeSideReceiveSettings, capacity) - 0usize];
    ["Offset of field: PipeSideReceiveSettings::trigger_level"]
        [::core::mem::offset_of!(PipeSideReceiveSettings, trigger_level) - 4usize];
};
unsafe extern "C" {
    #[doc = "Allocates two connected sides of one pipe.\n\n Creating a pair of sides using this function is the only way to connect two\n pipe sides together. Two unrelated orphaned sides may never be connected back\n together.\n\n The capacity and trigger level for both directions are the same when the pipe\n is created using this function. Use `pipe_alloc_ex` if you want more\n control.\n\n # Arguments\n\n* `capacity` - Maximum number of bytes buffered in one direction\n * `trigger_level` - Number of bytes that need to be available in the buffer\n in order for a blocked thread to unblock\n # Returns\n\nBundle with both sides of the pipe"]
    pub fn pipe_alloc(capacity: usize, trigger_level: usize) -> PipeSideBundle;
}
unsafe extern "C" {
    #[doc = "Allocates two connected sides of one pipe.\n\n Creating a pair of sides using this function is the only way to connect two\n pipe sides together. Two unrelated orphaned sides may never be connected back\n together.\n\n The capacity and trigger level may be different for the two directions when\n the pipe is created using this function. Use `pipe_alloc` if you don't\n need control this fine.\n\n # Arguments\n\n* `alice` - `capacity` and `trigger_level` settings for Alice's receiving\n buffer\n * `bob` - `capacity` and `trigger_level` settings for Bob's receiving buffer\n # Returns\n\nBundle with both sides of the pipe"]
    pub fn pipe_alloc_ex(
        alice: PipeSideReceiveSettings,
        bob: PipeSideReceiveSettings,
    ) -> PipeSideBundle;
}
unsafe extern "C" {
    #[doc = "Gets the role of a pipe side.\n\n The roles (Alice and Bob) are equal, as both can send and receive data. This\n status might be helpful in determining the role of a thread w.r.t. another\n thread.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to query\n # Returns\n\nRole of provided pipe side"]
    pub fn pipe_role(pipe: *mut PipeSide) -> PipeRole;
}
unsafe extern "C" {
    #[doc = "Gets the state of a pipe.\n\n When the state is `PipeStateOpen`, both sides are active and may send or\n receive data. When the state is `PipeStateBroken`, only one side is active\n (the one that this method has been called on). If you find yourself in that\n state, the data that you send will never be heard by anyone, and the data you\n receive are leftovers in the buffer.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to query\n # Returns\n\nState of the pipe"]
    pub fn pipe_state(pipe: *mut PipeSide) -> PipeState;
}
unsafe extern "C" {
    #[doc = "Frees a side of a pipe.\n\n When only one of the sides is freed, the pipe is transitioned from the \"Open\"\n state into the \"Broken\" state. When both sides are freed, the underlying data\n structures are freed too.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to free"]
    pub fn pipe_free(pipe: *mut PipeSide);
}
unsafe extern "C" {
    #[doc = "Connects the pipe to the `stdin` and `stdout` of the current thread.\n\n After performing this operation, you can use `getc`, `puts`, etc. to send and\n receive data to and from the pipe. If the pipe becomes broken, C stdlib calls\n will return `EOF` wherever possible.\n\n You can disconnect the pipe by manually calling\n `furi_thread_set_stdout_callback` and `furi_thread_set_stdin_callback` with\n `NULL`.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to connect to the stdio"]
    pub fn pipe_install_as_stdio(pipe: *mut PipeSide);
}
unsafe extern "C" {
    #[doc = "Receives data from the pipe.\n\n # Arguments\n\n* `[in]` - pipe The pipe side to read data out of\n * `[out]` - data The buffer to fill with data\n * `length` - Maximum length of data to read\n * `timeout` - The timeout (in ticks) after which the read operation is\n interrupted\n # Returns\n\nThe number of bytes actually written into the provided buffer"]
    pub fn pipe_receive(
        pipe: *mut PipeSide,
        data: *mut core::ffi::c_void,
        length: usize,
        timeout: FuriWait,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Sends data into the pipe.\n\n # Arguments\n\n* `[in]` - pipe The pipe side to send data into\n * `[out]` - data The buffer to get data from\n * `length` - Maximum length of data to send\n * `timeout` - The timeout (in ticks) after which the write operation is\n interrupted\n # Returns\n\nThe number of bytes actually read from the provided buffer"]
    pub fn pipe_send(
        pipe: *mut PipeSide,
        data: *const core::ffi::c_void,
        length: usize,
        timeout: FuriWait,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = "Determines how many bytes there are in the pipe available to be read.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to query\n # Returns\n\nNumber of bytes available to be read out from that side of the pipe"]
    pub fn pipe_bytes_available(pipe: *mut PipeSide) -> usize;
}
unsafe extern "C" {
    #[doc = "Determines how many space there is in the pipe for data to be written\n into.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to query\n # Returns\n\nNumber of bytes available to be written into that side of the pipe"]
    pub fn pipe_spaces_available(pipe: *mut PipeSide) -> usize;
}
unsafe extern "C" {
    #[doc = "Attaches a `PipeSide` to a `FuriEventLoop`, allowing to attach\n callbacks to the PipeSide.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to attach to the event loop\n * `[in]` - event_loop Event loop to attach the pipe side to"]
    pub fn pipe_attach_to_event_loop(pipe: *mut PipeSide, event_loop: *mut FuriEventLoop);
}
unsafe extern "C" {
    #[doc = "Detaches a `PipeSide` from the `FuriEventLoop` that it was previously\n attached to.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to detach to the event loop"]
    pub fn pipe_detach_from_event_loop(pipe: *mut PipeSide);
}
#[doc = "Callback for when data arrives to a `PipeSide`.\n\n # Arguments\n\n* `[in]` - pipe Pipe side that called the callback\n * `[inout]` - context Custom context"]
pub type PipeSideDataArrivedCallback = ::core::option::Option<
    unsafe extern "C" fn(pipe: *mut PipeSide, context: *mut core::ffi::c_void),
>;
#[doc = "Callback for when data is read out of the opposite `PipeSide`.\n\n # Arguments\n\n* `[in]` - pipe Pipe side that called the callback\n * `[inout]` - context Custom context"]
pub type PipeSideSpaceFreedCallback = ::core::option::Option<
    unsafe extern "C" fn(pipe: *mut PipeSide, context: *mut core::ffi::c_void),
>;
#[doc = "Callback for when the opposite `PipeSide` is freed, making the pipe\n broken.\n\n # Arguments\n\n* `[in]` - pipe Pipe side that called the callback\n * `[inout]` - context Custom context"]
pub type PipeSideBrokenCallback = ::core::option::Option<
    unsafe extern "C" fn(pipe: *mut PipeSide, context: *mut core::ffi::c_void),
>;
unsafe extern "C" {
    #[doc = "Sets the custom context for all callbacks.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to set the context of\n * `[inout]` - context Custom context that will be passed to callbacks"]
    pub fn pipe_set_callback_context(pipe: *mut PipeSide, context: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Sets the callback for when data arrives.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to assign the callback to\n * `[in]` - callback Callback to assign to the pipe side. Set to NULL to\n unsubscribe.\n * `[in]` - event Additional event loop flags (e.g. `Edge`, `Once`, etc.).\n Non-flag values of the enum are not allowed.\n\n Attach the pipe side to an event loop first using\n `pipe_attach_to_event_loop`."]
    pub fn pipe_set_data_arrived_callback(
        pipe: *mut PipeSide,
        callback: PipeSideDataArrivedCallback,
        event: FuriEventLoopEvent,
    );
}
unsafe extern "C" {
    #[doc = "Sets the callback for when data is read out of the opposite `PipeSide`.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to assign the callback to\n * `[in]` - callback Callback to assign to the pipe side. Set to NULL to\n unsubscribe.\n * `[in]` - event Additional event loop flags (e.g. `Edge`, `Once`, etc.).\n Non-flag values of the enum are not allowed.\n\n Attach the pipe side to an event loop first using\n `pipe_attach_to_event_loop`."]
    pub fn pipe_set_space_freed_callback(
        pipe: *mut PipeSide,
        callback: PipeSideSpaceFreedCallback,
        event: FuriEventLoopEvent,
    );
}
unsafe extern "C" {
    #[doc = "Sets the callback for when the opposite `PipeSide` is freed, making\n the pipe broken.\n\n # Arguments\n\n* `[in]` - pipe Pipe side to assign the callback to\n * `[in]` - callback Callback to assign to the pipe side. Set to NULL to\n unsubscribe.\n * `[in]` - event Additional event loop flags (e.g. `Edge`, `Once`, etc.).\n Non-flag values of the enum are not allowed.\n\n Attach the pipe side to an event loop first using\n `pipe_attach_to_event_loop`."]
    pub fn pipe_set_broken_callback(
        pipe: *mut PipeSide,
        callback: PipeSideBrokenCallback,
        event: FuriEventLoopEvent,
    );
}
unsafe extern "C" {
    #[doc = "Format a data buffer as a canonical HEX dump\n # Arguments\n\n* `[out]` - result pointer to the output string (must be initialised)\n * `[in]` - num_places the number of bytes on one line (both as HEX and ASCII)\n * `[in]` - line_prefix if not NULL, prepend this string to each line\n * `[in]` - data pointer to the input data buffer\n * `[in]` - data_size input data size"]
    pub fn pretty_format_bytes_hex_canonical(
        result: *mut FuriString,
        num_places: usize,
        line_prefix: *const core::ffi::c_char,
        data: *const u8,
        data_size: usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PulseGlue {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn pulse_glue_alloc() -> *mut PulseGlue;
}
unsafe extern "C" {
    pub fn pulse_glue_free(pulse_glue: *mut PulseGlue);
}
unsafe extern "C" {
    pub fn pulse_glue_reset(pulse_glue: *mut PulseGlue);
}
unsafe extern "C" {
    pub fn pulse_glue_push(pulse_glue: *mut PulseGlue, polarity: bool, length: u32) -> bool;
}
unsafe extern "C" {
    pub fn pulse_glue_pop(pulse_glue: *mut PulseGlue, length: *mut u32, period: *mut u32);
}
unsafe extern "C" {
    #[doc = "Load data from the file in saved structure format\n\n # Arguments\n\n* `path` (direction in) - The path to the file\n * `data` (direction out) - Pointer to the memory where to load data\n * `size` (direction in) - The size of the data\n * `magic` (direction in) - The magic to embed into metadata\n * `version` (direction in) - The version to embed into metadata\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn saved_struct_load(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Save data in saved structure format\n\n # Arguments\n\n* `path` (direction in) - The path to the file\n * `data` (direction in) - Pointer to the memory where data\n * `size` (direction in) - The size of the data\n * `magic` (direction in) - The magic to embed into metadata\n * `version` (direction in) - The version to embed into metadata\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn saved_struct_save(
        path: *const core::ffi::c_char,
        data: *const core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get SavedStructure file metadata\n\n # Arguments\n\n* `path` (direction in) - The path to the file\n * `magic` (direction out) - Pointer to store magic or NULL if you don't need it\n * `version` (direction out) - Pointer to store version or NULL if you don't need\n it\n * `payload_size` (direction out) - Pointer to store payload size or NULL if you don't\n need it\n\n # Returns\n\ntrue on success, false otherwise"]
    pub fn saved_struct_get_metadata(
        path: *const core::ffi::c_char,
        magic: *mut u8,
        version: *mut u8,
        payload_size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Allocate a file stream with buffered read operations\n # Returns\n\nStream*"]
    pub fn buffered_file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
unsafe extern "C" {
    #[doc = "Opens an existing file or creates a new one.\n # Arguments\n\n* `stream` - pointer to file stream object.\n * `path` - path to file\n * `access_mode` - access mode from FS_AccessMode\n * `open_mode` - open mode from FS_OpenMode\n # Returns\n\nTrue on success, False on failure. You need to close the file even if the open operation failed."]
    pub fn buffered_file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Closes the file.\n # Arguments\n\n* `stream` - pointer to file stream object.\n # Returns\n\nTrue on success, False on failure."]
    pub fn buffered_file_stream_close(stream: *mut Stream) -> bool;
}
unsafe extern "C" {
    #[doc = "Forces write from cache to the underlying file.\n # Arguments\n\n* `stream` - pointer to file stream object.\n # Returns\n\nTrue on success, False on failure."]
    pub fn buffered_file_stream_sync(stream: *mut Stream) -> bool;
}
unsafe extern "C" {
    #[doc = "Retrieves the error id from the file object\n # Arguments\n\n* `stream` - pointer to stream object.\n # Returns\n\nFS_Error error id"]
    pub fn buffered_file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Allocate file stream\n # Returns\n\nStream*"]
    pub fn file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
unsafe extern "C" {
    #[doc = "Opens an existing file or create a new one.\n # Arguments\n\n* `stream` - pointer to file stream object.\n * `path` - path to file\n * `access_mode` - access mode from FS_AccessMode\n * `open_mode` - open mode from FS_OpenMode\n # Returns\n\nsuccess flag. You need to close the file even if the open operation failed."]
    pub fn file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Closes the file.\n # Arguments\n\n* `stream` -\n # Returns\n\ntrue\n false"]
    pub fn file_stream_close(stream: *mut Stream) -> bool;
}
unsafe extern "C" {
    #[doc = "Retrieves the error id from the file object\n # Arguments\n\n* `stream` - pointer to stream object.\n # Returns\n\nFS_Error error id"]
    pub fn file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
unsafe extern "C" {
    #[doc = "Allocate string stream\n # Returns\n\nStream*"]
    pub fn string_stream_alloc() -> *mut Stream;
}
#[doc = "!< Conversion performed successfully"]
pub const StrintParseNoError: StrintParseError = StrintParseError(0);
#[doc = "!< Multiple leading `+` or `-` characters, or leading `-` character if the type is unsigned"]
pub const StrintParseSignError: StrintParseError = StrintParseError(1);
#[doc = "!< No valid digits after the leading whitespace, sign and prefix"]
pub const StrintParseAbsentError: StrintParseError = StrintParseError(2);
#[doc = "!< Result does not fit in the requested type"]
pub const StrintParseOverflowError: StrintParseError = StrintParseError(3);
#[repr(transparent)]
#[doc = "String to integer conversion error"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StrintParseError(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "See `strint_to_uint32`"]
    pub fn strint_to_uint64(
        str_: *const core::ffi::c_char,
        end: *mut *mut core::ffi::c_char,
        out: *mut u64,
        base: u8,
    ) -> StrintParseError;
}
unsafe extern "C" {
    #[doc = "See `strint_to_uint32`"]
    pub fn strint_to_int64(
        str_: *const core::ffi::c_char,
        end: *mut *mut core::ffi::c_char,
        out: *mut i64,
        base: u8,
    ) -> StrintParseError;
}
unsafe extern "C" {
    #[doc = "Converts a string to a `uint32_t`\n\n # Arguments\n\n* `str` (direction in) - Input string\n * `end` (direction out) - Pointer to first character after the number in input string\n * `out` (direction out) - Parse result\n * `base` (direction in) - Integer base\n\n # Returns\n\nParse error\n\n Parses the number in the input string. The number may be surrounded by\n whitespace characters to the left and any non-digit characters to the right.\n What's considered a digit is determined by the input base in the following\n order: `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The number may be prefixed\n with either a `+` or a `-` to indicate its sign. The pointer to the first\n character after the leading whitespace, allowed prefixes and digits is\n assigned to `end`.\n\n If the input base is 0, the base is inferred from the leading characters of\n the number:\n - If it starts with `0x`, it's read in base 16;\n - If it starts with a `0`, it's read in base 8;\n - If it starts with `0b`, it's read in base 2.\n - Otherwise, it's read in base 10.\n\n For a description of the return codes, see `StrintParseError`. If the return\n code is something other than `StrintParseNoError`, the values at `end` and\n `out` are unaltered."]
    pub fn strint_to_uint32(
        str_: *const core::ffi::c_char,
        end: *mut *mut core::ffi::c_char,
        out: *mut u32,
        base: u8,
    ) -> StrintParseError;
}
unsafe extern "C" {
    #[doc = "See `strint_to_uint32`"]
    pub fn strint_to_int32(
        str_: *const core::ffi::c_char,
        end: *mut *mut core::ffi::c_char,
        out: *mut i32,
        base: u8,
    ) -> StrintParseError;
}
unsafe extern "C" {
    #[doc = "See `strint_to_uint32`"]
    pub fn strint_to_uint16(
        str_: *const core::ffi::c_char,
        end: *mut *mut core::ffi::c_char,
        out: *mut u16,
        base: u8,
    ) -> StrintParseError;
}
unsafe extern "C" {
    #[doc = "See `strint_to_uint32`"]
    pub fn strint_to_int16(
        str_: *const core::ffi::c_char,
        end: *mut *mut core::ffi::c_char,
        out: *mut i16,
        base: u8,
    ) -> StrintParseError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TarArchive {
    _unused: [u8; 0],
}
pub const TarOpenModeRead: TarOpenMode = TarOpenMode(114);
pub const TarOpenModeWrite: TarOpenMode = TarOpenMode(119);
pub const TarOpenModeReadHeatshrink: TarOpenMode = TarOpenMode(104);
#[repr(transparent)]
#[doc = "Tar archive open mode"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TarOpenMode(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Get expected open mode for archive at the path.\n Used for automatic mode detection based on the file extension.\n\n # Arguments\n\n* `path` (direction in) - Path to the archive\n\n # Returns\n\nopen mode from TarOpenMode enum"]
    pub fn tar_archive_get_mode_for_path(path: *const core::ffi::c_char) -> TarOpenMode;
}
unsafe extern "C" {
    #[doc = "Tar archive constructor\n\n # Arguments\n\n* `storage` - Storage API pointer\n\n # Returns\n\nallocated object"]
    pub fn tar_archive_alloc(storage: *mut Storage) -> *mut TarArchive;
}
unsafe extern "C" {
    #[doc = "Open tar archive\n\n # Arguments\n\n* `archive` - Tar archive object\n * `path` (direction in) - Path to the tar archive\n * `mode` - Open mode\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_open(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        mode: TarOpenMode,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Tar archive destructor\n\n # Arguments\n\n* `archive` - Tar archive object"]
    pub fn tar_archive_free(archive: *mut TarArchive);
}
pub type TarArchiveNameConverter =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut FuriString)>;
unsafe extern "C" {
    #[doc = "Unpack tar archive to destination\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in read mode\n * `destination` (direction in) - Destination path\n * `converter` - Storage name converter\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_unpack_to(
        archive: *mut TarArchive,
        destination: *const core::ffi::c_char,
        converter: TarArchiveNameConverter,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add file to tar archive\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n * `fs_file_path` (direction in) - Path to the file on the filesystem\n * `archive_fname` (direction in) - Name of the file in the archive\n * `file_size` - Size of the file\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_add_file(
        archive: *mut TarArchive,
        fs_file_path: *const core::ffi::c_char,
        archive_fname: *const core::ffi::c_char,
        file_size: i32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add directory to tar archive\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n * `fs_full_path` - Path to the directory on the filesystem\n * `path_prefix` - Prefix to add to the directory name in the archive\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_add_dir(
        archive: *mut TarArchive,
        fs_full_path: *const core::ffi::c_char,
        path_prefix: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Get number of entries in the archive\n\n # Arguments\n\n* `archive` - Tar archive object\n\n # Returns\n\nnumber of entries. -1 on error"]
    pub fn tar_archive_get_entries_count(archive: *mut TarArchive) -> i32;
}
unsafe extern "C" {
    #[doc = "Get read progress\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in read mode\n * `processed` (direction in) - Number of processed entries\n * `total` (direction in) - Total number of entries\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_get_read_progress(
        archive: *mut TarArchive,
        processed: *mut i32,
        total: *mut i32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Unpack single file from tar archive\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in read mode\n * `archive_fname` (direction in) - Name of the file in the archive\n * `destination` (direction in) - Destination path\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_unpack_file(
        archive: *mut TarArchive,
        archive_fname: *const core::ffi::c_char,
        destination: *const core::ffi::c_char,
    ) -> bool;
}
#[doc = "Optional per-entry callback on unpacking\n # Arguments\n\n* `name` - Name of the file or directory\n * `is_directory` - True if the entry is a directory\n * `context` (direction in) - User context\n # Returns\n\ntrue to process the entry, false to skip"]
pub type tar_unpack_file_cb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        is_directory: bool,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = "Set per-entry callback on unpacking\n # Arguments\n\n* `archive` - Tar archive object\n * `callback` - Callback function\n * `context` (direction in) - User context"]
    pub fn tar_archive_set_file_callback(
        archive: *mut TarArchive,
        callback: tar_unpack_file_cb,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    #[doc = "Add tar archive directory header\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n * `dirpath` (direction in) - Path to the directory\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_dir_add_element(
        archive: *mut TarArchive,
        dirpath: *const core::ffi::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add tar archive file header\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n * `path` (direction in) - Path to the file\n * `data_len` - Size of the file\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_file_add_header(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data_len: i32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Add tar archive file data block\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n * `data_block` (direction in) - Data block\n * `block_len` - Size of the data block\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_file_add_data_block(
        archive: *mut TarArchive,
        data_block: *const u8,
        block_len: i32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Finalize tar archive file\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_file_finalize(archive: *mut TarArchive) -> bool;
}
unsafe extern "C" {
    #[doc = "Store data in tar archive\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n * `path` (direction in) - Path to the file\n * `data` (direction in) - Data to store\n * `data_len` - Size of the data\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_store_data(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data: *const u8,
        data_len: i32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Finalize tar archive\n\n # Arguments\n\n* `archive` - Tar archive object. Must be opened in write mode\n\n # Returns\n\ntrue if successful"]
    pub fn tar_archive_finalize(archive: *mut TarArchive) -> bool;
}
unsafe extern "C" {
    #[doc = "Get the index of a int32_t array element which is closest to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n # Arguments\n\n* `value` - value to be searched.\n * `values` - pointer to the array to perform the search in.\n * `values_count` - array size.\n\n # Returns\n\nvalue's index."]
    pub fn value_index_int32(value: i32, values: *const i32, values_count: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Get the index of a uint32_t array element which is closest to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n # Arguments\n\n* `value` - value to be searched.\n * `values` - pointer to the array to perform the search in.\n * `values_count` - array size.\n\n # Returns\n\nvalue's index."]
    pub fn value_index_uint32(value: u32, values: *const u32, values_count: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Get the index of a float array element which is closest to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n # Arguments\n\n* `value` - value to be searched.\n * `values` - pointer to the array to perform the search in.\n * `values_count` - array size.\n\n # Returns\n\nvalue's index."]
    pub fn value_index_float(value: f32, values: *const f32, values_count: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Get the index of a bool array element which is equal to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n # Arguments\n\n* `value` - value to be searched.\n * `values` - pointer to the array to perform the search in.\n * `values_count` - array size.\n\n # Returns\n\nvalue's index."]
    pub fn value_index_bool(value: bool, values: *const bool, values_count: usize) -> usize;
}
unsafe extern "C" {
    #[doc = "Pack uint32 to varint\n # Arguments\n\n* `value` - value from UINT32_MIN to UINT32_MAX\n * `output` - output array, need to be at least 5 bytes long\n # Returns\n\nsize_t"]
    pub fn varint_uint32_pack(value: u32, output: *mut u8) -> usize;
}
unsafe extern "C" {
    pub fn varint_uint32_unpack(value: *mut u32, input: *const u8, input_size: usize) -> usize;
}
unsafe extern "C" {
    pub fn varint_uint32_length(value: u32) -> usize;
}
unsafe extern "C" {
    #[doc = "Pack int32 to varint\n # Arguments\n\n* `value` - value from (INT32_MIN / 2 + 1) to INT32_MAX\n * `output` - output array, need to be at least 5 bytes long\n # Returns\n\nsize_t"]
    pub fn varint_int32_pack(value: i32, output: *mut u8) -> usize;
}
unsafe extern "C" {
    pub fn varint_int32_unpack(value: *mut i32, input: *const u8, input_size: usize) -> usize;
}
unsafe extern "C" {
    pub fn varint_int32_length(value: i32) -> usize;
}
pub const BleEventNotAck: BleEventAckStatus = BleEventAckStatus(0);
pub const BleEventAckFlowEnable: BleEventAckStatus = BleEventAckStatus(1);
pub const BleEventAckFlowDisable: BleEventAckStatus = BleEventAckStatus(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BleEventAckStatus(pub core::ffi::c_uchar);
pub const BleEventFlowDisable: BleEventFlowStatus = BleEventFlowStatus(0);
pub const BleEventFlowEnable: BleEventFlowStatus = BleEventFlowStatus(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BleEventFlowStatus(pub core::ffi::c_uchar);
pub type BleSvcEventHandlerCb = ::core::option::Option<
    unsafe extern "C" fn(
        event: *mut core::ffi::c_void,
        context: *mut core::ffi::c_void,
    ) -> BleEventAckStatus,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GapEventHandler {
    _unused: [u8; 0],
}
pub type GapSvcEventHandler = GapEventHandler;
unsafe extern "C" {
    pub fn ble_event_dispatcher_register_svc_handler(
        handler: BleSvcEventHandlerCb,
        context: *mut core::ffi::c_void,
    ) -> *mut GapSvcEventHandler;
}
unsafe extern "C" {
    pub fn ble_event_dispatcher_unregister_svc_handler(handler: *mut GapSvcEventHandler);
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union Service_UUID_t {
    #[doc = "16-bit UUID"]
    pub Service_UUID_16: u16,
    #[doc = "128-bit UUID"]
    pub Service_UUID_128: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Service_UUID_t"][::core::mem::size_of::<Service_UUID_t>() - 16usize];
    ["Alignment of Service_UUID_t"][::core::mem::align_of::<Service_UUID_t>() - 1usize];
    ["Offset of field: Service_UUID_t::Service_UUID_16"]
        [::core::mem::offset_of!(Service_UUID_t, Service_UUID_16) - 0usize];
    ["Offset of field: Service_UUID_t::Service_UUID_128"]
        [::core::mem::offset_of!(Service_UUID_t, Service_UUID_128) - 0usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union Char_UUID_t {
    #[doc = "16-bit UUID"]
    pub Char_UUID_16: u16,
    #[doc = "128-bit UUID"]
    pub Char_UUID_128: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Char_UUID_t"][::core::mem::size_of::<Char_UUID_t>() - 16usize];
    ["Alignment of Char_UUID_t"][::core::mem::align_of::<Char_UUID_t>() - 1usize];
    ["Offset of field: Char_UUID_t::Char_UUID_16"]
        [::core::mem::offset_of!(Char_UUID_t, Char_UUID_16) - 0usize];
    ["Offset of field: Char_UUID_t::Char_UUID_128"]
        [::core::mem::offset_of!(Char_UUID_t, Char_UUID_128) - 0usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union Char_Desc_Uuid_t {
    #[doc = "16-bit UUID"]
    pub Char_UUID_16: u16,
    #[doc = "128-bit UUID"]
    pub Char_UUID_128: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Char_Desc_Uuid_t"][::core::mem::size_of::<Char_Desc_Uuid_t>() - 16usize];
    ["Alignment of Char_Desc_Uuid_t"][::core::mem::align_of::<Char_Desc_Uuid_t>() - 1usize];
    ["Offset of field: Char_Desc_Uuid_t::Char_UUID_16"]
        [::core::mem::offset_of!(Char_Desc_Uuid_t, Char_UUID_16) - 0usize];
    ["Offset of field: Char_Desc_Uuid_t::Char_UUID_128"]
        [::core::mem::offset_of!(Char_Desc_Uuid_t, Char_UUID_128) - 0usize];
};
pub type cbBleGattCharacteristicData = ::core::option::Option<
    unsafe extern "C" fn(
        context: *const core::ffi::c_void,
        data: *mut *const u8,
        data_len: *mut u16,
    ) -> bool,
>;
pub const FlipperGattCharacteristicDataFixed: BleGattCharacteristicDataType =
    BleGattCharacteristicDataType(0);
pub const FlipperGattCharacteristicDataCallback: BleGattCharacteristicDataType =
    BleGattCharacteristicDataType(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct BleGattCharacteristicDataType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BleGattCharacteristicDescriptorParams {
    pub uuid: Char_Desc_Uuid_t,
    pub data_callback: BleGattCharacteristicDescriptorParams__bindgen_ty_1,
    pub uuid_type: u8,
    pub max_length: u8,
    pub security_permissions: u8,
    pub access_permissions: u8,
    pub gatt_evt_mask: u8,
    pub is_variable: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGattCharacteristicDescriptorParams__bindgen_ty_1 {
    pub fn_: cbBleGattCharacteristicData,
    pub context: *const core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicDescriptorParams__bindgen_ty_1"]
        [::core::mem::size_of::<BleGattCharacteristicDescriptorParams__bindgen_ty_1>() - 8usize];
    ["Alignment of BleGattCharacteristicDescriptorParams__bindgen_ty_1"]
        [::core::mem::align_of::<BleGattCharacteristicDescriptorParams__bindgen_ty_1>() - 4usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams__bindgen_ty_1::fn_"][::core::mem::offset_of!(
        BleGattCharacteristicDescriptorParams__bindgen_ty_1,
        fn_
    ) - 0usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams__bindgen_ty_1::context"][::core::mem::offset_of!(
        BleGattCharacteristicDescriptorParams__bindgen_ty_1,
        context
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicDescriptorParams"]
        [::core::mem::size_of::<BleGattCharacteristicDescriptorParams>() - 32usize];
    ["Alignment of BleGattCharacteristicDescriptorParams"]
        [::core::mem::align_of::<BleGattCharacteristicDescriptorParams>() - 4usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::uuid"]
        [::core::mem::offset_of!(BleGattCharacteristicDescriptorParams, uuid) - 0usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::data_callback"]
        [::core::mem::offset_of!(BleGattCharacteristicDescriptorParams, data_callback) - 16usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::uuid_type"]
        [::core::mem::offset_of!(BleGattCharacteristicDescriptorParams, uuid_type) - 24usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::max_length"]
        [::core::mem::offset_of!(BleGattCharacteristicDescriptorParams, max_length) - 25usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::security_permissions"][::core::mem::offset_of!(
        BleGattCharacteristicDescriptorParams,
        security_permissions
    ) - 26usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::access_permissions"][::core::mem::offset_of!(
        BleGattCharacteristicDescriptorParams,
        access_permissions
    ) - 27usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::gatt_evt_mask"]
        [::core::mem::offset_of!(BleGattCharacteristicDescriptorParams, gatt_evt_mask) - 28usize];
    ["Offset of field: BleGattCharacteristicDescriptorParams::is_variable"]
        [::core::mem::offset_of!(BleGattCharacteristicDescriptorParams, is_variable) - 29usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BleGattCharacteristicParams {
    pub name: *const core::ffi::c_char,
    pub descriptor_params: *mut BleGattCharacteristicDescriptorParams,
    pub data: BleGattCharacteristicParams__bindgen_ty_1,
    pub uuid: Char_UUID_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub char_properties: u8,
    pub security_permissions: u8,
    pub gatt_evt_mask: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BleGattCharacteristicParams__bindgen_ty_1 {
    pub fixed: BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1,
    pub callback: BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *const u8,
    pub length: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1"][::core::mem::size_of::<
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    ["Alignment of BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1"][::core::mem::align_of::<
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1,
    >() - 4usize];
    ["Offset of field: BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1::ptr"][::core::mem::offset_of!(
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1,
        ptr
    ) - 0usize];
    ["Offset of field: BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1::length"][::core::mem::offset_of!(
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_1,
        length
    )
        - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2 {
    pub fn_: cbBleGattCharacteristicData,
    pub context: *const core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2"][::core::mem::size_of::<
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2,
    >() - 8usize];
    ["Alignment of BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2"][::core::mem::align_of::<
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2,
    >() - 4usize];
    ["Offset of field: BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2::fn_"][::core::mem::offset_of!(
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2,
        fn_
    ) - 0usize];
    ["Offset of field: BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2::context"][::core::mem::offset_of!(
        BleGattCharacteristicParams__bindgen_ty_1__bindgen_ty_2,
        context
    )
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicParams__bindgen_ty_1"]
        [::core::mem::size_of::<BleGattCharacteristicParams__bindgen_ty_1>() - 8usize];
    ["Alignment of BleGattCharacteristicParams__bindgen_ty_1"]
        [::core::mem::align_of::<BleGattCharacteristicParams__bindgen_ty_1>() - 4usize];
    ["Offset of field: BleGattCharacteristicParams__bindgen_ty_1::fixed"]
        [::core::mem::offset_of!(BleGattCharacteristicParams__bindgen_ty_1, fixed) - 0usize];
    ["Offset of field: BleGattCharacteristicParams__bindgen_ty_1::callback"]
        [::core::mem::offset_of!(BleGattCharacteristicParams__bindgen_ty_1, callback) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicParams"]
        [::core::mem::size_of::<BleGattCharacteristicParams>() - 36usize];
    ["Alignment of BleGattCharacteristicParams"]
        [::core::mem::align_of::<BleGattCharacteristicParams>() - 4usize];
    ["Offset of field: BleGattCharacteristicParams::name"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, name) - 0usize];
    ["Offset of field: BleGattCharacteristicParams::descriptor_params"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, descriptor_params) - 4usize];
    ["Offset of field: BleGattCharacteristicParams::data"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, data) - 8usize];
    ["Offset of field: BleGattCharacteristicParams::uuid"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, uuid) - 16usize];
    ["Offset of field: BleGattCharacteristicParams::char_properties"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, char_properties) - 33usize];
    ["Offset of field: BleGattCharacteristicParams::security_permissions"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, security_permissions) - 34usize];
    ["Offset of field: BleGattCharacteristicParams::gatt_evt_mask"]
        [::core::mem::offset_of!(BleGattCharacteristicParams, gatt_evt_mask) - 35usize];
};
impl BleGattCharacteristicParams {
    #[inline]
    pub fn data_prop_type(&self) -> BleGattCharacteristicDataType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_data_prop_type(&mut self, val: BleGattCharacteristicDataType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn data_prop_type_raw(this: *const Self) -> BleGattCharacteristicDataType {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_data_prop_type_raw(this: *mut Self, val: BleGattCharacteristicDataType) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_variable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_is_variable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_variable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_variable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uuid_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_uuid_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uuid_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_uuid_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data_prop_type: BleGattCharacteristicDataType,
        is_variable: u8,
        uuid_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let data_prop_type: u8 = unsafe { ::core::mem::transmute(data_prop_type) };
            data_prop_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let is_variable: u8 = unsafe { ::core::mem::transmute(is_variable) };
            is_variable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let uuid_type: u8 = unsafe { ::core::mem::transmute(uuid_type) };
            uuid_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGattCharacteristicInstance {
    pub characteristic: *const BleGattCharacteristicParams,
    pub handle: u16,
    pub descriptor_handle: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BleGattCharacteristicInstance"]
        [::core::mem::size_of::<BleGattCharacteristicInstance>() - 8usize];
    ["Alignment of BleGattCharacteristicInstance"]
        [::core::mem::align_of::<BleGattCharacteristicInstance>() - 4usize];
    ["Offset of field: BleGattCharacteristicInstance::characteristic"]
        [::core::mem::offset_of!(BleGattCharacteristicInstance, characteristic) - 0usize];
    ["Offset of field: BleGattCharacteristicInstance::handle"]
        [::core::mem::offset_of!(BleGattCharacteristicInstance, handle) - 4usize];
    ["Offset of field: BleGattCharacteristicInstance::descriptor_handle"]
        [::core::mem::offset_of!(BleGattCharacteristicInstance, descriptor_handle) - 6usize];
};
unsafe extern "C" {
    pub fn ble_gatt_characteristic_init(
        svc_handle: u16,
        char_descriptor: *const BleGattCharacteristicParams,
        char_instance: *mut BleGattCharacteristicInstance,
    );
}
unsafe extern "C" {
    pub fn ble_gatt_characteristic_delete(
        svc_handle: u16,
        char_instance: *mut BleGattCharacteristicInstance,
    );
}
unsafe extern "C" {
    pub fn ble_gatt_characteristic_update(
        svc_handle: u16,
        char_instance: *mut BleGattCharacteristicInstance,
        source: *const core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ble_gatt_service_add(
        Service_UUID_Type: u8,
        Service_UUID: *const Service_UUID_t,
        Service_Type: u8,
        Max_Attribute_Records: u8,
        Service_Handle: *mut u16,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ble_gatt_service_delete(svc_handle: u16) -> bool;
}
pub const SerialServiceEventTypeDataReceived: SerialServiceEventType = SerialServiceEventType(0);
pub const SerialServiceEventTypeDataSent: SerialServiceEventType = SerialServiceEventType(1);
pub const SerialServiceEventTypesBleResetRequest: SerialServiceEventType =
    SerialServiceEventType(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SerialServiceEventType(pub core::ffi::c_uchar);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceData {
    pub buffer: *mut u8,
    pub size: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SerialServiceData"][::core::mem::size_of::<SerialServiceData>() - 8usize];
    ["Alignment of SerialServiceData"][::core::mem::align_of::<SerialServiceData>() - 4usize];
    ["Offset of field: SerialServiceData::buffer"]
        [::core::mem::offset_of!(SerialServiceData, buffer) - 0usize];
    ["Offset of field: SerialServiceData::size"]
        [::core::mem::offset_of!(SerialServiceData, size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceEvent {
    pub event: SerialServiceEventType,
    pub data: SerialServiceData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SerialServiceEvent"][::core::mem::size_of::<SerialServiceEvent>() - 12usize];
    ["Alignment of SerialServiceEvent"][::core::mem::align_of::<SerialServiceEvent>() - 4usize];
    ["Offset of field: SerialServiceEvent::event"]
        [::core::mem::offset_of!(SerialServiceEvent, event) - 0usize];
    ["Offset of field: SerialServiceEvent::data"]
        [::core::mem::offset_of!(SerialServiceEvent, data) - 4usize];
};
pub type SerialServiceEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: SerialServiceEvent, context: *mut core::ffi::c_void) -> u16,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleServiceSerial {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn ble_svc_serial_start() -> *mut BleServiceSerial;
}
unsafe extern "C" {
    pub fn ble_svc_serial_stop(service: *mut BleServiceSerial);
}
unsafe extern "C" {
    pub fn ble_svc_serial_set_callbacks(
        service: *mut BleServiceSerial,
        buff_size: u16,
        callback: SerialServiceEventCallback,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn ble_svc_serial_set_rpc_active(service: *mut BleServiceSerial, active: bool);
}
unsafe extern "C" {
    pub fn ble_svc_serial_notify_buffer_is_empty(service: *mut BleServiceSerial);
}
unsafe extern "C" {
    pub fn ble_svc_serial_update_tx(
        service: *mut BleServiceSerial,
        data: *mut u8,
        data_len: u16,
    ) -> bool;
}
pub const FuriHalBtSerialRpcStatusNotActive: FuriHalBtSerialRpcStatus = FuriHalBtSerialRpcStatus(0);
pub const FuriHalBtSerialRpcStatusActive: FuriHalBtSerialRpcStatus = FuriHalBtSerialRpcStatus(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalBtSerialRpcStatus(pub core::ffi::c_uchar);
#[doc = "Serial service callback type"]
pub type FuriHalBtSerialCallback = SerialServiceEventCallback;
unsafe extern "C" {
    #[doc = "Send data through BLE\n\n # Arguments\n\n* `profile` - Profile instance\n * `data` - data buffer\n * `size` - data buffer size\n\n # Returns\n\ntrue on success"]
    pub fn ble_profile_serial_tx(
        profile: *mut FuriHalBleProfileBase,
        data: *mut u8,
        size: u16,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "Set BLE RPC status\n\n # Arguments\n\n* `profile` - Profile instance\n * `active` - true if RPC is active"]
    pub fn ble_profile_serial_set_rpc_active(profile: *mut FuriHalBleProfileBase, active: bool);
}
unsafe extern "C" {
    #[doc = "Notify that application buffer is empty\n # Arguments\n\n* `profile` - Profile instance"]
    pub fn ble_profile_serial_notify_buffer_is_empty(profile: *mut FuriHalBleProfileBase);
}
unsafe extern "C" {
    #[doc = "Set Serial service events callback\n\n # Arguments\n\n* `profile` - Profile instance\n * `buffer_size` - Applicaition buffer size\n * `calback` - FuriHalBtSerialCallback instance\n * `context` - pointer to context"]
    pub fn ble_profile_serial_set_event_callback(
        profile: *mut FuriHalBleProfileBase,
        buff_size: u16,
        callback: FuriHalBtSerialCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleServiceBattery {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn ble_svc_battery_start(auto_update: bool) -> *mut BleServiceBattery;
}
unsafe extern "C" {
    pub fn ble_svc_battery_stop(service: *mut BleServiceBattery);
}
unsafe extern "C" {
    pub fn ble_svc_battery_update_level(service: *mut BleServiceBattery, battery_level: u8)
    -> bool;
}
unsafe extern "C" {
    pub fn ble_svc_battery_update_power_state(
        service: *mut BleServiceBattery,
        charging: bool,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ble_svc_battery_state_update(battery_level: *mut u8, charging: *mut bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleServiceDevInfo {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn ble_svc_dev_info_start() -> *mut BleServiceDevInfo;
}
unsafe extern "C" {
    pub fn ble_svc_dev_info_stop(service: *mut BleServiceDevInfo);
}
pub const FuriHalPwmOutputIdTim1PA7: FuriHalPwmOutputId = FuriHalPwmOutputId(0);
pub const FuriHalPwmOutputIdLptim2PA4: FuriHalPwmOutputId = FuriHalPwmOutputId(1);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalPwmOutputId(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Enable PWM channel and set parameters\n\n # Arguments\n\n* `channel` (direction in) - PWM channel (FuriHalPwmOutputId)\n * `freq` (direction in) - Frequency in Hz\n * `duty` (direction in) - Duty cycle value in %"]
    pub fn furi_hal_pwm_start(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
unsafe extern "C" {
    #[doc = "Disable PWM channel\n\n # Arguments\n\n* `channel` (direction in) - PWM channel (FuriHalPwmOutputId)"]
    pub fn furi_hal_pwm_stop(channel: FuriHalPwmOutputId);
}
unsafe extern "C" {
    #[doc = "Set PWM channel parameters\n\n # Arguments\n\n* `channel` (direction in) - PWM channel (FuriHalPwmOutputId)\n * `freq` (direction in) - Frequency in Hz\n * `duty` (direction in) - Duty cycle value in %"]
    pub fn furi_hal_pwm_set_params(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
unsafe extern "C" {
    #[doc = "Is PWM channel running?\n\n # Arguments\n\n* `channel` (direction in) - PWM channel (FuriHalPwmOutputId)\n # Returns\n\nbool - true if running"]
    pub fn furi_hal_pwm_is_running(channel: FuriHalPwmOutputId) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CdcCallbacks {
    pub tx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub rx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub state_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub ctrl_line_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub config_callback: ::core::option::Option<
        unsafe extern "C" fn(context: *mut core::ffi::c_void, config: *mut usb_cdc_line_coding),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CdcCallbacks"][::core::mem::size_of::<CdcCallbacks>() - 20usize];
    ["Alignment of CdcCallbacks"][::core::mem::align_of::<CdcCallbacks>() - 4usize];
    ["Offset of field: CdcCallbacks::tx_ep_callback"]
        [::core::mem::offset_of!(CdcCallbacks, tx_ep_callback) - 0usize];
    ["Offset of field: CdcCallbacks::rx_ep_callback"]
        [::core::mem::offset_of!(CdcCallbacks, rx_ep_callback) - 4usize];
    ["Offset of field: CdcCallbacks::state_callback"]
        [::core::mem::offset_of!(CdcCallbacks, state_callback) - 8usize];
    ["Offset of field: CdcCallbacks::ctrl_line_callback"]
        [::core::mem::offset_of!(CdcCallbacks, ctrl_line_callback) - 12usize];
    ["Offset of field: CdcCallbacks::config_callback"]
        [::core::mem::offset_of!(CdcCallbacks, config_callback) - 16usize];
};
unsafe extern "C" {
    pub fn furi_hal_cdc_set_callbacks(
        if_num: u8,
        cb: *mut CdcCallbacks,
        context: *mut core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn furi_hal_cdc_get_port_settings(if_num: u8) -> *mut usb_cdc_line_coding;
}
unsafe extern "C" {
    pub fn furi_hal_cdc_get_ctrl_line_state(if_num: u8) -> u8;
}
unsafe extern "C" {
    pub fn furi_hal_cdc_send(if_num: u8, buf: *mut u8, len: u16);
}
unsafe extern "C" {
    pub fn furi_hal_cdc_receive(if_num: u8, buf: *mut u8, max_len: u16) -> i32;
}
unsafe extern "C" {
    pub fn __errno() -> *mut core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __cxa_pure_virtual();
}
unsafe extern "C" {
    pub fn __clear_cache(arg1: *mut core::ffi::c_void, arg2: *mut core::ffi::c_void);
}
unsafe extern "C" {
    pub fn __aeabi_uldivmod(arg1: u64, arg2: u64) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Init memory pool manager"]
    pub fn furi_hal_memory_init();
}
unsafe extern "C" {
    #[doc = "Allocate memory from separate memory pool. That memory can't be freed.\n\n # Arguments\n\n* `size` -\n # Returns\n\nvoid*"]
    pub fn furi_hal_memory_alloc(size: usize) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = "Get free memory pool size\n\n # Returns\n\nsize_t"]
    pub fn furi_hal_memory_get_free() -> usize;
}
unsafe extern "C" {
    #[doc = "Get max free block size from memory pool\n\n # Returns\n\nsize_t"]
    pub fn furi_hal_memory_max_pool_block() -> usize;
}
pub const FuriHalMpuRegionNULL: FuriHalMpuRegion = FuriHalMpuRegion(0);
pub const FuriHalMpuRegionMainStack: FuriHalMpuRegion = FuriHalMpuRegion(1);
pub const FuriHalMpuRegionThreadStack: FuriHalMpuRegion = FuriHalMpuRegion(2);
pub const FuriHalMpuRegion3: FuriHalMpuRegion = FuriHalMpuRegion(3);
pub const FuriHalMpuRegion4: FuriHalMpuRegion = FuriHalMpuRegion(4);
pub const FuriHalMpuRegion5: FuriHalMpuRegion = FuriHalMpuRegion(5);
pub const FuriHalMpuRegion6: FuriHalMpuRegion = FuriHalMpuRegion(6);
pub const FuriHalMpuRegion7: FuriHalMpuRegion = FuriHalMpuRegion(7);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalMpuRegion(pub core::ffi::c_uchar);
pub const FuriHalMPURegionSize32B: FuriHalMPURegionSize = FuriHalMPURegionSize(4);
pub const FuriHalMPURegionSize64B: FuriHalMPURegionSize = FuriHalMPURegionSize(5);
pub const FuriHalMPURegionSize128B: FuriHalMPURegionSize = FuriHalMPURegionSize(6);
pub const FuriHalMPURegionSize256B: FuriHalMPURegionSize = FuriHalMPURegionSize(7);
pub const FuriHalMPURegionSize512B: FuriHalMPURegionSize = FuriHalMPURegionSize(8);
pub const FuriHalMPURegionSize1KB: FuriHalMPURegionSize = FuriHalMPURegionSize(9);
pub const FuriHalMPURegionSize2KB: FuriHalMPURegionSize = FuriHalMPURegionSize(10);
pub const FuriHalMPURegionSize4KB: FuriHalMPURegionSize = FuriHalMPURegionSize(11);
pub const FuriHalMPURegionSize8KB: FuriHalMPURegionSize = FuriHalMPURegionSize(12);
pub const FuriHalMPURegionSize16KB: FuriHalMPURegionSize = FuriHalMPURegionSize(13);
pub const FuriHalMPURegionSize32KB: FuriHalMPURegionSize = FuriHalMPURegionSize(14);
pub const FuriHalMPURegionSize64KB: FuriHalMPURegionSize = FuriHalMPURegionSize(15);
pub const FuriHalMPURegionSize128KB: FuriHalMPURegionSize = FuriHalMPURegionSize(16);
pub const FuriHalMPURegionSize256KB: FuriHalMPURegionSize = FuriHalMPURegionSize(17);
pub const FuriHalMPURegionSize512KB: FuriHalMPURegionSize = FuriHalMPURegionSize(18);
pub const FuriHalMPURegionSize1MB: FuriHalMPURegionSize = FuriHalMPURegionSize(19);
pub const FuriHalMPURegionSize2MB: FuriHalMPURegionSize = FuriHalMPURegionSize(20);
pub const FuriHalMPURegionSize4MB: FuriHalMPURegionSize = FuriHalMPURegionSize(21);
pub const FuriHalMPURegionSize8MB: FuriHalMPURegionSize = FuriHalMPURegionSize(22);
pub const FuriHalMPURegionSize16MB: FuriHalMPURegionSize = FuriHalMPURegionSize(23);
pub const FuriHalMPURegionSize32MB: FuriHalMPURegionSize = FuriHalMPURegionSize(24);
pub const FuriHalMPURegionSize64MB: FuriHalMPURegionSize = FuriHalMPURegionSize(25);
pub const FuriHalMPURegionSize128MB: FuriHalMPURegionSize = FuriHalMPURegionSize(26);
pub const FuriHalMPURegionSize256MB: FuriHalMPURegionSize = FuriHalMPURegionSize(27);
pub const FuriHalMPURegionSize512MB: FuriHalMPURegionSize = FuriHalMPURegionSize(28);
pub const FuriHalMPURegionSize1GB: FuriHalMPURegionSize = FuriHalMPURegionSize(29);
pub const FuriHalMPURegionSize2GB: FuriHalMPURegionSize = FuriHalMPURegionSize(30);
pub const FuriHalMPURegionSize4GB: FuriHalMPURegionSize = FuriHalMPURegionSize(31);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FuriHalMPURegionSize(pub core::ffi::c_uchar);
unsafe extern "C" {
    #[doc = "Enable memory protection unit"]
    pub fn furi_hal_mpu_enable();
}
unsafe extern "C" {
    #[doc = "Disable memory protection unit"]
    pub fn furi_hal_mpu_disable();
}
unsafe extern "C" {
    pub fn furi_hal_mpu_protect_no_access(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
unsafe extern "C" {
    pub fn furi_hal_mpu_protect_read_only(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
unsafe extern "C" {
    pub fn furi_hal_mpu_protect_disable(region: FuriHalMpuRegion);
}
pub const HidU2fDisconnected: HidU2fEvent = HidU2fEvent(0);
pub const HidU2fConnected: HidU2fEvent = HidU2fEvent(1);
pub const HidU2fRequest: HidU2fEvent = HidU2fEvent(2);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HidU2fEvent(pub core::ffi::c_uchar);
pub type HidU2fCallback =
    ::core::option::Option<unsafe extern "C" fn(ev: HidU2fEvent, context: *mut core::ffi::c_void)>;
unsafe extern "C" {
    #[doc = "Get HID U2F connection state\n\n # Returns\n\ntrue / false"]
    pub fn furi_hal_hid_u2f_is_connected() -> bool;
}
unsafe extern "C" {
    #[doc = "Set HID U2F event callback\n\n # Arguments\n\n* `cb` - callback\n * `ctx` - callback context"]
    pub fn furi_hal_hid_u2f_set_callback(cb: HidU2fCallback, ctx: *mut core::ffi::c_void);
}
unsafe extern "C" {
    #[doc = "Get received U2F HID packet\n"]
    pub fn furi_hal_hid_u2f_get_request(data: *mut u8) -> u32;
}
unsafe extern "C" {
    #[doc = "Send U2F HID response packet\n\n # Arguments\n\n* `data` - response data\n * `len` - packet length"]
    pub fn furi_hal_hid_u2f_send_response(data: *mut u8, len: u8);
}
